<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="暴徒">
<meta property="og:url" content="http://fukangwei.gitee.io/page/46/index.html">
<meta property="og:site_name" content="暴徒">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="暴徒">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/46/">





  <title>暴徒</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">暴徒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/02/Qt语法详解/Qt之sqlite数据库/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/02/Qt语法详解/Qt之sqlite数据库/" itemprop="url">Qt之sqlite数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-02T12:45:15+08:00">
                2019-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;在使用数据库功能时，需要在<code>.pro</code>文件中增加语句<code>QT += sql</code>，同时在代码中增加头文件<code>QtSql</code>。<br>&emsp;&emsp;<code>QtSql</code>模块提供了与平台以及数据库种类无关的访问<code>SQL</code>数据库的接口，这个接口由利用<code>Qt</code>的模型视图结构将数据库与用户界面集成的一套类来支持。<code>QSqlDatabase</code>对象象征了数据库的关联。<code>Qt</code>使用驱动程序与各种数据库的应用编程接口进行通信。<code>Qt</code>包括如下驱动程序：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>驱动程序</th>
<th>数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QDB2</code></td>
<td><code>IBM DB2</code></td>
</tr>
<tr>
<td><code>QIBASE</code></td>
<td><code>Borland InterBase</code></td>
</tr>
<tr>
<td><code>QMYSQL</code></td>
<td><code>MySql</code></td>
</tr>
<tr>
<td><code>QOCI</code></td>
<td>甲骨文公司(<code>Oracle Call Interface</code>)</td>
</tr>
<tr>
<td><code>QODBC</code></td>
<td><code>ODBC</code>(包括微软公司的<code>QSL</code>服务)</td>
</tr>
<tr>
<td><code>QPSQL</code></td>
<td><code>PostgreSQL</code></td>
</tr>
<tr>
<td><code>QSQLITE</code></td>
<td><code>QSLite</code>第<code>3</code>版</td>
</tr>
<tr>
<td><code>QSQLITE2</code></td>
<td><code>QSLite</code>第<code>2</code>版</td>
</tr>
<tr>
<td><code>QTDS</code></td>
<td><code>Qybase</code>自适应服务器</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;由于授权的许可限制，<code>Qt</code>的开源版本无法提供所有的驱动程序。当配置<code>Qt</code>时，既可以选择<code>Qt</code>本身包含的<code>SQL</code>驱动程序，也可以以插件的形式建立驱动程序。如下是<code>Qt</code>使用<code>SQLite</code>的基本操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 添加数据库驱动、设置数据库名称、数据库登录用户名、密码 */</span></span><br><span class="line">QSqlDatabase database = QSqlDatabase::addDatabase ( <span class="string">"QSQLITE"</span> );</span><br><span class="line">database.setDatabaseName ( <span class="string">"database.db"</span> );</span><br><span class="line">database.setUserName ( <span class="string">"root"</span> );</span><br><span class="line">database.setPassword ( <span class="string">"123456"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( !database.open() ) &#123; <span class="comment">/* 打开数据库 */</span></span><br><span class="line">    qDebug() &lt;&lt; database.lastError();</span><br><span class="line">    qFatal ( <span class="string">"failed to connect."</span> ) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* QSqlQuery类提供执行和操作的SQL语句的方法。可以用来执行DML(数据操作语言)语句，</span></span><br><span class="line"><span class="comment">       如SELECT、INSERT、UPDATE、DELETE，以及DDL(数据定义语言)语句，</span></span><br><span class="line"><span class="comment">       例如“CREATE TABLE”。也可以用来执行那些不是标准的SQL的数据库特定的命令 */</span></span><br><span class="line">    QSqlQuery sql_query;</span><br><span class="line">    QString create_sql = <span class="string">"create table student (id int primary key, name varchar(30), age int)"</span>;</span><br><span class="line">    QString select_max_sql = <span class="string">"select max(id) from student"</span>;</span><br><span class="line">    QString insert_sql = <span class="string">"insert into student values (?, ?, ?)"</span>;</span><br><span class="line">    QString update_sql = <span class="string">"update student set name = :name where id = :id"</span>;</span><br><span class="line">    QString select_sql = <span class="string">"select id, name from student"</span>;</span><br><span class="line">    QString select_all_sql = <span class="string">"select * from student"</span>;</span><br><span class="line">    QString delete_sql = <span class="string">"delete from student where id = ?"</span>;</span><br><span class="line">    QString clear_sql = <span class="string">"delete from student"</span>;</span><br><span class="line">    sql_query.prepare ( create_sql );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !sql_query.exec() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"table created!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 查询最大id */</span></span><br><span class="line">    <span class="keyword">int</span> max_id = <span class="number">0</span>;</span><br><span class="line">    sql_query.prepare ( select_max_sql );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !sql_query.exec() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( sql_query.next() ) &#123;</span><br><span class="line">            max_id = sql_query.value ( <span class="number">0</span> ).toInt();</span><br><span class="line">            qDebug() &lt;&lt; QString ( <span class="string">"max id:%1"</span> ).arg ( max_id );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 插入数据 */</span></span><br><span class="line">    sql_query.prepare ( insert_sql );</span><br><span class="line">    sql_query.addBindValue ( max_id + <span class="number">1</span> );</span><br><span class="line">    sql_query.addBindValue ( <span class="string">"name"</span> );</span><br><span class="line">    sql_query.addBindValue ( <span class="number">25</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !sql_query.exec() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"inserted!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 更新数据 */</span></span><br><span class="line">    sql_query.prepare ( update_sql );</span><br><span class="line">    sql_query.bindValue ( <span class="string">":name"</span>, <span class="string">"Qt"</span> );</span><br><span class="line">    sql_query.bindValue ( <span class="string">":id"</span>, <span class="number">1</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !sql_query.exec() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"updated!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 查询部分数据 */</span></span><br><span class="line">    <span class="keyword">if</span> ( !sql_query.exec ( select_sql ) ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( sql_query.next() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = sql_query.value ( <span class="string">"id"</span> ).toInt();</span><br><span class="line">            QString name = sql_query.value ( <span class="string">"name"</span> ).toString();</span><br><span class="line">            qDebug() &lt;&lt; QString ( <span class="string">"id:%1    name:%2"</span> ).arg ( id ).arg ( name );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 查询所有数据 */</span></span><br><span class="line">    sql_query.prepare ( select_all_sql );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !sql_query.exec() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( sql_query.next() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = sql_query.value ( <span class="number">0</span> ).toInt();</span><br><span class="line">            QString name = sql_query.value ( <span class="number">1</span> ).toString();</span><br><span class="line">            <span class="keyword">int</span> age = sql_query.value ( <span class="number">2</span> ).toInt();</span><br><span class="line">            qDebug() &lt;&lt; QString ( <span class="string">"id:%1 name:%2 age:%3"</span> ).arg ( id ).arg ( name ).arg ( age );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 删除数据 */</span></span><br><span class="line">    sql_query.prepare ( delete_sql );</span><br><span class="line">    sql_query.addBindValue ( max_id );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !sql_query.exec() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"deleted!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 清空表 */</span></span><br><span class="line">    sql_query.prepare ( clear_sql );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !sql_query.exec() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"cleared"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">database.close(); <span class="comment">/* 关闭数据库 */</span></span><br><span class="line">QFile::remove ( <span class="string">"database.db"</span> ); <span class="comment">/* 删除数据库 */</span></span><br></pre></td></tr></table></figure>
<hr>
<p>&emsp;&emsp;<code>QSqlDatabase</code>类实现了数据库连接的操作，<code>QSqlQuery</code>类执行<code>SQL</code>语句，<code>QSqlRecord</code>类封装数据库所有记录。</p>
<h3 id="QSqlDatabase类"><a href="#QSqlDatabase类" class="headerlink" title="QSqlDatabase类"></a>QSqlDatabase类</h3><p>&emsp;&emsp;使用示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase db = QSqlDatabase::addDatabase ( <span class="string">"QOCI"</span> );</span><br><span class="line">db.setHostName ( <span class="string">"localhost"</span> ); <span class="comment">/* 数据库主机名 */</span></span><br><span class="line">db.setDatabaseName ( <span class="string">"scott"</span> ); <span class="comment">/* 数据库名 */</span></span><br><span class="line">db.setUserName ( <span class="string">"stott"</span> ); <span class="comment">/* 数据库用户名 */</span></span><br><span class="line">db.setPassword ( <span class="string">"tiger"</span> ); <span class="comment">/* 数据库密码 */</span></span><br><span class="line">db.open(); <span class="comment">/* 打开数据库连接 */</span></span><br><span class="line">db.close(); <span class="comment">/* 释放数据库连接 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;建立数据库文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase db = QSqlDatabase::addDatabase ( <span class="string">"QSQLITE"</span> );</span><br><span class="line">db.setDatabaseName ( <span class="string">"database.db"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( !db.open() ) &#123;</span><br><span class="line">    qDebug ( <span class="string">"数据库不能打开"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;建立数据库文件后，创建表并插入两条数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line"><span class="comment">/* id自动增加 */</span></span><br><span class="line">query.exec ( <span class="string">"create table student(id INTEGER PRIMARY KEY autoincrement, name nvarchar(20), age int)"</span> );</span><br><span class="line">query.exec ( <span class="string">"insert into student values(1, '小明', 14)"</span> );</span><br><span class="line">query.exec ( <span class="string">"insert into student values(2, '小王', 15)"</span> );</span><br></pre></td></tr></table></figure>
<h3 id="QSqlQuery类"><a href="#QSqlQuery类" class="headerlink" title="QSqlQuery类"></a>QSqlQuery类</h3><p>&emsp;&emsp;插入值到数据库操作有两种方法：</p>
<ul>
<li>直接用<code>SQL</code>语句插入(参照上面)。</li>
<li>利用预处理方式插入(<code>ORACLE</code>语法和<code>ODBC</code>语法)。适合插入多条记录，或者避免将值转换成字符串(即正确地转义)，调用<code>prepare</code>函数指定一个包含占位符的<code>query</code>，然后绑定要插入的值。</li>
</ul>
<p>&emsp;&emsp;<code>ORACLE</code>语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line"><span class="comment">/* 准备执行SQL查询 */</span></span><br><span class="line">query.prepare ( <span class="string">"INSERT INTO T_STUDENT (name, age) VALUES (:name, :age)"</span> );</span><br><span class="line">query.bindValue ( <span class="string">":name"</span>, <span class="string">"小王"</span> ); <span class="comment">/* 在绑定要插入的值 */</span></span><br><span class="line">query.bindValue ( <span class="string">":age"</span>, <span class="number">11</span> );</span><br><span class="line">query.exec();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>ODBC</code>语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line"><span class="comment">/* 准备执行SQL查询 */</span></span><br><span class="line">query.prepare ( <span class="string">"INSERT INTO T_STUDENT (name,age) VALUES (?,?)"</span> );</span><br><span class="line">query.addBindValue ( <span class="string">"小王"</span> ); <span class="comment">/* 在绑定要插入的值 */</span></span><br><span class="line">query.addBindValue ( <span class="number">11</span> );</span><br><span class="line">query.exec();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;批量插入到数据库中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line">query.prepare ( “insert into student values ( ?, ? ) ” );</span><br><span class="line">QVariantList names;</span><br><span class="line"><span class="comment">/* 如果要提交空串，用QVariant(QVariant::String)代替名字 */</span></span><br><span class="line">names &lt;&lt; <span class="string">"小王"</span> &lt;&lt; <span class="string">"小明"</span> &lt;&lt; <span class="string">"小张"</span> &lt;&lt; <span class="string">"小新"</span>;</span><br><span class="line">query.addBindValue ( names );</span><br><span class="line">QVariantList ages;</span><br><span class="line">ages &lt;&lt; <span class="number">11</span> &lt;&lt; <span class="number">13</span> &lt;&lt; <span class="number">12</span> &lt;&lt; <span class="number">11</span>;</span><br><span class="line">query.addBindValue ( ages );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( !query.execBatch() ) &#123; <span class="comment">/* 进行批处理，如果出错就输出错误 */</span></span><br><span class="line">    qDebug() &lt;&lt; query.lastError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;查询数据库操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line"><span class="comment">/* 查询的结果可能不止一条记录，所以我们称之为结果集 */</span></span><br><span class="line">query.exec ( <span class="string">"SELECT * FROM t_STUDENT"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( query.next() ) &#123;</span><br><span class="line">    <span class="comment">/* 取第i条记录第1个字段(从0开始计数)的结果 */</span></span><br><span class="line">    QString name = query.value ( <span class="number">0</span> ).toString();</span><br><span class="line">    <span class="comment">/* 取第i条记录第2个字段的结果 */</span></span><br><span class="line">    <span class="keyword">int</span> age = query.value ( <span class="number">1</span> ).toInt();</span><br><span class="line">    <span class="comment">/* 处理name、age变量数据 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>UPDATE</code>操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line">query.prepare ( <span class="string">"UPDATE employee SET salary = ? WHERE id = 1003"</span> );</span><br><span class="line">query.bindValue ( <span class="number">0</span>, <span class="number">70000</span> );</span><br><span class="line">query.exe();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>DELETE</code>操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line">query.exec ( <span class="string">"DELETE FROM employee WHERE id = 1007"</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>seek(int n)</code>：<code>query</code>指向结果集的第<code>n</code>条记录，指定当前的位置。</li>
<li><code>first()</code>：<code>query</code>指向结果集的第一条记录。</li>
<li><code>last()</code>：<code>query</code>指向结果集的最后一条记录。</li>
<li><code>next()</code>：<code>query</code>指向下一条记录，每执行一次该函数，便指向相邻的下一条记录。</li>
<li><code>previous()</code>：<code>query</code>指向上一条记录，每执行一次该函数，便指向相邻的上一条记录。</li>
<li><code>record()</code>：获得现在指向的记录。</li>
<li><code>value(int n)</code>：获得属性的值，其中<code>n</code>表示查询的第<code>n</code>个属性。</li>
<li><code>int rowNum = query.at()</code>：获取<code>query</code>所指向的记录在结果集中的编号。</li>
<li><code>int fieldNo = query.record().indexOf(&quot;name&quot;)</code>：返回<code>name</code>的列号。</li>
<li><code>int columnNum = query.record().count()</code>：获取每条记录中属性(即<code>列</code>)的个数。</li>
</ul>
<hr>
<p>&emsp;&emsp;在<code>Qt</code>上使用<code>SQLite</code>时，如果第二次使用<code>QSqlDatabase::addDatabase</code>方法，可能会出现错误<code>QSqlDatabasePrivate::addDatabase: duplicate connection name &#39;qt_sql_default_connection&#39;, old connection removed</code>。<br>&emsp;&emsp;解决方法：先判断一下这个默认的连接名是否存在，如果不存在，则使用<code>addDatabase</code>方法；如果存在，则使用<code>database</code>方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase db;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( QSqlDatabase::contains ( <span class="string">"qt_sql_default_connection"</span> ) ) &#123;</span><br><span class="line">    db = QSqlDatabase::database ( <span class="string">"qt_sql_default_connection"</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    db = QSqlDatabase::addDatabase ( <span class="string">"QSQLITE"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>&emsp;&emsp;使用<code>QSqlQuery</code>时，最好这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase db;</span><br><span class="line"><span class="function">QSqlQuery <span class="title">sql_query</span> <span class="params">( db )</span></span>;</span><br><span class="line">sql_query.prepare ( create_sql );</span><br></pre></td></tr></table></figure>
<p>否则可能会出现<code>Driver not loaded</code>的错误。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/02/Qt语法详解/Qt之QTextDocument/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/02/Qt语法详解/Qt之QTextDocument/" itemprop="url">Qt之QTextDocument</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-02T00:28:55+08:00">
                2019-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTextDocument</code> class holds formatted text that can be viewed and edited using a <code>QTextEdit</code>.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextDocument</code></td>
<td><code>QObject</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextDocument(QObject * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTextDocument(const QString &amp; text, QObject * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QTextDocument()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addResource(int type, const QUrl &amp; name, const QVariant &amp; resource)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>adjustSize()</code></td>
</tr>
<tr>
<td><code>QVector&lt;QTextFormat&gt;</code></td>
<td><code>allFormats() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>availableRedoSteps() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>availableUndoSteps() const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>blockCount() const</code></td>
</tr>
<tr>
<td><code>QChar</code></td>
<td><code>characterAt(int pos) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>characterCount() const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clearUndoRedoStacks(Stacks stacksToClear = UndoAndRedoStacks)</code></td>
</tr>
<tr>
<td><code>QTextDocument *</code></td>
<td><code>clone(QObject * parent = 0) const</code></td>
</tr>
<tr>
<td><code>Qt::CursorMoveStyle</code></td>
<td><code>defaultCursorMoveStyle() const</code></td>
</tr>
<tr>
<td><code>QFont</code></td>
<td><code>defaultFont() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>defaultStyleSheet() const</code></td>
</tr>
<tr>
<td><code>QTextOption</code></td>
<td><code>defaultTextOption() const</code></td>
</tr>
<tr>
<td><code>QAbstractTextDocumentLayout *</code></td>
<td><code>documentLayout() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>documentMargin() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>drawContents(QPainter * p, const QRectF &amp; rect = QRectF())</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>QTextCursor</code></td>
<td><code>find(const QString &amp; subString, const QTextCursor &amp; cursor, FindFlags options = 0) const</code></td>
</tr>
<tr>
<td><code>QTextCursor</code></td>
<td><code>find(const QRegExp &amp; expr, const QTextCursor &amp; cursor, FindFlags options = 0) const</code></td>
</tr>
<tr>
<td><code>QTextCursor</code></td>
<td><code>find(const QString &amp; subString, int position = 0, FindFlags options = 0) const</code></td>
</tr>
<tr>
<td><code>QTextCursor</code></td>
<td><code>find(const QRegExp &amp; expr, int position = 0, FindFlags options = 0) const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>findBlock(int pos) const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>findBlockByLineNumber(int lineNumber) const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>findBlockByNumber(int blockNumber) const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>firstBlock() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>idealWidth() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>indentWidth() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isModified() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isRedoAvailable() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isUndoAvailable() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isUndoRedoEnabled() const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>lastBlock() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lineCount() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>markContentsDirty(int position, int length)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>maximumBlockCount() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>metaInformation(MetaInformation info) const</code></td>
</tr>
<tr>
<td><code>QTextObject *</code></td>
<td><code>object(int objectIndex) const</code></td>
</tr>
<tr>
<td><code>QTextObject *</code></td>
<td><code>objectForFormat(const QTextFormat &amp; f) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>pageCount() const</code></td>
</tr>
<tr>
<td><code>QSizeF</code></td>
<td><code>pageSize() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>print(QPrinter * printer) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>redo(QTextCursor * cursor)</code></td>
</tr>
<tr>
<td><code>QVariant</code></td>
<td><code>resource(int type, const QUrl &amp; name) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>revision() const</code></td>
</tr>
<tr>
<td><code>QTextFrame *</code></td>
<td><code>rootFrame() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDefaultCursorMoveStyle(Qt::CursorMoveStyle style)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDefaultFont(const QFont &amp; font)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDefaultStyleSheet(const QString &amp; sheet)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDefaultTextOption(const QTextOption &amp; option)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDocumentLayout(QAbstractTextDocumentLayout * layout)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDocumentMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHtml(const QString &amp; html)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setIndentWidth(qreal width)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMaximumBlockCount(int maximum)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMetaInformation(MetaInformation info, const QString &amp; string)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPageSize(const QSizeF &amp; size)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPlainText(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTextWidth(qreal width)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUndoRedoEnabled(bool enable)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUseDesignMetrics(bool b)</code></td>
</tr>
<tr>
<td><code>QSizeF</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>textWidth() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>toHtml(const QByteArray &amp; encoding = QByteArray()) const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>toPlainText() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>undo(QTextCursor * cursor)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>useDesignMetrics() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Slots"><a href="#Public-Slots" class="headerlink" title="Public Slots"></a>Public Slots</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>redo()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setModified(bool m = true)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>undo()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>blockCountChanged(int newBlockCount)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>contentsChange(int position, int charsRemoved, int charsAdded)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>contentsChanged()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>cursorPositionChanged(const QTextCursor &amp; cursor)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>documentLayoutChanged()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>modificationChanged(bool changed)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>redoAvailable(bool available)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>undoAvailable(bool available)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>undoCommandAdded()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Retrun</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual QTextObject *</code></td>
<td><code>createObject(const QTextFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>virtual QVariant</code></td>
<td><code>loadResource(int type, const QUrl &amp; name)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextDocument</code> class holds formatted text that can be viewed and edited using a <code>QTextEdit</code>.<br>&emsp;&emsp;<code>QTextDocument</code> is a container for structured rich text documents, providing support for styled text and various types of document elements, such as lists, tables, frames, and images. They can be created for use in a <code>QTextEdit</code>, or used independently.<br>&emsp;&emsp;Each document element is described by an associated format object. Each format object is treated as a unique object by <code>QTextDocuments</code>, and can be passed to <code>objectForFormat()</code> to obtain the document element that it is applied to.<br>&emsp;&emsp;A <code>QTextDocument</code> can be edited programmatically using a <code>QTextCursor</code>, and its contents can be examined by traversing the document structure. The entire document structure is stored as a hierarchy of document elements beneath the root frame, found with the <code>rootFrame()</code> function. Alternatively, if you just want to iterate over the textual contents of the document you can use <code>begin()</code>, <code>end()</code> and <code>findBlock()</code> to retrieve text blocks that you can examine and iterate over.<br>&emsp;&emsp;The layout of a document is determined by the <code>documentLayout()</code>; you can create your own <code>QAbstractTextDocumentLayout</code> subclass and set it using <code>setDocumentLayout()</code> if you want to use your own layout logic. The document’s title and other <code>meta-information</code> can be obtained by calling the <code>metaInformation()</code> function. For documents that are exposed to users through the <code>QTextEdit</code> class, the document title is also available via the <code>QTextEdit::documentTitle()</code> function.<br>&emsp;&emsp;The <code>toPlainText()</code> and <code>toHtml()</code> convenience functions allow you to retrieve the contents of the document as <code>plain text</code> and <code>HTML</code>. The document’s text can be searched using the <code>find()</code> functions.<br>&emsp;&emsp;Undo/redo of operations performed on the document can be controlled using the <code>setUndoRedoEnabled()</code> function. The undo/redo system can be controlled by an editor widget through the <code>undo()</code> and <code>redo()</code> slots; the document also provides <code>contentsChanged()</code>, <code>undoAvailable()</code> and <code>redoAvailable()</code> signals that inform connected editor widgets about the state of the undo/redo system. The following are the undo/redo operations of a <code>QTextDocument</code>:</p>
<ul>
<li>Insertion or removal of characters. A sequence of insertions or removals within the same text block are regarded as a single undo/redo operation.</li>
<li>Insertion or removal of text blocks. Sequences of insertion or removals in a single operation (e.g., by selecting and then deleting text) are regarded as a single undo/redo operation.</li>
<li>Text character format changes.</li>
<li>Text block format changes.</li>
<li>Text block group format changes.</li>
</ul>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QTextDocument::FindFlag &amp; flags QTextDocument::FindFlags</code>: This enum describes the options available to <code>QTextDocument&#39;s</code> find function. The options can be <code>OR-ed</code> together from the following list:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextDocument::FindBackward</code></td>
<td><code>0x00001</code></td>
<td>Search backwards instead of forwards.</td>
</tr>
<tr>
<td><code>QTextDocument::FindCaseSensitively</code></td>
<td><code>0x00002</code></td>
<td>By default find works case insensitive. Specifying this option changes the behaviour to a case sensitive find operation.</td>
</tr>
<tr>
<td><code>QTextDocument::FindWholeWords</code></td>
<td><code>0x00004</code></td>
<td>Makes find match only complete words.</td>
</tr>
</tbody>
</table>
</div>
<p>The FindFlags type is a typedef for <code>QFlags&lt;FindFlag&gt;</code>. It stores an <code>OR</code> combination of <code>FindFlag</code> values.</p>
<ul>
<li>enum <code>QTextDocument::MetaInformation</code>: This enum describes the different types of meta information that can be added to a document.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextDocument::DocumentTitle</code></td>
<td><code>0</code></td>
<td>The title of the document.</td>
</tr>
<tr>
<td><code>QTextDocument::DocumentUrl</code></td>
<td><code>1</code></td>
<td>The url of the document. The <code>loadResource()</code> function uses this url as the base when loading relative resources.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QTextDocument::ResourceType</code>: This enum describes the types of resources that can be loaded by <code>QTextDocument&#39;s</code> <code>loadResource()</code> function.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextDocument::HtmlResource</code></td>
<td><code>1</code></td>
<td>The resource contains <code>HTML</code>.</td>
</tr>
<tr>
<td><code>QTextDocument::ImageResource</code></td>
<td><code>2</code></td>
<td>The resource contains image data. Currently supported data types are <code>QVariant::Pixmap</code> and <code>QVariant::Image</code>. If the corresponding variant is of type <code>QVariant::ByteArray</code> then Qt attempts to load the image using <code>QImage::loadFromData</code>. <code>QVariant::Icon</code> is currently not supported. The icon needs to be converted to one of the supported types first, for example using <code>QIcon::pixmap</code>.</td>
</tr>
<tr>
<td><code>QTextDocument::StyleSheetResource</code></td>
<td><code>3</code></td>
<td>The resource contains <code>CSS</code>.</td>
</tr>
<tr>
<td><code>QTextDocument::UserResource</code></td>
<td><code>100</code></td>
<td>The first available value for user defined resource types.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QTextDocument::Stacks</code>:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextDocument::UndoStack</code></td>
<td><code>0x01</code></td>
<td>The undo stack.</td>
</tr>
<tr>
<td><code>QTextDocument::RedoStack</code></td>
<td><code>0x02</code></td>
<td>The redo stack.</td>
</tr>
<tr>
<td><code>QTextDocument::UndoAndRedoStacks</code></td>
<td><code>UndoStack &#124; RedoStack</code></td>
<td>Both the undo and redo stacks.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Property-Documentation"><a href="#Property-Documentation" class="headerlink" title="Property Documentation"></a>Property Documentation</h3><ul>
<li><code>blockCount(const int)</code>: Returns the number of text blocks in the document. The value of this property is undefined in documents with tables or frames. By default, if defined, this property contains a value of <code>1</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">blockCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>defaultFont(QFont)</code>: This property holds the default font used to display the document’s text. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFont <span class="title">defaultFont</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDefaultFont</span> <span class="params">( <span class="keyword">const</span> QFont &amp;font )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>defaultStyleSheet(QString)</code>: The default style sheet is applied to all newly <code>HTML</code> formatted text that is inserted into the document, for example using <code>setHtml()</code> or <code>QTextCursor::insertHtml()</code>. The style sheet needs to be compliant to <code>CSS 2.1</code> syntax. <strong>Note</strong>: Changing the default style sheet does not have any effect to the existing content of the document. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">defaultStyleSheet</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDefaultStyleSheet</span> <span class="params">( <span class="keyword">const</span> QString &amp;sheet )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>defaultTextOption(QTextOption)</code>: This property holds the default text option will be set on all <code>QTextLayouts</code> in the document. When <code>QTextBlocks</code> are created, the <code>defaultTextOption</code> is set on their <code>QTextLayout</code>. This allows setting global properties for the document such as the default word wrap mode. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTextOption <span class="title">defaultTextOption</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDefaultTextOption</span> <span class="params">( <span class="keyword">const</span> QTextOption &amp;option )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>documentMargin(qreal)</code>: The margin around the document. The default is <code>4</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">qreal <span class="title">documentMargin</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDocumentMargin</span> <span class="params">( qreal margin )</span></span></span><br></pre></td></tr></table></figure>
<p><code>indentWidth(qreal)</code>: Returns the width used for text list and text block indenting. The indent properties of <code>QTextListFormat</code> and <code>QTextBlockFormat</code> specify multiples of this value. The default indent width is <code>40</code>. Access functions:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">qreal <span class="title">indentWidth</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIndentWidth</span> <span class="params">( qreal width )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>maximumBlockCount(int)</code>: This property specifies the limit for blocks in the document. Specifies the maximum number of blocks the document may have. If there are more blocks in the document that specified with this property blocks are removed from the beginning of the document. A negative or zero value specifies that the document may contain an unlimited amount of blocks. The default value is <code>0</code>. Note that setting this property will apply the limit immediately to the document contents. Setting this property also disables the undo redo history. This property is undefined in documents with tables or frames. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumBlockCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMaximumBlockCount</span> <span class="params">( <span class="keyword">int</span> maximum )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>modified(bool)</code>: This property holds whether the document has been modified by the user. By default, this property is <code>false</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isModified</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setModified</span> <span class="params">( <span class="keyword">bool</span> m = <span class="literal">true</span> )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>pageSize(QSizeF)</code>: This property holds the page size that should be used for laying out the document. By default, for a <code>newly-created</code>, empty document, this property contains an undefined size. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QSizeF <span class="title">pageSize</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPageSize</span><span class="params">(<span class="keyword">const</span> QSizeF &amp; size)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>size(const QSizeF)</code>: Returns the actual size of the document. This is equivalent to <code>documentLayout()-&gt;documentSize()</code>; The size of the document can be changed either by setting a text width or setting an entire page size. Note that the width is always <code>&gt;= pageSize().width()</code>. By default, for a <code>newly-created</code>, empty document, this property contains a <code>configuration-dependent</code> size. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QSizeF <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>textWidth(qreal)</code>: The text width specifies the preferred width for text in the document. If the text (or content in general) is wider than the specified with it is broken into multiple lines and grows vertically. If the text cannot be broken into multiple lines to fit into the specified text width it will be larger and the <code>size()</code> and the <code>idealWidth()</code> property will reflect that. If the text width is set to <code>-1</code> then the text will not be broken into multiple lines unless it is enforced through an explicit line break or a new paragraph. The default value is <code>-1</code>. Setting the text width will also set the page height to <code>-1</code>, causing the document to grow or shrink vertically in a continuous way. If you want the document layout to break the text into multiple pages then you have to set the pageSize property instead. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">qreal <span class="title">textWidth</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTextWidth</span> <span class="params">( qreal width )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>undoRedoEnabled(bool)</code>: This property holds whether undo/redo are enabled for this document. This defaults to <code>true</code>. If disabled, the undo stack is cleared and no items will be added to it. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUndoRedoEnabled</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setUndoRedoEnabled</span> <span class="params">( <span class="keyword">bool</span> enable )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>useDesignMetrics(bool)</code>: This property holds whether the document uses design metrics of fonts to improve the accuracy of text layout. If this property is set to <code>true</code>, the layout will use design metrics. Otherwise, the metrics of the paint device as set on <code>QAbstractTextDocumentLayout::setPaintDevice()</code> will be used. Using design metrics makes a layout have a width that is no longer dependent on hinting and <code>pixel-rounding</code>. This means that <code>WYSIWYG</code> text layout becomes possible because the width scales much more linearly based on paintdevice metrics than it would otherwise. By default, this property is <code>false</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">useDesignMetrics</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setUseDesignMetrics</span> <span class="params">( <span class="keyword">bool</span> b )</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextDocument::QTextDocument(QObject * parent = 0)</code>: Constructs an empty <code>QTextDocument</code> with the given <code>parent</code>.</li>
<li><code>QTextDocument::QTextDocument(const QString &amp; text, QObject * parent = 0)</code>: Constructs a <code>QTextDocument</code> containing the plain (unformatted) <code>text</code> specified, and with the given <code>parent</code>.</li>
<li><code>QTextDocument::~QTextDocument()</code>: Destroys the document.</li>
<li><code>void QTextDocument::addResource(int type, const QUrl &amp; name, const QVariant &amp; resource)</code>: Adds the <code>resource</code> to the resource cache, using <code>type</code> and <code>name</code> as identifiers. <code>type</code> should be a value from <code>QTextDocument::ResourceType</code>. For example, you can add an image as a resource in order to reference it from within the document:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document-&gt;addResource ( QTextDocument::ImageResource, QUrl ( <span class="string">"mydata://image.png"</span> ), QVariant ( image ) );</span><br></pre></td></tr></table></figure>
<p>The image can be inserted into the document using the <code>QTextCursor</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QTextImageFormat imageFormat;</span><br><span class="line">imageFormat.setName ( <span class="string">"mydata://image.png"</span> );</span><br><span class="line">cursor.insertImage ( imageFormat );</span><br></pre></td></tr></table></figure>
<p>Alternatively, you can insert images using the <code>HTML</code> img tag:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">editor-&gt;append ( <span class="string">"&lt;img src=\"mydata://image.png\" /&gt;"</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QTextDocument::adjustSize()</code>: Adjusts the document to a reasonable size.</li>
<li><code>QVector&lt;QTextFormat&gt; QTextDocument::allFormats() const</code>: Returns a vector of text formats for all the formats used in the document.</li>
<li><code>int QTextDocument::availableRedoSteps() const</code>: Returns the number of available redo steps.</li>
<li><code>int QTextDocument::availableUndoSteps() const</code>: Returns the number of available undo steps.</li>
<li><code>QTextBlock QTextDocument::begin() const</code>: Returns the document’s first text block.</li>
<li><code>void QTextDocument::blockCountChanged(int newBlockCount) [signal]</code>: This signal is emitted when the total number of text blocks in the document changes. The value passed in <code>newBlockCount</code> is the new total.</li>
<li><code>QChar QTextDocument::characterAt(int pos) const</code>: Returns the character at position <code>pos</code>, or a null character if the position is out of range.</li>
<li><code>int QTextDocument::characterCount() const</code>: Returns the number of characters of this document.</li>
<li><code>void QTextDocument::clear() [virtual]</code>: Clears the document.</li>
<li><code>void QTextDocument::clearUndoRedoStacks(Stacks stacksToClear = UndoAndRedoStacks)</code>: Clears the stacks specified by <code>stacksToClear</code>. This method clears any commands on the undo stack, the redo stack, or both (the default). If commands are cleared, the appropriate signals are emitted, <code>QTextDocument::undoAvailable()</code> or <code>QTextDocument::redoAvailable()</code>.</li>
<li><code>QTextDocument * QTextDocument::clone(QObject * parent = 0) const</code>: Creates a new QTextDocument that is a copy of this text document. <code>parent</code> is the parent of the returned text document.</li>
<li><code>void QTextDocument::contentsChange(int position, int charsRemoved, int charsAdded) [signal]</code>: This signal is emitted whenever the document’s content changes; for example, when text is inserted or deleted, or when formatting is applied. Information is provided about the <code>position</code> of the character in the document where the change occurred, the number of characters removed (<code>charsRemoved</code>), and the number of characters added (<code>charsAdded</code>). The signal is emitted before the document’s layout manager is notified about the change. This hook allows you to implement syntax highlighting for the document.</li>
<li><code>void QTextDocument::contentsChanged() [signal]</code>: This signal is emitted whenever the document’s content changes; for example, when text is inserted or deleted, or when formatting is applied.</li>
<li><code>QTextObject * QTextDocument::createObject(const QTextFormat &amp; format) [virtual protected]</code>: Creates and returns a new document object (a <code>QTextObject</code>), based on the given <code>format</code>. <code>QTextObjects</code> will always get created through this method, so you must reimplement it if you use custom text objects inside your document.</li>
<li><code>void QTextDocument::cursorPositionChanged(const QTextCursor &amp; cursor) [signal]</code>: This signal is emitted whenever the position of a cursor changed due to an editing operation. The cursor that changed is passed in <code>cursor</code>. If you need a signal when the cursor is moved with the arrow keys, you can use the <code>cursorPositionChanged()</code> signal in <code>QTextEdit</code>.</li>
<li><code>Qt::CursorMoveStyle QTextDocument::defaultCursorMoveStyle() const</code>: The default cursor movement style is used by all <code>QTextCursor</code> objects created from the document. The default is <code>Qt::LogicalMoveStyle</code>.</li>
<li><code>QAbstractTextDocumentLayout * QTextDocument::documentLayout() const</code>: Returns the document layout for this document.</li>
<li><code>void QTextDocument::documentLayoutChanged() [signal]</code>: This signal is emitted when a new document layout is set.</li>
<li><code>void QTextDocument::drawContents(QPainter * p, const QRectF &amp; rect = QRectF())</code>: Draws the content of the document with painter <code>p</code>, clipped to <code>rect</code>. If <code>rect</code> is a null rectangle (default), then the document is painted unclipped.</li>
<li><code>QTextBlock QTextDocument::end() const</code>: This function returns a block to test for the end of the document while iterating over it.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( QTextBlock it = doc-&gt;begin(); it != doc-&gt;end(); it = it.next() ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it.text().toStdString() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The block returned is invalid and represents the block after the last block in the document. You can use <code>lastBlock()</code> to retrieve the last valid block of the document.</p>
<ul>
<li><code>QTextCursor QTextDocument::find(const QString &amp; subString, const QTextCursor &amp; cursor, FindFlags options = 0) const</code>: Finds the next occurrence of the string, <code>subString</code>, in the document. The search starts at the position of the given <code>cursor</code>, and proceeds forwards through the document unless specified otherwise in the search options. The <code>options</code> control the type of search performed. Returns a cursor with the match selected if <code>subString</code> was found; otherwise returns a null cursor. If the given <code>cursor</code> has a selection, the search begins after the selection; otherwise it begins at the cursor’s position. By default the search is <code>case-sensitive</code>, and can match text anywhere in the document.</li>
<li><code>QTextCursor QTextDocument::find(const QRegExp &amp; expr, const QTextCursor &amp; cursor, FindFlags options = 0) const</code>: Finds the next occurrence, matching the regular expression, <code>expr</code>, in the document. The search starts at the position of the given <code>cursor</code>, and proceeds forwards through the document unless specified otherwise in the search options. The <code>options</code> control the type of search performed. The <code>FindCaseSensitively</code> option is ignored for this overload, use <code>QRegExp::caseSensitivity</code> instead. Returns a cursor with the match selected if a match was found; otherwise returns a null cursor. If the given <code>cursor</code> has a selection, the search begins after the selection; otherwise it begins at the cursor’s position. By default the search is <code>case-sensitive</code>, and can match text anywhere in the document.</li>
<li><code>QTextCursor QTextDocument::find(const QString &amp; subString, int position = 0, FindFlags options = 0) const</code>: This is an overloaded function. Finds the next occurrence of the string, <code>subString</code>, in the document. The search starts at the given <code>position</code>, and proceeds forwards through the document unless specified otherwise in the search options. The <code>options</code> control the type of search performed. Returns a cursor with the match selected if <code>subString</code> was found; otherwise returns a null cursor. If the <code>position</code> is <code>0</code> (the default), the search begins from the beginning of the document; otherwise it begins at the specified <code>position</code>.</li>
<li><code>QTextCursor QTextDocument::find(const QRegExp &amp; expr, int position = 0, FindFlags options = 0) const</code>: This is an overloaded function. Finds the next occurrence, matching the regular expression, <code>expr</code>, in the document. The search starts at the given <code>position</code>, and proceeds forwards through the document unless specified otherwise in the search options. The <code>options</code> control the type of search performed. The <code>FindCaseSensitively</code> option is ignored for this overload, use <code>QRegExp::caseSensitivity</code> instead. Returns a cursor with the match selected if a match was found; otherwise returns a null cursor. If the <code>position</code> is <code>0</code> (the default) the search begins from the beginning of the document; otherwise it begins at the specified <code>position</code>.</li>
<li><code>QTextBlock QTextDocument::findBlock(int pos) const</code>: Returns the text block that contains the <code>pos-th</code> character.</li>
<li><code>QTextBlock QTextDocument::findBlockByLineNumber(int lineNumber) const</code>: Returns the text block that contains the specified <code>lineNumber</code>.</li>
<li><code>QTextBlock QTextDocument::findBlockByNumber(int blockNumber) const</code>: Returns the text block with the specified <code>blockNumber</code>.</li>
<li><code>QTextBlock QTextDocument::firstBlock() const</code>: Returns the document’s first text block.</li>
<li><code>qreal QTextDocument::idealWidth() const</code>: Returns the ideal width of the text document. The ideal width is the actually used width of the document without optional alignments taken into account. It is always <code>&lt;= size().width()</code>.</li>
<li><code>bool QTextDocument::isEmpty() const</code>: Returns <code>true</code> if the document is empty; otherwise returns <code>false</code>.</li>
<li><code>bool QTextDocument::isRedoAvailable() const</code>: Returns <code>true</code> if redo is available; otherwise returns <code>false</code>.</li>
<li><code>bool QTextDocument::isUndoAvailable() const</code>: Returns <code>true</code> if undo is available; otherwise returns <code>false</code>.</li>
<li><code>QTextBlock QTextDocument::lastBlock() const</code>: Returns the document’s last (valid) text block.</li>
<li><code>int QTextDocument::lineCount() const</code>: Returns the number of lines of this document (if the layout supports this). Otherwise, this is identical to the number of blocks.</li>
<li><code>QVariant QTextDocument::loadResource(int type, const QUrl &amp; name) [virtual protected]</code>: Loads data of the specified <code>type</code> from the resource with the given <code>name</code>. This function is called by the rich text engine to request data that isn’t directly stored by <code>QTextDocument</code>, but still associated with it. For example, images are referenced indirectly by the name attribute of a <code>QTextImageFormat</code> object. When called by <code>Qt</code>, <code>type</code> is one of the values of <code>QTextDocument::ResourceType</code>. If the <code>QTextDocument</code> is a child object of a <code>QTextEdit</code>, <code>QTextBrowser</code>, or a <code>QTextDocument</code> itself then the default implementation tries to retrieve the data from the parent.</li>
<li><code>void QTextDocument::markContentsDirty(int position, int length)</code>: Marks the contents specified by the given <code>position</code> and <code>length</code> as <code>dirty</code>, informing the document that it needs to be laid out again.</li>
<li><code>QString QTextDocument::metaInformation(MetaInformation info) const</code>: Returns meta information about the document of the type specified by <code>info</code>.</li>
<li><code>void QTextDocument::modificationChanged(bool changed) [signal]</code>: This signal is emitted whenever the content of the document changes in a way that affects the modification state. If <code>changed</code> is <code>true</code>, the document has been modified; otherwise it is <code>false</code>. For example, calling <code>setModified(false)</code> on a document and then inserting text causes the signal to get emitted. If you undo that operation, causing the document to return to its original unmodified state, the signal will get emitted again.</li>
<li><code>QTextObject * QTextDocument::object(int objectIndex) const</code>: Returns the text object associated with the given <code>objectIndex</code>.</li>
<li><code>QTextObject * QTextDocument::objectForFormat(const QTextFormat &amp; f) const</code>: Returns the text object associated with the format <code>f</code>.</li>
<li><code>int QTextDocument::pageCount() const</code>: Returns the number of pages in this document.</li>
<li><code>void QTextDocument::print(QPrinter * printer) const</code>: Prints the document to the given <code>printer</code>. The <code>QPrinter</code> must be set up before being used with this function. This is only a convenience method to print the whole document to the printer. If the document is already paginated through a specified height in the <code>pageSize()</code> property it is printed <code>as-is</code>. If the document is not paginated, like for example a document used in a <code>QTextEdit</code>, then a temporary copy of the document is created and the copy is broken into multiple pages according to the size of the <code>QPrinter&#39;s</code> <code>paperRect()</code>. By default a <code>2</code> cm margin is set around the document contents. In addition the current page number is printed at the bottom of each page. Note that <code>QPrinter::Selection</code> is not supported as print range with this function since the selection is a property of <code>QTextCursor</code>. If you have a <code>QTextEdit</code> associated with your <code>QTextDocument</code> then you can use <code>QTextEdit&#39;s</code> <code>print()</code> function because <code>QTextEdit</code> has access to the user’s selection.</li>
<li><code>void QTextDocument::redo(QTextCursor * cursor)</code>: Redoes the last editing operation on the document if redo is available. The provided <code>cursor</code> is positioned at the end of the location where the edition operation was redone.</li>
<li><code>void QTextDocument::redo() [slot]</code>: This is an overloaded function. Redoes the last editing operation on the document if redo is available.</li>
<li><code>void QTextDocument::redoAvailable(bool available) [signal]</code>: This signal is emitted whenever redo operations become available (<code>available</code> is <code>true</code>) or unavailable (<code>available</code> is <code>false</code>).</li>
<li><code>QVariant QTextDocument::resource(int type, const QUrl &amp; name) const</code>: Returns data of the specified <code>type</code> from the resource with the given <code>name</code>. This function is called by the rich text engine to request data that isn’t directly stored by <code>QTextDocument</code>, but still associated with it. For example, images are referenced indirectly by the name attribute of a <code>QTextImageFormat</code> object. Resources are cached internally in the document. If a resource can not be found in the cache, <code>loadResource</code> is called to try to load the resource. <code>loadResource</code> should then use <code>addResource</code> to add the resource to the cache.</li>
<li><code>int QTextDocument::revision() const</code>: Returns the document’s revision (if undo is enabled). The revision is guaranteed to increase when a document that is not modified is edited.</li>
<li><code>QTextFrame * QTextDocument::rootFrame() const</code>: Returns the document’s root frame.</li>
<li><code>void QTextDocument::setDefaultCursorMoveStyle(Qt::CursorMoveStyle style)</code>: Sets the default cursor movement style to the given <code>style</code>.</li>
<li><code>void QTextDocument::setDocumentLayout(QAbstractTextDocumentLayout * layout)</code>: Sets the document to use the given <code>layout</code>. The previous layout is deleted.</li>
<li><code>void QTextDocument::setHtml(const QString &amp; html)</code>: Replaces the entire contents of the document with the given <code>HTML-formatted</code> text in the <code>html</code> string. The <code>HTML</code> formatting is respected as much as possible; for example, <code>&lt;b&gt;bold&lt;/b&gt; text</code> will produce text where the first word has a font weight that gives it a bold appearance: <code>bold text</code>. <strong>Note</strong>: It is the responsibility of the caller to make sure that the text is correctly decoded when a <code>QString</code> containing <code>HTML</code> is created and passed to <code>setHtml()</code>.</li>
<li><code>void QTextDocument::setMetaInformation(MetaInformation info, const QString &amp; string)</code>: Sets the document’s meta information of the type specified by <code>info</code> to the given <code>string</code>.</li>
<li><code>void QTextDocument::setPlainText(const QString &amp; text)</code>: Replaces the entire contents of the document with the given plain <code>text</code>.</li>
<li><code>QString QTextDocument::toHtml(const QByteArray &amp; encoding = QByteArray()) const</code>: Returns a string containing an <code>HTML</code> representation of the document. The <code>encoding</code> parameter specifies the value for the charset attribute in the html header. For example if <code>utf-8</code> is specified then the beginning of the generated html will look like this:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>...</span><br></pre></td></tr></table></figure>
<p>If no encoding is specified then no such meta information is generated. If you later on convert the returned html string into a byte array for transmission over a network or when saving to disk you should specify the encoding you’re going to use for the conversion to a byte array here.</p>
<ul>
<li><code>QString QTextDocument::toPlainText() const</code>: Returns the plain text contained in the document. If you want formatting information use a <code>QTextCursor</code> instead.</li>
<li><code>void QTextDocument::undo(QTextCursor * cursor)</code>: Undoes the last editing operation on the document if undo is available. The provided <code>cursor</code> is positioned at the end of the location where the edition operation was undone.</li>
<li><code>void QTextDocument::undo() [slot]</code>: This is an overloaded function.</li>
<li><code>void QTextDocument::undoAvailable(bool available) [signal]</code>: This signal is emitted whenever undo operations become available (<code>available</code> is true) or unavailable (<code>available</code> is false).</li>
<li><code>void QTextDocument::undoCommandAdded() [signal]</code>: This signal is emitted every time a new level of undo is added to the <code>QTextDocument</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/01/Qt语法详解/Qt之拖放/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/01/Qt语法详解/Qt之拖放/" itemprop="url">Qt之拖放</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-01T18:27:48+08:00">
                2019-02-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;拖放是应用程序内或者多个应用程序之间传递信息的一种直观的操作方式。除了为剪贴板提供支持之外，通常还提供数据的移动和复制功能。<br>&emsp;&emsp;拖放操作包括两个截然不同的动作，即拖动、放下。<code>Qt</code>窗口部件可以作为拖动点(<code>drag site</code>)、放下点(<code>drop site</code>)或者同时作为拖动点和放下点。<br>&emsp;&emsp;下面介绍如何让一个<code>Qt</code>应用程序接收一个拖动操作，当用户从桌面或者文件资源管理器中拖动一个文件到这个应用程序上放下时，该应用程序就会将文件的信息显示出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabelView</span> :</span> <span class="keyword">public</span> QTableView &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TabelView</span> <span class="params">( QWidget *parent = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dragEnterEvent</span> <span class="params">( QDragEnterEvent *event )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dragMoveEvent</span> <span class="params">( QDragMoveEvent *event )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dropEvent</span> <span class="params">( QDropEvent *event )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">TabelView::TabelView ( QWidget *parent ) : QTableView ( parent ) &#123;</span><br><span class="line">    setAcceptDrops ( <span class="literal">true</span> );</span><br><span class="line">    setDragDropMode ( QAbstractItemView::DragDrop );</span><br><span class="line">    setDragEnabled ( <span class="literal">true</span> );</span><br><span class="line">    setDropIndicatorShown ( <span class="literal">true</span> );</span><br><span class="line">    <span class="keyword">this</span>-&gt;setWindowTitle ( <span class="string">"TableView"</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> TabelView::dragEnterEvent ( QDragEnterEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasFormat ( <span class="string">"text/uri-list"</span> ) ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"drag enter"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;以上通过自定义<code>QTableView</code>来实现拖放事件，首先需要设置<code>setAcceptDrops(true)</code>来接受放下事件，通过设置<code>setDropIndicatorShown(true)</code>则可以清晰地看到放下过程中的图标指示。然后实现<code>dragEnterEvent</code>、<code>dropEvent</code>方法，当用户把一个对象拖动到这个窗体上时，就会调用<code>dragEnterEvent</code>，如果对这个事件调用<code>acceptProposedAction</code>，就表明可以在这个窗体上拖放对象。默认情况下窗口部件是不接受拖动的，<code>Qt</code>会自动改变光标向用户说明这个窗口部件不是有效的放下点。<br>&emsp;&emsp;我们希望用户拖放的只能是文件，而非其他类型的东西。为了实现这一点，可以检查拖动的<code>MIME</code>类型。<code>MIME</code>类型中<code>text/uri-list</code>用于存储统一资源标识符，它们可以是文件名、统一资源定位器(例如<code>HTTP</code>、<code>FTP</code>路径)或者其它全局资源标识符。标准的<code>MIME</code>类型由国际因特网地址分配委员会<code>IANA</code>定义的，它们由类型、子类型信息以及分割两者的斜线组成。<code>MIME</code>类通常由剪贴板和拖放系统使用，以识别不同类型的数据。<br>&emsp;&emsp;当用户在窗口部件上放下一个对象时，就会调用<code>dropEvent</code>。我们调用函数<code>QMimeData::urls</code>来获得<code>QUrl</code>列表。通常情况下，用户一次只拖动一个选择区域来同时拖动多个文件也是可能的，如果要拖放的<code>URL</code>不止一个，或者要拖放的<code>URL</code>不是一个本地文件名，则会立即返回到原调用处。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TabelView::dragMoveEvent ( QDragMoveEvent *event ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"drag move"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>QWidget</code>也提供了<code>dragMoveEvent</code>和<code>dragLeveEvent</code>函数，但是绝大多数情况下并不需要重新实现，上面简单实现了<code>dragMoveEvent</code>函数。</p>
<hr>
<h3 id="Drag-and-Drop"><a href="#Drag-and-Drop" class="headerlink" title="Drag and Drop"></a>Drag and Drop</h3><p>&emsp;&emsp;Drag and drop provides a simple visual mechanism which users can use to transfer information between and within applications (In the literature this is referred to as a <code>direct manipulation model</code>). Drag and drop is similar in function to the clipboard’s cut and paste mechanism.<br>&emsp;&emsp;This document describes the basic drag and drop mechanism and outlines the approach used to enable it in custom widgets. Drag and drop operations are also supported by Qt’s item views and by the graphics view framework. More information is available in Using drag and drop with item views and <code>Graphics View Framework</code>.</p>
<h3 id="Drag-and-Drop-Classes"><a href="#Drag-and-Drop-Classes" class="headerlink" title="Drag and Drop Classes"></a>Drag and Drop Classes</h3><p>&emsp;&emsp;These classes deal with drag and drop and the necessary mime type encoding and decoding.</p>
<ul>
<li>QDragEnterEvent: Event which is sent to a widget when a drag and drop action enters it.</li>
<li>QDragLeaveEvent: Event that is sent to a widget when a drag and drop action leaves it.</li>
<li>QDragMoveEvent: Event which is sent while a drag and drop action is in progress.</li>
<li>QDropEvent: Event which is sent when a drag and drop action is completed.</li>
<li>QMacPasteboardMime: Converts between a <code>MIME</code> type and a <code>Uniform Type Identifier</code> (<code>UTI</code>) format.</li>
<li>QWindowsMime: Maps <code>open-standard</code> <code>MIME</code> to Window <code>Clipboard</code> formats.</li>
</ul>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><p>&emsp;&emsp;The <code>QApplication</code> object provides some properties that are related to drag and drop operations:</p>
<ul>
<li><code>QApplication::startDragTime</code> describes the amount of time in milliseconds that the user must hold down a mouse button over an object before a drag will begin.</li>
<li><code>QApplication::startDragDistance</code> indicates how far the user has to move the mouse while holding down a mouse button before the movement will be interpreted as dragging. Use of high values for this quantity prevents accidental dragging when the user only meant to click on an object.</li>
</ul>
<p>&emsp;&emsp;These quantities provide sensible default values for you to use if you provide drag and drop support in your widgets.</p>
<h3 id="Dragging"><a href="#Dragging" class="headerlink" title="Dragging"></a>Dragging</h3><p>&emsp;&emsp;To start a drag, create a <code>QDrag</code> object, and call its <code>exec()</code> function. In most applications, it is a good idea to begin a drag and drop operation only after a mouse button has been pressed and the cursor has been moved a certain distance. However, the simplest way to enable dragging from a widget is to reimplement the widget’s <code>mousePressEvent()</code> and start a drag and drop operation:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::mousePressEvent ( QMouseEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;button() == Qt::LeftButton</span><br><span class="line">         &amp;&amp; iconLabel-&gt;geometry().contains ( event-&gt;pos() ) ) &#123;</span><br><span class="line">        QDrag *drag = <span class="keyword">new</span> QDrag ( <span class="keyword">this</span> );</span><br><span class="line">        QMimeData *mimeData = <span class="keyword">new</span> QMimeData;</span><br><span class="line">        mimeData-&gt;setText ( commentEdit-&gt;toPlainText() );</span><br><span class="line">        drag-&gt;setMimeData ( mimeData );</span><br><span class="line">        drag-&gt;setPixmap ( iconPixmap );</span><br><span class="line">        Qt::DropAction dropAction = drag-&gt;exec();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Although the user may take some time to complete the dragging operation, as far as the application is concerned the <code>exec()</code> function is a blocking function that returns with one of several values. These indicate how the operation ended, and are described in more detail below.<br>&emsp;&emsp;Note that the <code>exec()</code> function does not block the main event loop.<br>&emsp;&emsp;For widgets that need to distinguish between mouse clicks and drags, it is useful to reimplement the widget’s <code>mousePressEvent()</code> function to record to start position of the drag:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DragWidget::mousePressEvent ( QMouseEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;button() == Qt::LeftButton ) &#123;</span><br><span class="line">        dragStartPosition = event-&gt;pos();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Later, in <code>mouseMoveEvent()</code>, we can determine whether a drag should begin, and construct a drag object to handle the operation:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DragWidget::mouseMoveEvent ( QMouseEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ! ( event-&gt;buttons() &amp; Qt::LeftButton ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( event-&gt;pos() - dragStartPosition ).manhattanLength() &lt; QApplication::startDragDistance() ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    QDrag *drag = <span class="keyword">new</span> QDrag ( <span class="keyword">this</span> );</span><br><span class="line">    QMimeData *mimeData = <span class="keyword">new</span> QMimeData;</span><br><span class="line">    mimeData-&gt;setData ( mimeType, data );</span><br><span class="line">    drag-&gt;setMimeData ( mimeData );</span><br><span class="line">    Qt::DropAction dropAction = drag-&gt;exec ( Qt::CopyAction | Qt::MoveAction );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This particular approach uses the <code>QPoint::manhattanLength()</code> function to get a rough estimate of the distance between where the mouse click occurred and the current cursor position. This function trades accuracy for speed, and is usually suitable for this purpose.</p>
<h3 id="Dropping"><a href="#Dropping" class="headerlink" title="Dropping"></a>Dropping</h3><p>&emsp;&emsp;To be able to receive media dropped on a widget, call <code>setAcceptDrops(true)</code> for the widget, and reimplement the <code>dragEnterEvent()</code> and <code>dropEvent()</code> event handler functions.<br>&emsp;&emsp;For example, the following code enables drop events in the constructor of a <code>QWidget</code> subclass, making it possible to usefully implement drop event handlers:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Window::Window ( QWidget *parent ) : QWidget ( parent ) &#123;</span><br><span class="line">    ...</span><br><span class="line">    setAcceptDrops ( <span class="literal">true</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>dragEnterEvent()</code> function is typically used to inform Qt about the types of data that the widget accepts. You must reimplement this function if you want to receive either <code>QDragMoveEvent</code> or <code>QDropEvent</code> in your reimplementations of <code>dragMoveEvent()</code> and <code>dropEvent()</code>.<br>&emsp;&emsp;The following code shows how <code>dragEnterEvent()</code> can be reimplemented to tell the drag and drop system that we can only handle plain text:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Window::dragEnterEvent ( QDragEnterEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasFormat ( <span class="string">"text/plain"</span> ) ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>dropEvent()</code> is used to unpack dropped data and handle it in way that is suitable for your application.<br>&emsp;&emsp;In the following code, the text supplied in the event is passed to a <code>QTextBrowser</code> and a <code>QComboBox</code> is filled with the list of <code>MIME</code> types that are used to describe the data:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Window::dropEvent ( QDropEvent *event ) &#123;</span><br><span class="line">    textBrowser-&gt;setPlainText ( event-&gt;mimeData()-&gt;text() );</span><br><span class="line">    mimeTypeCombo-&gt;clear();</span><br><span class="line">    mimeTypeCombo-&gt;addItems ( event-&gt;mimeData()-&gt;formats() );</span><br><span class="line">    event-&gt;acceptProposedAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;In this case, we accept the proposed action without checking what it is. In a real world application, it may be necessary to return from the <code>dropEvent()</code> function without accepting the proposed action or handling the data if the action is not relevant. For example, we may choose to ignore <code>Qt::LinkAction</code> actions if we do not support links to external sources in our application.</p>
<h3 id="Overriding-Proposed-Actions"><a href="#Overriding-Proposed-Actions" class="headerlink" title="Overriding Proposed Actions"></a>Overriding Proposed Actions</h3><p>&emsp;&emsp;We may also ignore the proposed action, and perform some other action on the data. To do this, we would call the event object’s <code>setDropAction()</code> with the preferred action from <code>Qt::DropAction</code> before calling <code>accept()</code>. This ensures that the replacement drop action is used instead of the proposed action.<br>&emsp;&emsp;For more sophisticated applications, reimplementing <code>dragMoveEvent()</code> and <code>dragLeaveEvent()</code> will let you make certain parts of your widgets sensitive to drop events, and give you more control over drag and drop in your application.</p>
<h3 id="Subclassing-Complex-Widgets"><a href="#Subclassing-Complex-Widgets" class="headerlink" title="Subclassing Complex Widgets"></a>Subclassing Complex Widgets</h3><p>&emsp;&emsp;Certain standard Qt widgets provide their own support for drag and drop. When subclassing these widgets, it may be necessary to reimplement <code>dragMoveEvent()</code> in addition to <code>dragEnterEvent()</code> and <code>dropEvent()</code> to prevent the base class from providing default drag and drop handling, and to handle any special cases you are interested in.</p>
<h3 id="Drag-and-Drop-Actions"><a href="#Drag-and-Drop-Actions" class="headerlink" title="Drag and Drop Actions"></a>Drag and Drop Actions</h3><p>&emsp;&emsp;In the simplest case, the target of a drag and drop action receives a copy of the data being dragged, and the source decides whether to delete the original. This is described by the <code>CopyAction</code> action. The target may also choose to handle other actions, specifically the <code>MoveAction</code> and <code>LinkAction</code> actions. If the source calls <code>QDrag::exec()</code>, and it returns <code>MoveAction</code>, the source is responsible for deleting any original data if it chooses to do so. The <code>QMimeData</code> and <code>QDrag</code> objects created by the source widget should not be deleted — they will be destroyed by Qt. The target is responsible for taking ownership of the data sent in the drag and drop operation; this is usually done by keeping references to the data.<br>&emsp;&emsp;If the target understands the <code>LinkAction</code> action, it should store its own reference to the original information; the source does not need to perform any further processing on the data. The most common use of drag and drop actions is when performing a <code>Move</code> within the same widget.<br>&emsp;&emsp;The other major use of drag actions is when using a reference type such as text/uri-list, where the dragged data are actually references to files or objects.</p>
<h3 id="Adding-New-Drag-and-Drop-Types"><a href="#Adding-New-Drag-and-Drop-Types" class="headerlink" title="Adding New Drag and Drop Types"></a>Adding New Drag and Drop Types</h3><p>&emsp;&emsp;Drag and drop is not limited to text and images. Any type of information can be transferred in a drag and drop operation. To drag information between applications, the applications must be able to indicate to each other which data formats they can accept and which they can produce. This is achieved using <code>MIME</code> types. The <code>QDrag</code> object constructed by the source contains a list of <code>MIME</code> types that it uses to represent the data (ordered from most appropriate to least appropriate), and the drop target uses one of these to access the data. For common data types, the convenience functions handle the <code>MIME</code> types used transparently but, for custom data types, it is necessary to state them explicitly.<br>&emsp;&emsp;To implement drag and drop actions for a type of information that is not covered by the <code>QDrag</code> convenience functions, the first and most important step is to look for existing formats that are appropriate: The <code>Internet Assigned Numbers Authority</code> (<code>IANA</code>) provides a hierarchical list of <code>MIME</code> media types at the <code>Information Sciences Institute</code> (<code>ISI</code>). Using standard <code>MIME</code> types maximizes the interoperability of your application with other software now and in the future.<br>&emsp;&emsp;To support an additional media type, simply set the data in the <code>QMimeData</code> object with the <code>setData()</code> function, supplying the full <code>MIME</code> type and a <code>QByteArray</code> containing the data in the appropriate format. The following code takes a pixmap from a label and stores it as a <code>Portable Network Graphics</code> (<code>PNG</code>) file in a <code>QMimeData</code> object:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QByteArray output;</span><br><span class="line"><span class="function">QBuffer <span class="title">outputBuffer</span> <span class="params">( &amp;output )</span></span>;</span><br><span class="line">outputBuffer.open ( QIODevice::WriteOnly );</span><br><span class="line">imageLabel-&gt;pixmap()-&gt;toImage().save ( &amp;outputBuffer, <span class="string">"PNG"</span> );</span><br><span class="line">mimeData-&gt;setData ( <span class="string">"image/png"</span>, output );</span><br></pre></td></tr></table></figure>
<p>Of course, for this case we could have simply used <code>setImageData()</code> instead to supply image data in a variety of formats:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimeData-&gt;setImageData ( QVariant ( *imageLabel-&gt;pixmap() ) );</span><br></pre></td></tr></table></figure>
<p>The <code>QByteArray</code> approach is still useful in this case because it provides greater control over the amount of data stored in the <code>QMimeData</code> object. Note that custom datatypes used in item views must be declared as meta objects and that stream operators for them must be implemented.</p>
<h3 id="Drop-Actions"><a href="#Drop-Actions" class="headerlink" title="Drop Actions"></a>Drop Actions</h3><p>&emsp;&emsp;In the clipboard model, the user can cut or copy the source information, then later paste it. Similarly in the drag and drop model, the user can drag a copy of the information or they can drag the information itself to a new place (moving it). The drag and drop model has an additional complication for the programmer: The program doesn’t know whether the user wants to cut or copy the information until the operation is complete. This often makes no difference when dragging information between applications, but within an application it is important to check which drop action was used.<br>&emsp;&emsp;We can reimplement the <code>mouseMoveEvent()</code> for a widget, and start a drag and drop operation with a combination of possible drop actions. For example, we may want to ensure that dragging always moves objects in the widget:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DragWidget::mouseMoveEvent ( QMouseEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ! ( event-&gt;buttons() &amp; Qt::LeftButton ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( event-&gt;pos() - dragStartPosition ).manhattanLength()</span><br><span class="line">         &lt; QApplication::startDragDistance() ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    QDrag *drag = <span class="keyword">new</span> QDrag ( <span class="keyword">this</span> );</span><br><span class="line">    QMimeData *mimeData = <span class="keyword">new</span> QMimeData;</span><br><span class="line">    mimeData-&gt;setData ( mimeType, data );</span><br><span class="line">    drag-&gt;setMimeData ( mimeData );</span><br><span class="line">    Qt::DropAction dropAction = drag-&gt;exec ( Qt::CopyAction | Qt::MoveAction );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The action returned by the <code>exec()</code> function may default to a <code>CopyAction</code> if the information is dropped into another application but, if it is dropped in another widget in the same application, we may obtain a different drop action.<br>&emsp;&emsp;The proposed drop actions can be filtered in a widget’s <code>dragMoveEvent()</code> function. However, it is possible to accept all proposed actions in the <code>dragEnterEvent()</code> and let the user decide which they want to accept later:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DragWidget::dragEnterEvent ( QDragEnterEvent *event ) &#123;</span><br><span class="line">    event-&gt;acceptProposedAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;When a drop occurs in the widget, the <code>dropEvent()</code> handler function is called, and we can deal with each possible action in turn. First, we deal with drag and drop operations within the same widget:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DragWidget::dropEvent ( QDropEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;source() == <span class="keyword">this</span> &amp;&amp; event-&gt;possibleActions() &amp; Qt::MoveAction )</span><br><span class="line">        <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;In this case, we refuse to deal with move operations. Each type of drop action that we accept is checked and dealt with accordingly:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ( event-&gt;proposedAction() == Qt::MoveAction ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">        <span class="comment">/* Process the data from the event */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( event-&gt;proposedAction() == Qt::CopyAction ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">        <span class="comment">/* Process the data from the event */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Ignore the drop */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that we checked for individual drop actions in the above code. As mentioned above in the section on <code>Overriding Proposed Actions</code>, it is sometimes necessary to override the proposed drop action and choose a different one from the selection of possible drop actions. To do this, you need to check for the presence of each action in the value supplied by the event’s <code>possibleActions()</code>, set the drop action with <code>setDropAction()</code>, and call <code>accept()</code>.</p>
<h3 id="Drop-Rectangles"><a href="#Drop-Rectangles" class="headerlink" title="Drop Rectangles"></a>Drop Rectangles</h3><p>&emsp;&emsp;The widget’s <code>dragMoveEvent()</code> can be used to restrict drops to certain parts of the widget by only accepting the proposed drop actions when the cursor is within those areas. For example, the following code accepts any proposed drop actions when the cursor is over a child widget (dropFrame):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Window::dragMoveEvent ( QDragMoveEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasFormat ( <span class="string">"text/plain"</span> ) &amp;&amp; \</span><br><span class="line">         event-&gt;answerRect().intersects ( dropFrame-&gt;geometry() ) ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>dragMoveEvent()</code> can also be used if you need to give visual feedback during a drag and drop operation, to scroll the window, or whatever is appropriate.</p>
<h3 id="The-Clipboard"><a href="#The-Clipboard" class="headerlink" title="The Clipboard"></a>The Clipboard</h3><p>&emsp;&emsp;Applications can also communicate with each other by putting data on the clipboard. To access this, you need to obtain a <code>QClipboard</code> object from the <code>QApplication</code> object:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clipboard = QApplication::clipboard();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>QMimeData</code> class is used to represent data that is transferred to and from the clipboard. To put data on the clipboard, you can use the <code>setText()</code>, <code>setImage()</code> and <code>setPixmap()</code> convenience functions for common data types. These functions are similar to those found in the <code>QMimeData</code> class, except that they also take an additional argument that controls where the data is stored: If <code>Clipboard</code> is specified, the data is placed on the clipboard; if <code>Selection</code> is specified, the data is placed in the mouse selection (on <code>X11</code> only). By default, data is put on the clipboard.<br>&emsp;&emsp;For example, we can copy the contents of a <code>QLineEdit</code> to the clipboard with the following code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clipboard-&gt;setText ( lineEdit-&gt;text(), QClipboard::Clipboard );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Data with different <code>MIME</code> types can also be put on the clipboard. Construct a <code>QMimeData</code> object and set data with <code>setData()</code> function in the way described in the previous section; this object can then be put on the clipboard with the <code>setMimeData()</code> function.<br>&emsp;&emsp;The <code>QClipboard</code> class can notify the application about changes to the data it contains via its <code>dataChanged()</code> signal. For example, we can monitor the clipboard by connecting this signal to a slot in a widget:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect ( clipboard, SIGNAL ( dataChanged() ), <span class="keyword">this</span>, SLOT ( updateClipboard() ) );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The slot connected to this signal can read the data on the clipboard using one of the <code>MIME</code> types that can be used to represent it:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ClipWindow::updateClipboard() &#123;</span><br><span class="line">    QStringList formats = clipboard-&gt;mimeData()-&gt;formats();</span><br><span class="line">    QByteArray data = clipboard-&gt;mimeData()-&gt;data ( format );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>selectionChanged()</code> signal can be used on <code>X11</code> to monitor the mouse selection.</p>
<h3 id="Interoperating-with-Other-Applications"><a href="#Interoperating-with-Other-Applications" class="headerlink" title="Interoperating with Other Applications"></a>Interoperating with Other Applications</h3><p>&emsp;&emsp;On <code>X11</code>, the public <code>XDND</code> protocol is used, while on <code>Windows</code> Qt uses the <code>OLE</code> standard, and Qt for <code>Mac OS X</code> uses the <code>Carbon Drag Manager</code>. On <code>X11</code>, <code>XDND</code> uses <code>MIME</code>, so no translation is necessary. The Qt API is the same regardless of the platform. On <code>Windows</code>, <code>MIME-aware</code> applications can communicate by using clipboard format names that are <code>MIME</code> types. Already some Windows applications use <code>MIME</code> naming conventions for their clipboard formats. Internally, Qt uses <code>QWindowsMime</code> and <code>QMacPasteboardMime</code> for translating proprietary clipboard formats to and from <code>MIME</code> types.<br><strong>Note</strong>: The <code>Motif Drag &amp; Drop Protocol</code> only allows receivers to request data in response to a <code>QDropEvent</code>. If you attempt to request data in response to e.g. a <code>QDragMoveEvent</code>, an empty <code>QByteArray</code> is returned.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/01/Qt语法详解/QString用法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/01/Qt语法详解/QString用法/" itemprop="url">QString用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-01T16:01:27+08:00">
                2019-02-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;从字符串<code>one, two, three, four</code>中获取第二个由<code>,</code>分隔的子串，即<code>two</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtCore/QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QString str = <span class="string">"one, two, three, four"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str.section ( <span class="string">','</span>, <span class="number">1</span>, <span class="number">1</span> ).trimmed().toStdString() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>trimmed</code>用于去掉字符串前后的<code>\t</code>、<code>\n</code>、<code>\v</code>、<code>\f</code>、<code>\r</code>和<code>空格</code>，这些字符用<code>QChar::isSpace</code>判断都返回<code>true</code>。<br>&emsp;&emsp;从字符串<code>one, two* three / four / five ^ six</code>中获取第四个由<code>,</code>、<code>*</code>、<code>/</code>和<code>^</code>分隔的子串，即<code>four</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtCore/QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QRegExp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QString str = <span class="string">"one, two* three / four / five ^ six"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str.section ( QRegExp ( <span class="string">"[,*/^]"</span> ), <span class="number">3</span>, <span class="number">3</span> ).trimmed().toStdString() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面用到了一个简单的正则表达式，在<code>Qt</code>中可以由类<code>QRegExp</code>构造，函数<code>section</code>支持使用正则表达式。</p>
<hr>
<p>&emsp;&emsp;<code>section</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString QString::section ( QChar sep, <span class="keyword">int</span> start, <span class="keyword">int</span> end = <span class="number">-1</span>, \</span><br><span class="line">                           SectionFlags flags = SectionDefault ) <span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<p>这个函数把字符串看成是几个块，这些块由<code>sep</code>分隔，<code>start</code>和<code>end</code>指定块号，返回的是<code>[start, end]</code>内的块组成的字符串。如果<code>start</code>和<code>end</code>都是负数，那么将从字符串的后面往前面数，返回<code>[-end, -start]</code>内的块组成的字符串。<code>SectionFlags</code>是一些标记，例如<code>SectionSkipEmpty</code>表示如果两个分隔符之间是空串，那么就会跳过。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QString str;</span><br><span class="line">QString csv = <span class="string">"forename,middlename,surname,phone"</span>;</span><br><span class="line">QString path = <span class="string">"/usr/local/bin/myapp"</span>; <span class="comment">// First field is empty</span></span><br><span class="line">QString::SectionFlag flag = QString::SectionSkipEmpty;</span><br><span class="line">​</span><br><span class="line">str = csv.section ( <span class="string">','</span>, <span class="number">2</span>, <span class="number">2</span> ); <span class="comment">// str == "surname"</span></span><br><span class="line">str = path.section ( <span class="string">'/'</span>, <span class="number">3</span>, <span class="number">4</span> ); <span class="comment">// str == "bin/myapp"</span></span><br><span class="line">str = path.section ( <span class="string">'/'</span>, <span class="number">3</span>, <span class="number">3</span>, flag ); <span class="comment">// str == "myapp"</span></span><br><span class="line">​</span><br><span class="line">str = csv.section ( <span class="string">','</span>, <span class="number">-3</span>, <span class="number">-2</span> ); <span class="comment">// str == "middlename,surname"</span></span><br><span class="line">str = path.section ( <span class="string">'/'</span>, <span class="number">-1</span> ); <span class="comment">// str == "myapp"</span></span><br></pre></td></tr></table></figure>
<p>这个函数的另两个重载函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString QString::section ( <span class="keyword">const</span> QString &amp;sep, <span class="keyword">int</span> start, <span class="keyword">int</span> end = <span class="number">-1</span>, \</span><br><span class="line">                           SectionFlags flags = SectionDefault ) <span class="keyword">const</span></span><br><span class="line">QString QString::section ( <span class="keyword">const</span> QRegExp &amp;reg, <span class="keyword">int</span> start, <span class="keyword">int</span> end = <span class="number">-1</span>, \</span><br><span class="line">                           SectionFlags flags = SectionDefault ) <span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>split</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QStringList QString::split ( <span class="keyword">const</span> QChar &amp;sep, SplitBehavior behavior = KeepEmptyParts, \</span><br><span class="line">                             Qt::CaseSensitivity cs = Qt::CaseSensitive ) <span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<p>这个函数把所有的由<code>sep</code>分隔的块装进一个<code>QStringList</code>中返回，这个函数同样有两个重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QStringList QString::split ( <span class="keyword">const</span> QString &amp;sep, SplitBehavior behavior = KeepEmptyParts, \</span><br><span class="line">                             Qt::CaseSensitivity cs = Qt::CaseSensitive ) <span class="keyword">const</span></span><br><span class="line">QStringList QString::split ( <span class="keyword">const</span> QRegExp &amp;rx, SplitBehavior behavior = KeepEmptyParts ) <span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<p>使用实例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtCore/QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QRegExp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QStringList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QString str = <span class="string">"one, two* three / four / five ^ six"</span>;</span><br><span class="line">    <span class="comment">/* 把每一个块装进一个QStringList中 */</span></span><br><span class="line">    QStringList sections = str.split ( QRegExp ( <span class="string">"[,*/^]"</span> ) );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sections.at ( <span class="number">3</span> ).trimmed().toStdString() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="QString与数字的相互转化"><a href="#QString与数字的相互转化" class="headerlink" title="QString与数字的相互转化"></a>QString与数字的相互转化</h3><h4 id="把QString转换为double类型"><a href="#把QString转换为double类型" class="headerlink" title="把QString转换为double类型"></a>把QString转换为double类型</h4><p>&emsp;&emsp;方法<code>1</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">"123.45"</span>;</span><br><span class="line"><span class="keyword">double</span> val = str.toDouble(); <span class="comment">/* val = 123.45 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;方法<code>2</code>很适合科学计数法形式转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="comment">/* ok is true, d is 12.3456 */</span></span><br><span class="line">d = QString ( <span class="string">"1234.56e-02"</span> ).toDouble ( &amp;ok );</span><br></pre></td></tr></table></figure>
<h4 id="把QString转换为float型"><a href="#把QString转换为float型" class="headerlink" title="把QString转换为float型"></a>把QString转换为float型</h4><p>&emsp;&emsp;方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方法1 */</span></span><br><span class="line">QString str = <span class="string">"123.45"</span>;</span><br><span class="line"><span class="keyword">float</span> d = str.toFloat(); <span class="comment">/* d = 123.45 */</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 方法2 */</span></span><br><span class="line">QString str = <span class="string">"R2D2"</span>;</span><br><span class="line"><span class="keyword">bool</span> ok;</span><br><span class="line"><span class="keyword">float</span> d = str.toFloat ( &amp;ok ); <span class="comment">/* 转换失败返回0.0，ok为false */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;把<code>double</code>型数据转换为<code>QString</code>类型：<code>double</code>类转换<code>QString</code>类型使用<code>QString::number</code>函数，第一个参数为需要转换的<code>double</code>数据；第二个参数为基数，即<code>10</code>、<code>2</code>、<code>8</code>等；第三个参数为精度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> intResult;</span><br><span class="line">QLabel *pornPropLabel;</span><br><span class="line">pornPropLabel-&gt;setText ( QString::number ( intResult, <span class="number">10</span>, <span class="number">4</span> ) );</span><br></pre></td></tr></table></figure>
<h3 id="把QString形转换为整型"><a href="#把QString形转换为整型" class="headerlink" title="把QString形转换为整型"></a>把QString形转换为整型</h3><p>&emsp;&emsp;1. 转换为十进制整型：基数默认为<code>10</code>。如果基数为<code>0</code>，若字符串是以<code>0x</code>开头的就会转换为<code>16</code>进制，若以<code>0</code>开头就转换为八进制，否则就转换为十进制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Qstring str = <span class="string">"FF"</span>;</span><br><span class="line"><span class="keyword">bool</span> ok;</span><br><span class="line"><span class="keyword">int</span> dec = str.toInt ( &amp;ok, <span class="number">10</span> ); <span class="comment">/* dec is 255, ok is true */</span></span><br><span class="line"><span class="keyword">int</span> hex = str.toInt ( &amp;ok, <span class="number">16</span> ); <span class="comment">/* hex is 255, ok is true */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 常整型转换为<code>Qstring</code>型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a = <span class="number">63</span>;</span><br><span class="line">QString str = QString::number ( a, <span class="number">16</span> ); <span class="comment">/* str = "3f" */</span></span><br><span class="line">QString str = QString::number ( a, <span class="number">16</span> ).toUpper(); <span class="comment">/* str = "3F" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>Qstring</code>转换为<code>char *</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方法一 */</span></span><br><span class="line"><span class="function">QString <span class="title">qstr</span> <span class="params">( <span class="string">"hello,word"</span> )</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = qstr.toLocal8Bit().data();</span><br><span class="line"><span class="comment">/* 方法二 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = qstr.toStdString().data(); <span class="comment">/* 转换过来的是常量 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;把当前时间转化为<code>QString</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QDateTime qdate = QDateTime::currentDateTime();</span><br><span class="line">datetime = qdate.toString ( <span class="string">"yyyy年MM月dd日ddddhh:mm:ss"</span> );</span><br></pre></td></tr></table></figure>
<hr>
<p>&emsp;&emsp;<code>QString</code>类提供了很方便的对字符串操作的接口。<br>&emsp;&emsp;1. 使某个字符填满字符串，也就是说字符串里的所有字符都用等长度的<code>ch</code>来代替：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString::fill ( QChar ch, <span class="keyword">int</span> size = <span class="number">-1</span> );</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">"Berlin"</span>;</span><br><span class="line">str.fill ( <span class="string">'z'</span> ); <span class="comment">/* str is "zzzzzz" */</span></span><br><span class="line">str.fill ( <span class="string">'A'</span>, <span class="number">2</span> ); <span class="comment">/* str is "AA" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 从字符串里查找相同的某个字符串<code>str</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QString::indexOf ( <span class="keyword">const</span> QString &amp;str, <span class="keyword">int</span> from = <span class="number">0</span>, \</span><br><span class="line">                       Qt::CaseSensitivity cs = Qt::CaseSensitive ) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QString x = <span class="string">"sticky question"</span>;</span><br><span class="line">QString y = <span class="string">"sti"</span>;</span><br><span class="line">x.indexOf ( y );  <span class="comment">/* returns 0 */</span></span><br><span class="line">x.indexOf ( y, <span class="number">1</span> ); <span class="comment">/* returns 10 */</span></span><br><span class="line">x.indexOf ( y, <span class="number">10</span> ); <span class="comment">/* returns 10 */</span></span><br><span class="line">x.indexOf ( y, <span class="number">11</span> ); <span class="comment">/* returns -1 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3. 指定位置插入字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString &amp;QString::insert ( <span class="keyword">int</span> position, <span class="keyword">const</span> QString &amp;str );</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">"Meal"</span>;</span><br><span class="line">str.insert ( <span class="number">1</span>, QString ( <span class="string">"ontr"</span> ) ); <span class="comment">/* str is "Montreal" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;4. 判断字符串是否为空：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> QString::isEmpty () <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString().isEmpty(); <span class="comment">/* returns true */</span></span><br><span class="line">QString ( <span class="string">""</span> ).isEmpty(); <span class="comment">/* returns true */</span></span><br><span class="line">QString ( <span class="string">"x"</span> ).isEmpty(); <span class="comment">/* returns false */</span></span><br><span class="line">QString ( <span class="string">"abc"</span> ).isEmpty(); <span class="comment">/* returns false */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;5. 判断字符串是否存在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> QString::isNull () <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString().isNull(); <span class="comment">/* returns true */</span></span><br><span class="line">QString ( <span class="string">""</span> ).isNull(); <span class="comment">/* returns false */</span></span><br><span class="line">QString ( <span class="string">"abc"</span> ).isNull(); <span class="comment">/* returns false */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;6. 从左向右截取字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString QString::left ( <span class="keyword">int</span> n ) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString x = <span class="string">"Pineapple"</span>;</span><br><span class="line">QString y = x.left ( <span class="number">4</span> ); <span class="comment">/* y is "Pine" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;7. 从中间截取字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString QString::mid ( <span class="keyword">int</span> position, <span class="keyword">int</span> n = <span class="number">-1</span> ) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString x = <span class="string">"Nine pineapples"</span>;</span><br><span class="line">QString y = x.mid ( <span class="number">5</span>, <span class="number">4</span> ); <span class="comment">/* y is "pine" */</span></span><br><span class="line">QString z = x.mid ( <span class="number">5</span> ); <span class="comment">/* z is "pineapples" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;8. 删除字符串中的某个字符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString &amp;QString::remove ( <span class="keyword">int</span> position, <span class="keyword">int</span> n );</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString s = <span class="string">"Montreal"</span>;</span><br><span class="line">s.remove ( <span class="number">1</span>, <span class="number">4</span> ); <span class="comment">/* s is "Meal" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;9. 替换字符串中的某些字符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString &amp;QString::replace ( <span class="keyword">int</span> position, <span class="keyword">int</span> n, <span class="keyword">const</span> QString &amp;after );</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString x = <span class="string">"Say yes!"</span>;</span><br><span class="line">QString y = <span class="string">"no"</span>;</span><br><span class="line">x.replace ( <span class="number">4</span>, <span class="number">3</span>, y ); <span class="comment">/* x is "Say no!" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;10. 把整型、浮点型或其他类型转化为<code>QString</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString &amp;QString::setNum ( uint n, <span class="keyword">int</span> base = <span class="number">10</span> );</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="QString与“char-”之间的转换"><a href="#QString与“char-”之间的转换" class="headerlink" title="QString与“char *”之间的转换"></a>QString与“char *”之间的转换</h3><p>&emsp;&emsp;1. <code>QString</code>转换为<code>char *</code>。<br>&emsp;&emsp;先将<code>QString</code>转换为<code>QByteArray</code>，再将<code>QByteArray</code>转换为<code>char *</code>。注意，不能用下面的转换形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *mm = str.toLatin1().data();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. <code>char *</code>转换为<code>QString</code>。<br>&emsp;&emsp;可以使用<code>QString</code>的构造函数进行转换，即<code>QString(const QLatin1String &amp;str);</code>，<code>QLatin1String</code>的构造函数为<code>QLatin1String(const char *str);</code>。如下语句是将<code>char * mm</code>转换为<code>QString str</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = QString ( QLatin1String ( mm ) );</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtGui/QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QString&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    QString str = “hello”; <span class="comment">/* QString转“char *” */</span></span><br><span class="line">    QByteArray ba = str.toLatin1();</span><br><span class="line">    <span class="keyword">char</span> *mm = ba.data();</span><br><span class="line">    qDebug() &lt;&lt; mm &lt;&lt; <span class="built_in">endl</span>; <span class="comment">/* 调试时，在console中输出 */</span></span><br><span class="line">    QString nn = QString ( QLatin1String ( mm ) ); <span class="comment">/* “char *”转QString */</span></span><br><span class="line">    qDebug() &lt;&lt; nn &lt;&lt; <span class="built_in">endl</span>; <span class="comment">/* 调试时，在console中输出 */</span></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="如何使用QString-arg？"><a href="#如何使用QString-arg？" class="headerlink" title="如何使用QString::arg？"></a>如何使用QString::arg？</h3><p>&emsp;&emsp;<code>QString::arg</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString QString::arg ( <span class="keyword">const</span> QString &amp;a, <span class="keyword">int</span> fieldWidth = <span class="number">0</span>, \</span><br><span class="line">                       <span class="keyword">const</span> QChar &amp;fillChar = QLatin1Char ( <span class="string">' '</span> ) ) <span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<p>功能为<code>Returns a copy of this string with the lowest numbered place marker replaced by string a, i.e., %1, %2, ..., %99.</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QString i = <span class="string">"5"</span>; <span class="comment">/* current file's number */</span></span><br><span class="line">QString total = <span class="string">"10"</span>; <span class="comment">/* number of files to process */</span></span><br><span class="line">QString fileName = <span class="string">"lyc.txt"</span>; <span class="comment">/* current file's name */</span></span><br><span class="line">QString status = QString ( <span class="string">"Processing file %1 of %2: %3"</span> ).arg ( i ).arg ( total ).arg ( fileName );</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"status:"</span> &lt;&lt; status;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status: <span class="string">"Processing file 5 of 10: lyc.txt"</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="String和QString之间的转化"><a href="#String和QString之间的转化" class="headerlink" title="String和QString之间的转化"></a>String和QString之间的转化</h3><p>&emsp;&emsp;代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString qstr;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">str = qstr.toStdString();</span><br><span class="line">qstr = QString::fromStdString ( str );</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/31/Qt语法详解/Qt之QList/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/31/Qt语法详解/Qt之QList/" itemprop="url">Qt之QList</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-31T19:46:43+08:00">
                2019-01-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QList</code> class is a template class that provides lists.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QList</code></td>
<td><code>QItemSelection</code>, <code>QQueue</code>, <code>QSignalSpy</code>, <code>QStringList</code> and <code>QTestEventList</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QList()</code></td>
</tr>
<tr>
<td></td>
<td><code>QList(const QList&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td></td>
<td><code>QList(std::initializer_list&lt;T&gt; args)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QList()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>append(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>append(const QList&lt;T&gt; &amp; value)</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>at(int i) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>back()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>back() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>begin()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constBegin() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constEnd() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>contains(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>empty() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>end()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>endsWith(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator pos)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator begin, iterator end)</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>first()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>first() const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>front()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>front() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>indexOf(const T &amp; value, int from = 0) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insert(int i, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insert(iterator before, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>last()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>last() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lastIndexOf(const T &amp; value, int from = -1) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>length() const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>mid(int pos, int length = -1) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>move(int from, int to)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>pop_back()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>pop_front()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>prepend(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>push_back(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>push_front(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>removeAll(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeAt(int i)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeFirst()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeLast()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>removeOne(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>replace(int i, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>reserve(int alloc)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>startsWith(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(QList&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(int i, int j)</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>takeAt(int i)</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>takeFirst()</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>takeLast()</code></td>
</tr>
<tr>
<td><code>QSet&lt;T&gt;</code></td>
<td><code>toSet() const</code></td>
</tr>
<tr>
<td><code>std::list&lt;T&gt;</code></td>
<td><code>toStdList() const</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>toVector() const</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>value(int i) const</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>value(int i, const T &amp; defaultValue) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QList&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>operator+(const QList&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt; &amp;</code></td>
<td><code>operator+=(const QList&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt; &amp;</code></td>
<td><code>operator+=(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt; &amp;</code></td>
<td><code>operator&lt;&lt;(const QList&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt; &amp;</code></td>
<td><code>operator&lt;&lt;(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt; &amp;</code></td>
<td><code>operator=(const QList&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QList &amp;</code></td>
<td><code>operator=(QList &amp;&amp; other)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QList&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>operator[](int i)</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>operator[](int i) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Static-Public-Members"><a href="#Static-Public-Members" class="headerlink" title="Static Public Members"></a>Static Public Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>fromSet ( const QSet&lt;T&gt; &amp;set );</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>fromStdList ( const std::list&lt;T&gt; &amp;list );</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>fromVector ( const QVector&lt;T&gt; &amp;vector );</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&lt;&lt; ( QDataStream &amp;out, const QList&lt;T&gt; &amp;list );</code></td>
</tr>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&gt;&gt; ( QDataStream &amp;in, QList&lt;T&gt; &amp;list );</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QList</code> class is a template class that provides lists.<br>&emsp;&emsp;<code>QList&lt;T&gt;</code> is one of <code>Qt&#39;s</code> generic container classes. It stores a list of values and provides fast <code>index-based</code> access as well as fast insertions and removals.<br>&emsp;&emsp;<code>QList&lt;T&gt;</code>, <code>QLinkedList&lt;T&gt;</code>, and <code>QVector&lt;T&gt;</code> provide similar functionality. Here’s an overview:<br>&emsp;&emsp;For most purposes, <code>QList</code> is the right class to use. Its <code>index-based</code> <code>API</code> is more convenient than <code>QLinkedList&#39;s</code> <code>iterator-based</code> <code>API</code>, and it is usually faster than <code>QVector</code> because of the way it stores its items in memory. It also expands to less code in your executable.<br>&emsp;&emsp;If you need a real linked list, with guarantees of constant time insertions in the middle of the list and iterators to items rather than indexes, use <code>QLinkedList</code>.<br>&emsp;&emsp;If you want the items to occupy adjacent memory positions, use <code>QVector</code>.<br>&emsp;&emsp;Internally, <code>QList&lt;T&gt;</code> is represented as an array of pointers to items of type <code>T</code>. If <code>T</code> is itself a pointer type or a basic type that is no larger than a pointer, or if <code>T</code> is one of Qt’s shared classes, then <code>QList&lt;T&gt;</code> stores the items directly in the pointer array. For lists under a thousand items, this array representation allows for very fast insertions in the middle, and it allows <code>index-based</code> access. Furthermore, operations like <code>prepend()</code> and <code>append()</code> are very fast, because <code>QList</code> preallocates memory at both ends of its internal array. Note, however, that for unshared list items that are larger than a pointer, each append or insert of a new item requires allocating the new item on the heap, and this per item allocation might make <code>QVector</code> a better choice in cases that do lots of appending or inserting, since <code>QVector</code> allocates memory for its items in a single heap allocation.<br>&emsp;&emsp;Note that the internal array only ever gets bigger over the life of the list. It never shrinks. The internal array is deallocated by the destructor, by <code>clear()</code>, and by the assignment operator, when one list is assigned to another.<br>&emsp;&emsp;Here’s an example of a <code>QList</code> that stores integers and a <code>QList</code> that stores <code>QDate</code> values:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;<span class="keyword">int</span>&gt; integerList;</span><br><span class="line">QList&lt;QDate&gt; dateList;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Qt includes a <code>QStringList</code> class that inherits <code>QList&lt;QString&gt;</code> and adds a convenience function <code>QStringList::join()</code> (<code>QString::split()</code> creates <code>QStringLists</code> from strings).<br>&emsp;&emsp;<code>QList</code> stores a list of items. The default constructor creates an empty list. To insert items into the list, you can use <code>operator&lt;&lt;()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "one" &lt;&lt; "two" &lt;&lt; "three"; /* <span class="built_in">list</span>: ["one", "two", "three"] */</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>QList</code> provides these basic functions to add, move, and remove items: <code>insert()</code>, <code>replace()</code>, <code>removeAt()</code>, <code>move()</code>, and <code>swap()</code>. In addition, it provides the following convenience functions: <code>append()</code>, <code>prepend()</code>, <code>removeFirst()</code> and <code>removeLast()</code>.<br>&emsp;&emsp;<code>QList</code> uses <code>0-based</code> indexes, just like <code>C++</code> arrays. To access the item at a particular index position, you can use <code>operator[]()</code>. On <code>non-const</code> lists, <code>operator[]()</code> returns a reference to the item and can be used on the left side of an assignment:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">list</span>[<span class="number">0</span>] == <span class="string">"Bob"</span> ) &#123;</span><br><span class="line">    <span class="built_in">list</span>[<span class="number">0</span>] = <span class="string">"Robert"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Because <code>QList</code> is implemented as an array of pointers, this operation is very fast (constant time). For <code>read-only</code> access, an alternative syntax is to use <code>at()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">list</span>.at ( i ) == <span class="string">"Jane"</span> ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found Jane at position "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>at()</code> can be faster than <code>operator[]()</code>, because it never causes a deep copy to occur.<br>&emsp;&emsp;A common requirement is to remove an item from a list and do something with it. For this, <code>QList</code> provides <code>takeAt()</code>, <code>takeFirst()</code>, and <code>takeLast()</code>. Here’s a loop that removes the items from a list one at a time and calls delete on them:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QWidget *&gt; <span class="built_in">list</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( !<span class="built_in">list</span>.isEmpty() ) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">list</span>.takeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Inserting and removing items at either ends of the list is very fast (constant time in most cases), because <code>QList</code> preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.<br>&emsp;&emsp;If you want to find all occurrences of a particular value in a list, use <code>indexOf()</code> or <code>lastIndexOf()</code>. The former searches forward starting from a given index position, the latter searches backward. Both return the index of a matching item if they find it; otherwise, they return <code>-1</code>. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="built_in">list</span>.indexOf ( <span class="string">"Jane"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( i != <span class="number">-1</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"First occurrence of Jane is at position "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If you simply want to check whether a list contains a particular value, use <code>contains()</code>. If you want to find out how many times a particular value occurs in the list, use <code>count()</code>. If you want to replace all occurrences of a particular value with another, use <code>replace()</code>.<br>&emsp;&emsp;<code>QList&#39;s</code> value type must be an assignable data type. This covers most data types that are commonly used, but the compiler won’t let you, for example, store a <code>QWidget</code> as a value; instead, store a <code>QWidget *</code>. A few functions have additional requirements; for example, <code>indexOf()</code> and <code>lastIndexOf()</code> expect the value type to support <code>operator==()</code>. These requirements are documented on a <code>per-function</code> basis.<br>&emsp;&emsp;Like the other container classes, <code>QList</code> provides <code>Java-style</code> iterators (<code>QListIterator</code> and <code>QMutableListIterator</code>) and <code>STL-style</code> iterators (<code>QList::const_iterator</code> and <code>QList::iterator</code>). In practice, these are rarely used, because you can use indexes into the <code>QList</code>. <code>QList</code> is implemented in such a way that direct <code>index-based</code> access is just as fast as using iterators.<br>&emsp;&emsp;<code>QList</code> does not support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.<br>&emsp;&emsp;To make <code>QList</code> as efficient as possible, its member functions don’t validate their input before using it. Except for <code>isEmpty()</code>, member functions always assume the list is not empty. Member functions that take index values as parameters always assume their index value parameters are in the valid range. This means <code>QList</code> member functions can fail. If you define <code>QT_NO_DEBUG</code> when you compile, failures will not be detected. If you don’t define <code>QT_NO_DEBUG</code>, failures will be detected using <code>Q_ASSERT()</code> or <code>Q_ASSERT_X()</code> with an appropriate message.<br>&emsp;&emsp;To avoid failures when your list can be empty, call <code>isEmpty()</code> before calling other member functions. If you must pass an index value that might not be in the valid range, check that it is less than the value returned by <code>size()</code> but not less than <code>0</code>.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>typedef <code>QList::ConstIterator</code>: <code>Qt-style</code> synonym for <code>QList::const_iterator</code>.</li>
<li>typedef <code>QList::Iterator</code>: <code>Qt-style</code> synonym for <code>QList::iterator</code>.</li>
<li>typedef <code>QList::const_pointer</code>: Typedef for <code>const T *</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::const_reference</code>: Typedef for <code>const T &amp;</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::difference_type</code>: Typedef for <code>ptrdiff_t</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::pointer</code>: Typedef for <code>T *</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::reference</code>: Typedef for <code>T &amp;</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::size_type</code>: Typedef for <code>int</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::value_type</code>: Typedef for <code>T</code>. Provided for <code>STL</code> compatibility.</li>
</ul>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QList::QList()</code>: Constructs an empty list.</li>
<li><code>QList::QList(const QList&lt;T&gt; &amp; other)</code>: Constructs a copy of <code>other</code>. This operation takes constant time, because <code>QList</code> is implicitly shared. This makes returning a <code>QList</code> from a function very fast. If a shared instance is modified, it will be copied (<code>copy-on-write</code>), and that takes linear time.</li>
<li><code>QList::QList(std::initializer_list&lt;T&gt; args)</code>: Construct a list from the <code>std::initializer_list specified</code> by <code>args</code>. This constructor is only enabled if the compiler supports <code>C++0x</code>.</li>
<li><code>QList::~QList()</code>: Destroys the list. References to the values in the list and all iterators of this list become invalid.</li>
<li><code>void QList::append(const T &amp; value)</code>: Inserts <code>value</code> at the end of the list. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span>.append ( <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">list</span>.append ( <span class="string">"two"</span> );</span><br><span class="line"><span class="built_in">list</span>.append ( <span class="string">"three"</span> ); <span class="comment">/* list: ["one", "two", "three"] */</span></span><br></pre></td></tr></table></figure>
<p>This is the same as <code>list.insert(size(), value)</code>. This operation is typically very fast (constant time), because <code>QList</code> preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.</p>
<ul>
<li><code>void QList::append(const QList&lt;T&gt; &amp; value)</code>: This is an overloaded function. Appends the items of the <code>value</code> list to this list.</li>
<li><code>const T &amp; QList::at(int i) const</code>: Returns the item at index position <code>i</code> in the list. <code>i</code> must be a valid index position in the list (i.e., <code>0 &lt;= i &lt; size()</code>). This function is very fast (constant time).</li>
<li><code>T &amp; QList::back()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>last()</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>const T &amp; QList::back() const</code>: This is an overloaded function.</li>
<li><code>iterator QList::begin()</code>: Returns an <code>STL-style</code> iterator pointing to the first item in the list.</li>
<li><code>const_iterator QList::begin() const</code>: This is an overloaded function.</li>
<li><code>void QList::clear()</code>: Removes all items from the list.</li>
<li><code>const_iterator QList::constBegin() const</code>: Returns a const <code>STL-style</code> iterator pointing to the first item in the list.</li>
<li><code>const_iterator QList::constEnd() const</code>: Returns a const <code>STL-style</code> iterator pointing to the imaginary item after the last item in the list.</li>
<li><code>bool QList::contains(const T &amp; value) const</code>: Returns <code>true</code> if the list contains an occurrence of <code>value</code>; otherwise returns <code>false</code>. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>int QList::count(const T &amp; value) const</code>: Returns the number of occurrences of <code>value</code> in the list. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>int QList::count() const</code>: Returns the number of items in the list. This is effectively the same as <code>size()</code>.</li>
<li><code>bool QList::empty() const</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>isEmpty()</code> and returns <code>true</code> if the list is empty.</li>
<li><code>iterator QList::end()</code>: Returns an <code>STL-style</code> iterator pointing to the imaginary item after the last item in the list.</li>
<li><code>const_iterator QList::end() const</code>: This is an overloaded function.</li>
<li><code>bool QList::endsWith(const T &amp; value) const</code>: Returns <code>true</code> if this list is not empty and its last item is equal to <code>value</code>; otherwise returns <code>false</code>.</li>
<li><code>iterator QList::erase(iterator pos)</code>: Removes the item associated with the iterator <code>pos</code> from the list, and returns an iterator to the next item in the list (which may be <code>end()</code>).</li>
<li><code>iterator QList::erase(iterator begin, iterator end)</code>: This is an overloaded function. Removes all the items from <code>begin</code> up to (but not including) <code>end</code>. Returns an iterator to the same item that end referred to before the call.</li>
<li><code>T &amp; QList::first()</code>: Returns a reference to the first item in the list. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>const T &amp; QList::first() const</code>: This is an overloaded function.</li>
<li><code>QList&lt;T&gt; QList::fromSet(const QSet&lt;T&gt; &amp; set) [static]</code>: Returns a <code>QList</code> object with the data contained in <code>set</code>. The order of the elements in the <code>QList</code> is undefined. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QSet&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line"><span class="built_in">set</span> &lt;&lt; 20 &lt;&lt; 30 &lt;&lt; 40 &lt;&lt; ... &lt;&lt; 70;</span><br><span class="line">​</span><br><span class="line">QList&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span> = QList&lt;<span class="keyword">int</span>&gt;::fromSet ( <span class="built_in">set</span> );</span><br><span class="line">qSort ( <span class="built_in">list</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QList&lt;T&gt; QList::fromStdList(const std::list&lt;T&gt; &amp; list) [static]</code>: Returns a <code>QList</code> object with the data contained in <code>list</code>. The order of the elements in the <code>QList</code> is the same as in <code>list</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; stdlist;</span><br><span class="line"><span class="built_in">list</span>.push_back ( <span class="number">1.2</span> );</span><br><span class="line"><span class="built_in">list</span>.push_back ( <span class="number">0.5</span> );</span><br><span class="line"><span class="built_in">list</span>.push_back ( <span class="number">3.14</span> );</span><br><span class="line">​</span><br><span class="line">QList&lt;<span class="keyword">double</span>&gt; <span class="built_in">list</span> = QList&lt;<span class="keyword">double</span>&gt;::fromStdList ( stdlist );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QList&lt;T&gt; QList::fromVector(const QVector&lt;T&gt; &amp; vector) [static]</code>: Returns a <code>QList</code> object with the data contained in <code>vector</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">double</span>&gt; vect;</span><br><span class="line">vect &lt;&lt; <span class="number">20.0</span> &lt;&lt; <span class="number">30.0</span> &lt;&lt; <span class="number">40.0</span> &lt;&lt; <span class="number">50.0</span>;</span><br><span class="line">​</span><br><span class="line">QList&lt;<span class="keyword">double</span>&gt; <span class="built_in">list</span> = QVector&lt;T&gt;::fromVector ( vect ); <span class="comment">/* list: [20.0, 30.0, 40.0, 50.0] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>T &amp; QList::front()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>first()</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>const T &amp; QList::front() const</code>: This is an overloaded function.</li>
<li><code>int QList::indexOf(const T &amp; value, int from = 0) const</code>: Returns the index position of the first occurrence of <code>value</code> in the list, searching forward from index position <code>from</code>. Returns <code>-1</code> if no item matched. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "B" &lt;&lt; "A";</span><br><span class="line"><span class="built_in">list</span>.indexOf ( "B" ); /* returns 1 */</span><br><span class="line"><span class="built_in">list</span>.indexOf ( "B", 1 ); /* returns 1 */</span><br><span class="line"><span class="built_in">list</span>.indexOf ( "B", 2 ); /* returns 3 */</span><br><span class="line"><span class="built_in">list</span>.indexOf ( "X" ); /* returns -1 */</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>. Note that <code>QList</code> uses <code>0-based</code> indexes, just like <code>C++</code> arrays. Negative indexes are not supported with the exception of the value mentioned above.</p>
<ul>
<li><code>void QList::insert(int i, const T &amp; value)</code>: Inserts <code>value</code> at index position <code>i</code> in the list. If <code>i</code> is <code>0</code>, the <code>value</code> is prepended to the list. If <code>i</code> is <code>size()</code>, the <code>value</code> is appended to the list. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "alpha" &lt;&lt; "beta" &lt;&lt; "delta";</span><br><span class="line"><span class="built_in">list</span>.insert ( 2, "gamma" ); /* <span class="built_in">list</span>: ["alpha", "beta", "gamma", "delta"] */</span><br></pre></td></tr></table></figure>
<ul>
<li><code>iterator QList::insert(iterator before, const T &amp; value)</code>: This is an overloaded function. Inserts <code>value</code> in front of the item pointed to by the iterator <code>before</code>. Returns an iterator pointing at the inserted item. Note that the iterator passed to the function will be invalid after the call; the returned iterator should be used instead.</li>
<li><code>bool QList::isEmpty() const</code>: Returns <code>true</code> if the list contains no items; otherwise returns <code>false</code>.</li>
<li><code>T &amp; QList::last()</code>: Returns a reference to the last item in the list. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>const T &amp; QList::last() const</code>: This is an overloaded function.</li>
<li><code>int QList::lastIndexOf(const T &amp; value, int from = -1) const</code>: Returns the index position of the last occurrence of <code>value</code> in the list, searching backward from index position <code>from</code>. If <code>from</code> is <code>-1</code> (the default), the search starts at the last item. Returns <code>-1</code> if no item matched. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "B" &lt;&lt; "A";</span><br><span class="line"><span class="built_in">list</span>.lastIndexOf ( "B" ); /* returns 3 */</span><br><span class="line"><span class="built_in">list</span>.lastIndexOf ( "B", 3 ); /* returns 3 */</span><br><span class="line"><span class="built_in">list</span>.lastIndexOf ( "B", 2 ); /* returns 1 */</span><br><span class="line"><span class="built_in">list</span>.lastIndexOf ( "X" ); /* returns -1 */</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>. Note that <code>QList</code> uses <code>0-based</code> indexes, just like <code>C++</code> arrays. Negative indexes are not supported with the exception of the value mentioned above.</p>
<ul>
<li><code>int QList::length() const</code>: This function is identical to <code>count()</code>.</li>
<li><code>QList&lt;T&gt; QList::mid(int pos, int length = -1) const</code>: Returns a list whose elements are copied from this list, starting at position <code>pos</code>. If <code>length</code> is <code>-1</code> (the default), all elements from <code>pos</code> are copied; otherwise <code>length</code> elements (or all remaining elements if there are less than <code>length</code> elements) are copied.</li>
<li><code>void QList::move(int from, int to)</code>: Moves the item at index position <code>from</code> to index position <code>to</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "D" &lt;&lt; "E" &lt;&lt; "F";</span><br><span class="line"><span class="built_in">list</span>.move ( 1, 4 ); /* <span class="built_in">list</span>: ["A", "C", "D", "E", "B", "F"] */</span><br></pre></td></tr></table></figure>
<p>This is the same as <code>insert(to, takeAt(from))</code>. This function assumes that both from and to are at least <code>0</code> but less than <code>size()</code>. To avoid failure, test that both from and to are at least <code>0</code> and less than <code>size()</code>.</p>
<ul>
<li><code>void QList::pop_back()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>removeLast()</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>void QList::pop_front()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>removeFirst()</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>void QList::prepend(const T &amp; value)</code>: Inserts <code>value</code> at the beginning of the list. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span>.prepend ( <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">list</span>.prepend ( <span class="string">"two"</span> );</span><br><span class="line"><span class="built_in">list</span>.prepend ( <span class="string">"three"</span> ); <span class="comment">/* list: ["three", "two", "one"] */</span></span><br></pre></td></tr></table></figure>
<p>This is the same as <code>list.insert(0, value)</code>. This operation is usually very fast (constant time), because <code>QList</code> preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.</p>
<ul>
<li><code>void QList::push_back(const T &amp; value)</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>append(value)</code>.</li>
<li><code>void QList::push_front(const T &amp; value)</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>prepend(value)</code>.</li>
<li><code>int QList::removeAll(const T &amp; value)</code>: Removes all occurrences of <code>value</code> in the list and returns the number of entries removed. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "sun" &lt;&lt; "cloud" &lt;&lt; "sun" &lt;&lt; "rain";</span><br><span class="line"><span class="built_in">list</span>.removeAll("sun"); /* <span class="built_in">list</span>: ["cloud", "rain"] */</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>.</p>
<ul>
<li><code>void QList::removeAt(int i)</code>: Removes the item at index position <code>i</code>. <code>i</code> must be a valid index position in the list (i.e., <code>0 &lt;= i &lt; size()</code>).</li>
<li><code>void QList::removeFirst()</code>: Removes the first item in the list. Calling this function is equivalent to calling <code>removeAt(0)</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>void QList::removeLast()</code>: Removes the last item in the list. Calling this function is equivalent to calling <code>removeAt(size() - 1)</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>bool QList::removeOne(const T &amp; value)</code>: Removes the first occurrence of <code>value</code> in the list and returns <code>true</code> on success; otherwise returns <code>false</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "sun" &lt;&lt; "cloud" &lt;&lt; "sun" &lt;&lt; "rain";</span><br><span class="line"><span class="built_in">list</span>.removeOne("sun"); /* <span class="built_in">list</span>: ["cloud", ,"sun", "rain"] */</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>.</p>
<ul>
<li><code>void QList::replace(int i, const T &amp; value)</code>: Replaces the item at index position <code>i</code> with <code>value</code>. <code>i</code> must be a valid index position in the list (i.e., <code>0 &lt;= i &lt; size()</code>).</li>
<li><code>void QList::reserve(int alloc)</code>: Reserve space for <code>alloc</code> elements. If <code>alloc</code> is smaller than the current size of the list, nothing will happen. Use this function to avoid repetetive reallocation of <code>QList&#39;s</code> internal data if you can predict how many elements will be appended. Note that the reservation applies only to the internal pointer array.</li>
<li><code>int QList::size() const</code>: Returns the number of items in the list.</li>
<li><code>bool QList::startsWith(const T &amp; value) const</code>: Returns <code>true</code> if this list is not empty and its first item is equal to <code>value</code>; otherwise returns <code>false</code>.</li>
<li><code>void QList::swap(QList&lt;T&gt; &amp; other)</code>: Swaps list <code>other</code> with this list. This operation is very fast and never fails.</li>
<li><code>void QList::swap(int i, int j)</code>: Exchange the item at index position <code>i</code> with the item at index position <code>j</code>. This function assumes that both <code>i</code> and <code>j</code> are at least <code>0</code> but less than <code>size()</code>. To avoid failure, test that both <code>i</code> and <code>j</code> are at least <code>0</code> and less than <code>size()</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "D" &lt;&lt; "E" &lt;&lt; "F";</span><br><span class="line"><span class="built_in">list</span>.swap ( 1, 4 ); /* <span class="built_in">list</span>: ["A", "E", "C", "D", "B", "F"] */</span><br></pre></td></tr></table></figure>
<ul>
<li><code>T QList::takeAt(int i)</code>: Removes the item at index position <code>i</code> and returns it. <code>i</code> must be a valid index position in the list (i.e., <code>0 &lt;= i &lt; size()</code>). If you don’t use the return value, <code>removeAt()</code> is more efficient.</li>
<li><code>T QList::takeFirst()</code>: Removes the first item in the list and returns it. This is the same as <code>takeAt(0)</code>. This function assumes the list is not empty. To avoid failure, call <code>isEmpty()</code> before calling this function. This operation takes constant time. If you don’t use the return value, <code>removeFirst()</code> is more efficient.</li>
<li><code>T QList::takeLast()</code>: Removes the last item in the list and returns it. This is the same as <code>takeAt(size() - 1)</code>. This function assumes the list is not empty. To avoid failure, call <code>isEmpty()</code> before calling this function. This operation takes constant time. If you don’t use the return value, <code>removeLast()</code> is more efficient.</li>
<li><code>QSet&lt;T&gt; QList::toSet() const</code>: Returns a <code>QSet</code> object with the data contained in this <code>QList</code>. Since <code>QSet</code> doesn’t allow duplicates, the resulting <code>QSet</code> might be smaller than the original list was. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QStringList <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "Julia" &lt;&lt; "Mike" &lt;&lt; "Mike" &lt;&lt; "Julia" &lt;&lt; "Julia";</span><br><span class="line">​</span><br><span class="line">QSet&lt;QString&gt; <span class="built_in">set</span> = <span class="built_in">list</span>.toSet();</span><br><span class="line"><span class="built_in">set</span>.contains ( <span class="string">"Julia"</span> ); <span class="comment">/* returns true */</span></span><br><span class="line"><span class="built_in">set</span>.contains ( <span class="string">"Mike"</span> ); <span class="comment">/* returns true */</span></span><br><span class="line"><span class="built_in">set</span>.size(); <span class="comment">/* returns 2 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::list&lt;T&gt; QList::toStdList() const</code>: Returns a <code>std::list</code> object with the data contained in this <code>QList</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;<span class="keyword">double</span>&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; 1.2 &lt;&lt; 0.5 &lt;&lt; 3.14;</span><br><span class="line">​</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; stdlist = <span class="built_in">list</span>.toStdList();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QVector&lt;T&gt; QList::toVector() const</code>: Returns a <code>QVector</code> object with the data contained in this <code>QList</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QStringList <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "Sven" &lt;&lt; "Kim" &lt;&lt; "Ola";</span><br><span class="line">​</span><br><span class="line">QVector&lt;QString&gt; vect = <span class="built_in">list</span>.toVector(); <span class="comment">/* vect: ["Sven", "Kim", "Ola"] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>T QList::value(int i) const</code>: Returns the value at index position <code>i</code> in the list. If the index <code>i</code> is out of bounds, the function returns a <code>default-constructed</code> value. If you are certain that the index is going to be within bounds, you can use <code>at()</code> instead, which is slightly faster.</li>
<li><code>T QList::value(int i, const T &amp; defaultValue) const</code>: This is an overloaded function. If the index <code>i</code> is out of bounds, the function returns <code>defaultValue</code>.</li>
<li><code>bool QList::operator!=(const QList&lt;T&gt; &amp; other) const</code>: Returns <code>true</code> if other is not equal to this list; otherwise returns <code>false</code>. Two lists are considered equal if they contain the same values in the same order. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>QList&lt;T&gt; QList::operator+(const QList&lt;T&gt; &amp; other) const</code>: Returns a list that contains all the items in this list followed by all the items in the <code>other</code> list.</li>
<li><code>QList&lt;T&gt; &amp; QList::operator+=(const QList&lt;T&gt; &amp; other)</code>: Appends the items of the <code>other</code> list to this list and returns a reference to this list.</li>
<li><code>QList&lt;T&gt; &amp; QList::operator+=(const T &amp; value)</code>: This is an overloaded function. Appends <code>value</code> to the list.</li>
<li><code>QList&lt;T&gt; &amp; QList::operator&lt;&lt;(const QList&lt;T&gt; &amp; other)</code>: Appends the items of the <code>other</code> list to this list and returns a reference to this list.</li>
<li><code>QList&lt;T&gt; &amp; QList::operator&lt;&lt;(const T &amp; value)</code>: This is an overloaded function. Appends <code>value</code> to the list.</li>
<li><code>QList&lt;T&gt; &amp; QList::operator=(const QList&lt;T&gt; &amp; other)</code>: Assigns <code>other</code> to this list and returns a reference to this list.</li>
<li><code>bool QList::operator==(const QList&lt;T&gt; &amp; other) const</code>: Returns <code>true</code> if <code>other</code> is equal to this list; otherwise returns <code>false</code>. Two lists are considered equal if they contain the same values in the same order. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>T &amp; QList::operator[](int i)</code>: Returns the item at index position <code>i</code> as a modifiable reference. <code>i</code> must be a valid index position in the list (i.e., <code>0 &lt;= i &lt; size()</code>). This function is very fast (constant time).</li>
<li><code>const T &amp; QList::operator[](int i) const</code>: This is an overloaded function. Same as <code>at()</code>.</li>
</ul>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; out, const QList&lt;T&gt; &amp; list)</code>: Writes the <code>list</code> to stream <code>out</code>. This function requires the value type to implement <code>operator&lt;&lt;()</code>.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; in, QList&lt;T&gt; &amp; list)</code>: Reads a list from stream <code>in</code> into <code>list</code>. This function requires the value type to implement <code>operator&gt;&gt;()</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/30/Qt语法详解/Qt之QVector/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/30/Qt语法详解/Qt之QVector/" itemprop="url">Qt之QVector</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-30T20:04:17+08:00">
                2019-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QVector</code> class is a template class that provides a dynamic array.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QVector</code></td>
<td><code>Q3ValueVector</code>, <code>QPolygon</code>, <code>QPolygonF</code>, <code>QStack</code>, and <code>QXmlStreamAttributes</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QVector()</code></td>
</tr>
<tr>
<td></td>
<td><code>QVector(int size)</code></td>
</tr>
<tr>
<td></td>
<td><code>QVector(int size, const T &amp; value)</code></td>
</tr>
<tr>
<td></td>
<td><code>QVector(const QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td></td>
<td><code>QVector(std::initializer_list&lt;T&gt; args)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QVector()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>append(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>at(int i) const</code></td>
</tr>
<tr>
<td><code>reference</code></td>
<td><code>back()</code></td>
</tr>
<tr>
<td><code>const_reference</code></td>
<td><code>back() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>begin()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>capacity() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constBegin() const</code></td>
</tr>
<tr>
<td><code>const T *</code></td>
<td><code>constData() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constEnd() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>contains(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count() const</code></td>
</tr>
<tr>
<td><code>T *</code></td>
<td><code>data()</code></td>
</tr>
<tr>
<td><code>const T *</code></td>
<td><code>data() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>empty() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>end()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>endsWith(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator pos)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator begin, iterator end)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>fill(const T &amp; value, int size = -1)</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>first()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>first() const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>front()</code></td>
</tr>
<tr>
<td><code>const_reference</code></td>
<td><code>front() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>indexOf(const T &amp; value, int from = 0) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insert(int i, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insert(iterator before, int count, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insert(int i, int count, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insert(iterator before, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>last()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>last() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lastIndexOf(const T &amp; value, int from = -1) const</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>mid(int pos, int length = -1) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>pop_back()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>pop_front()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>prepend(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>push_back(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>push_front(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>remove(int i)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>remove(int i, int count)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>replace(int i, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>reserve(int size)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>resize(int size)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>squeeze()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>startsWith(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>toList() const</code></td>
</tr>
<tr>
<td><code>std::vector&lt;T&gt;</code></td>
<td><code>toStdVector() const</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>value(int i) const</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>value(int i, const T &amp; defaultValue) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QVector&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>operator+(const QVector&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator+=(const QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator+=(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator&lt;&lt;(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator&lt;&lt;(const QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator=(const QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>operator=(QVector&lt;T&gt; &amp;&amp; other)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QVector&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>operator[](int i)</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>operator[](int i) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Static-Public-Members"><a href="#Static-Public-Members" class="headerlink" title="Static Public Members"></a>Static Public Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>fromList(const QList&lt;T&gt; &amp; list)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>fromStdVector(const std::vector&lt;T&gt; &amp; vector)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&lt;&lt;(QDataStream &amp; out, const QVector&lt;T&gt; &amp; vector)</code></td>
</tr>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&gt;&gt;(QDataStream &amp; in, QVector&lt;T&gt; &amp; vector)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QVector</code> class is a template class that provides a dynamic array.<br>&emsp;&emsp;<code>QVector&lt;T&gt;</code> is one of Qt’s generic container classes. It stores its items in adjacent memory locations and provides fast <code>index-based</code> access.<br>&emsp;&emsp;<code>QList&lt;T&gt;</code>, <code>QLinkedList&lt;T&gt;</code>, and <code>QVarLengthArray&lt;T&gt;</code> provide similar functionality. Here’s an overview:</p>
<ul>
<li>For most purposes, <code>QList</code> is the right class to use. Operations like <code>prepend()</code> and <code>insert()</code> are usually faster than with <code>QVector</code> because of the way <code>QList</code> stores its items in memory, and its <code>index-based</code> <code>API</code> is more convenient than <code>QLinkedList&#39;s</code> <code>iterator-based</code> <code>API</code>. It also expands to less code in your executable.</li>
<li>If you need a real linked list, with guarantees of constant time insertions in the middle of the list and iterators to items rather than indexes, use <code>QLinkedList</code>.</li>
<li>If you want the items to occupy adjacent memory positions, or if your items are larger than a pointer and you want to avoid the overhead of allocating them on the heap individually at insertion time, then use <code>QVector</code>.</li>
<li>If you want a <code>low-level</code> <code>variable-size</code> array, <code>QVarLengthArray</code> may be sufficient.</li>
</ul>
<p>&emsp;&emsp;Here’s an example of a <code>QVector</code> that stores integers and a <code>QVector</code> that stores <code>QString</code> values:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; integerVector;</span><br><span class="line">QVector&lt;QString&gt; stringVector;</span><br></pre></td></tr></table></figure>
<p><code>QVector</code> stores a vector (or array) of items. Typically, vectors are created with an initial size. For example, the following code constructs a <code>QVector</code> with <code>200</code> elements:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span> ( <span class="number">200</span> );</span><br></pre></td></tr></table></figure>
<p>The elements are automatically initialized with a <code>default-constructed</code> value. If you want to initialize the vector with a different value, pass that value as the second argument to the constructor:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span> ( <span class="number">200</span>, <span class="string">"Pass"</span> );</span><br></pre></td></tr></table></figure>
<p>You can also call <code>fill()</code> at any time to fill the vector with a value.<br>&emsp;&emsp;<code>QVector</code> uses <code>0-based</code> indexes, just like <code>C++</code> arrays. To access the item at a particular index position, you can use <code>operator[]()</code>. On <code>non-const</code> vectors, <code>operator[]()</code> returns a reference to the item that can be used on the left side of an assignment:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">vector</span>[<span class="number">0</span>] == <span class="string">"Liz"</span> ) &#123;</span><br><span class="line">    <span class="built_in">vector</span>[<span class="number">0</span>] = <span class="string">"Elizabeth"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For <code>read-only</code> access, an alternative syntax is to use <code>at()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.size(); ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">vector</span>.at ( i ) == <span class="string">"Alfonso"</span> ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found Alfonso at position "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>at()</code> can be faster than <code>operator[]()</code>, because it never causes a deep copy to occur.<br>&emsp;&emsp;Another way to access the data stored in a <code>QVector</code> is to call <code>data()</code>. The function returns a pointer to the first item in the vector. You can use the pointer to directly access and modify the elements stored in the vector. The pointer is also useful if you need to pass a <code>QVector</code> to a function that accepts a plain <code>C++</code> array.<br>&emsp;&emsp;If you want to find all occurrences of a particular value in a vector, use <code>indexOf()</code> or <code>lastIndexOf()</code>. The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return <code>-1</code>. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="built_in">vector</span>.indexOf ( <span class="string">"Harumi"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( i != <span class="number">-1</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"First occurrence of Harumi is at position "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If you simply want to check whether a vector contains a particular value, use <code>contains()</code>. If you want to find out how many times a particular value occurs in the vector, use <code>count()</code>.<br>&emsp;&emsp;<code>QVector</code> provides these basic functions to add, move, and remove items: <code>insert()</code>, <code>replace()</code>, <code>remove()</code>, <code>prepend()</code>, <code>append()</code>. With the exception of <code>append()</code> and <code>replace()</code>, these functions can be slow (linear time) for large vectors, because they require moving many items in the vector by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use <code>QList</code> or <code>QLinkedList</code> instead.<br>&emsp;&emsp;Unlike plain <code>C++</code> arrays, <code>QVectors</code> can be resized at any time by calling <code>resize()</code>. If the new size is larger than the old size, <code>QVector</code> might need to reallocate the whole vector. <code>QVector</code> tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.<br>&emsp;&emsp;If you know in advance approximately how many items the <code>QVector</code> will contain, you can call <code>reserve()</code>, asking <code>QVector</code> to preallocate a certain amount of memory. You can also call <code>capacity()</code> to find out how much memory <code>QVector</code> actually allocated.<br>&emsp;&emsp;Note that using <code>non-const</code> operators and functions can cause <code>QVector</code> to do a deep copy of the data. This is due to implicit sharing.<br>&emsp;&emsp;<code>QVector&#39;s</code> value type must be an assignable data type. This covers most data types that are commonly used, but the compiler won’t let you, for example, store a <code>QWidget</code> as a value; instead, store a <code>QWidget *</code>. A few functions have additional requirements; for example, <code>indexOf()</code> and <code>lastIndexOf()</code> expect the value type to support <code>operator==()</code>. These requirements are documented on a <code>per-function</code> basis.<br>&emsp;&emsp;Like the other container classes, <code>QVector</code> provides <code>Java-style</code> iterators (<code>QVectorIterator</code> and <code>QMutableVectorIterator</code>) and <code>STL-style</code> iterators (<code>QVector::const_iterator</code> and <code>QVector::iterator</code>). In practice, these are rarely used, because you can use indexes into the <code>QVector</code>.<br>&emsp;&emsp;In addition to <code>QVector</code>, Qt also provides <code>QVarLengthArray</code>, a very <code>low-level</code> class with little functionality that is optimized for speed.<br>&emsp;&emsp;<code>QVector</code> does not support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>typedef <code>QVector::ConstIterator</code>: <code>Qt-style</code> synonym for <code>QVector::const_iterator</code>.</li>
<li>typedef <code>QVector::Iterator</code>: <code>Qt-style</code> synonym for <code>QVector::iterator</code>.</li>
<li>typedef <code>QVector::const_iterator</code>: The <code>QVector::const_iterator</code> typedef provides an <code>STL-style</code> const iterator for <code>QVector</code> and <code>QStack</code>. <code>QVector</code> provides both <code>STL-style</code> iterators and <code>Java-style</code> iterators. The <code>STL-style</code> const iterator is simply a typedef for <code>const T *</code> (pointer to <code>const T</code>).</li>
<li>typedef <code>QVector::const_pointer</code>: Typedef for <code>const T *</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::const_reference</code>: Typedef for <code>T &amp;</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::difference_type</code>: Typedef for <code>ptrdiff_t</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::iterator</code>: The <code>QVector::iterator</code> typedef provides an <code>STL-style</code> <code>non-const</code> iterator for <code>QVector</code> and <code>QStack</code>. <code>QVector</code> provides both <code>STL-style</code> iterators and <code>Java-style</code> iterators. The <code>STL-style</code> <code>non-const</code> iterator is simply a typedef for <code>T *</code> (pointer to <code>T</code>).</li>
<li>typedef <code>QVector::pointer</code>: Typedef for <code>T *</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::reference</code>: Typedef for <code>T &amp;</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::size_type</code>: Typedef for <code>int</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::value_type</code>: Typedef for <code>T</code>. Provided for <code>STL</code> compatibility.</li>
</ul>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QVector::QVector()</code>: Constructs an empty vector.</li>
<li><code>QVector::QVector(int size)</code>: Constructs a vector with an initial size of <code>size</code> elements. The elements are initialized with a <code>default-constructed</code> value.</li>
<li><code>QVector::QVector(int size, const T &amp; value)</code>: Constructs a vector with an initial size of <code>size</code> elements. Each element is initialized with <code>value</code>.</li>
<li><code>QVector::QVector(const QVector&lt;T&gt; &amp; other)</code>: Constructs a copy of <code>other</code>. This operation takes constant time, because <code>QVector</code> is implicitly shared. This makes returning a <code>QVector</code> from a function very fast. If a shared instance is modified, it will be copied (<code>copy-on-write</code>), and that takes linear time.</li>
<li><code>QVector::QVector(std::initializer_list&lt;T&gt; args)</code>: Construct a vector from the <code>std::initilizer_list</code> given by <code>args</code>. This constructor is only enabled if the compiler supports <code>C++0x</code>.</li>
<li><code>QVector::~QVector()</code>: Destroys the vector.</li>
<li><code>void QVector::append(const T &amp; value)</code>: Inserts <code>value</code> at the end of the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span> ( <span class="number">0</span> );</span><br><span class="line"><span class="built_in">vector</span>.append ( <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">vector</span>.append ( <span class="string">"two"</span> );</span><br><span class="line"><span class="built_in">vector</span>.append ( <span class="string">"three"</span> ); <span class="comment">/* vector: ["one", "two", "three"] */</span></span><br></pre></td></tr></table></figure>
<p>This is the same as calling <code>resize(size() + 1)</code> and assigning value to the new last element in the vector. This operation is relatively fast, because <code>QVector</code> typically allocates more memory than necessary, so it can grow without reallocating the entire vector each time.</p>
<ul>
<li><code>const T &amp; QVector::at(int i) const</code>: Returns the item at index position <code>i</code> in the vector. <code>i</code> must be a valid index position in the vector (i.e., <code>0 &lt;= i &lt; size()</code>).</li>
<li><code>reference QVector::back()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>last()</code>.</li>
<li><code>const_reference QVector::back() const</code>: This is an overloaded function.</li>
<li><code>iterator QVector::begin()</code>: Returns an <code>STL-style</code> iterator pointing to the first item in the vector.</li>
<li><code>const_iterator QVector::begin() const</code>: This is an overloaded function.</li>
<li><code>int QVector::capacity() const</code>: Returns the maximum number of items that can be stored in the vector without forcing a reallocation. The sole purpose of this function is to provide a means of fine tuning <code>QVector&#39;s</code> memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the vector, call <code>size()</code>.</li>
<li><code>void QVector::clear()</code>: Removes all the elements from the vector and releases the memory used by the vector.</li>
<li><code>const_iterator QVector::constBegin() const</code>: Returns a const <code>STL-style</code> iterator pointing to the first item in the vector.</li>
<li><code>const T * QVector::constData() const</code>: Returns a const pointer to the data stored in the vector. The pointer can be used to access the items in the vector. The pointer remains valid as long as the vector isn’t reallocated. This function is mostly useful to pass a vector to a function that accepts a plain <code>C++</code> array.</li>
<li><code>const_iterator QVector::constEnd() const</code>: Returns a const <code>STL-style</code> iterator pointing to the imaginary item after the last item in the vector.</li>
<li><code>bool QVector::contains(const T &amp; value) const</code>: Returns <code>true</code> if the vector contains an occurrence of <code>value</code>; otherwise returns <code>false</code>. This function requires the <code>value</code> type to have an implementation of <code>operator==()</code>.</li>
<li><code>int QVector::count(const T &amp; value) const</code>: Returns the number of occurrences of <code>value</code> in the vector. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>int QVector::count() const</code>: This is an overloaded function. Same as <code>size()</code>.</li>
<li><code>T * QVector::data()</code>: Returns a pointer to the data stored in the vector. The pointer can be used to access and modify the items in the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; <span class="built_in">vector</span> ( <span class="number">10</span> );</span><br><span class="line"><span class="keyword">int</span> *data = <span class="built_in">vector</span>.data();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i ) &#123;</span><br><span class="line">    data[i] = <span class="number">2</span> * i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The pointer remains valid as long as the vector isn’t reallocated. This function is mostly useful to pass a vector to a function that accepts a plain <code>C++</code> array.</p>
<ul>
<li><code>const T * QVector::data() const</code>: This is an overloaded function.</li>
<li><code>bool QVector::empty() const</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>isEmpty()</code>, returning <code>true</code> if the vector is empty; otherwise returns <code>false</code>.</li>
<li><code>iterator QVector::end()</code>: Returns an <code>STL-style</code> iterator pointing to the imaginary item after the last item in the vector.</li>
<li><code>const_iterator QVector::end() const</code>: This is an overloaded function.</li>
<li><code>bool QVector::endsWith(const T &amp; value) const</code>: Returns <code>true</code> if this vector is not empty and its last item is equal to <code>value</code>; otherwise returns <code>false</code>.</li>
<li><code>iterator QVector::erase(iterator pos)</code>: Removes the item pointed to by the iterator <code>pos</code> from the vector, and returns an iterator to the next item in the vector (which may be <code>end()</code>).</li>
<li><code>iterator QVector::erase(iterator begin, iterator end)</code>: This is an overloaded function. Removes all the items from <code>begin</code> up to (but not including) <code>end</code>. Returns an iterator to the same item that end referred to before the call.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::fill(const T &amp; value, int size = -1)</code>: Assigns <code>value</code> to all items in the vector. If <code>size</code> is different from <code>-1</code> (the default), the vector is resized to <code>size</code> beforehand. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span> ( <span class="number">3</span> );</span><br><span class="line"><span class="built_in">vector</span>.fill ( <span class="string">"Yes"</span> ); <span class="comment">/* vector: ["Yes", "Yes", "Yes"] */</span></span><br><span class="line"><span class="built_in">vector</span>.fill ( <span class="string">"oh"</span>, <span class="number">5</span> ); <span class="comment">/* vector: ["oh", "oh", "oh", "oh", "oh"] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>T &amp; QVector::first()</code>: Returns a reference to the first item in the vector. This function assumes that the vector isn’t empty.</li>
<li><code>const T &amp; QVector::first() const</code>: This is an overloaded function.</li>
<li><code>QVector&lt;T&gt; QVector::fromList(const QList&lt;T&gt; &amp; list) [static]</code>: Returns a <code>QVector</code> object with the data contained in <code>list</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QStringList <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "Sven" &lt;&lt; "Kim" &lt;&lt; "Ola";</span><br><span class="line">QVector&lt;QString&gt; vect = QVector&lt;QString&gt;::fromList ( <span class="built_in">list</span> ); <span class="comment">/* vect: ["Sven", "Kim", "Ola"] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>QVector&lt;T&gt; QVector::fromStdVector(const std::vector&lt;T&gt; &amp; vector) [static]</code>: Returns a <code>QVector</code> object with the data contained in <code>vector</code>. The order of the elements in the <code>QVector</code> is the same as in vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; stdvector;</span><br><span class="line"><span class="built_in">vector</span>.push_back ( <span class="number">1.2</span> );</span><br><span class="line"><span class="built_in">vector</span>.push_back ( <span class="number">0.5</span> );</span><br><span class="line"><span class="built_in">vector</span>.push_back ( <span class="number">3.14</span> );</span><br><span class="line">QVector&lt;<span class="keyword">double</span>&gt; <span class="built_in">vector</span> = QVector&lt;<span class="keyword">double</span>&gt;::fromStdVector ( stdvector );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>T &amp; QVector::front()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>first()</code>.</li>
<li><code>const_reference QVector::front() const</code>: This is an overloaded function.</li>
<li><code>int QVector::indexOf(const T &amp; value, int from = 0) const</code>: Returns the index position of the first occurrence of <code>value</code> in the vector, searching forward <code>from</code> index position <code>from</code>. Returns <code>-1</code> if no item matched. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "B" &lt;&lt; "A";</span><br><span class="line"><span class="built_in">vector</span>.indexOf ( "B" );    // returns 1</span><br><span class="line"><span class="built_in">vector</span>.indexOf ( "B", 1 ); // returns 1</span><br><span class="line"><span class="built_in">vector</span>.indexOf ( "B", 2 ); // returns 3</span><br><span class="line"><span class="built_in">vector</span>.indexOf ( "X" );    // returns -1</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>.</p>
<ul>
<li><code>void QVector::insert(int i, const T &amp; value)</code>: Inserts <code>value</code> at index position <code>i</code> in the vector. If <code>i</code> is <code>0</code>, the <code>value</code> is prepended to the vector. If <code>i</code> is <code>size()</code>, the <code>value</code> is appended to the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; "alpha" &lt;&lt; "beta" &lt;&lt; "delta";</span><br><span class="line"><span class="built_in">vector</span>.insert ( 2, "gamma" ); /* <span class="built_in">vector</span>: ["alpha", "beta", "gamma", "delta"] */</span><br></pre></td></tr></table></figure>
<p>For large vectors, this operation can be slow (linear time), because it requires moving all the items at indexes i and above by one position further in memory. If you want a container class that provides a fast <code>insert()</code> function, use <code>QLinkedList</code> instead.</p>
<ul>
<li><code>iterator QVector::insert(iterator before, int count, const T &amp; value)</code>: Inserts <code>count</code> copies of <code>value</code> in front of the item pointed to by the iterator <code>before</code>. Returns an iterator pointing at the first of the inserted items.</li>
<li><code>void QVector::insert(int i, int count, const T &amp; value)</code>: This is an overloaded function. Inserts <code>count</code> copies of <code>value</code> at index position <code>i</code> in the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">double</span>&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; 2.718 &lt;&lt; 1.442 &lt;&lt; 0.4342;</span><br><span class="line"><span class="built_in">vector</span>.insert ( 1, 3, 9.9 ); /* <span class="built_in">vector</span>: [2.718, 9.9, 9.9, 9.9, 1.442, 0.4342] */</span><br></pre></td></tr></table></figure>
<ul>
<li><code>iterator QVector::insert(iterator before, const T &amp; value)</code>: This is an overloaded function. Inserts <code>value</code> in front of the item pointed to by the iterator <code>before</code>. Returns an iterator pointing at the inserted item.</li>
<li><code>bool QVector::isEmpty() const</code>: Returns <code>true</code> if the vector has size <code>0</code>; otherwise returns <code>false</code>.</li>
<li><code>T &amp; QVector::last()</code>: Returns a reference to the last item in the vector. This function assumes that the vector isn’t empty.</li>
<li><code>const T &amp; QVector::last() const</code>: This is an overloaded function.</li>
<li><code>int QVector::lastIndexOf(const T &amp; value, int from = -1) const</code>: Returns the index position of the last occurrence of the <code>value</code> in the vector, searching backward from index position <code>from</code>. If <code>from</code> is <code>-1</code> (the default), the search starts at the last item. Returns <code>-1</code> if no item matched. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "B" &lt;&lt; "A";</span><br><span class="line"><span class="built_in">vector</span>.lastIndexOf ( "B" );    // returns 3</span><br><span class="line"><span class="built_in">vector</span>.lastIndexOf ( "B", 3 ); // returns 3</span><br><span class="line"><span class="built_in">vector</span>.lastIndexOf ( "B", 2 ); // returns 1</span><br><span class="line"><span class="built_in">vector</span>.lastIndexOf ( "X" );    // returns -1</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>.</p>
<ul>
<li><code>QVector&lt;T&gt; QVector::mid(int pos, int length = -1) const</code>: Returns a vector whose elements are copied from this vector, starting at position <code>pos</code>. If <code>length</code> is <code>-1</code> (the default), all elements after <code>pos</code> are copied; otherwise <code>length</code> elements (or all remaining elements if there are less than <code>length</code> elements) are copied.</li>
<li><code>void QVector::pop_back()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>erase(end() - 1)</code>.</li>
<li><code>void QVector::pop_front()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>erase(begin())</code>.</li>
<li><code>void QVector::prepend(const T &amp; value)</code>: Inserts <code>value</code> at the beginning of the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span>.prepend ( <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">vector</span>.prepend ( <span class="string">"two"</span> );</span><br><span class="line"><span class="built_in">vector</span>.prepend ( <span class="string">"three"</span> ); <span class="comment">/* vector: ["three", "two", "one"] */</span></span><br></pre></td></tr></table></figure>
<p>This is the same as <code>vector.insert(0, value)</code>. For large vectors, this operation can be slow (linear time), because it requires moving all the items in the vector by one position further in memory. If you want a container class that provides a fast <code>prepend()</code> function, use <code>QList</code> or <code>QLinkedList</code> instead.</p>
<ul>
<li><code>void QVector::push_back(const T &amp; value)</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>append(value)</code>.</li>
<li><code>void QVector::push_front(const T &amp; value)</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>prepend(value)</code>.</li>
<li><code>void QVector::remove(int i)</code>: This is an overloaded function. Removes the element at index position <code>i</code>.</li>
<li><code>void QVector::remove(int i, int count)</code>: This is an overloaded function. Removes <code>count</code> elements from the middle of the vector, starting at index position <code>i</code>.</li>
<li><code>void QVector::replace(int i, const T &amp; value)</code>: Replaces the item at index position <code>i</code> with <code>value</code>. <code>i</code> must be a valid index position in the vector (i.e., <code>0 &lt;= i &lt; size()</code>).</li>
<li><code>void QVector::reserve(int size)</code>: Attempts to allocate memory for at least <code>size</code> elements. If you know in advance how large the vector will be, you can call this function, and if you call <code>resize()</code> often you are likely to get better performance. If size is an underestimate, the worst that will happen is that the <code>QVector</code> will be a bit slower. The sole purpose of this function is to provide a means of fine tuning <code>QVector&#39;s</code> memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the vector, call <code>resize()</code>.</li>
<li><code>void QVector::resize(int size)</code>: Sets the size of the vector to <code>size</code>. If <code>size</code> is greater than the current size, elements are added to the end; the new elements are initialized with a <code>default-constructed</code> value. If <code>size</code> is less than the current size, elements are removed from the end.</li>
<li><code>int QVector::size() const</code>: Returns the number of items in the vector.</li>
<li><code>void QVector::squeeze()</code>: Releases any memory not required to store the items. The sole purpose of this function is to provide a means of fine tuning <code>QVector&#39;s</code> memory usage. In general, you will rarely ever need to call this function.</li>
<li><code>bool QVector::startsWith(const T &amp; value) const</code>: Returns <code>true</code> if this vector is not empty and its first item is equal to <code>value</code>; otherwise returns <code>false</code>.</li>
<li><code>void QVector::swap(QVector&lt;T&gt; &amp; other)</code>: Swaps vector <code>other</code> with this vector. This operation is very fast and never fails.</li>
<li><code>QList&lt;T&gt; QVector::toList() const</code>: Returns a <code>QList</code> object with the data contained in this <code>QVector</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; vect;</span><br><span class="line">vect &lt;&lt; <span class="string">"red"</span> &lt;&lt; <span class="string">"green"</span> &lt;&lt; <span class="string">"blue"</span> &lt;&lt; <span class="string">"black"</span>;</span><br><span class="line">QList&lt;QString&gt; <span class="built_in">list</span> = vect.toList(); <span class="comment">/* list: ["red", "green", "blue", "black"] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::vector&lt;T&gt; QVector::toStdVector() const</code>: Returns a <code>std::vector</code> object with the data contained in this <code>QVector</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">double</span>&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; 1.2 &lt;&lt; 0.5 &lt;&lt; 3.14;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; stdvector = <span class="built_in">vector</span>.toStdVector();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>T QVector::value(int i) const</code>: Returns the value at index position <code>i</code> in the vector. If the index <code>i</code> is out of bounds, the function returns a <code>default-constructed</code> value. If you are certain that <code>i</code> is within bounds, you can use <code>at()</code> instead, which is slightly faster.</li>
<li><code>T QVector::value(int i, const T &amp; defaultValue) const</code>: This is an overloaded function. If the index <code>i</code> is out of bounds, the function returns <code>defaultValue</code>.</li>
<li><code>bool QVector::operator!=(const QVector&lt;T&gt; &amp; other) const</code>: Returns <code>true</code> if <code>other</code> is not equal to this vector; otherwise returns <code>false</code>. Two vectors are considered equal if they contain the same values in the same order. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>QVector&lt;T&gt; QVector::operator+(const QVector&lt;T&gt; &amp; other) const</code>: Returns a vector that contains all the items in this vector followed by all the items in the <code>other</code> vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator+=(const QVector&lt;T&gt; &amp; other)</code>: Appends the items of the <code>other</code> vector to this vector and returns a reference to this vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator+=(const T &amp; value)</code>: This is an overloaded function. Appends <code>value</code> to the vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator&lt;&lt;(const T &amp; value)</code>: Appends <code>value</code> to the vector and returns a reference to this vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator&lt;&lt;(const QVector&lt;T&gt; &amp; other)</code>: Appends <code>other</code> to the vector and returns a reference to the vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator=(const QVector&lt;T&gt; &amp; other)</code>: Assigns <code>other</code> to this vector and returns a reference to this vector.</li>
<li><code>bool QVector::operator==(const QVector&lt;T&gt; &amp; other) const</code>: Returns <code>true</code> if <code>other</code> is equal to this vector; otherwise returns <code>false</code>. Two vectors are considered equal if they contain the same values in the same order. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>T &amp; QVector::operator[](int i)</code>: Returns the item at index position <code>i</code> as a modifiable reference. <code>i</code> must be a valid index position in the vector (i.e., <code>0 &lt;= i &lt; size()</code>). Note that using <code>non-const</code> operators can cause <code>QVector</code> to do a deep copy.</li>
<li><code>const T &amp; QVector::operator[](int i) const</code>: This is an overloaded function. Same as <code>at(i)</code>.</li>
</ul>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; out, const QVector&lt;T&gt; &amp; vector)</code>: Writes the <code>vector</code> to stream <code>out</code>. This function requires the value type to implement <code>operator&lt;&lt;()</code>.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; in, QVector&lt;T&gt; &amp; vector)</code>: Reads a vector from stream <code>in</code> into <code>vector</code>. This function requires the value type to implement <code>operator&gt;&gt;()</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/29/Qt语法详解/Qt之QTextCursor/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/29/Qt语法详解/Qt之QTextCursor/" itemprop="url">Qt之QTextCursor</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-29T11:13:18+08:00">
                2019-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTextCursor</code> class offers an <code>API</code> to access and modify <code>QTextDocuments</code>. The header file is <code>QTextCursor</code>. <strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextCursor()</code></td>
</tr>
<tr>
<td></td>
<td><code>QTextCursor(QTextDocument * document)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTextCursor(QTextFrame * frame)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTextCursor(const QTextBlock &amp; block)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTextCursor(const QTextCursor &amp; cursor)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QTextCursor()</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>anchor() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>atBlockEnd() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>atBlockStart() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>atEnd() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>atStart() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>beginEditBlock()</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>block() const</code></td>
</tr>
<tr>
<td><code>QTextCharFormat</code></td>
<td><code>blockCharFormat() const</code></td>
</tr>
<tr>
<td><code>QTextBlockFormat</code></td>
<td><code>blockFormat() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>blockNumber() const</code></td>
</tr>
<tr>
<td><code>QTextCharFormat</code></td>
<td><code>charFormat() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clearSelection()</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>columnNumber() const</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>createList(const QTextListFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>createList(QTextListFormat::Style style)</code></td>
</tr>
<tr>
<td><code>QTextFrame *</code></td>
<td><code>currentFrame() const</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>currentList() const</code></td>
</tr>
<tr>
<td><code>QTextTable *</code></td>
<td><code>currentTable() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>deleteChar()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>deletePreviousChar()</code></td>
</tr>
<tr>
<td><code>QTextDocument *</code></td>
<td><code>document() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>endEditBlock()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasComplexSelection() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasSelection() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertBlock()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertBlock(const QTextBlockFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertBlock(const QTextBlockFormat &amp; format, const QTextCharFormat &amp; charFormat)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertFragment(const QTextDocumentFragment &amp; fragment)</code></td>
</tr>
<tr>
<td><code>QTextFrame *</code></td>
<td><code>insertFrame(const QTextFrameFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertHtml(const QString &amp; html)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertImage(const QTextImageFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertImage(const QTextImageFormat &amp; format, QTextFrameFormat::Position alignment)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertImage(const QString &amp; name)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertImage(const QImage &amp; image, const QString &amp; name = QString())</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>insertList(const QTextListFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>insertList(QTextListFormat::Style style)</code></td>
</tr>
<tr>
<td><code>QTextTable *</code></td>
<td><code>insertTable(int rows, int columns, const QTextTableFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>QTextTable *</code></td>
<td><code>insertTable(int rows, int columns)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertText(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertText(const QString &amp; text, const QTextCharFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isCopyOf(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isNull() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>joinPreviousEditBlock()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>keepPositionOnInsert() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>mergeBlockCharFormat(const QTextCharFormat &amp; modifier)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>mergeBlockFormat(const QTextBlockFormat &amp; modifier)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>mergeCharFormat(const QTextCharFormat &amp; modifier)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>movePosition(MoveOperation operation, MoveMode mode = MoveAnchor, int n = 1)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>position() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>positionInBlock() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeSelectedText()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>select(SelectionType selection)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>selectedTableCells(int * firstRow, int * numRows, int * firstColumn, int * numColumns) const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>selectedText() const</code></td>
</tr>
<tr>
<td><code>QTextDocumentFragment</code></td>
<td><code>selection() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>selectionEnd() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>selectionStart() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBlockCharFormat(const QTextCharFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBlockFormat(const QTextBlockFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCharFormat(const QTextCharFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setKeepPositionOnInsert(bool b)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPosition(int pos, MoveMode m = MoveAnchor)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setVerticalMovementX(int x)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setVisualNavigation(bool b)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>verticalMovementX() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>visualNavigation() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&lt;(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&lt;=(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>QTextCursor &amp;</code></td>
<td><code>operator=(const QTextCursor &amp; cursor)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&gt;(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&gt;=(const QTextCursor &amp; other) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextCursor</code> class offers an <code>API</code> to access and modify <code>QTextDocuments</code>.<br>&emsp;&emsp;Text cursors are objects that are used to access and modify the contents and underlying structure of text documents via a programming interface that mimics the behavior of a cursor in a text editor. <code>QTextCursor</code> contains information about both the cursor’s position within a <code>QTextDocument</code> and any selection that it has made.<br>&emsp;&emsp;<code>QTextCursor</code> is modeled on the way a text cursor behaves in a text editor, providing a programmatic means of performing standard actions through the user interface. A document can be thought of as a single string of characters. The cursor’s current <code>position()</code> then is always either between two consecutive characters in the string, or else before the very first character or after the very last character in the string. Documents can also contain tables, lists, images, and other objects in addition to text but, from the developer’s point of view, the document can be treated as one long string. Some portions of that string can be considered to lie within particular blocks (e.g. paragraphs), or within a table’s cell, or a list’s item, or other structural elements. When we refer to <code>current character</code> we mean the character immediately before the cursor <code>position()</code> in the document. Similarly, the <code>current block</code> is the block that contains the cursor <code>position()</code>.<br>&emsp;&emsp;A <code>QTextCursor</code> also has an <code>anchor()</code> position. The text that is between the <code>anchor()</code> and the <code>position()</code> is the selection. If <code>anchor() == position()</code> there is no selection.<br>&emsp;&emsp;The cursor position can be changed programmatically using <code>setPosition()</code> and <code>movePosition()</code>; the latter can also be used to select text. For selections see <code>selectionStart()</code>, <code>selectionEnd()</code>, <code>hasSelection()</code>, <code>clearSelection()</code>, and <code>removeSelectedText()</code>.<br>&emsp;&emsp;If the <code>position()</code> is at the start of a block <code>atBlockStart()</code> returns <code>true</code>; and if it is at the end of a block <code>atBlockEnd()</code> returns <code>true</code>. The format of the current character is returned by <code>charFormat()</code>, and the format of the current block is returned by <code>blockFormat()</code>.<br>&emsp;&emsp;Formatting can be applied to the current text document using the <code>setCharFormat()</code>, <code>mergeCharFormat()</code>, <code>setBlockFormat()</code> and <code>mergeBlockFormat()</code> functions. The <code>set</code> functions will replace the cursor’s current character or block format, while the <code>merge</code> functions add the given format properties to the cursor’s current format. If the cursor has a selection the given format is applied to the current selection. Note that when only parts of a block is selected the block format is applied to the entire block. The text at the current character position can be turned into a list using <code>createList()</code>.<br>&emsp;&emsp;Deletions can be achieved using <code>deleteChar()</code>, <code>deletePreviousChar()</code>, and <code>removeSelectedText()</code>.<br>&emsp;&emsp;Text strings can be inserted into the document with the <code>insertText()</code> function, blocks (representing new paragraphs) can be inserted with <code>insertBlock()</code>.<br>&emsp;&emsp;Existing fragments of text can be inserted with <code>insertFragment()</code>, but if you want to insert pieces of text in various formats, it is usually still easier to use <code>insertText()</code> and supply a character format.<br>&emsp;&emsp;Various types of <code>higher-level</code> structure can also be inserted into the document with the cursor:</p>
<ul>
<li>Lists are ordered sequences of block elements that are decorated with bullet points or symbols. These are inserted in a specified format with <code>insertList()</code>.</li>
<li>Tables are inserted with the <code>insertTable()</code> function, and can be given an optional format. These contain an array of cells that can be traversed using the cursor.</li>
<li>Inline images are inserted with <code>insertImage()</code>. The image to be used can be specified in an image format, or by name.</li>
<li>Frames are inserted by calling <code>insertFrame()</code> with a specified format.</li>
</ul>
<p>&emsp;&emsp;Actions can be grouped (i.e. treated as a single action for undo/redo) using <code>beginEditBlock()</code> and <code>endEditBlock()</code>.<br>&emsp;&emsp;Cursor movements are limited to valid cursor positions. In <code>Latin</code> writing this is between any two consecutive characters in the text, before the first character, or after the last character. In some other writing systems cursor movements are limited to <code>clusters</code> (e.g. a syllable in Devanagari, or a base letter plus diacritics). Functions such as <code>movePosition()</code> and <code>deleteChar()</code> limit cursor movement to these valid positions.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QTextCursor::MoveMode</code>:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCursor::MoveAnchor</code></td>
<td><code>0</code></td>
<td>Moves the anchor to the same position as the cursor itself.</td>
</tr>
<tr>
<td><code>QTextCursor::KeepAnchor</code></td>
<td><code>1</code></td>
<td>Keeps the anchor where it is.</td>
</tr>
</tbody>
</table>
</div>
<p>If the <code>anchor()</code> is kept where it is and the <code>position()</code> is moved, the text in between will be selected.</p>
<ul>
<li>enum <code>QTextCursor::MoveOperation</code>:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCursor::NoMove</code></td>
<td><code>0</code></td>
<td>Keep the cursor where it is.</td>
</tr>
<tr>
<td><code>QTextCursor::Start</code></td>
<td><code>1</code></td>
<td>Move to the start of the document.</td>
</tr>
<tr>
<td><code>QTextCursor::StartOfLine</code></td>
<td><code>3</code></td>
<td>Move to the start of the current line.</td>
</tr>
<tr>
<td><code>QTextCursor::StartOfBlock</code></td>
<td><code>4</code></td>
<td>Move to the start of the current block.</td>
</tr>
<tr>
<td><code>QTextCursor::StartOfWord</code></td>
<td><code>5</code></td>
<td>Move to the start of the current word.</td>
</tr>
<tr>
<td><code>QTextCursor::PreviousBlock</code></td>
<td><code>6</code></td>
<td>Move to the start of the previous block.</td>
</tr>
<tr>
<td><code>QTextCursor::PreviousCharacter</code></td>
<td><code>7</code></td>
<td>Move to the previous character.</td>
</tr>
<tr>
<td><code>QTextCursor::PreviousWord</code></td>
<td><code>8</code></td>
<td>Move to the beginning of the previous word.</td>
</tr>
<tr>
<td><code>QTextCursor::Up</code></td>
<td><code>2</code></td>
<td>Move up one line.</td>
</tr>
<tr>
<td><code>QTextCursor::Left</code></td>
<td><code>9</code></td>
<td>Move left one character.</td>
</tr>
<tr>
<td><code>QTextCursor::WordLeft</code></td>
<td><code>10</code></td>
<td>Move left one word.</td>
</tr>
<tr>
<td><code>QTextCursor::End</code></td>
<td><code>11</code></td>
<td>Move to the end of the document.</td>
</tr>
<tr>
<td><code>QTextCursor::EndOfLine</code></td>
<td><code>13</code></td>
<td>Move to the end of the current line.</td>
</tr>
<tr>
<td><code>QTextCursor::EndOfWord</code></td>
<td><code>14</code></td>
<td>Move to the end of the current word.</td>
</tr>
<tr>
<td><code>QTextCursor::EndOfBlock</code></td>
<td><code>15</code></td>
<td>Move to the end of the current block.</td>
</tr>
<tr>
<td><code>QTextCursor::NextBlock</code></td>
<td><code>16</code></td>
<td>Move to the beginning of the next block.</td>
</tr>
<tr>
<td><code>QTextCursor::NextCharacter</code></td>
<td><code>17</code></td>
<td>Move to the next character.</td>
</tr>
<tr>
<td><code>QTextCursor::NextWord</code></td>
<td><code>18</code></td>
<td>Move to the next word.</td>
</tr>
<tr>
<td><code>QTextCursor::Down</code></td>
<td><code>12</code></td>
<td>Move down one line.</td>
</tr>
<tr>
<td><code>QTextCursor::Right</code></td>
<td><code>19</code></td>
<td>Move right one character.</td>
</tr>
<tr>
<td><code>QTextCursor::WordRight</code></td>
<td><code>20</code></td>
<td>Move right one word.</td>
</tr>
<tr>
<td><code>QTextCursor::NextCell</code></td>
<td><code>21</code></td>
<td>Move to the beginning of the next table cell inside the current table. If the current cell is the last cell in the row, the cursor will move to the first cell in the next row.</td>
</tr>
<tr>
<td><code>QTextCursor::PreviousCell</code></td>
<td><code>22</code></td>
<td>Move to the beginning of the previous table cell inside the current table. If the current cell is the first cell in the row, the cursor will move to the last cell in the previous row.</td>
</tr>
<tr>
<td><code>QTextCursor::NextRow</code></td>
<td><code>23</code></td>
<td>Move to the first new cell of the next row in the current table.</td>
</tr>
<tr>
<td><code>QTextCursor::PreviousRow</code></td>
<td><code>24</code></td>
<td>Move to the last cell of the previous row in the current table.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QTextCursor::SelectionType</code>: This enum describes the types of selection that can be applied with the <code>select()</code> function.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCursor::Document</code></td>
<td><code>3</code></td>
<td>Selects the entire document.</td>
</tr>
<tr>
<td><code>QTextCursor::BlockUnderCursor</code></td>
<td><code>2</code></td>
<td>Selects the block of text under the cursor.</td>
</tr>
<tr>
<td><code>QTextCursor::LineUnderCursor</code></td>
<td><code>1</code></td>
<td>Selects the line of text under the cursor.</td>
</tr>
<tr>
<td><code>QTextCursor::WordUnderCursor</code></td>
<td><code>0</code></td>
<td>Selects the word under the cursor. If the cursor is not positioned within a string of selectable characters, no text is selected.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextCursor::QTextCursor()</code>: Constructs a null cursor.</li>
<li><code>QTextCursor::QTextCursor(QTextDocument * document)</code>: Constructs a cursor pointing to the beginning of the <code>document</code>.</li>
<li><code>QTextCursor::QTextCursor(QTextFrame * frame)</code>: Constructs a cursor pointing to the beginning of the <code>frame</code>.</li>
<li><code>QTextCursor::QTextCursor(const QTextBlock &amp; block)</code>: Constructs a cursor pointing to the beginning of the <code>block</code>.</li>
<li><code>QTextCursor::QTextCursor(const QTextCursor &amp; cursor)</code>: Constructs a new cursor that is a copy of <code>cursor</code>.</li>
<li><code>QTextCursor::~QTextCursor()</code>: Destroys the <code>QTextCursor</code>.</li>
<li><code>int QTextCursor::anchor() const</code>: Returns the anchor position; this is the same as <code>position()</code> unless there is a selection in which case <code>position()</code> marks one end of the selection and <code>anchor()</code> marks the other end. Just like the cursor position, the anchor position is between characters.</li>
<li><code>bool QTextCursor::atBlockEnd() const</code>: Returns <code>true</code> if the cursor is at the end of a block; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::atBlockStart() const</code>: Returns <code>true</code> if the cursor is at the start of a block; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::atEnd() const</code>: Returns <code>true</code> if the cursor is at the end of the document; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::atStart() const</code>: Returns <code>true</code> if the cursor is at the start of the document; otherwise returns <code>false</code>.</li>
<li><code>void QTextCursor::beginEditBlock()</code>: Indicates the start of a block of editing operations on the document that should appear as a single operation from an undo/redo point of view. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTextCursor <span class="title">cursor</span> <span class="params">( textDocument )</span></span>;</span><br><span class="line">cursor.beginEditBlock();</span><br><span class="line">cursor.insertText ( <span class="string">"Hello"</span> );</span><br><span class="line">cursor.insertText ( <span class="string">"World"</span> );</span><br><span class="line">cursor.endEditBlock();</span><br><span class="line">​</span><br><span class="line">textDocument-&gt;undo();</span><br></pre></td></tr></table></figure>
<p>The call to <code>undo()</code> will cause both insertions to be undone, causing both <code>World</code> and <code>Hello</code> to be removed. It is possible to nest calls to <code>beginEditBlock</code> and <code>endEditBlock</code>. The <code>top-most</code> pair will determine the scope of the undo/redo operation.</p>
<ul>
<li><code>QTextBlock QTextCursor::block() const</code> — Returns the block that contains the cursor.</li>
<li><code>QTextCharFormat QTextCursor::blockCharFormat() const</code>: Returns the block character format of the block the cursor is in. The block char format is the format used when inserting text at the beginning of an empty block.</li>
<li><code>QTextBlockFormat QTextCursor::blockFormat() const</code>: Returns the block format of the block the cursor is in.</li>
<li><code>int QTextCursor::blockNumber() const</code>: Returns the number of the block the cursor is in, or <code>0</code> if the cursor is invalid. Note that this function only makes sense in documents without complex objects such as tables or frames.</li>
<li><code>QTextCharFormat QTextCursor::charFormat() const</code>: Returns the format of the character immediately before the cursor <code>position()</code>. If the cursor is positioned at the beginning of a text block that is not empty then the format of the character immediately after the cursor is returned.</li>
<li><code>void QTextCursor::clearSelection()</code>: Clears the current selection by setting the anchor to the cursor position. Note that it does not delete the text of the selection.</li>
<li><code>int QTextCursor::columnNumber() const</code>: Returns the position of the cursor within its containing line. Note that this is the column number relative to a wrapped line, not relative to the block (i.e. the paragraph). You probably want to call <code>positionInBlock()</code> instead.</li>
<li><code>QTextList * QTextCursor::createList(const QTextListFormat &amp; format)</code>: Creates and returns a new list with the given <code>format</code>, and makes the current paragraph the cursor is in the first list item.</li>
<li><code>QTextList * QTextCursor::createList(QTextListFormat::Style style)</code>: This is an overloaded function. Creates and returns a new list with the given <code>style</code>, making the cursor’s current paragraph the first list item. The <code>style</code> to be used is defined by the <code>QTextListFormat::Style</code> enum.</li>
<li><code>QTextFrame * QTextCursor::currentFrame() const</code>: Returns a pointer to the current frame. Returns <code>0</code> if the cursor is invalid.</li>
<li><code>QTextList * QTextCursor::currentList() const</code>: Returns the current list if the cursor <code>position()</code> is inside a block that is part of a list; otherwise returns <code>0</code>.</li>
<li><code>QTextTable * QTextCursor::currentTable() const</code>: Returns a pointer to the current table if the cursor <code>position()</code> is inside a block that is part of a table; otherwise returns <code>0</code>.</li>
<li><code>void QTextCursor::deleteChar()</code>: If there is no selected text, deletes the character at the current cursor position; otherwise deletes the selected text.</li>
<li><code>void QTextCursor::deletePreviousChar()</code>: If there is no selected text, deletes the character before the current cursor position; otherwise deletes the selected text.</li>
<li><code>QTextDocument * QTextCursor::document() const</code>: Returns the document this cursor is associated with.</li>
<li><code>void QTextCursor::endEditBlock()</code>: Indicates the end of a block of editing operations on the document that should appear as a single operation from an undo/redo point of view.</li>
<li><code>bool QTextCursor::hasComplexSelection() const</code>: Returns <code>true</code> if the cursor contains a selection that is not simply a range from <code>selectionStart()</code> to <code>selectionEnd()</code>; otherwise returns <code>false</code>. Complex selections are ones that span at least two cells in a table; their extent is specified by <code>selectedTableCells()</code>.</li>
<li><code>bool QTextCursor::hasSelection() const</code>: Returns <code>true</code> if the cursor contains a selection; otherwise returns <code>false</code>.</li>
<li><code>void QTextCursor::insertBlock()</code>: Inserts a new empty block at the cursor <code>position()</code> with the current <code>blockFormat()</code> and <code>charFormat()</code>.</li>
<li><code>void QTextCursor::insertBlock(const QTextBlockFormat &amp; format)</code>: This is an overloaded function. Inserts a new empty block at the cursor <code>position()</code> with block <code>format</code> and the current <code>charFormat()</code> as block char format.</li>
<li><code>void QTextCursor::insertBlock(const QTextBlockFormat &amp; format, const QTextCharFormat &amp; charFormat)</code>: This is an overloaded function. Inserts a new empty block at the cursor <code>position()</code> with block <code>format</code> and <code>charFormat</code> as block char format.</li>
<li><code>void QTextCursor::insertFragment(const QTextDocumentFragment &amp; fragment)</code>: Inserts the text <code>fragment</code> at the current <code>position()</code>.</li>
<li><code>QTextFrame * QTextCursor::insertFrame(const QTextFrameFormat &amp; format)</code>: Inserts a frame with the given <code>format</code> at the current cursor <code>position()</code>, moves the cursor <code>position()</code> inside the frame, and returns the frame. If the cursor holds a selection, the whole selection is moved inside the frame.</li>
<li><code>void QTextCursor::insertHtml(const QString &amp; html)</code>: Inserts the text <code>html</code> at the current <code>position()</code>. The text is interpreted as <code>HTML</code>. <strong>Note</strong>: When using this function with a style sheet, the style sheet will only apply to the current block in the document. In order to apply a style sheet throughout a document, use <code>QTextDocument::setDefaultStyleSheet()</code> instead.</li>
<li><code>void QTextCursor::insertImage(const QTextImageFormat &amp; format)</code>: Inserts the image defined by <code>format</code> at the current <code>position()</code>.</li>
<li><code>void QTextCursor::insertImage(const QTextImageFormat &amp; format, QTextFrameFormat::Position alignment)</code>: This is an overloaded function. Inserts the image defined by the given <code>format</code> at the cursor’s current position with the specified <code>alignment</code>.</li>
<li><code>void QTextCursor::insertImage(const QString &amp; name)</code>: This is an overloaded function. Convenience method for inserting the image with the given <code>name</code> at the current <code>position()</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QImage img = ...;</span><br><span class="line">textDocument-&gt;addResource ( QTextDocument::ImageResource, QUrl ( <span class="string">"myimage"</span> ), img );</span><br><span class="line">cursor.insertImage ( <span class="string">"myimage"</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QTextCursor::insertImage(const QImage &amp; image, const QString &amp; name = QString())</code>: This is an overloaded function. Convenience function for inserting the given <code>image</code> with an optional <code>name</code> at the current <code>position()</code>.</li>
<li><code>QTextList * QTextCursor::insertList(const QTextListFormat &amp; format)</code>: Inserts a new block at the current position and makes it the first list item of a newly created list with the given <code>format</code>. Returns the created list.</li>
<li><code>QTextList * QTextCursor::insertList(QTextListFormat::Style style)</code>: This is an overloaded function. Inserts a new block at the current position and makes it the first list item of a newly created list with the given <code>style</code>. Returns the created list.</li>
<li><code>QTextTable * QTextCursor::insertTable(int rows, int columns, const QTextTableFormat &amp; format)</code>: Creates a new table with the given number of <code>rows</code> and <code>columns</code> in the specified <code>format</code>, inserts it at the current cursor <code>position()</code> in the document, and returns the table object. The cursor is moved to the beginning of the first cell. There must be at least one row and one column in the table.</li>
<li><code>QTextTable * QTextCursor::insertTable(int rows, int columns)</code>: This is an overloaded function. Creates a new table with the given number of <code>rows</code> and <code>columns</code>, inserts it at the current cursor <code>position()</code> in the document, and returns the table object. The cursor is moved to the beginning of the first cell. There must be at least one row and one column in the table.</li>
<li><code>void QTextCursor::insertText(const QString &amp; text)</code>: Inserts <code>text</code> at the current position, using the current character format. If there is a selection, the selection is deleted and replaced by <code>text</code>, for example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cursor.clearSelection();</span><br><span class="line">cursor.movePosition ( QTextCursor::NextWord, QTextCursor::KeepAnchor );</span><br><span class="line">cursor.insertText ( <span class="string">"Hello World"</span> );</span><br></pre></td></tr></table></figure>
<p>This clears any existing selection, selects the word at the cursor (i.e. from <code>position()</code> forward), and replaces the selection with the phrase <code>Hello World</code>. Any <code>ASCII</code> linefeed characters (<code>\n</code>) in the inserted text are transformed into unicode block separators, corresponding to <code>insertBlock()</code> calls.</p>
<ul>
<li><code>void QTextCursor::insertText(const QString &amp; text, const QTextCharFormat &amp; format)</code>: This is an overloaded function. Inserts <code>text</code> at the current position with the given <code>format</code>.</li>
<li><code>bool QTextCursor::isCopyOf(const QTextCursor &amp; other) const</code>: Returns true if this cursor and <code>other</code> are copies of each <code>other</code>, i.e. one of them was created as a copy of the <code>other</code> and neither has moved since. This is much stricter than equality.</li>
<li><code>bool QTextCursor::isNull() const</code>: Returns <code>true</code> if the cursor is null; otherwise returns <code>false</code>. A null cursor is created by the default constructor.</li>
<li><code>void QTextCursor::joinPreviousEditBlock()</code>: Like <code>beginEditBlock()</code> indicates the start of a block of editing operations that should appear as a single operation for undo/redo. However unlike <code>beginEditBlock()</code> it does not start a new block but reverses the previous call to <code>endEditBlock()</code> and therefore makes following operations part of the previous edit block created. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTextCursor <span class="title">cursor</span> <span class="params">( textDocument )</span></span>;</span><br><span class="line">cursor.beginEditBlock();</span><br><span class="line">cursor.insertText ( <span class="string">"Hello"</span> );</span><br><span class="line">cursor.insertText ( <span class="string">"World"</span> );</span><br><span class="line">cursor.endEditBlock();</span><br><span class="line">...</span><br><span class="line">cursor.joinPreviousEditBlock();</span><br><span class="line">cursor.insertText ( <span class="string">"Hey"</span> );</span><br><span class="line">cursor.endEditBlock();</span><br><span class="line">​</span><br><span class="line">textDocument-&gt;undo();</span><br></pre></td></tr></table></figure>
<p>The call to <code>undo()</code> will cause all three insertions to be undone.</p>
<ul>
<li><code>bool QTextCursor::keepPositionOnInsert() const</code>: Returns whether the cursor should keep its current position when text gets inserted at the position of the cursor. The default is <code>false</code>.</li>
<li><code>void QTextCursor::mergeBlockCharFormat(const QTextCharFormat &amp; modifier)</code>: Modifies the block char format of the current block (or all blocks that are contained in the selection) with the block format specified by <code>modifier</code>.</li>
<li><code>void QTextCursor::mergeBlockFormat(const QTextBlockFormat &amp; modifier)</code>: Modifies the block format of the current block (or all blocks that are contained in the selection) with the block format specified by <code>modifier</code>.</li>
<li><code>void QTextCursor::mergeCharFormat(const QTextCharFormat &amp; modifier)</code>: Merges the cursor’s current character format with the properties described by format <code>modifier</code>. If the cursor has a selection, this function applies all the properties set in <code>modifier</code> to all the character formats that are part of the selection.</li>
<li><code>bool QTextCursor::movePosition(MoveOperation operation, MoveMode mode = MoveAnchor, int n = 1)</code>: Moves the cursor by performing the given <code>operation</code> <code>n</code> times, using the specified <code>mode</code>, and returns <code>true</code> if all operations were completed successfully; otherwise returns <code>false</code>. For example, if this function is repeatedly used to seek to the end of the next word, it will eventually fail when the end of the document is reached. By default, the move <code>operation</code> is performed once (<code>n = 1</code>). If <code>mode</code> is <code>KeepAnchor</code>, the cursor selects the text it moves over. This is the same effect that the user achieves when they hold down the <code>Shift</code> key and move the cursor with the cursor keys.</li>
<li><code>int QTextCursor::position() const</code>: Returns the absolute position of the cursor within the document. The cursor is positioned between characters.</li>
<li><code>int QTextCursor::positionInBlock() const</code>: Returns the relative position of the cursor within the block. The cursor is positioned between characters.</li>
<li><code>void QTextCursor::removeSelectedText()</code>: If there is a selection, its content is deleted; otherwise does nothing.</li>
<li><code>void QTextCursor::select(SelectionType selection)</code>: Selects text in the document according to the given <code>selection</code>.</li>
<li><code>void QTextCursor::selectedTableCells(int * firstRow, int * numRows, int * firstColumn, int * numColumns) const</code>: If the selection spans over table cells, <code>firstRow</code> is populated with the number of the first row in the selection, <code>firstColumn</code> with the number of the first column in the selection, and <code>numRows</code> and <code>numColumns</code> with the number of rows and columns in the selection. If the selection does not span any table cells the results are harmless but undefined.</li>
<li><code>QString QTextCursor::selectedText() const</code>: Returns the current selection’s text (which may be empty). This only returns the text, with no rich text formatting information. If you want a document fragment (i.e. formatted rich text) use <code>selection()</code> instead. <strong>Note</strong>: If the selection obtained from an editor spans a line break, the text will contain a <code>Unicode U+2029</code> paragraph separator character instead of a newline <code>\n</code> character. Use <code>QString::replace()</code> to replace these characters with newlines.</li>
<li><code>QTextDocumentFragment QTextCursor::selection() const</code>: Returns the current selection (which may be empty) with all its formatting information. If you just want the selected text (i.e. plain text) use <code>selectedText()</code> instead. <strong>Note</strong>: Unlike <code>QTextDocumentFragment::toPlainText()</code>, <code>selectedText()</code> may include special unicode characters such as <code>QChar::ParagraphSeparator</code>.</li>
<li><code>int QTextCursor::selectionEnd() const</code>: Returns the end of the <code>selection</code> or <code>position()</code> if the cursor doesn’t have a selection.</li>
<li><code>int QTextCursor::selectionStart() const</code>: Returns the start of the <code>selection</code> or <code>position()</code> if the cursor doesn’t have a selection.</li>
<li><code>void QTextCursor::setBlockCharFormat(const QTextCharFormat &amp; format)</code>: Sets the block char <code>format</code> of the current block (or all blocks that are contained in the selection) to <code>format</code>.</li>
<li><code>void QTextCursor::setBlockFormat(const QTextBlockFormat &amp; format)</code>: Sets the block <code>format</code> of the current block (or all blocks that are contained in the selection) to <code>format</code>.</li>
<li><code>void QTextCursor::setCharFormat(const QTextCharFormat &amp; format)</code>: Sets the cursor’s current character <code>format</code> to the given <code>format</code>. If the cursor has a selection, the given <code>format</code> is applied to the current selection.</li>
<li><code>void QTextCursor::setKeepPositionOnInsert(bool b)</code>: Defines whether the cursor should keep its current position when text gets inserted at the current position of the cursor. If <code>b</code> is <code>true</code>, the cursor keeps its current position when text gets inserted at the positing of the cursor. If <code>b</code> is <code>false</code>, the cursor moves along with the inserted text. The default is <code>false</code>. Note that a cursor always moves when text is inserted before the current position of the cursor, and it always keeps its position when text is inserted after the current position of the cursor.</li>
<li><code>void QTextCursor::setPosition(int pos, MoveMode m = MoveAnchor)</code>: Moves the cursor to the absolute position in the document specified by <code>pos</code> using a <code>MoveMode</code> specified by <code>m</code>. The cursor is positioned between characters.</li>
<li><code>void QTextCursor::setVerticalMovementX(int x)</code>: Sets the visual <code>x</code> position for vertical cursor movements to <code>x</code>. The vertical movement <code>x</code> position is cleared automatically when the cursor moves horizontally, and kept unchanged when the cursor moves vertically. The mechanism allows the cursor to move up and down on a visually straight line with proportional fonts, and to gently <code>jump</code> over short lines. A value of <code>-1</code> indicates no predefined <code>x</code> position. It will then be set automatically the next time the cursor moves up or down.</li>
<li><code>void QTextCursor::setVisualNavigation(bool b)</code>: Sets visual navigation to <code>b</code>. Visual navigation means skipping over hidden text pragraphs. The default is <code>false</code>.</li>
<li><code>int QTextCursor::verticalMovementX() const</code>: Returns the visual <code>x</code> position for vertical cursor movements. A value of <code>-1</code> indicates no predefined <code>x</code> position. It will then be set automatically the next time the cursor moves up or down.</li>
<li><code>bool QTextCursor::visualNavigation() const</code>: Returns <code>true</code> if the cursor does visual navigation; otherwise returns <code>false</code>. Visual navigation means skipping over hidden text pragraphs. The default is <code>false</code>.</li>
<li><code>bool QTextCursor::operator!=(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is at a different position in the document as this cursor; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::operator&lt;(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is positioned later in the document than this cursor; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::operator&lt;=(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is positioned later or at the same position in the document as this cursor; otherwise returns <code>false</code>.</li>
<li><code>QTextCursor &amp; QTextCursor::operator=(const QTextCursor &amp; cursor)</code>: Makes a copy of <code>cursor</code> and assigns it to this <code>QTextCursor</code>. Note that <code>QTextCursor</code> is an implicitly shared class.</li>
<li><code>bool QTextCursor::operator==(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is at the same position in the document as this cursor; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::operator&gt;(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is positioned earlier in the document than this cursor; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::operator&gt;=(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is positioned earlier or at the same position in the document as this cursor; otherwise returns <code>false</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/28/Qt语法详解/Qt之QHash/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/28/Qt语法详解/Qt之QHash/" itemprop="url">Qt之QHash</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-28T18:27:15+08:00">
                2019-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QHash</code> class is a template class that provides a <code>hash-table-based</code> dictionary.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QHash</code></td>
<td><code>QMultiHash</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QHash()</code></td>
</tr>
<tr>
<td></td>
<td><code>QHash(const QHash&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QHash()</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>begin()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>capacity() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constBegin() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constEnd() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constFind(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>contains(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>empty() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>end()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator pos)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>find(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>find(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insert(const Key &amp; key, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insertMulti(const Key &amp; key, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>const Key</code></td>
<td><code>key(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>const Key</code></td>
<td><code>key(const T &amp; value, const Key &amp; defaultKey) const</code></td>
</tr>
<tr>
<td><code>QList&lt;Key&gt;</code></td>
<td><code>keys() const</code></td>
</tr>
<tr>
<td><code>QList&lt;Key&gt;</code></td>
<td><code>keys(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>remove(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>reserve(int size)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>squeeze()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(QHash&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>take(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>QList&lt;Key&gt;</code></td>
<td><code>uniqueKeys() const</code></td>
</tr>
<tr>
<td><code>QHash&lt;Key, T&gt; &amp;</code></td>
<td><code>unite(const QHash&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>const T</code></td>
<td><code>value(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>const T</code></td>
<td><code>value(const Key &amp; key, const T &amp; defaultValue) const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>values() const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>values(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QHash&lt;Key, T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QHash&lt;Key, T&gt; &amp;</code></td>
<td><code>operator=(const QHash&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QHash&lt;Key, T&gt; &amp;</code></td>
<td><code>operator=(QHash&lt;Key, T&gt; &amp;&amp; other)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QHash&lt;Key, T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>operator[](const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>const T</code></td>
<td><code>operator[](const Key &amp; key) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>uint</code></td>
<td><code>qHash(const QXmlNodeModelIndex &amp; index)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(char key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(uchar key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(signed char key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(ushort key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(short key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(uint key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(int key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(ulong key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(long key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(quint64 key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(qint64 key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(QChar key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(const QByteArray &amp; key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(const QString &amp; key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(const QBitArray &amp; key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(const T * key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(const QPair&lt;T1, T2&gt; &amp; key)</code></td>
</tr>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&lt;&lt;(QDataStream &amp; out, const QHash&lt;Key, T&gt; &amp; hash)</code></td>
</tr>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&gt;&gt;(QDataStream &amp; in, QHash&lt;Key, T&gt; &amp; hash)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QHash</code> class is a template class that provides a <code>hash-table-based</code> dictionary.<br>&emsp;&emsp;<code>QHash&lt;Key, T&gt;</code> is one of <code>Qt&#39;s</code> generic container classes. It stores <code>(key, value)</code> pairs and provides very fast lookup of the value associated with a key.<br>&emsp;&emsp;<code>QHash</code> provides very similar functionality to <code>QMap</code>. The differences are:</p>
<ul>
<li><code>QHash</code> provides faster lookups than <code>QMap</code>.</li>
<li>When iterating over a <code>QMap</code>, the items are always sorted by key. With <code>QHash</code>, the items are arbitrarily ordered.</li>
<li>The key type of a <code>QMap</code> must provide <code>operator&lt;()</code>. The key type of a <code>QHash</code> must provide <code>operator==()</code> and a global hash function called <code>qHash()</code>.</li>
</ul>
<p>&emsp;&emsp;Here’s an example <code>QHash</code> with <code>QString</code> keys and int values:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QHash&lt;QString, <span class="keyword">int</span>&gt; hash;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;To insert a <code>(key, value)</code> pair into the hash, you can use <code>operator[]()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hash[<span class="string">"one"</span>] = <span class="number">1</span>;</span><br><span class="line">hash[<span class="string">"three"</span>] = <span class="number">3</span>;</span><br><span class="line">hash[<span class="string">"seven"</span>] = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;This inserts the following three <code>(key, value)</code> pairs into the <code>QHash</code>: <code>(&quot;one&quot;, 1)</code>, <code>(&quot;three&quot;, 3)</code>, and <code>(&quot;seven&quot;, 7)</code>. Another way to insert items into the hash is to use <code>insert()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.insert(<span class="string">"twelve"</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;To look up a value, use <code>operator[]()</code> or <code>value()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = hash[<span class="string">"thirteen"</span>];</span><br><span class="line"><span class="keyword">int</span> num2 = hash.value ( <span class="string">"thirteen"</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If there is no item with the specified key in the hash, these functions return a <code>default-constructed</code> value.<br>&emsp;&emsp;If you want to check whether the hash contains a particular key, use <code>contains()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> timeout = <span class="number">30</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( hash.contains ( <span class="string">"TIMEOUT"</span> ) ) &#123;</span><br><span class="line">    timeout = hash.value ( <span class="string">"TIMEOUT"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;There is also a <code>value()</code> overload that uses its second argument as a default value if there is no item with the specified key:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> timeout = hash.value ( <span class="string">"TIMEOUT"</span>, <span class="number">30</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;In general, we recommend that you use <code>contains()</code> and <code>value()</code> rather than <code>operator[]()</code> for looking up a key in a hash. The reason is that <code>operator[]()</code> silently inserts an item into the hash if no item exists with the same key (unless the hash is const). For example, the following code snippet will create <code>1000</code> items in memory:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line">QHash&lt;<span class="keyword">int</span>, QWidget *&gt; hash;</span><br><span class="line">...</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( hash[i] == okButton ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found button at index "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;To avoid this problem, replace <code>hash[i]</code> with <code>hash.value(i)</code> in the code above.<br>&emsp;&emsp;If you want to navigate through all the <code>(key, value)</code> pairs stored in a <code>QHash</code>, you can use an iterator. <code>QHash</code> provides both <code>Java-style</code> iterators (<code>QHashIterator</code> and <code>QMutableHashIterator</code>) and <code>STL-style</code> iterators (<code>QHash::const_iterator</code> and <code>QHash::iterator</code>). Here’s how to iterate over a <code>QHash&lt;QString, int&gt;</code> using a <code>Java-style</code> iterator:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QHashIterator&lt;QString, <span class="keyword">int</span>&gt; i ( hash );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i.hasNext() ) &#123;</span><br><span class="line">    i.next();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.key() &lt;&lt; <span class="string">": "</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Here’s the same code, but using an <code>STL-style</code> iterator:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QHash&lt;QString, <span class="keyword">int</span>&gt;::const_iterator i = hash.constBegin();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != hash.constEnd() ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.key() &lt;&lt; <span class="string">": "</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>QHash</code> is unordered, so an iterator’s sequence cannot be assumed to be predictable. If ordering by key is required, use a <code>QMap</code>.<br>&emsp;&emsp;Normally, a <code>QHash</code> allows only one value per key. If you call <code>insert()</code> with a key that already exists in the <code>QHash</code>, the previous value is erased. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash.insert ( <span class="string">"plenty"</span>, <span class="number">100</span> );</span><br><span class="line">hash.insert ( <span class="string">"plenty"</span>, <span class="number">2000</span> ); <span class="comment">/* hash.value("plenty") == 2000 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;However, you can store multiple values per key by using <code>insertMulti()</code> instead of <code>insert()</code> (or using the convenience subclass <code>QMultiHash</code>). If you want to retrieve all the values for a single key, you can use <code>values(const Key &amp;key)</code>, which returns a <code>QList&lt;T&gt;</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;<span class="keyword">int</span>&gt; values = hash.values ( <span class="string">"plenty"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.size(); ++i ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values.at ( i ) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The items that share the same key are available from most recently to least recently inserted. A more efficient approach is to call <code>find()</code> to get the iterator for the first item with a key and iterate from there:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QHash&lt;QString, <span class="keyword">int</span>&gt;::iterator i = hash.find ( <span class="string">"plenty"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != hash.end() &amp;&amp; i.key() == <span class="string">"plenty"</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If you only need to extract the values from a hash (not the keys), you can also use <code>foreach</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QHash&lt;QString, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">...</span><br><span class="line">​</span><br><span class="line">foreach ( <span class="keyword">int</span> value, hash ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Items can be removed from the hash in several ways. One way is to call <code>remove()</code>; this will remove any item with the given key. Another way is to use <code>QMutableHashIterator::remove()</code>. In addition, you can clear the entire hash using <code>clear()</code>.<br>&emsp;&emsp;<code>QHash&#39;s</code> key and value data types must be assignable data types. You cannot, for example, store a <code>QWidget</code> as a value; instead, store a <code>QWidget *</code>. In addition, <code>QHash&#39;s</code> key type must provide <code>operator==()</code>, and there must also be a global <code>qHash()</code> function that returns a hash value for an argument of the key’s type.<br>&emsp;&emsp;Here’s a list of the <code>C++</code> and <code>Qt</code> types that can serve as keys in a <code>QHash</code>: any integer type (<code>char</code>, <code>unsigned long</code>, etc.), any pointer type, <code>QChar</code>, <code>QString</code>, and <code>QByteArray</code>. For all of these, the <code>QHash</code> header defines a <code>qHash()</code> function that computes an adequate hash value. If you want to use other types as the key, make sure that you provide <code>operator==()</code> and a <code>qHash()</code> implementation.<br>&emsp;&emsp;Example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EMPLOYEE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EMPLOYEE_H</span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Employee() &#123;&#125;</span><br><span class="line">    Employee ( <span class="keyword">const</span> QString &amp;name, <span class="keyword">const</span> QDate &amp;dateOfBirth );</span><br><span class="line">    ...</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString myName;</span><br><span class="line">    QDate myDateOfBirth;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== ( <span class="keyword">const</span> Employee &amp;e1, <span class="keyword">const</span> Employee &amp;e2 ) &#123;</span><br><span class="line">    <span class="keyword">return</span> e1.name() == e2.name() &amp;&amp; e1.dateOfBirth() == e2.dateOfBirth();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">inline</span> uint <span class="title">qHash</span> <span class="params">( <span class="keyword">const</span> Employee &amp;key )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qHash ( key.name() ) ^ key.dateOfBirth().day();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// EMPLOYEE_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>qHash()</code> function computes a numeric value based on a key. It can use any algorithm imaginable, as long as it always returns the same value if given the same argument. In other words, if <code>e1 == e2</code>, then <code>qHash(e1) == qHash(e2)</code> must hold as well. However, to obtain good performance, the <code>qHash()</code> function should attempt to return different hash values for different keys to the largest extent possible.<br>&emsp;&emsp;In the example above, we’ve relied on <code>Qt&#39;s</code> global <code>qHash(const QString &amp;)</code> to give us a hash value for the employee’s name, and <code>XOR&#39;ed</code> this with the day they were born to help produce unique hashes for people with the same name.<br>&emsp;&emsp;Internally, <code>QHash</code> uses a hash table to perform lookups. Unlike <code>Qt 3&#39;s</code> <code>QDict</code> class, which needed to be initialized with a prime number, <code>QHash&#39;s</code> hash table automatically grows and shrinks to provide fast lookups without wasting too much memory. You can still control the size of the hash table by calling <code>reserve()</code> if you already know approximately how many items the <code>QHash</code> will contain, but this isn’t necessary to obtain good performance. You can also call <code>capacity()</code> to retrieve the hash table’s size.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>typedef <code>QHash::ConstIterator</code>: <code>Qt-style</code> synonym for <code>QHash::const_iterator</code>.</li>
<li>typedef <code>QHash::Iterator</code>: <code>Qt-style</code> synonym for <code>QHash::iterator</code>.</li>
<li>typedef <code>QHash::difference_type</code>: Typedef for <code>ptrdiff_t</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QHash::key_type</code>: Typedef for <code>Key</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QHash::mapped_type</code>: Typedef for <code>T</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QHash::size_type</code> — Typedef for int. Provided for STL compatibility.</li>
</ul>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QHash::QHash()</code>: Constructs an empty hash.</li>
<li><code>QHash::QHash(const QHash&lt;Key, T&gt; &amp; other)</code>: Constructs a copy of <code>other</code>. This operation occurs in constant time, because <code>QHash</code> is implicitly shared. This makes returning a <code>QHash</code> from a function very fast. If a shared instance is modified, it will be copied (<code>copy-on-write</code>), and this takes linear time.</li>
<li><code>QHash::~QHash()</code>: Destroys the hash. References to the values in the hash and all iterators of this hash become invalid.</li>
<li><code>iterator QHash::begin()</code>: Returns an <code>STL-style</code> iterator pointing to the first item in the hash.</li>
<li><code>const_iterator QHash::begin() const</code>: This is an overloaded function.</li>
<li><code>int QHash::capacity() const</code>: Returns the number of buckets in the <code>QHash&#39;s</code> internal hash table. The sole purpose of this function is to provide a means of fine tuning <code>QHash&#39;s</code> memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the hash, call <code>size()</code>.</li>
<li><code>void QHash::clear()</code>: Removes all items from the hash.</li>
<li><code>const_iterator QHash::constBegin() const</code>: Returns a const <code>STL-style</code> iterator pointing to the first item in the hash.</li>
<li><code>const_iterator QHash::constEnd() const</code>: Returns a const <code>STL-style</code> iterator pointing to the imaginary item after the last item in the hash.</li>
<li><code>const_iterator QHash::constFind(const Key &amp; key) const</code>: Returns an iterator pointing to the item with the <code>key</code> in the hash. If the hash contains no item with the <code>key</code>, the function returns <code>constEnd()</code>.</li>
<li><code>bool QHash::contains(const Key &amp; key) const</code>: Returns <code>true</code> if the hash contains an item with the <code>key</code>; otherwise returns <code>false</code>.</li>
<li><code>int QHash::count(const Key &amp; key) const</code>: Returns the number of items associated with the <code>key</code>.</li>
<li><code>int QHash::count() const</code>: This is an overloaded function. Same as <code>size()</code>.</li>
<li><code>bool QHash::empty() const</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>isEmpty()</code>, returning <code>true</code> if the hash is empty; otherwise returns <code>false</code>.</li>
<li><code>iterator QHash::end()</code>: Returns an <code>STL-style</code> iterator pointing to the imaginary item after the last item in the hash.</li>
<li><code>const_iterator QHash::end() const</code>: This is an overloaded function.</li>
<li><code>iterator QHash::erase(iterator pos)</code>: Removes the <code>(key, value)</code> pair associated with the iterator <code>pos</code> from the hash, and returns an iterator to the next item in the hash. Unlike <code>remove()</code> and <code>take()</code>, this function never causes <code>QHash</code> to rehash its internal data structure. This means that it can safely be called while iterating, and won’t affect the order of items in the hash. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QHash&lt;QObject *, <span class="keyword">int</span>&gt; objectHash;</span><br><span class="line">...</span><br><span class="line">QHash&lt;QObject *, <span class="keyword">int</span>&gt;::iterator i = objectHash.find ( obj );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != objectHash.end() &amp;&amp; i.key() == obj ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i.value() == <span class="number">0</span> ) &#123;</span><br><span class="line">        i = objectHash.erase ( i );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>iterator QHash::find(const Key &amp; key)</code>: Returns an iterator pointing to the item with the <code>key</code> in the hash. If the hash contains no item with the <code>key</code>, the function returns <code>end()</code>. If the hash contains multiple items with the <code>key</code>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here’s some code that iterates over all the items with the same <code>key</code>:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QHash&lt;QString, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">...</span><br><span class="line">QHash&lt;QString, <span class="keyword">int</span>&gt;::const_iterator i = hash.find ( <span class="string">"HDR"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != hash.end() &amp;&amp; i.key() == <span class="string">"HDR"</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>const_iterator QHash::find(const Key &amp; key) const</code>: This is an overloaded function.</li>
<li><code>iterator QHash::insert(const Key &amp; key, const T &amp; value)</code>: Inserts a new item with the <code>key</code> and a <code>value</code> of value. If there is already an item with the <code>key</code>, that item’s value is replaced with <code>value</code>. If there are multiple items with the <code>key</code>, the most recently inserted item’s value is replaced with <code>value</code>.</li>
<li><code>iterator QHash::insertMulti(const Key &amp; key, const T &amp; value)</code>: Inserts a new item with the <code>key</code> and a <code>value</code> of value. If there is already an item with the same <code>key</code> in the hash, this function will simply create a new one (This behavior is different from <code>insert()</code>, which overwrites the <code>value</code> of an existing item).</li>
<li><code>bool QHash::isEmpty() const</code>: Returns <code>true</code> if the hash contains no items; otherwise returns <code>false</code>.</li>
<li><code>const Key QHash::key(const T &amp; value) const</code>: Returns the first key mapped to <code>value</code>. If the hash contains no item with the <code>value</code>, the function returns a <code>default-constructed</code> key. This function can be slow (linear time), because <code>QHash&#39;s</code> internal data structure is optimized for fast lookup by key, not by value.</li>
<li><code>const Key QHash::key(const T &amp; value, const Key &amp; defaultKey) const</code>: This is an overloaded function. Returns the first key mapped to <code>value</code>, or <code>defaultKey</code> if the hash contains no item mapped to <code>value</code>. This function can be slow (linear time), because <code>QHash&#39;s</code> internal data structure is optimized for fast lookup by key, not by value.</li>
<li><code>QList&lt;Key&gt; QHash::keys() const</code>: Returns a list containing all the keys in the hash, in an arbitrary order. Keys that occur multiple times in the hash (because items were inserted with <code>insertMulti()</code>, or <code>unite()</code> was used) also occur multiple times in the list. To obtain a list of unique keys, where each key from the map only occurs once, use <code>uniqueKeys()</code>. The order is guaranteed to be the same as that used by <code>values()</code>.</li>
<li><code>QList&lt;Key&gt; QHash::keys(const T &amp; value) const</code>: This is an overloaded function. Returns a list containing all the keys associated with <code>value</code>, in an arbitrary order. This function can be slow (linear time), because <code>QHash&#39;s</code> internal data structure is optimized for fast lookup by key, not by value.</li>
<li><code>int QHash::remove(const Key &amp; key)</code>: Removes all the items that have the <code>key</code> from the hash. Returns the number of items removed which is usually <code>1</code> but will be <code>0</code> if the <code>key</code> isn’t in the hash, or greater than <code>1</code> if <code>insertMulti()</code> has been used with the <code>key</code>.</li>
<li><code>void QHash::reserve(int size)</code>: Ensures that the <code>QHash&#39;s</code> internal hash table consists of at least <code>size</code> buckets. This function is useful for code that needs to build a huge hash and wants to avoid repeated reallocation. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QHash&lt;QString, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">hash.reserve ( <span class="number">20000</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; ++i ) &#123;</span><br><span class="line">    hash.insert ( keys[i], values[i] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Ideally, size should be slightly more than the maximum number of items expected in the hash. size doesn’t have to be prime, because <code>QHash</code> will use a prime number internally anyway. If size is an underestimate, the worst that will happen is that the <code>QHash</code> will be a bit slower. In general, you will rarely ever need to call this function. <code>QHash&#39;s</code> internal hash table automatically shrinks or grows to provide good performance without wasting too much memory.</p>
<ul>
<li><code>int QHash::size() const</code>: Returns the number of items in the hash.</li>
<li><code>void QHash::squeeze()</code>: Reduces the size of the <code>QHash&#39;s</code> internal hash table to save memory. The sole purpose of this function is to provide a means of fine tuning <code>QHash&#39;s</code> memory usage. In general, you will rarely ever need to call this function.</li>
<li><code>void QHash::swap(QHash&lt;Key, T&gt; &amp; other)</code>: Swaps hash <code>other</code> with this hash. This operation is very fast and never fails.</li>
<li><code>T QHash::take(const Key &amp; key)</code>: Removes the item with the <code>key</code> from the hash and returns the value associated with it. If the item does not exist in the hash, the function simply returns a <code>default-constructed</code> value. If there are multiple items for key in the hash, only the most recently inserted one is removed. If you don’t use the return value, <code>remove()</code> is more efficient.</li>
<li><code>QList&lt;Key&gt; QHash::uniqueKeys() const</code>: Returns a list containing all the keys in the map. Keys that occur multiple times in the map (because items were inserted with <code>insertMulti()</code>, or <code>unite()</code> was used) occur only once in the returned list.</li>
<li><code>QHash&lt;Key, T&gt; &amp; QHash::unite(const QHash&lt;Key, T&gt; &amp; other)</code>: Inserts all the items in the <code>other</code> hash into this hash. If a key is common to both hashes, the resulting hash will contain the key multiple times.</li>
<li><code>const T QHash::value(const Key &amp; key) const</code>: Returns the value associated with the <code>key</code>. If the hash contains no item with the <code>key</code>, the function returns a <code>default-constructed</code> value. If there are multiple items for the key in the hash, the value of the most recently inserted one is returned.</li>
<li><code>const T QHash::value(const Key &amp; key, const T &amp; defaultValue) const</code>: This is an overloaded function. If the hash contains no item with the given <code>key</code>, the function returns <code>defaultValue</code>.</li>
<li><code>QList&lt;T&gt; QHash::values() const</code>: Returns a list containing all the values in the hash, in an arbitrary order. If a key is associated multiple values, all of its values will be in the list, and not just the most recently inserted one. The order is guaranteed to be the same as that used by <code>keys()</code>.</li>
<li><code>QList&lt;T&gt; QHash::values(const Key &amp; key) const</code>: This is an overloaded function. Returns a list of all the values associated with the <code>key</code>, from the most recently inserted to the least recently inserted.</li>
<li><code>bool QHash::operator!=(const QHash&lt;Key, T&gt; &amp; other) const</code>: Returns <code>true</code> if <code>other</code> is not equal to this hash; otherwise returns <code>false</code>. Two hashes are considered equal if they contain the same <code>(key, value)</code> pairs. This function requires the value type to implement <code>operator==()</code>.</li>
<li><code>QHash&lt;Key, T&gt; &amp; QHash::operator=(const QHash&lt;Key, T&gt; &amp; other)</code>: Assigns <code>other</code> to this hash and returns a reference to this hash.</li>
<li><code>bool QHash::operator==(const QHash&lt;Key, T&gt; &amp; other) const</code>: Returns <code>true</code> if <code>other</code> is equal to this hash; otherwise returns <code>false</code>. Two hashes are considered equal if they contain the same <code>(key, value)</code> pairs. This function requires the value type to implement <code>operator==()</code>.</li>
<li><code>T &amp; QHash::operator[](const Key &amp; key)</code>: Returns the value associated with the <code>key</code> as a modifiable reference. If the hash contains no item with the <code>key</code>, the function inserts a <code>default-constructed</code> value into the hash with the <code>key</code>, and returns a reference to it. If the hash contains multiple items with the <code>key</code>, this function returns a reference to the most recently inserted value.</li>
<li><code>const T QHash::operator[](const Key &amp; key) const</code>: This is an overloaded function. Same as <code>value()</code>.</li>
</ul>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>uint qHash(const QXmlNodeModelIndex &amp; index)</code>: Computes a hash key from the <code>QXmlNodeModelIndex</code> <code>index</code>, and returns it. This function would be used by <code>QHash</code> if you wanted to build a hash table for instances of <code>QXmlNodeModelIndex</code>. The hash is computed on <code>QXmlNodeModelIndex::data()</code>, <code>QXmlNodeModelIndex::additionalData()</code>, and <code>QXmlNodeModelIndex::model()</code>. This means the hash key can be used for node indexes from different node models.</li>
<li><code>uint qHash(char key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(uchar key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(signed char key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(ushort key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(short key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(uint key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(int key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(ulong key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(long key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(quint64 key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(qint64 key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(QChar key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(const QByteArray &amp; key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(const QString &amp; key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(const QBitArray &amp; key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(const T * key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(const QPair&lt;T1, T2&gt; &amp; key)</code>: Returns the hash value for the <code>key</code>. Types <code>T1</code> and <code>T2</code> must be supported by <code>qHash()</code>.</li>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; out, const QHash&lt;Key, T&gt; &amp; hash)</code>: Writes the <code>hash</code> to stream <code>out</code>. This function requires the key and value types to implement <code>operator&lt;&lt;()</code>.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; in, QHash&lt;Key, T&gt; &amp; hash)</code>: Reads a hash from stream <code>in</code> into <code>hash</code>. This function requires the key and value types to implement <code>operator&gt;&gt;()</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/28/Qt语法详解/Qt之Qmap/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/28/Qt语法详解/Qt之Qmap/" itemprop="url">Qt之Qmap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-28T10:46:17+08:00">
                2019-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QMap</code> class is a template class that provides a <code>skip-list-based</code> dictionary.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QMap</code></td>
<td><code>QMultiMap</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QMap()</code></td>
</tr>
<tr>
<td></td>
<td><code>QMap(const QMap&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td></td>
<td><code>QMap(const std::map&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QMap()</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>begin()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constBegin() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constEnd() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constFind(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>contains(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>empty() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>end()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator pos)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>find(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>find(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insert(const Key &amp; key, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insertMulti(const Key &amp; key, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>const Key</code></td>
<td><code>key(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>const Key</code></td>
<td><code>key(const T &amp; value, const Key &amp; defaultKey) const</code></td>
</tr>
<tr>
<td><code>QList&lt;Key&gt;</code></td>
<td><code>keys() const</code></td>
</tr>
<tr>
<td><code>QList&lt;Key&gt;</code></td>
<td><code>keys(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>lowerBound(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>lowerBound(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>remove(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(QMap&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>take(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>std::map&lt;Key, T&gt;</code></td>
<td><code>toStdMap() const</code></td>
</tr>
<tr>
<td><code>QList&lt;Key&gt;</code></td>
<td><code>uniqueKeys() const</code></td>
</tr>
<tr>
<td><code>QMap&lt;Key, T&gt; &amp;</code></td>
<td><code>unite(const QMap&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>upperBound(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>upperBound(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>const T</code></td>
<td><code>value(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>const T</code></td>
<td><code>value(const Key &amp; key, const T &amp; defaultValue) const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>values() const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>values(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QMap&lt;Key, T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QMap&lt;Key, T&gt; &amp;</code></td>
<td><code>operator=(const QMap&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QMap&lt;Key, T&gt; &amp;</code></td>
<td><code>operator=(QMap&lt;Key, T&gt; &amp;&amp; other)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QMap&lt;Key, T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>operator[](const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>const T</code></td>
<td><code>operator[](const Key &amp; key) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QDataStream</code></td>
<td><code>&amp;operator&lt;&lt; ( QDataStream &amp;out, const QMap&lt;Key, T&gt; &amp;map );</code></td>
</tr>
<tr>
<td><code>QDataStream</code></td>
<td><code>&amp;operator&gt;&gt; ( QDataStream &amp;in, QMap&lt;Key, T&gt; &amp;map );</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QMap</code> class is a template class that provides a <code>skip-list-based</code> dictionary.<br>&emsp;&emsp;<code>QMap&lt;Key, T&gt;</code> is one of <code>Qt&#39;s</code> generic container classes. It stores <code>(key, value)</code> pairs and provides fast lookup of the value associated with a key.<br>&emsp;&emsp;<code>QMap</code> and <code>QHash</code> provide very similar functionality. The differences are:</p>
<ul>
<li><code>QHash</code> provides faster lookups than <code>QMap</code>.</li>
<li>When iterating over a <code>QHash</code>, the items are arbitrarily ordered. With <code>QMap</code>, the items are always sorted by key.</li>
<li>The key type of a <code>QHash</code> must provide <code>operator==()</code> and a global <code>qHash(Key)</code> function. The key type of a <code>QMap</code> must provide <code>operator&lt;()</code> specifying a total order.</li>
</ul>
<p>&emsp;&emsp;Here’s an example <code>QMap</code> with <code>QString</code> keys and int values:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br></pre></td></tr></table></figure>
<p>To insert a <code>(key, value)</code> pair into the map, you can use <code>operator[]()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>[<span class="string">"one"</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">map</span>[<span class="string">"three"</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">map</span>[<span class="string">"seven"</span>] = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;This inserts the following three <code>(key, value)</code> pairs into the <code>QMap</code>: <code>(&quot;one&quot;, 1)</code>, <code>(&quot;three&quot;, 3)</code>, and <code>(&quot;seven&quot;, 7)</code>. Another way to insert items into the map is to use <code>insert()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.insert ( <span class="string">"twelve"</span>, <span class="number">12</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;To look up a value, use <code>operator[]()</code> or <code>value()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = <span class="built_in">map</span>[<span class="string">"thirteen"</span>];</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="built_in">map</span>.value ( <span class="string">"thirteen"</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If there is no item with the specified key in the map, these functions return a <code>default-constructed</code> value.<br>&emsp;&emsp;If you want to check whether the map contains a certain key, use <code>contains()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> timeout = <span class="number">30</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">map</span>.contains ( <span class="string">"TIMEOUT"</span> ) ) &#123;</span><br><span class="line">    timeout = <span class="built_in">map</span>.value ( <span class="string">"TIMEOUT"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;There is also a <code>value()</code> overload that uses its second argument as a default value if there is no item with the specified key:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> timeout = <span class="built_in">map</span>.value ( <span class="string">"TIMEOUT"</span>, <span class="number">30</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;In general, we recommend that you use <code>contains()</code> and <code>value()</code> rather than <code>operator[]()</code> for looking up a key in a map. The reason is that <code>operator[]()</code> silently inserts an item into the map if no item exists with the same key (unless the map is const). For example, the following code snippet will create <code>1000</code> items in memory:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line">QMap&lt;<span class="keyword">int</span>, QWidget *&gt; <span class="built_in">map</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">map</span>[i] == okButton ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found button at index "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;To avoid this problem, replace <code>map[i]</code> with <code>map.value(i)</code> in the code above.<br>&emsp;&emsp;If you want to navigate through all the <code>(key, value)</code> pairs stored in a <code>QMap</code>, you can use an iterator. <code>QMap</code> provides both <code>Java-style</code> iterators (<code>QMapIterator</code> and <code>QMutableMapIterator</code>) and <code>STL-style</code> iterators (<code>QMap::const_iterator</code> and <code>QMap::iterator</code>). Here’s how to iterate over a <code>QMap&lt;QString, int&gt;</code> using a <code>Java-style</code> iterator:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QMapIterator&lt;QString, <span class="keyword">int</span>&gt; i ( <span class="built_in">map</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i.hasNext() ) &#123;</span><br><span class="line">    i.next();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.key() &lt;&lt; <span class="string">": "</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Here’s the same code, but using an <code>STL-style</code> iterator this time:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt;::const_iterator i = <span class="built_in">map</span>.constBegin();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != <span class="built_in">map</span>.constEnd() ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.key() &lt;&lt; <span class="string">": "</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The items are traversed in ascending key order.<br>&emsp;&emsp;Normally, a <code>QMap</code> allows only one value per key. If you call <code>insert()</code> with a key that already exists in the <code>QMap</code>, the previous value will be erased. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.insert ( <span class="string">"plenty"</span>, <span class="number">100</span> );</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="string">"plenty"</span>, <span class="number">2000</span> ); <span class="comment">/* map.value("plenty") == 2000 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;However, you can store multiple values per key by using <code>insertMulti()</code> instead of <code>insert()</code> (or using the convenience subclass <code>QMultiMap</code>). If you want to retrieve all the values for a single key, you can use <code>values(const Key &amp;key)</code>, which returns a <code>QList&lt;T&gt;</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;<span class="keyword">int</span>&gt; values = <span class="built_in">map</span>.values ( <span class="string">"plenty"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.size(); ++i ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values.at ( i ) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The items that share the same key are available from most recently to least recently inserted. Another approach is to call <code>find()</code> to get the <code>STL-style</code> iterator for the first item with a key and iterate from there:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt;::iterator i = <span class="built_in">map</span>.find ( <span class="string">"plenty"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != <span class="built_in">map</span>.end() &amp;&amp; i.key() == <span class="string">"plenty"</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If you only need to extract the values from a map (not the keys), you can also use <code>foreach</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">​</span><br><span class="line">foreach ( <span class="keyword">int</span> value, <span class="built_in">map</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Items can be removed from the map in several ways. One way is to call <code>remove()</code>; this will remove any item with the given key. Another way is to use <code>QMutableMapIterator::remove()</code>. In addition, you can clear the entire map using <code>clear()</code>.<br>&emsp;&emsp;<code>QMap&#39;s</code> key and value data types must be assignable data types. This covers most data types you are likely to encounter, but the compiler won’t let you, for example, store a <code>QWidget</code> as a value; instead, store a <code>QWidget *</code>. In addition, <code>QMap&#39;s</code> key type must provide <code>operator&lt;()</code>. <code>QMap</code> uses it to keep its items sorted, and assumes that two keys <code>x</code> and <code>y</code> are equal if neither <code>x &lt; y</code> nor <code>y &lt; x</code> is <code>true</code>. Example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EMPLOYEE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EMPLOYEE_H</span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Employee() &#123;&#125;</span><br><span class="line">    Employee ( <span class="keyword">const</span> QString &amp;name, <span class="keyword">const</span> QDate &amp;dateOfBirth );</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString myName;</span><br><span class="line">    QDate myDateOfBirth;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; ( <span class="keyword">const</span> Employee &amp;e1, <span class="keyword">const</span> Employee &amp;e2 ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( e1.name() != e2.name() ) &#123;</span><br><span class="line">        <span class="keyword">return</span> e1.name() &lt; e2.name();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> e1.dateOfBirth() &lt; e2.dateOfBirth();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// EMPLOYEE_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;In the example, we start by comparing the employees’ names. If they’re equal, we compare their dates of birth to break the tie.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>typedef <code>QMap::ConstIterator</code>: <code>Qt-style</code> synonym for <code>QMap::const_iterator</code>.</li>
<li>typedef <code>QMap::Iterator</code>: <code>Qt-style</code> synonym for <code>QMap::iterator</code>.</li>
<li>typedef <code>QMap::difference_type</code>: Typedef for <code>ptrdiff_t</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QMap::key_type</code>: Typedef for <code>Key</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QMap::mapped_type</code>: Typedef for <code>T</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QMap::size_type</code>: Typedef for <code>int</code>. Provided for <code>STL</code> compatibility.</li>
</ul>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QMap::QMap()</code>: Constructs an empty map.</li>
<li><code>QMap::QMap(const QMap&lt;Key, T&gt; &amp; other)</code>: Constructs a copy of <code>other</code>. This operation occurs in constant time, because <code>QMap</code> is implicitly shared. This makes returning a <code>QMap</code> from a function very fast. If a shared instance is modified, it will be copied (<code>copy-on-write</code>), and this takes linear time.</li>
<li><code>QMap::QMap(const std::map&lt;Key, T&gt; &amp; other)</code>: Constructs a copy of <code>other</code>. This function is only available if <code>Qt</code> is configured with <code>STL</code> compatibility enabled.</li>
<li><code>QMap::~QMap()</code>: Destroys the map. References to the values in the map, and all iterators over this map, become invalid.</li>
<li><code>iterator QMap::begin()</code>: Returns an <code>STL-style</code> iterator pointing to the first item in the map.</li>
<li><code>const_iterator QMap::begin() const</code>: This is an overloaded function.</li>
<li><code>void QMap::clear()</code>: Removes all items from the map.</li>
<li><code>const_iterator QMap::constBegin() const</code>: Returns a const <code>STL-style</code> iterator pointing to the first item in the map.</li>
<li><code>const_iterator QMap::constEnd() const</code>: Returns a const <code>STL-style</code> iterator pointing to the imaginary item after the last item in the map.</li>
<li><code>const_iterator QMap::constFind(const Key &amp; key) const</code>: Returns an const iterator pointing to the item with <code>key</code> in the map. If the map contains no item with <code>key</code>, the function returns <code>constEnd()</code>.</li>
<li><code>bool QMap::contains(const Key &amp; key) const</code>: Returns <code>true</code> if the map contains an item with <code>key</code>; otherwise returns <code>false</code>.</li>
<li><code>int QMap::count(const Key &amp; key) const</code>: Returns the number of items associated with <code>key</code>.</li>
<li><code>int QMap::count() const</code>: This is an overloaded function. Same as <code>size()</code>.</li>
<li><code>bool QMap::empty() const</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>isEmpty()</code>, returning <code>true</code> if the map is empty; otherwise returning <code>false</code>.</li>
<li><code>iterator QMap::end()</code>: Returns an <code>STL-style</code> iterator pointing to the imaginary item after the last item in the map.</li>
<li><code>const_iterator QMap::end() const</code>: This is an overloaded function.</li>
<li><code>iterator QMap::erase(iterator pos)</code>: Removes the <code>(key, value)</code> pair pointed to by the iterator <code>pos</code> from the map, and returns an iterator to the next item in the map.</li>
<li><code>iterator QMap::find(const Key &amp; key)</code>: Returns an iterator pointing to the item with <code>key</code> in the map. If the map contains no item with <code>key</code>, the function returns <code>end()</code>. If the map contains multiple items with <code>key</code>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here’s some code that iterates over all the items with the same <code>key</code>:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">​</span><br><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt;::const_iterator i = <span class="built_in">map</span>.find ( <span class="string">"HDR"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != <span class="built_in">map</span>.end() &amp;&amp; i.key() == <span class="string">"HDR"</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>const_iterator QMap::find(const Key &amp; key) const</code>: This is an overloaded function.</li>
<li><code>iterator QMap::insert(const Key &amp; key, const T &amp; value)</code>: Inserts a new item with the <code>key</code> and a <code>value</code> of value. If there is already an item with the <code>key</code>, that item’s value is replaced with <code>value</code>. If there are multiple items with the <code>key</code>, the most recently inserted item’s value is replaced with <code>value</code>.</li>
<li><code>iterator QMap::insertMulti(const Key &amp; key, const T &amp; value)</code>: Inserts a new item with the <code>key</code> and a <code>value</code> of value. If there is already an item with the same <code>key</code> in the map, this function will simply create a new one (This behavior is different from <code>insert()</code>, which overwrites the value of an existing item).</li>
<li><code>bool QMap::isEmpty() const</code>: Returns <code>true</code> if the map contains no items; otherwise returns <code>false</code>.</li>
<li><code>const Key QMap::key(const T &amp; value) const</code>: Returns the first key with <code>value</code>. If the map contains no item with <code>value</code>, the function returns a <code>default-constructed</code> key. This function can be slow (linear time), because <code>QMap&#39;s</code> internal data structure is optimized for fast lookup by key, not by value.</li>
<li><code>const Key QMap::key(const T &amp; value, const Key &amp; defaultKey) const</code>: This is an overloaded function. Returns the first key with <code>value</code>, or defaultKey if the map contains no item with <code>value</code>. This function can be slow (linear time), because <code>QMap&#39;s</code> internal data structure is optimized for fast lookup by key, not by value.</li>
<li><code>QList&lt;Key&gt; QMap::keys() const</code>: Returns a list containing all the keys in the map in ascending order. Keys that occur multiple times in the map (because items were inserted with <code>insertMulti()</code>, or <code>unite()</code> was used) also occur multiple times in the list. To obtain a list of unique keys, where each key from the map only occurs once, use <code>uniqueKeys()</code>. The order is guaranteed to be the same as that used by <code>values()</code>.</li>
<li><code>QList&lt;Key&gt; QMap::keys(const T &amp; value) const</code>: This is an overloaded function. Returns a list containing all the keys associated with <code>value</code> in ascending order. This function can be slow (linear time), because <code>QMap&#39;s</code> internal data structure is optimized for fast lookup by key, not by value.</li>
<li><code>iterator QMap::lowerBound(const Key &amp; key)</code>: Returns an iterator pointing to the first item with <code>key</code> in the map. If the map contains no item with <code>key</code>, the function returns an iterator to the nearest item with a greater key. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;<span class="keyword">int</span>, QString&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">1</span>, <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">5</span>, <span class="string">"five"</span> );</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">10</span>, <span class="string">"ten"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="built_in">map</span>.lowerBound ( <span class="number">0</span> ); <span class="comment">/* returns iterator to (1, "one") */</span></span><br><span class="line"><span class="built_in">map</span>.lowerBound ( <span class="number">1</span> ); <span class="comment">/* returns iterator to (1, "one") */</span></span><br><span class="line"><span class="built_in">map</span>.lowerBound ( <span class="number">2</span> ); <span class="comment">/* returns iterator to (5, "five") */</span></span><br><span class="line"><span class="built_in">map</span>.lowerBound ( <span class="number">10</span> ); <span class="comment">/* returns iterator to (10, "ten") */</span></span><br><span class="line"><span class="built_in">map</span>.lowerBound ( <span class="number">999</span> ); <span class="comment">/* returns end() */</span></span><br></pre></td></tr></table></figure>
<p>If the map contains multiple items with <code>key</code>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here’s some code that iterates over all the items with the same key:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">​</span><br><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt;::const_iterator i = <span class="built_in">map</span>.lowerBound ( <span class="string">"HDR"</span> );</span><br><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt;::const_iterator upperBound = <span class="built_in">map</span>.upperBound ( <span class="string">"HDR"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != upperBound ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>const_iterator QMap::lowerBound(const Key &amp; key) const</code>: This is an overloaded function.</li>
<li><code>int QMap::remove(const Key &amp; key)</code>: Removes all the items that have the <code>key</code> from the map. Returns the number of items removed which is usually <code>1</code> but will be <code>0</code> if the <code>key</code> isn’t in the map, or <code>&gt; 1</code> if <code>insertMulti()</code> has been used with the <code>key</code>.</li>
<li><code>int QMap::size() const</code>: Returns the number of <code>(key, value)</code> pairs in the map.</li>
<li><code>void QMap::swap(QMap&lt;Key, T&gt; &amp; other)</code>: Swaps map <code>other</code> with this map. This operation is very fast and never fails.</li>
<li><code>T QMap::take(const Key &amp; key)</code>: Removes the item with the <code>key</code> from the map and returns the value associated with it. If the item does not exist in the map, the function simply returns a <code>default-constructed</code> value. If there are multiple items for <code>key</code> in the map, only the most recently inserted one is removed and returned. If you don’t use the return value, <code>remove()</code> is more efficient.</li>
<li><code>std::map&lt;Key, T&gt; QMap::toStdMap() const</code>: Returns an <code>STL</code> map equivalent to this <code>QMap</code>. This function is only available if <code>Qt</code> is configured with <code>STL</code> compatibility enabled.</li>
<li><code>QList&lt;Key&gt; QMap::uniqueKeys() const</code>: Returns a list containing all the keys in the map in ascending order. Keys that occur multiple times in the map (because items were inserted with <code>insertMulti()</code>, or <code>unite()</code> was used) occur only once in the returned list.</li>
<li><code>QMap&lt;Key, T&gt; &amp; QMap::unite(const QMap&lt;Key, T&gt; &amp; other)</code>: Inserts all the items in the <code>other</code> map into this map. If a key is common to both maps, the resulting map will contain the key multiple times.</li>
<li><code>iterator QMap::upperBound(const Key &amp; key)</code>: Returns an iterator pointing to the item that immediately follows the last item with <code>key</code> in the map. If the map contains no item with <code>key</code>, the function returns an iterator to the nearest item with a greater key. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;<span class="keyword">int</span>, QString&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">1</span>, <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">5</span>, <span class="string">"five"</span> );</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">10</span>, <span class="string">"ten"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="built_in">map</span>.upperBound ( <span class="number">0</span> ); <span class="comment">/* returns iterator to (1, "one") */</span></span><br><span class="line"><span class="built_in">map</span>.upperBound ( <span class="number">1</span> ); <span class="comment">/* returns iterator to (5, "five") */</span></span><br><span class="line"><span class="built_in">map</span>.upperBound ( <span class="number">2</span> ); <span class="comment">/* returns iterator to (5, "five") */</span></span><br><span class="line"><span class="built_in">map</span>.upperBound ( <span class="number">10</span> ); <span class="comment">/* returns end() */</span></span><br><span class="line"><span class="built_in">map</span>.upperBound ( <span class="number">999</span> ); <span class="comment">/* returns end() */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>const_iterator QMap::upperBound(const Key &amp; key) const</code>: This is an overloaded function.</li>
<li><code>const T QMap::value(const Key &amp; key) const</code>: Returns the value associated with the <code>key</code>. If the map contains no item with <code>key</code>, the function returns a <code>default-constructed</code> value. If there are multiple items for key in the map, the value of the most recently inserted one is returned.</li>
<li><code>const T QMap::value(const Key &amp; key, const T &amp; defaultValue) const</code>: This is an overloaded function. If the map contains no item with <code>key</code>, the function returns <code>defaultValue</code>.</li>
<li><code>QList&lt;T&gt; QMap::values() const</code>: Returns a list containing all the values in the map, in ascending order of their keys. If a key is associated with multiple values, all of its values will be in the list, and not just the most recently inserted one.</li>
<li><code>QList&lt;T&gt; QMap::values(const Key &amp; key) const</code>: This is an overloaded function. Returns a list containing all the values associated with <code>key</code>, from the most recently inserted to the least recently inserted one.</li>
<li><code>bool QMap::operator!=(const QMap&lt;Key, T&gt; &amp; other) const</code>: Returns true if <code>other</code> is not equal to this map; otherwise returns false. Two maps are considered equal if they contain the same <code>(key, value)</code> pairs. This function requires the value type to implement <code>operator==()</code>.</li>
<li><code>QMap&lt;Key, T&gt; &amp; QMap::operator=(const QMap&lt;Key, T&gt; &amp; other)</code>: Assigns <code>other</code> to this map and returns a reference to this map.</li>
<li><code>QMap&lt;Key, T&gt; &amp; QMap::operator=(QMap&lt;Key, T&gt; &amp;&amp; other)</code>: bool <code>QMap::operator==(const QMap&lt;Key, T&gt; &amp; other)</code> const Returns <code>true</code> if other is equal to this map; otherwise returns <code>false</code>. Two maps are considered equal if they contain the same <code>(key, value)</code> pairs. This function requires the value type to implement <code>operator==()</code>.</li>
<li><code>T &amp; QMap::operator[](const Key &amp; key)</code>: Returns the value associated with the key key as a modifiable reference. If the map contains no item with <code>key</code>, the function inserts a <code>default-constructed</code> value into the map with <code>key</code>, and returns a reference to it. If the map contains multiple items with <code>key</code>, this function returns a reference to the most recently inserted value.</li>
<li><code>const T QMap::operator[](const Key &amp; key) const</code>: This is an overloaded function.</li>
</ul>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; out, const QMap&lt;Key, T&gt; &amp; map)</code>: Writes the <code>map</code> to stream <code>out</code>. This function requires the key and value types to implement <code>operator&lt;&lt;()</code>.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; in, QMap&lt;Key, T&gt; &amp; map)</code>: Reads a map from stream <code>in</code> into <code>map</code>. This function requires the key and value types to implement <code>operator&gt;&gt;()</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/27/Qt语法详解/Qt之QFtp/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/27/Qt语法详解/Qt之QFtp/" itemprop="url">Qt之QFtp</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T22:10:59+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>QFtp</code>类提供了一个<code>FTP</code>协议的客户端实现，该类提供了一个访问到<code>FTP</code>服务器的接口。对于新的应用程序，建议使用<code>QNetworkAccessManager</code>和<code>QNetworkReply</code>，因为这些类拥有一个更简单、更强大的<code>API</code>。<br>&emsp;&emsp;<code>QFtp</code>支持异步工作，因此没有阻塞函数。如果无法立即执行操作，函数仍将立即返回，并且该操作将被操作系统调度，供以后执行。调度操作的结果通过信号报告，这种方法依赖于事件循环操作。可以调度的操作(也被称为<code>命令</code>)有<code>connectToHost</code>、<code>login</code>、<code>close</code>、<code>list</code>、<code>cd</code>、<code>get</code>、<code>put</code>、<code>remove</code>、<code>mkdir</code>、<code>rmdir</code>、<code>rename</code>和<code>rawCommand</code>。所有这些命令都会返回一个唯一的标识符，允许程序员跟踪当前正在执行的命令。当命令的执行开始时，发出带有命令标识符的<code>commandStarted</code>信号。当命令完成时，会发出<code>commandFinished</code>信号，并带有命令标识符和一个<code>bool</code>参数，表明该命令在完成时是否出错。<br>&emsp;&emsp;在某些情况下，可能想要执行一系列命令。例如连接并登录到<code>FTP</code>服务器，简单的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QFtp *ftp = <span class="keyword">new</span> QFtp ( parent );</span><br><span class="line">ftp-&gt;connectToHost ( <span class="string">"192.168.***.***"</span>, <span class="number">21</span> );</span><br><span class="line">ftp-&gt;login ( <span class="string">"wang"</span>, <span class="string">"123456"</span> );</span><br></pre></td></tr></table></figure>
<p>在这种情况下，调度了两个<code>FTP</code>命令。当最后一个调度命令完成时，会发出<code>done</code>信号，并带有一个<code>bool</code>参数，告诉你命令序列在完成时是否出错。<br>&emsp;&emsp;如果命令序列中的某个命令的执行期间发生错误，则所有挂起的命令(即已调度，但尚未执行的命令)会被清除，并且不为它们发射信号。一些命令(例如<code>list</code>)会发出额外的信号(<code>listInfo</code>)以报告其结果。<br>&emsp;&emsp;对于文件传输，<code>QFtp</code>可以使用主动或被动模式，并且默认使用被动文件传输模式，可使用<code>setTransferMode</code>设置。函数<code>hasPendingCommands</code>和<code>clearPendingCommands</code>允许查询和清除挂起的命令列表。如果你在网络编程方面比较有经验，可以使用<code>rawCommand</code>来执行任意的<code>FTP</code>命令。注意，当前版本的<code>QFtp</code>不完全支持非<code>Unix</code>的<code>FTP</code>服务器。<br>&emsp;&emsp;如果要从<code>FTP</code>服务器下载<code>/home/wang/ftp.qdoc</code>文件，可以分为下面几步：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ftp-&gt;connectToHost ( <span class="string">"192.168.***.***"</span>, <span class="number">21</span> );</span><br><span class="line">ftp-&gt;login ( <span class="string">"wang"</span>, <span class="string">"123456"</span> );</span><br><span class="line">ftp-&gt;cd ( <span class="string">"/home/wang"</span> );</span><br><span class="line">ftp-&gt;get ( <span class="string">"ftp.qdoc"</span> );</span><br><span class="line">ftp-&gt;close();</span><br></pre></td></tr></table></figure>
<p>流程如下：</p>
<ul>
<li><code>connectToHost</code>：指定主机和端口号，连接<code>FTP</code>服务器。</li>
<li><code>login</code>：指定用户名和密码，登录到<code>FTP</code>服务器。</li>
<li><code>cd</code>：改变服务器的当前工作目录。</li>
<li><code>get</code>：从服务器上下载文件<code>ftp.qdoc</code>(绝对路径为<code>/home/wang/ftp.qdoc</code>)。</li>
<li><code>close</code>：关闭到<code>FTP</code>服务器的连接。</li>
</ul>
<p>&emsp;&emsp;对于该示例，发射以下序列的信号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">commandStarted ( <span class="number">1</span> )</span><br><span class="line">stateChanged ( HostLookup )</span><br><span class="line">stateChanged ( Connecting )</span><br><span class="line">stateChanged ( Connected )</span><br><span class="line">commandFinished ( <span class="number">1</span>, <span class="literal">false</span> )</span><br><span class="line">​</span><br><span class="line">commandStarted ( <span class="number">2</span> )</span><br><span class="line">stateChanged ( LoggedIn )</span><br><span class="line">commandFinished ( <span class="number">2</span>, <span class="literal">false</span> )</span><br><span class="line">​</span><br><span class="line">commandStarted ( <span class="number">3</span> )</span><br><span class="line">commandFinished ( <span class="number">3</span>, <span class="literal">false</span> )</span><br><span class="line">​</span><br><span class="line">commandStarted ( <span class="number">4</span> )</span><br><span class="line">dataTransferProgress ( <span class="number">0</span>, <span class="number">8710</span> )</span><br><span class="line">dataTransferProgress ( <span class="number">8192</span>, <span class="number">8710</span> )</span><br><span class="line">readyRead()</span><br><span class="line">dataTransferProgress ( <span class="number">8710</span>, <span class="number">8710</span> )</span><br><span class="line">readyRead()</span><br><span class="line">commandFinished ( <span class="number">4</span>, <span class="literal">false</span> )</span><br><span class="line">​</span><br><span class="line">commandStarted ( <span class="number">5</span> )</span><br><span class="line">stateChanged ( Closing )</span><br><span class="line">stateChanged ( Unconnected )</span><br><span class="line">commandFinished ( <span class="number">5</span>, <span class="literal">false</span> )</span><br><span class="line">​</span><br><span class="line">done ( <span class="literal">false</span> )</span><br></pre></td></tr></table></figure>
<p>如果要显示进度条以通知用户下载进度，上述示例中的<code>dataTransferProgress</code>信号就会很有用。<code>readyRead</code>信号告诉你有数据准备好被读取，然后可以使用<code>bytesAvailable</code>函数查询数据量，并且可以使用<code>read</code>或<code>readAll</code>函数读取数据量。<br>&emsp;&emsp;如果上述示例登录失败(例如用户名或密码错误)，信号将如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">commandStarted ( <span class="number">1</span> )</span><br><span class="line">stateChanged ( HostLookup )</span><br><span class="line">stateChanged ( Connecting )</span><br><span class="line">stateChanged ( Connected )</span><br><span class="line">commandFinished ( <span class="number">1</span>, <span class="literal">false</span> )</span><br><span class="line">​</span><br><span class="line">commandStarted ( <span class="number">2</span> )</span><br><span class="line">commandFinished ( <span class="number">2</span>, <span class="literal">true</span> )</span><br><span class="line">​</span><br><span class="line">done ( <span class="literal">true</span> )</span><br></pre></td></tr></table></figure>
<p>然后可以使用<code>error</code>和<code>errorString</code>函数获取有关错误的详细信息。<br>&emsp;&emsp;在进行其他命令操作之前，先一起看看<code>doc</code>的树结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/wang/doc</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── c++</span><br><span class="line">│   └── qt5_cadaques.pdf</span><br><span class="line">├── hello.sh</span><br><span class="line">├── linux</span><br><span class="line">│   └── linux-program.pdf</span><br><span class="line">└── python</span><br><span class="line">    └── hello.py</span><br><span class="line">​</span><br><span class="line">3 directories, 4 files</span><br></pre></td></tr></table></figure>
<p>里面包含<code>3</code>个目录以及<code>4</code>个文件。<br>&emsp;&emsp;要列出<code>dir</code>目录的内容，可以使用<code>list</code>。如果<code>dir</code>为空，将列出当前目录的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QFtp::<span class="built_in">list</span> ( <span class="keyword">const</span> QString &amp;dir = QString() )</span><br></pre></td></tr></table></figure>
<p>对于找到的每个目录条目，都会发出<code>listInfo</code>信号。输出文件详细信息的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">connect ( ftp, &amp;QFtp::listInfo, [ = ] ( <span class="keyword">const</span> QUrlInfo &amp;urlInfo ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; urlInfo.name() &lt;&lt; urlInfo.size() &lt;&lt; urlInfo.owner() &lt;&lt; urlInfo.group() \</span><br><span class="line">             &lt;&lt; urlInfo.lastModified().toString ( <span class="string">"MMM dd yyyy"</span> ) &lt;&lt; urlInfo.isDir();</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">ftp-&gt;<span class="built_in">list</span>();</span><br></pre></td></tr></table></figure>
<p>这里只列出文件的一部分信息，其他更多信息请参考<code>QUrlInfo</code>。输出如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"c++"</span>      <span class="number">29</span> <span class="string">"1000"</span> <span class="string">"1000"</span> <span class="string">"十一月 28 2016"</span> <span class="literal">true</span></span><br><span class="line"><span class="string">"hello.sh"</span> <span class="number">55</span> <span class="string">"1000"</span> <span class="string">"1000"</span> <span class="string">"十月 20 2016"</span>   <span class="literal">false</span></span><br><span class="line"><span class="string">"Linux"</span>    <span class="number">30</span> <span class="string">"1000"</span> <span class="string">"1000"</span> <span class="string">"十一月 28 2016"</span> <span class="literal">true</span></span><br><span class="line"><span class="string">"Python"</span>   <span class="number">21</span> <span class="string">"1000"</span> <span class="string">"1000"</span> <span class="string">"十一月 28 2016"</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>可以和服务端比对一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">总用量 4</span><br><span class="line">drwxrwxr-x. 2 wang wang 29 11月 28 10:41 c++</span><br><span class="line">-rw-rw-r--. 1 wang wang 55 10月 20 15:59 hello.sh</span><br><span class="line">drwxrwxr-x. 2 wang wang 30 11月 28 10:40 linux</span><br><span class="line">drwxrwxr-x. 2 wang wang 21 11月 28 10:39 python</span><br></pre></td></tr></table></figure>
<p>要在服务器上创建一个名为<code>dir</code>的目录，使用<code>mkdir</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp-&gt;mkdir ( <span class="string">"new_dir"</span> );</span><br></pre></td></tr></table></figure>
<p><code>remove</code>是删除文件，<code>rmdir</code>则是删除目录。要从服务器中删除文件，使用<code>remove</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp-&gt;remove( <span class="string">"hello.sh"</span> );</span><br></pre></td></tr></table></figure>
<p>要从服务器中删除目录，使用<code>rmdir</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp-&gt;rmdir ( <span class="string">"new_dir"</span> ); <span class="comment">/* 删除空目录 */</span></span><br></pre></td></tr></table></figure>
<p>注意只能删除空目录，如果目录下有文件，则不能删除。<br>&emsp;&emsp;如果要对文件进行重命名，使用<code>rename</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp-&gt;rename(<span class="string">"c++"</span>, <span class="string">"c"</span>); <span class="comment">/* c++ -&gt; c */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关于上传文件，有两个重载的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QFtp::put ( QIODevice *dev, <span class="keyword">const</span> QString &amp;file, TransferType type = Binary );</span><br></pre></td></tr></table></figure>
<p>该函数从<code>IO</code>设备<code>dev</code>读取数据，并将其写入服务器上名为<code>file</code>的文件。从<code>IO</code>设备读取数据块，因此此重载允许传输大量数据，而无需立即将所有数据读入内存。注意确保<code>dev</code>指针在操作期间有效(在发出<code>commandFinished</code>时可以安全地删除它)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m_file = <span class="keyword">new</span> QFile ( <span class="string">"E:/Qt.zip"</span> );</span><br><span class="line">ftp-&gt;put ( m_file, <span class="string">"Qt.zip"</span> );</span><br></pre></td></tr></table></figure>
<p><code>put</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QFtp::put ( <span class="keyword">const</span> QByteArray &amp;data, <span class="keyword">const</span> QString &amp;file, TransferType type = Binary );</span><br></pre></td></tr></table></figure>
<p>该函数将给定数据的副本写入服务器上名为<code>file</code>的文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp-&gt;put ( <span class="string">"Hello World!\nI'am a Qter."</span>, <span class="string">"readMe.txt"</span> );</span><br></pre></td></tr></table></figure>
<p>上传完成后，去服务端查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">c  linux  python  readMe.txt</span><br><span class="line">$ cat readMe.txt</span><br><span class="line">Hello World!</span><br><span class="line">I<span class="string">'am a Qter.</span></span><br></pre></td></tr></table></figure>
<p>如果要获取上传的进度，可以关联<code>dataTransferProgress</code>信号。<br>&emsp;&emsp;要从服务器下载文件，使用<code>get</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QFtp::get ( <span class="keyword">const</span> QString &amp;file, QIODevice *dev = <span class="number">0</span>, TransferType type = Binary );</span><br></pre></td></tr></table></figure>
<p>如果<code>dev</code>为<code>0</code>，则当有可用的数据可读时，发出<code>readyRead</code>信号，然后可以使用<code>read</code>或<code>readAll</code>函数读取数据；如果<code>dev</code>不为<code>0</code>，则将数据直接写入设备<code>dev</code>。<br>&emsp;&emsp;如果想要在有可用的数据时向用户提供数据，请连接到<code>readyRead</code>信号并立即读取数据；如果只想使用完整的数据，则可以连接到<code>commandFinished</code>信号，并在<code>get</code>命令完成后读取数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">m_file = <span class="keyword">new</span> QFile ( <span class="string">"E:/Qt.zip"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( !m_file-&gt;open ( QIODevice::WriteOnly ) ) &#123;</span><br><span class="line">    m_file-&gt;remove();</span><br><span class="line">    <span class="keyword">delete</span> m_file;</span><br><span class="line">    m_file = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    ftp-&gt;get ( <span class="string">"Qt.zip"</span>, m_file ); <span class="comment">/* 下载文件 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当前的状态<code>QFtp::State</code>由<code>state</code>返回，当状态改变时，发出<code>stateChanged</code>信号，参数是连接的新状态。该信号通常用于<code>connectToHost</code>或者<code>close</code>命令，也可以<code>自发地</code>发射，例如当服务器意外关闭连接时。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QFtp::Unconnected</code></td>
<td><code>0</code></td>
<td>没有连接到主机</td>
</tr>
<tr>
<td><code>QFtp::HostLookup</code></td>
<td><code>1</code></td>
<td>正在进行主机名查找</td>
</tr>
<tr>
<td><code>QFtp::Connecting</code></td>
<td><code>2</code></td>
<td>正在尝试连接到主机</td>
</tr>
<tr>
<td><code>QFtp::Connected</code></td>
<td><code>3</code></td>
<td>已实现与主机的连接</td>
</tr>
<tr>
<td><code>QFtp::LoggedIn</code></td>
<td><code>4</code></td>
<td>已实现连接和用户登录</td>
</tr>
<tr>
<td><code>QFtp::Closing</code></td>
<td><code>5</code></td>
<td>连接正在关闭，但尚未关闭(当连接关闭时，状态将为<code>Unconnected</code>)</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;当连接<code>TCP</code>服务器的时候，使用一个<code>QLabel</code>显示连接的状态信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FtpWindow::stateChanged ( <span class="keyword">int</span> state ) &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( state ) &#123;</span><br><span class="line">        <span class="keyword">case</span> QFtp::Unconnected: &#123;</span><br><span class="line">                stateLabel-&gt;setText ( QStringLiteral ( <span class="string">"没有连接到主机"</span> ) );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> QFtp::HostLookup: &#123;</span><br><span class="line">                stateLabel-&gt;setText ( QStringLiteral ( <span class="string">"正在进行主机名查找"</span> ) );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> QFtp::Connecting: &#123;</span><br><span class="line">                stateLabel-&gt;setText ( QStringLiteral ( <span class="string">"正在尝试连接到主机"</span> ) );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> QFtp::Connected: &#123;</span><br><span class="line">                stateLabel-&gt;setText ( QStringLiteral ( <span class="string">"已实现与主机的连接"</span> ) );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> QFtp::LoggedIn: &#123;</span><br><span class="line">                stateLabel-&gt;setText ( QStringLiteral ( <span class="string">"已实现连接和用户登录"</span> ) );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> QFtp::Closing: &#123;</span><br><span class="line">                stateLabel-&gt;setText ( QStringLiteral ( <span class="string">"连接正在关闭•"</span> ) );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>currentId</code>和<code>currentCommand</code>提供了有关当前执行命令的信息。<code>currentCommand</code>返回当前<code>FTP</code>的命令类型<code>QFtp::Command</code>，如果没有命令正在执行，则返回<code>None</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QFtp::None</code></td>
<td><code>0</code></td>
<td>未执行任何命令</td>
</tr>
<tr>
<td><code>QFtp::SetTransferMode</code></td>
<td><code>1</code></td>
<td>设置传输模式</td>
</tr>
<tr>
<td><code>QFtp::SetProxy</code></td>
<td><code>2</code></td>
<td>切换代理打开或关闭</td>
</tr>
<tr>
<td><code>QFtp::ConnectToHost</code></td>
<td><code>3</code></td>
<td>正在执行<code>connectToHost</code></td>
</tr>
<tr>
<td><code>QFtp::Login</code></td>
<td><code>4</code></td>
<td>正在执行<code>login</code></td>
</tr>
<tr>
<td><code>QFtp::Close</code></td>
<td><code>5</code></td>
<td>正在执行<code>close</code></td>
</tr>
<tr>
<td><code>QFtp::List</code></td>
<td><code>6</code></td>
<td>正在执行<code>list</code></td>
</tr>
<tr>
<td><code>QFtp::Cd</code></td>
<td><code>7</code></td>
<td>正在执行<code>cd</code></td>
</tr>
<tr>
<td><code>QFtp::Get</code></td>
<td><code>8</code></td>
<td>正在执行<code>get</code></td>
</tr>
<tr>
<td><code>QFtp::Put</code></td>
<td><code>9</code></td>
<td>正在执行<code>put</code></td>
</tr>
<tr>
<td><code>QFtp::Remove</code></td>
<td><code>10</code></td>
<td>正在执行<code>remove</code></td>
</tr>
<tr>
<td><code>QFtp::Mkdir</code></td>
<td><code>11</code></td>
<td>正在执行<code>mkdir</code></td>
</tr>
<tr>
<td><code>QFtp::Rmdir</code></td>
<td><code>12</code></td>
<td>正在执行<code>rmdir</code></td>
</tr>
<tr>
<td><code>QFtp::Rename</code></td>
<td><code>13</code></td>
<td>正在执行<code>rename</code></td>
</tr>
<tr>
<td><code>QFtp::RawCommand</code></td>
<td><code>14</code></td>
<td>正在执行<code>rawCommand</code></td>
</tr>
</tbody>
</table>
</div>
<p>这允许你对特定命令执行特定操作，例如在FTP客户端中，可能需要在启动<code>list</code>命令时清除目录视图。在这种情况下，可以简单地检查连接到<code>commandStarted</code>信号的槽函数中的<code>currentCommand</code>是否为<code>List</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FtpWindow::commandStarted ( <span class="keyword">int</span> id ) &#123;</span><br><span class="line">    QFtp::Command command = ftp-&gt;currentCommand();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( command ) &#123;</span><br><span class="line">        <span class="keyword">case</span> QFtp::List: &#123; <span class="comment">/* 正在执行list：列出目录下的文件 */</span></span><br><span class="line">                fileListTree-&gt;clear(); <span class="comment">/* 清除目录视图QTreeWidget */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"commandStarted "</span> &lt;&lt; id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过<code>error</code>和<code>errorString</code>返回最后一次发生的错误。当接收到<code>commandFinished</code>或者<code>done</code>信号时，如果标识<code>error</code>的<code>bool</code>参数为<code>true</code>，这就非常有用了。<code>error</code>返回的是一个<code>QFtp::Error</code>枚举类型，用来标识发生的错误：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QFtp::NoError</code></td>
<td><code>0</code></td>
<td>没有发生错误</td>
</tr>
<tr>
<td><code>QFtp::HostNotFound</code></td>
<td><code>2</code></td>
<td>主机名查找失败</td>
</tr>
<tr>
<td><code>QFtp::ConnectionRefused</code></td>
<td><code>3</code></td>
<td>服务器拒绝连接</td>
</tr>
<tr>
<td><code>QFtp::NotConnected</code></td>
<td><code>4</code></td>
<td>尝试发送命令，但没有到服务器的连接</td>
</tr>
<tr>
<td><code>QFtp::UnknownError</code></td>
<td><code>1</code></td>
<td>除了以上指定的错误发生</td>
</tr>
</tbody>
</table>
</div>
<p>注意，如果启动一个新命令，错误的状态会被重置为<code>NoError</code>。<br>&emsp;&emsp;<code>errorString</code>返回的是一个人类可读的字符串。通常是(但不总是)来自服务器的回复，因此并不总是可以翻译成字符串。如果消息来自<code>Qt</code>，则字符串已经通过<code>tr</code>函数的处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FtpWindow::commandFinished ( <span class="keyword">int</span> id, <span class="keyword">bool</span> error ) &#123;</span><br><span class="line">    Q_UNUSED ( id );</span><br><span class="line">    QFtp::Command command = ftp-&gt;currentCommand();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( command ) &#123;</span><br><span class="line">        <span class="keyword">case</span> QFtp::ConnectToHost: &#123; <span class="comment">/* 连接FTP服务器 */</span></span><br><span class="line">                <span class="keyword">if</span> ( error ) &#123; <span class="comment">/* 发生错误 */</span></span><br><span class="line">                    qDebug() &lt;&lt; <span class="string">"Error "</span> &lt;&lt; ftp-&gt;error() &lt;&lt; <span class="string">"ErrorString "</span> &lt;&lt; ftp-&gt;errorString();</span><br><span class="line">                    QMessageBox::information (</span><br><span class="line">                        <span class="keyword">this</span>, <span class="string">"FTP"</span>,</span><br><span class="line">                        QStringLiteral ( <span class="string">"无法连接到FTP服务器，请检查主机名是否正确！"</span> ) );</span><br><span class="line">                    ftp-&gt;<span class="built_in">abort</span>();</span><br><span class="line">                    ftp-&gt;deleteLater();</span><br><span class="line">                    ftp = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    qDebug() &lt;&lt; QStringLiteral ( <span class="string">"登录FTP服务器"</span> );</span><br><span class="line">                &#125;</span><br><span class="line">​</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;设置文件传输模式是枚举变量<code>QFtp::TransferMode</code>。<code>FTP</code>使用两个套接字连接：一个用于命令，另一个用于发送数据。虽然命令连接始终由客户端发起，但第二个连接可以由客户端或服务器发起。此枚举定义客户端(被动模式)还是服务器(活动模式)应设置数据连接。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QFtp::Passive</code></td>
<td><code>1</code></td>
<td>客户端连接到服务器以传输其数据</td>
</tr>
<tr>
<td><code>QFtp::Active</code></td>
<td><code>0</code></td>
<td>服务器连接到客户端以传输其数据</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;设置数据传输类型是使用枚举变量<code>QFtp::TransferType</code>，此枚举标识使用<code>get</code>和<code>put</code>命令进行数据传输的类型。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QFtp::Binary</code></td>
<td><code>0</code></td>
<td>数据将以二进制模式传输</td>
</tr>
<tr>
<td><code>QFtp::Ascii</code></td>
<td><code>1</code></td>
<td>数据将以<code>ASCII</code>模式传输，换行符将转换为本地格式</td>
</tr>
</tbody>
</table>
</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/45/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/45/">45</a><span class="page-number current">46</span><a class="page-number" href="/page/47/">47</a><span class="space">&hellip;</span><a class="page-number" href="/page/94/">94</a><a class="extend next" rel="next" href="/page/47/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">939</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
