<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="泥腿子出身">
<meta property="og:url" content="http://fukangwei.gitee.io/page/46/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="泥腿子出身">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/46/">





  <title>泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/02/Linux应用笔记/配置SLIP链路/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/02/Linux应用笔记/配置SLIP链路/" itemprop="url">配置SLIP链路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-02T14:43:27+08:00">
                2019-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>SLIP</code>即<code>Serial Line IP</code>，它是一个数据链路层协议，用于在串行线路上传输<code>IP</code>数据报。本文讲述如何在两台用串口线(<code>RS232</code>)连接的<code>Linux</code>机器之间配置<code>SLIP</code>链路。设两台机器为<code>A</code>和<code>B</code>，首先将两台机器用串口线连接好，然后在<code>A</code>机器上依次运行如下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slattach /dev/ttyS0 -p slip -s 9600 -m -d &amp;</span><br><span class="line">ifconfig sl0 192.168.1.1 pointopoint 192.168.1.2 up</span><br><span class="line">route add default gw 192.168.1.2</span><br></pre></td></tr></table></figure>
<p>其中，<code>/dev/ttyS0</code>是第<code>1</code>个串口设备，如果有多个串口，则依次是<code>/dev/ttyS1</code>、<code>/dev/ttyS2</code>。<br>&emsp;&emsp;<code>slattach</code>的<code>-p</code>选项指定要使用的数据链路层协议，可以是<code>slip</code>、<code>cslip</code>、<code>ppp</code>等；<code>-s</code>指定传输速率，可以是<code>9600</code>、<code>115200</code>等；<code>-m</code>告诉串口设备不要工作在<code>RAW data</code>模式，而是要工作在协议驱动模式；<code>-d</code>输出调试信息。<code>ifconfig</code>可以配置串行接口的<code>ip</code>信息，<code>sl0</code>代表第一个串行接口，如果有更多，依次是<code>sl1</code>、<code>sl2</code>等。<code>route</code>将对方<code>ip</code>添加为默认网关。<br>&emsp;&emsp;然后在<code>B</code>机器上依次运行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slattach /dev/ttyS0 -p slip -s 9600 -m -d &amp;</span><br><span class="line">ifconfig sl0 192.168.1.2 pointopoint 192.168.1.1 up</span><br><span class="line">route add default gw 192.168.1.1</span><br></pre></td></tr></table></figure>
<p>指令和<code>A</code>一样，要注意的是<code>ip</code>地址要设置对。两边所用的协议、传输速率也要一样。<br>&emsp;&emsp;如果没有出错，连接就建立成功了，可以用在<code>A</code>或<code>B</code>上运行<code>ping 对方地址</code>来测试连接是否畅通。建立好<code>SLIP</code>链路后，就可以使用互联网套接字编程来进行二者之间的通信，而不必关心底层是串行线路还是以太网线。如果不配置此链路，则串口设备工作在<code>RAW data</code>模式，收、发的数据都是原始数据，不走协议栈，不进行<code>IP</code>等封装。<br>&emsp;&emsp;<strong>补充说明</strong>：我使用的是<code>USB</code>转串口，设备文件是<code>/dev/ttyUSB0</code>，第一条命令应该是<code>slattach -l /dev/ttyUSB0 -p slip -s 9600 -m -d &amp;</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/02/Linux应用笔记/开机自启动程序/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/02/Linux应用笔记/开机自启动程序/" itemprop="url">开机自启动程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-02T14:35:38+08:00">
                2019-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="mini2440开机自启动程序"><a href="#mini2440开机自启动程序" class="headerlink" title="mini2440开机自启动程序"></a>mini2440开机自启动程序</h3><p>&emsp;&emsp;需要修改文件<code>/etc/init.d/rcS</code>，在文件末尾添加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/xx  <span class="comment"># “xx”是可执行文件所在目录</span></span><br><span class="line">./pwm_arm</span><br></pre></td></tr></table></figure>
<h3 id="openwrt开机自启动程序"><a href="#openwrt开机自启动程序" class="headerlink" title="openwrt开机自启动程序"></a>openwrt开机自启动程序</h3><p>&emsp;&emsp;将开机后需要启动的命令填入<code>/etc/rc.d/rc.local</code>(或者<code>/etc/rc.local</code>)文件中，然后<code>reboot</code>即可。需要注意自启动程序和所需设备启动的顺序。</p>
<h3 id="树莓派开机启动Qt程序"><a href="#树莓派开机启动Qt程序" class="headerlink" title="树莓派开机启动Qt程序"></a>树莓派开机启动Qt程序</h3><p>&emsp;&emsp;在树莓派上用<code>Qt</code>进行图形界面开发，发现无法自动启动程序。网上都是讲解如何启动脚本的，但是脚本的启动与图形程序是不同的。树莓派开机启动流程是：<code>自动登录-&gt;自动启动窗口-&gt;自动运行用户程序</code>。脚本程序可以在自动启动窗口这一步之前运行，但用户程序是不行的。下面来看一下怎样启动用户程序：<br>&emsp;&emsp;进入当前用户<code>HOME</code>目录下的<code>.config</code>目录，这是一个隐藏目录，需用<code>ls -a</code>显示出来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.config</span><br></pre></td></tr></table></figure>
<p>建立一个名为<code>autostart</code>的子目录，并进入该目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir autostart</span><br><span class="line"><span class="built_in">cd</span> autostart</span><br></pre></td></tr></table></figure>
<p>生成一个<code>*.desktop</code>文件，例如<code>my.desktop</code>，然后输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Type=Application</span><br><span class="line">Exec=Path</span><br></pre></td></tr></table></figure>
<p>其中<code>Exec</code>的值就是要启动的程序名，最好是全路径的可执行文件名，然后重启即可。<br>&emsp;&emsp;上述方法的原理：系统执行<code>startx</code>后，<code>LXDE</code>窗口管理器会找到<code>~/.config/autostart</code>目录下所有的<code>.desktop</code>文件，并一一执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/02/Linux应用笔记/proc目录/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/02/Linux应用笔记/proc目录/" itemprop="url">proc目录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-02T14:06:54+08:00">
                2019-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>Linux</code>内核提供了一种通过<code>/proc</code>文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。<code>proc</code>文件系统是一个伪文件系统，它只存在于内存当中，不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。<br>&emsp;&emsp;用户和应用程序可以通过<code>proc</code>得到系统的信息，并可以改变内核的某些参数。由于系统的信息(例如<code>进程</code>)是动态改变的，所以用户或应用程序读取<code>proc</code>文件时，<code>proc</code>文件系统是动态从系统内核读出所需信息并提交的。下面列出的这些文件或子文件夹，并不是都是在你的系统中存在，这取决于你的内核配置和装载的模块。另外，在<code>/proc</code>下还有三个很重要的目录，即<code>net</code>、<code>scsi</code>和<code>sys</code>。<code>sys</code>目录是可写的，可以通过它来访问或修改内核的参数，而<code>net</code>和<code>scsi</code>则依赖于内核配置。如果系统不支持<code>scsi</code>，则<code>scsi</code>目录不存在。<br>&emsp;&emsp;除了以上介绍的这些，还有的是一些以数字命名的目录，它们是进程目录。系统中当前运行的每一个进程都有对应的一个目录在<code>/proc</code>下，以进程的<code>PID</code>号为目录名，它们是读取进程信息的接口。而<code>self</code>目录则是读取进程本身的信息接口，是一个<code>link</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/proc/buddyinfo</code></td>
<td>每个内存区中的每个<code>order</code>有多少块可用，和内存碎片问题有关</td>
</tr>
<tr>
<td><code>/proc/cmdline</code></td>
<td>启动时传递给<code>kernel</code>的参数信息</td>
</tr>
<tr>
<td><code>/proc/cpuinfo</code></td>
<td><code>cpu</code>信息</td>
</tr>
<tr>
<td><code>/proc/crypto</code></td>
<td>内核使用的所有已安装的加密密码及细节</td>
</tr>
<tr>
<td><code>/proc/devices</code></td>
<td>已经加载的设备并分类</td>
</tr>
<tr>
<td><code>/proc/dma</code></td>
<td>已注册使用的<code>ISA DMA</code>频道列表</td>
</tr>
<tr>
<td><code>/proc/execdomains</code></td>
<td><code>Linux</code>内核当前支持的<code>execution domains</code></td>
</tr>
<tr>
<td><code>/proc/fb</code></td>
<td>帧缓冲设备列表，包括数量和控制它的驱动</td>
</tr>
<tr>
<td><code>/proc/filesystems</code></td>
<td>内核当前支持的文件系统类型</td>
</tr>
<tr>
<td><code>/proc/interrupts</code></td>
<td><code>x86</code>架构中的每个<code>IRQ</code>中断数</td>
</tr>
<tr>
<td><code>/proc/iomem</code></td>
<td>每个物理设备当前在系统内存中的映射</td>
</tr>
<tr>
<td><code>/proc/ioports</code></td>
<td>一个设备的输入输出所使用的注册端口范围</td>
</tr>
<tr>
<td><code>/proc/kcore</code></td>
<td>代表系统的物理内存，存储为核心文件格式，里边显示的是字节数，等于<code>RAM</code>大小加上<code>4kb</code></td>
</tr>
<tr>
<td><code>/proc/kmsg</code></td>
<td>记录内核生成的信息，可以通过<code>/sbin/klogd</code>或<code>/bin/dmesg</code>来处理</td>
</tr>
<tr>
<td><code>/proc/loadavg</code></td>
<td>根据过去一段时间内<code>CPU</code>和<code>IO</code>的状态得出的负载状态，与<code>uptime</code>命令有关</td>
</tr>
<tr>
<td><code>/proc/locks</code></td>
<td>内核锁住的文件列表</td>
</tr>
<tr>
<td><code>/proc/mdstat</code></td>
<td>多硬盘，<code>RAID</code>配置信息(<code>md = multiple disks</code>)</td>
</tr>
<tr>
<td><code>/proc/meminfo</code></td>
<td><code>RAM</code>使用的相关信息</td>
</tr>
<tr>
<td><code>/proc/misc</code></td>
<td>其他的主要设备(设备号为<code>10</code>)上注册的驱动</td>
</tr>
<tr>
<td><code>/proc/modules</code></td>
<td>所有加载到内核的模块列表</td>
</tr>
<tr>
<td><code>/proc/mounts</code></td>
<td>系统中使用的所有挂载</td>
</tr>
<tr>
<td><code>/proc/mtrr</code></td>
<td>系统使用的<code>Memory Type Range Registers(MTRRs)</code></td>
</tr>
<tr>
<td><code>/proc/partitions</code></td>
<td>分区中的块分配信息</td>
</tr>
<tr>
<td><code>/proc/pci</code></td>
<td>系统中的<code>PCI</code>设备列表</td>
</tr>
<tr>
<td><code>/proc/slabinfo</code></td>
<td>系统中所有活动的<code>slab</code>缓存信息</td>
</tr>
<tr>
<td><code>/proc/stat</code></td>
<td>所有的<code>CPU</code>活动信息</td>
</tr>
<tr>
<td><code>/proc/uptime</code></td>
<td>系统已经运行了多久</td>
</tr>
<tr>
<td><code>/proc/swaps</code></td>
<td>交换空间的使用情况</td>
</tr>
<tr>
<td><code>/proc/version</code></td>
<td><code>Linux</code>内核版本和<code>gcc</code>版本</td>
</tr>
<tr>
<td><code>/proc/bus</code></td>
<td>系统总线(<code>Bus</code>)信息，例如<code>pci/usb</code></td>
</tr>
<tr>
<td><code>/proc/driver</code></td>
<td>驱动信息</td>
</tr>
<tr>
<td><code>/proc/fs</code></td>
<td>文件系统信息</td>
</tr>
<tr>
<td><code>/proc/ide</code></td>
<td><code>IDE</code>设备信息</td>
</tr>
<tr>
<td><code>/proc/irq</code></td>
<td>中断请求设备信息</td>
</tr>
<tr>
<td><code>/proc/net</code></td>
<td>网卡设备信息</td>
</tr>
<tr>
<td><code>/proc/scsi</code></td>
<td><code>scsi</code>设备信息</td>
</tr>
<tr>
<td><code>/proc/tty</code></td>
<td><code>tty</code>设备信息</td>
</tr>
<tr>
<td><code>/proc/net/dev</code></td>
<td>显示网络适配器及统计信息</td>
</tr>
<tr>
<td><code>/proc/vmstat</code></td>
<td>虚拟内存统计信息</td>
</tr>
<tr>
<td><code>/proc/vmcore</code></td>
<td>内核<code>panic</code>时的内存映像</td>
</tr>
<tr>
<td><code>/proc/diskstats</code></td>
<td>取得磁盘信息</td>
</tr>
<tr>
<td><code>/proc/schedstat</code></td>
<td><code>kernel</code>调度器的统计信息</td>
</tr>
<tr>
<td><code>/proc/zoneinfo</code></td>
<td>显示内存空间的统计信息，对分析虚拟内存行为很有用</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;以下是<code>/proc</code>目录中进程<code>N</code>的信息：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/proc/N</code></td>
<td><code>pid</code>为<code>N</code>的进程信息</td>
</tr>
<tr>
<td><code>/proc/N/cmdline</code></td>
<td>进程启动命令</td>
</tr>
<tr>
<td><code>/proc/N/cwd</code></td>
<td>链接到进程当前工作目录</td>
</tr>
<tr>
<td><code>/proc/N/environ</code></td>
<td>进程环境变量列表</td>
</tr>
<tr>
<td><code>/proc/N/exe</code></td>
<td>链接到进程的执行命令文件</td>
</tr>
<tr>
<td><code>/proc/N/fd</code></td>
<td>包含进程相关的所有的文件描述符</td>
</tr>
<tr>
<td><code>/proc/N/maps</code></td>
<td>与进程相关的内存映射信息</td>
</tr>
<tr>
<td><code>/proc/N/mem</code></td>
<td>指代进程持有的内存，不可读</td>
</tr>
<tr>
<td><code>/proc/N/root</code></td>
<td>链接到进程的根目录</td>
</tr>
<tr>
<td><code>/proc/N/stat</code></td>
<td>进程的状态</td>
</tr>
<tr>
<td><code>/proc/N/statm</code></td>
<td>进程使用的内存的状态</td>
</tr>
<tr>
<td><code>/proc/N/status</code></td>
<td>进程状态信息，比<code>stat</code>和<code>statm</code>更具可读性</td>
</tr>
<tr>
<td><code>/proc/self</code></td>
<td>链接到当前正在运行的进程</td>
</tr>
</tbody>
</table>
</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/02/Linux应用笔记/设置硬件时间和系统时间/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/02/Linux应用笔记/设置硬件时间和系统时间/" itemprop="url">设置硬件时间和系统时间</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-02T14:00:01+08:00">
                2019-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;在Linux系统中，设置正确的系统时间很重要，否则无法登陆网站和使用<code>Makefile</code>。设置系统时间后，要将该时间写入<code>BIOS</code>中，即设置硬件时间。这样，操作系统在重启后就不需对系统时间进行设置，只需要读取硬件时间即可。<br>&emsp;&emsp;<code>Linux</code>使用世界时间<code>GMT</code>和本地时间<code>Local Time</code>。世界时间是格林尼治时间，本地时间是用户所在时区与国际时间的差值。<code>Linux</code>与<code>Windows</code>相同之处是在每次启动时加载<code>BIOS</code>时间，在退出时把时间写回<code>BIOS</code>；不同之处是<code>Linux</code>把世界时间作为<code>BIOS</code>时间，而<code>Windows</code>直接把本地时间作为<code>BIOS</code>时间。在多操作系统环境下，这种不同的时间机制将使时间无法正确显示。解决的办法是编辑文件<code>/etc/default/rcS</code>，把<code>UTC=yes</code>改为<code>UTC=no</code>，然后再设置正确的本地时间。<br>&emsp;&emsp;查看系统时间使用<code>date</code>命令，设置系统时间也是使用该命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date -s 11/03/2009  <span class="comment"># 将系统日期设定成2009年11月3日</span></span><br><span class="line">date -s 17:55:55    <span class="comment"># 系统时间设定成下午5点55分55秒</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;使用<code>hwclock --show</code>命令可以直接查看硬件时间(该命令需要<code>root</code>权限)。如果要对其进行设置，则使用如下命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock --<span class="built_in">set</span> --date=<span class="string">"09/17/2003 13:26:00"</span>  # 设置时间为“<span class="number">2003</span>/<span class="number">09</span>/<span class="number">17</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">00</span>”</span><br></pre></td></tr></table></figure>
<p>通用的设置格式为<code>hwclock --set --date=&quot;月/日/年 时:分:秒&quot;</code>。常用的<code>hwclock</code>命令还有：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hwclock --systohc  <span class="comment"># 将系统时间写入硬件</span></span><br><span class="line">hwclock --hctosys  <span class="comment"># 将硬件时间写入系统时间</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/02/Qt语法详解/Qt之sqlite数据库/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/02/Qt语法详解/Qt之sqlite数据库/" itemprop="url">Qt之sqlite数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-02T12:45:15+08:00">
                2019-02-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;在使用数据库功能时，需要在<code>.pro</code>文件中增加语句<code>QT += sql</code>，同时在代码中增加头文件<code>QtSql</code>。<br>&emsp;&emsp;<code>QtSql</code>模块提供了与平台以及数据库种类无关的访问<code>SQL</code>数据库的接口，这个接口由利用<code>Qt</code>的模型视图结构将数据库与用户界面集成的一套类来支持。<code>QSqlDatabase</code>对象象征了数据库的关联。<code>Qt</code>使用驱动程序与各种数据库的应用编程接口进行通信。<code>Qt</code>包括如下驱动程序：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>驱动程序</th>
<th>数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QDB2</code></td>
<td><code>IBM DB2</code></td>
</tr>
<tr>
<td><code>QIBASE</code></td>
<td><code>Borland InterBase</code></td>
</tr>
<tr>
<td><code>QMYSQL</code></td>
<td><code>MySql</code></td>
</tr>
<tr>
<td><code>QOCI</code></td>
<td>甲骨文公司(<code>Oracle Call Interface</code>)</td>
</tr>
<tr>
<td><code>QODBC</code></td>
<td><code>ODBC</code>(包括微软公司的<code>QSL</code>服务)</td>
</tr>
<tr>
<td><code>QPSQL</code></td>
<td><code>PostgreSQL</code></td>
</tr>
<tr>
<td><code>QSQLITE</code></td>
<td><code>QSLite</code>第<code>3</code>版</td>
</tr>
<tr>
<td><code>QSQLITE2</code></td>
<td><code>QSLite</code>第<code>2</code>版</td>
</tr>
<tr>
<td><code>QTDS</code></td>
<td><code>Qybase</code>自适应服务器</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;由于授权的许可限制，<code>Qt</code>的开源版本无法提供所有的驱动程序。当配置<code>Qt</code>时，既可以选择<code>Qt</code>本身包含的<code>SQL</code>驱动程序，也可以以插件的形式建立驱动程序。如下是<code>Qt</code>使用<code>SQLite</code>的基本操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 添加数据库驱动、设置数据库名称、数据库登录用户名、密码 */</span></span><br><span class="line">QSqlDatabase database = QSqlDatabase::addDatabase ( <span class="string">"QSQLITE"</span> );</span><br><span class="line">database.setDatabaseName ( <span class="string">"database.db"</span> );</span><br><span class="line">database.setUserName ( <span class="string">"root"</span> );</span><br><span class="line">database.setPassword ( <span class="string">"123456"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( !database.open() ) &#123; <span class="comment">/* 打开数据库 */</span></span><br><span class="line">    qDebug() &lt;&lt; database.lastError();</span><br><span class="line">    qFatal ( <span class="string">"failed to connect."</span> ) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* QSqlQuery类提供执行和操作的SQL语句的方法。可以用来执行DML(数据操作语言)语句，</span></span><br><span class="line"><span class="comment">       如SELECT、INSERT、UPDATE、DELETE，以及DDL(数据定义语言)语句，</span></span><br><span class="line"><span class="comment">       例如“CREATE TABLE”。也可以用来执行那些不是标准的SQL的数据库特定的命令 */</span></span><br><span class="line">    QSqlQuery sql_query;</span><br><span class="line">    QString create_sql = <span class="string">"create table student (id int primary key, name varchar(30), age int)"</span>;</span><br><span class="line">    QString select_max_sql = <span class="string">"select max(id) from student"</span>;</span><br><span class="line">    QString insert_sql = <span class="string">"insert into student values (?, ?, ?)"</span>;</span><br><span class="line">    QString update_sql = <span class="string">"update student set name = :name where id = :id"</span>;</span><br><span class="line">    QString select_sql = <span class="string">"select id, name from student"</span>;</span><br><span class="line">    QString select_all_sql = <span class="string">"select * from student"</span>;</span><br><span class="line">    QString delete_sql = <span class="string">"delete from student where id = ?"</span>;</span><br><span class="line">    QString clear_sql = <span class="string">"delete from student"</span>;</span><br><span class="line">    sql_query.prepare ( create_sql );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !sql_query.exec() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"table created!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 查询最大id */</span></span><br><span class="line">    <span class="keyword">int</span> max_id = <span class="number">0</span>;</span><br><span class="line">    sql_query.prepare ( select_max_sql );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !sql_query.exec() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( sql_query.next() ) &#123;</span><br><span class="line">            max_id = sql_query.value ( <span class="number">0</span> ).toInt();</span><br><span class="line">            qDebug() &lt;&lt; QString ( <span class="string">"max id:%1"</span> ).arg ( max_id );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 插入数据 */</span></span><br><span class="line">    sql_query.prepare ( insert_sql );</span><br><span class="line">    sql_query.addBindValue ( max_id + <span class="number">1</span> );</span><br><span class="line">    sql_query.addBindValue ( <span class="string">"name"</span> );</span><br><span class="line">    sql_query.addBindValue ( <span class="number">25</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !sql_query.exec() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"inserted!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 更新数据 */</span></span><br><span class="line">    sql_query.prepare ( update_sql );</span><br><span class="line">    sql_query.bindValue ( <span class="string">":name"</span>, <span class="string">"Qt"</span> );</span><br><span class="line">    sql_query.bindValue ( <span class="string">":id"</span>, <span class="number">1</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !sql_query.exec() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"updated!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 查询部分数据 */</span></span><br><span class="line">    <span class="keyword">if</span> ( !sql_query.exec ( select_sql ) ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( sql_query.next() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = sql_query.value ( <span class="string">"id"</span> ).toInt();</span><br><span class="line">            QString name = sql_query.value ( <span class="string">"name"</span> ).toString();</span><br><span class="line">            qDebug() &lt;&lt; QString ( <span class="string">"id:%1    name:%2"</span> ).arg ( id ).arg ( name );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 查询所有数据 */</span></span><br><span class="line">    sql_query.prepare ( select_all_sql );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !sql_query.exec() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( sql_query.next() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = sql_query.value ( <span class="number">0</span> ).toInt();</span><br><span class="line">            QString name = sql_query.value ( <span class="number">1</span> ).toString();</span><br><span class="line">            <span class="keyword">int</span> age = sql_query.value ( <span class="number">2</span> ).toInt();</span><br><span class="line">            qDebug() &lt;&lt; QString ( <span class="string">"id:%1 name:%2 age:%3"</span> ).arg ( id ).arg ( name ).arg ( age );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 删除数据 */</span></span><br><span class="line">    sql_query.prepare ( delete_sql );</span><br><span class="line">    sql_query.addBindValue ( max_id );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !sql_query.exec() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"deleted!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 清空表 */</span></span><br><span class="line">    sql_query.prepare ( clear_sql );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !sql_query.exec() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; sql_query.lastError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"cleared"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">database.close(); <span class="comment">/* 关闭数据库 */</span></span><br><span class="line">QFile::remove ( <span class="string">"database.db"</span> ); <span class="comment">/* 删除数据库 */</span></span><br></pre></td></tr></table></figure>
<hr>
<p>&emsp;&emsp;<code>QSqlDatabase</code>类实现了数据库连接的操作，<code>QSqlQuery</code>类执行<code>SQL</code>语句，<code>QSqlRecord</code>类封装数据库所有记录。</p>
<h3 id="QSqlDatabase类"><a href="#QSqlDatabase类" class="headerlink" title="QSqlDatabase类"></a>QSqlDatabase类</h3><p>&emsp;&emsp;使用示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase db = QSqlDatabase::addDatabase ( <span class="string">"QOCI"</span> );</span><br><span class="line">db.setHostName ( <span class="string">"localhost"</span> ); <span class="comment">/* 数据库主机名 */</span></span><br><span class="line">db.setDatabaseName ( <span class="string">"scott"</span> ); <span class="comment">/* 数据库名 */</span></span><br><span class="line">db.setUserName ( <span class="string">"stott"</span> ); <span class="comment">/* 数据库用户名 */</span></span><br><span class="line">db.setPassword ( <span class="string">"tiger"</span> ); <span class="comment">/* 数据库密码 */</span></span><br><span class="line">db.open(); <span class="comment">/* 打开数据库连接 */</span></span><br><span class="line">db.close(); <span class="comment">/* 释放数据库连接 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;建立数据库文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase db = QSqlDatabase::addDatabase ( <span class="string">"QSQLITE"</span> );</span><br><span class="line">db.setDatabaseName ( <span class="string">"database.db"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( !db.open() ) &#123;</span><br><span class="line">    qDebug ( <span class="string">"数据库不能打开"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;建立数据库文件后，创建表并插入两条数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line"><span class="comment">/* id自动增加 */</span></span><br><span class="line">query.exec ( <span class="string">"create table student(id INTEGER PRIMARY KEY autoincrement, name nvarchar(20), age int)"</span> );</span><br><span class="line">query.exec ( <span class="string">"insert into student values(1, '小明', 14)"</span> );</span><br><span class="line">query.exec ( <span class="string">"insert into student values(2, '小王', 15)"</span> );</span><br></pre></td></tr></table></figure>
<h3 id="QSqlQuery类"><a href="#QSqlQuery类" class="headerlink" title="QSqlQuery类"></a>QSqlQuery类</h3><p>&emsp;&emsp;插入值到数据库操作有两种方法：</p>
<ul>
<li>直接用<code>SQL</code>语句插入(参照上面)。</li>
<li>利用预处理方式插入(<code>ORACLE</code>语法和<code>ODBC</code>语法)。适合插入多条记录，或者避免将值转换成字符串(即正确地转义)，调用<code>prepare</code>函数指定一个包含占位符的<code>query</code>，然后绑定要插入的值。</li>
</ul>
<p>&emsp;&emsp;<code>ORACLE</code>语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line"><span class="comment">/* 准备执行SQL查询 */</span></span><br><span class="line">query.prepare ( <span class="string">"INSERT INTO T_STUDENT (name, age) VALUES (:name, :age)"</span> );</span><br><span class="line">query.bindValue ( <span class="string">":name"</span>, <span class="string">"小王"</span> ); <span class="comment">/* 在绑定要插入的值 */</span></span><br><span class="line">query.bindValue ( <span class="string">":age"</span>, <span class="number">11</span> );</span><br><span class="line">query.exec();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>ODBC</code>语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line"><span class="comment">/* 准备执行SQL查询 */</span></span><br><span class="line">query.prepare ( <span class="string">"INSERT INTO T_STUDENT (name,age) VALUES (?,?)"</span> );</span><br><span class="line">query.addBindValue ( <span class="string">"小王"</span> ); <span class="comment">/* 在绑定要插入的值 */</span></span><br><span class="line">query.addBindValue ( <span class="number">11</span> );</span><br><span class="line">query.exec();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;批量插入到数据库中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line">query.prepare ( “insert into student values ( ?, ? ) ” );</span><br><span class="line">QVariantList names;</span><br><span class="line"><span class="comment">/* 如果要提交空串，用QVariant(QVariant::String)代替名字 */</span></span><br><span class="line">names &lt;&lt; <span class="string">"小王"</span> &lt;&lt; <span class="string">"小明"</span> &lt;&lt; <span class="string">"小张"</span> &lt;&lt; <span class="string">"小新"</span>;</span><br><span class="line">query.addBindValue ( names );</span><br><span class="line">QVariantList ages;</span><br><span class="line">ages &lt;&lt; <span class="number">11</span> &lt;&lt; <span class="number">13</span> &lt;&lt; <span class="number">12</span> &lt;&lt; <span class="number">11</span>;</span><br><span class="line">query.addBindValue ( ages );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( !query.execBatch() ) &#123; <span class="comment">/* 进行批处理，如果出错就输出错误 */</span></span><br><span class="line">    qDebug() &lt;&lt; query.lastError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;查询数据库操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line"><span class="comment">/* 查询的结果可能不止一条记录，所以我们称之为结果集 */</span></span><br><span class="line">query.exec ( <span class="string">"SELECT * FROM t_STUDENT"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( query.next() ) &#123;</span><br><span class="line">    <span class="comment">/* 取第i条记录第1个字段(从0开始计数)的结果 */</span></span><br><span class="line">    QString name = query.value ( <span class="number">0</span> ).toString();</span><br><span class="line">    <span class="comment">/* 取第i条记录第2个字段的结果 */</span></span><br><span class="line">    <span class="keyword">int</span> age = query.value ( <span class="number">1</span> ).toInt();</span><br><span class="line">    <span class="comment">/* 处理name、age变量数据 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>UPDATE</code>操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line">query.prepare ( <span class="string">"UPDATE employee SET salary = ? WHERE id = 1003"</span> );</span><br><span class="line">query.bindValue ( <span class="number">0</span>, <span class="number">70000</span> );</span><br><span class="line">query.exe();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>DELETE</code>操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line">query.exec ( <span class="string">"DELETE FROM employee WHERE id = 1007"</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>seek(int n)</code>：<code>query</code>指向结果集的第<code>n</code>条记录，指定当前的位置。</li>
<li><code>first()</code>：<code>query</code>指向结果集的第一条记录。</li>
<li><code>last()</code>：<code>query</code>指向结果集的最后一条记录。</li>
<li><code>next()</code>：<code>query</code>指向下一条记录，每执行一次该函数，便指向相邻的下一条记录。</li>
<li><code>previous()</code>：<code>query</code>指向上一条记录，每执行一次该函数，便指向相邻的上一条记录。</li>
<li><code>record()</code>：获得现在指向的记录。</li>
<li><code>value(int n)</code>：获得属性的值，其中<code>n</code>表示查询的第<code>n</code>个属性。</li>
<li><code>int rowNum = query.at()</code>：获取<code>query</code>所指向的记录在结果集中的编号。</li>
<li><code>int fieldNo = query.record().indexOf(&quot;name&quot;)</code>：返回<code>name</code>的列号。</li>
<li><code>int columnNum = query.record().count()</code>：获取每条记录中属性(即<code>列</code>)的个数。</li>
</ul>
<hr>
<p>&emsp;&emsp;在<code>Qt</code>上使用<code>SQLite</code>时，如果第二次使用<code>QSqlDatabase::addDatabase</code>方法，可能会出现错误<code>QSqlDatabasePrivate::addDatabase: duplicate connection name &#39;qt_sql_default_connection&#39;, old connection removed</code>。<br>&emsp;&emsp;解决方法：先判断一下这个默认的连接名是否存在，如果不存在，则使用<code>addDatabase</code>方法；如果存在，则使用<code>database</code>方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase db;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( QSqlDatabase::contains ( <span class="string">"qt_sql_default_connection"</span> ) ) &#123;</span><br><span class="line">    db = QSqlDatabase::database ( <span class="string">"qt_sql_default_connection"</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    db = QSqlDatabase::addDatabase ( <span class="string">"QSQLITE"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>&emsp;&emsp;使用<code>QSqlQuery</code>时，最好这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase db;</span><br><span class="line"><span class="function">QSqlQuery <span class="title">sql_query</span> <span class="params">( db )</span></span>;</span><br><span class="line">sql_query.prepare ( create_sql );</span><br></pre></td></tr></table></figure>
<p>否则可能会出现<code>Driver not loaded</code>的错误。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/02/Qt语法详解/Qt之QTextDocument/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/02/Qt语法详解/Qt之QTextDocument/" itemprop="url">Qt之QTextDocument</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-02T00:28:55+08:00">
                2019-02-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTextDocument</code> class holds formatted text that can be viewed and edited using a <code>QTextEdit</code>.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextDocument</code></td>
<td><code>QObject</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextDocument(QObject * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTextDocument(const QString &amp; text, QObject * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QTextDocument()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addResource(int type, const QUrl &amp; name, const QVariant &amp; resource)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>adjustSize()</code></td>
</tr>
<tr>
<td><code>QVector&lt;QTextFormat&gt;</code></td>
<td><code>allFormats() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>availableRedoSteps() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>availableUndoSteps() const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>blockCount() const</code></td>
</tr>
<tr>
<td><code>QChar</code></td>
<td><code>characterAt(int pos) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>characterCount() const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clearUndoRedoStacks(Stacks stacksToClear = UndoAndRedoStacks)</code></td>
</tr>
<tr>
<td><code>QTextDocument *</code></td>
<td><code>clone(QObject * parent = 0) const</code></td>
</tr>
<tr>
<td><code>Qt::CursorMoveStyle</code></td>
<td><code>defaultCursorMoveStyle() const</code></td>
</tr>
<tr>
<td><code>QFont</code></td>
<td><code>defaultFont() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>defaultStyleSheet() const</code></td>
</tr>
<tr>
<td><code>QTextOption</code></td>
<td><code>defaultTextOption() const</code></td>
</tr>
<tr>
<td><code>QAbstractTextDocumentLayout *</code></td>
<td><code>documentLayout() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>documentMargin() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>drawContents(QPainter * p, const QRectF &amp; rect = QRectF())</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>QTextCursor</code></td>
<td><code>find(const QString &amp; subString, const QTextCursor &amp; cursor, FindFlags options = 0) const</code></td>
</tr>
<tr>
<td><code>QTextCursor</code></td>
<td><code>find(const QRegExp &amp; expr, const QTextCursor &amp; cursor, FindFlags options = 0) const</code></td>
</tr>
<tr>
<td><code>QTextCursor</code></td>
<td><code>find(const QString &amp; subString, int position = 0, FindFlags options = 0) const</code></td>
</tr>
<tr>
<td><code>QTextCursor</code></td>
<td><code>find(const QRegExp &amp; expr, int position = 0, FindFlags options = 0) const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>findBlock(int pos) const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>findBlockByLineNumber(int lineNumber) const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>findBlockByNumber(int blockNumber) const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>firstBlock() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>idealWidth() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>indentWidth() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isModified() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isRedoAvailable() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isUndoAvailable() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isUndoRedoEnabled() const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>lastBlock() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lineCount() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>markContentsDirty(int position, int length)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>maximumBlockCount() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>metaInformation(MetaInformation info) const</code></td>
</tr>
<tr>
<td><code>QTextObject *</code></td>
<td><code>object(int objectIndex) const</code></td>
</tr>
<tr>
<td><code>QTextObject *</code></td>
<td><code>objectForFormat(const QTextFormat &amp; f) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>pageCount() const</code></td>
</tr>
<tr>
<td><code>QSizeF</code></td>
<td><code>pageSize() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>print(QPrinter * printer) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>redo(QTextCursor * cursor)</code></td>
</tr>
<tr>
<td><code>QVariant</code></td>
<td><code>resource(int type, const QUrl &amp; name) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>revision() const</code></td>
</tr>
<tr>
<td><code>QTextFrame *</code></td>
<td><code>rootFrame() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDefaultCursorMoveStyle(Qt::CursorMoveStyle style)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDefaultFont(const QFont &amp; font)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDefaultStyleSheet(const QString &amp; sheet)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDefaultTextOption(const QTextOption &amp; option)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDocumentLayout(QAbstractTextDocumentLayout * layout)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDocumentMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHtml(const QString &amp; html)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setIndentWidth(qreal width)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMaximumBlockCount(int maximum)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMetaInformation(MetaInformation info, const QString &amp; string)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPageSize(const QSizeF &amp; size)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPlainText(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTextWidth(qreal width)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUndoRedoEnabled(bool enable)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUseDesignMetrics(bool b)</code></td>
</tr>
<tr>
<td><code>QSizeF</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>textWidth() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>toHtml(const QByteArray &amp; encoding = QByteArray()) const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>toPlainText() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>undo(QTextCursor * cursor)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>useDesignMetrics() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Slots"><a href="#Public-Slots" class="headerlink" title="Public Slots"></a>Public Slots</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>redo()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setModified(bool m = true)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>undo()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>blockCountChanged(int newBlockCount)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>contentsChange(int position, int charsRemoved, int charsAdded)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>contentsChanged()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>cursorPositionChanged(const QTextCursor &amp; cursor)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>documentLayoutChanged()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>modificationChanged(bool changed)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>redoAvailable(bool available)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>undoAvailable(bool available)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>undoCommandAdded()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Retrun</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual QTextObject *</code></td>
<td><code>createObject(const QTextFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>virtual QVariant</code></td>
<td><code>loadResource(int type, const QUrl &amp; name)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextDocument</code> class holds formatted text that can be viewed and edited using a <code>QTextEdit</code>.<br>&emsp;&emsp;<code>QTextDocument</code> is a container for structured rich text documents, providing support for styled text and various types of document elements, such as lists, tables, frames, and images. They can be created for use in a <code>QTextEdit</code>, or used independently.<br>&emsp;&emsp;Each document element is described by an associated format object. Each format object is treated as a unique object by <code>QTextDocuments</code>, and can be passed to <code>objectForFormat()</code> to obtain the document element that it is applied to.<br>&emsp;&emsp;A <code>QTextDocument</code> can be edited programmatically using a <code>QTextCursor</code>, and its contents can be examined by traversing the document structure. The entire document structure is stored as a hierarchy of document elements beneath the root frame, found with the <code>rootFrame()</code> function. Alternatively, if you just want to iterate over the textual contents of the document you can use <code>begin()</code>, <code>end()</code> and <code>findBlock()</code> to retrieve text blocks that you can examine and iterate over.<br>&emsp;&emsp;The layout of a document is determined by the <code>documentLayout()</code>; you can create your own <code>QAbstractTextDocumentLayout</code> subclass and set it using <code>setDocumentLayout()</code> if you want to use your own layout logic. The document’s title and other <code>meta-information</code> can be obtained by calling the <code>metaInformation()</code> function. For documents that are exposed to users through the <code>QTextEdit</code> class, the document title is also available via the <code>QTextEdit::documentTitle()</code> function.<br>&emsp;&emsp;The <code>toPlainText()</code> and <code>toHtml()</code> convenience functions allow you to retrieve the contents of the document as <code>plain text</code> and <code>HTML</code>. The document’s text can be searched using the <code>find()</code> functions.<br>&emsp;&emsp;Undo/redo of operations performed on the document can be controlled using the <code>setUndoRedoEnabled()</code> function. The undo/redo system can be controlled by an editor widget through the <code>undo()</code> and <code>redo()</code> slots; the document also provides <code>contentsChanged()</code>, <code>undoAvailable()</code> and <code>redoAvailable()</code> signals that inform connected editor widgets about the state of the undo/redo system. The following are the undo/redo operations of a <code>QTextDocument</code>:</p>
<ul>
<li>Insertion or removal of characters. A sequence of insertions or removals within the same text block are regarded as a single undo/redo operation.</li>
<li>Insertion or removal of text blocks. Sequences of insertion or removals in a single operation (e.g., by selecting and then deleting text) are regarded as a single undo/redo operation.</li>
<li>Text character format changes.</li>
<li>Text block format changes.</li>
<li>Text block group format changes.</li>
</ul>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QTextDocument::FindFlag &amp; flags QTextDocument::FindFlags</code>: This enum describes the options available to <code>QTextDocument&#39;s</code> find function. The options can be <code>OR-ed</code> together from the following list:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextDocument::FindBackward</code></td>
<td><code>0x00001</code></td>
<td>Search backwards instead of forwards.</td>
</tr>
<tr>
<td><code>QTextDocument::FindCaseSensitively</code></td>
<td><code>0x00002</code></td>
<td>By default find works case insensitive. Specifying this option changes the behaviour to a case sensitive find operation.</td>
</tr>
<tr>
<td><code>QTextDocument::FindWholeWords</code></td>
<td><code>0x00004</code></td>
<td>Makes find match only complete words.</td>
</tr>
</tbody>
</table>
</div>
<p>The FindFlags type is a typedef for <code>QFlags&lt;FindFlag&gt;</code>. It stores an <code>OR</code> combination of <code>FindFlag</code> values.</p>
<ul>
<li>enum <code>QTextDocument::MetaInformation</code>: This enum describes the different types of meta information that can be added to a document.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextDocument::DocumentTitle</code></td>
<td><code>0</code></td>
<td>The title of the document.</td>
</tr>
<tr>
<td><code>QTextDocument::DocumentUrl</code></td>
<td><code>1</code></td>
<td>The url of the document. The <code>loadResource()</code> function uses this url as the base when loading relative resources.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QTextDocument::ResourceType</code>: This enum describes the types of resources that can be loaded by <code>QTextDocument&#39;s</code> <code>loadResource()</code> function.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextDocument::HtmlResource</code></td>
<td><code>1</code></td>
<td>The resource contains <code>HTML</code>.</td>
</tr>
<tr>
<td><code>QTextDocument::ImageResource</code></td>
<td><code>2</code></td>
<td>The resource contains image data. Currently supported data types are <code>QVariant::Pixmap</code> and <code>QVariant::Image</code>. If the corresponding variant is of type <code>QVariant::ByteArray</code> then Qt attempts to load the image using <code>QImage::loadFromData</code>. <code>QVariant::Icon</code> is currently not supported. The icon needs to be converted to one of the supported types first, for example using <code>QIcon::pixmap</code>.</td>
</tr>
<tr>
<td><code>QTextDocument::StyleSheetResource</code></td>
<td><code>3</code></td>
<td>The resource contains <code>CSS</code>.</td>
</tr>
<tr>
<td><code>QTextDocument::UserResource</code></td>
<td><code>100</code></td>
<td>The first available value for user defined resource types.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QTextDocument::Stacks</code>:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextDocument::UndoStack</code></td>
<td><code>0x01</code></td>
<td>The undo stack.</td>
</tr>
<tr>
<td><code>QTextDocument::RedoStack</code></td>
<td><code>0x02</code></td>
<td>The redo stack.</td>
</tr>
<tr>
<td><code>QTextDocument::UndoAndRedoStacks</code></td>
<td><code>UndoStack &#124; RedoStack</code></td>
<td>Both the undo and redo stacks.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Property-Documentation"><a href="#Property-Documentation" class="headerlink" title="Property Documentation"></a>Property Documentation</h3><ul>
<li><code>blockCount(const int)</code>: Returns the number of text blocks in the document. The value of this property is undefined in documents with tables or frames. By default, if defined, this property contains a value of <code>1</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">blockCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>defaultFont(QFont)</code>: This property holds the default font used to display the document’s text. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFont <span class="title">defaultFont</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDefaultFont</span> <span class="params">( <span class="keyword">const</span> QFont &amp;font )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>defaultStyleSheet(QString)</code>: The default style sheet is applied to all newly <code>HTML</code> formatted text that is inserted into the document, for example using <code>setHtml()</code> or <code>QTextCursor::insertHtml()</code>. The style sheet needs to be compliant to <code>CSS 2.1</code> syntax. <strong>Note</strong>: Changing the default style sheet does not have any effect to the existing content of the document. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">defaultStyleSheet</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDefaultStyleSheet</span> <span class="params">( <span class="keyword">const</span> QString &amp;sheet )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>defaultTextOption(QTextOption)</code>: This property holds the default text option will be set on all <code>QTextLayouts</code> in the document. When <code>QTextBlocks</code> are created, the <code>defaultTextOption</code> is set on their <code>QTextLayout</code>. This allows setting global properties for the document such as the default word wrap mode. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTextOption <span class="title">defaultTextOption</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDefaultTextOption</span> <span class="params">( <span class="keyword">const</span> QTextOption &amp;option )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>documentMargin(qreal)</code>: The margin around the document. The default is <code>4</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">qreal <span class="title">documentMargin</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDocumentMargin</span> <span class="params">( qreal margin )</span></span></span><br></pre></td></tr></table></figure>
<p><code>indentWidth(qreal)</code>: Returns the width used for text list and text block indenting. The indent properties of <code>QTextListFormat</code> and <code>QTextBlockFormat</code> specify multiples of this value. The default indent width is <code>40</code>. Access functions:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">qreal <span class="title">indentWidth</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIndentWidth</span> <span class="params">( qreal width )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>maximumBlockCount(int)</code>: This property specifies the limit for blocks in the document. Specifies the maximum number of blocks the document may have. If there are more blocks in the document that specified with this property blocks are removed from the beginning of the document. A negative or zero value specifies that the document may contain an unlimited amount of blocks. The default value is <code>0</code>. Note that setting this property will apply the limit immediately to the document contents. Setting this property also disables the undo redo history. This property is undefined in documents with tables or frames. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumBlockCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMaximumBlockCount</span> <span class="params">( <span class="keyword">int</span> maximum )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>modified(bool)</code>: This property holds whether the document has been modified by the user. By default, this property is <code>false</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isModified</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setModified</span> <span class="params">( <span class="keyword">bool</span> m = <span class="literal">true</span> )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>pageSize(QSizeF)</code>: This property holds the page size that should be used for laying out the document. By default, for a <code>newly-created</code>, empty document, this property contains an undefined size. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QSizeF <span class="title">pageSize</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPageSize</span><span class="params">(<span class="keyword">const</span> QSizeF &amp; size)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>size(const QSizeF)</code>: Returns the actual size of the document. This is equivalent to <code>documentLayout()-&gt;documentSize()</code>; The size of the document can be changed either by setting a text width or setting an entire page size. Note that the width is always <code>&gt;= pageSize().width()</code>. By default, for a <code>newly-created</code>, empty document, this property contains a <code>configuration-dependent</code> size. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QSizeF <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>textWidth(qreal)</code>: The text width specifies the preferred width for text in the document. If the text (or content in general) is wider than the specified with it is broken into multiple lines and grows vertically. If the text cannot be broken into multiple lines to fit into the specified text width it will be larger and the <code>size()</code> and the <code>idealWidth()</code> property will reflect that. If the text width is set to <code>-1</code> then the text will not be broken into multiple lines unless it is enforced through an explicit line break or a new paragraph. The default value is <code>-1</code>. Setting the text width will also set the page height to <code>-1</code>, causing the document to grow or shrink vertically in a continuous way. If you want the document layout to break the text into multiple pages then you have to set the pageSize property instead. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">qreal <span class="title">textWidth</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTextWidth</span> <span class="params">( qreal width )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>undoRedoEnabled(bool)</code>: This property holds whether undo/redo are enabled for this document. This defaults to <code>true</code>. If disabled, the undo stack is cleared and no items will be added to it. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUndoRedoEnabled</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setUndoRedoEnabled</span> <span class="params">( <span class="keyword">bool</span> enable )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>useDesignMetrics(bool)</code>: This property holds whether the document uses design metrics of fonts to improve the accuracy of text layout. If this property is set to <code>true</code>, the layout will use design metrics. Otherwise, the metrics of the paint device as set on <code>QAbstractTextDocumentLayout::setPaintDevice()</code> will be used. Using design metrics makes a layout have a width that is no longer dependent on hinting and <code>pixel-rounding</code>. This means that <code>WYSIWYG</code> text layout becomes possible because the width scales much more linearly based on paintdevice metrics than it would otherwise. By default, this property is <code>false</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">useDesignMetrics</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setUseDesignMetrics</span> <span class="params">( <span class="keyword">bool</span> b )</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextDocument::QTextDocument(QObject * parent = 0)</code>: Constructs an empty <code>QTextDocument</code> with the given <code>parent</code>.</li>
<li><code>QTextDocument::QTextDocument(const QString &amp; text, QObject * parent = 0)</code>: Constructs a <code>QTextDocument</code> containing the plain (unformatted) <code>text</code> specified, and with the given <code>parent</code>.</li>
<li><code>QTextDocument::~QTextDocument()</code>: Destroys the document.</li>
<li><code>void QTextDocument::addResource(int type, const QUrl &amp; name, const QVariant &amp; resource)</code>: Adds the <code>resource</code> to the resource cache, using <code>type</code> and <code>name</code> as identifiers. <code>type</code> should be a value from <code>QTextDocument::ResourceType</code>. For example, you can add an image as a resource in order to reference it from within the document:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document-&gt;addResource ( QTextDocument::ImageResource, QUrl ( <span class="string">"mydata://image.png"</span> ), QVariant ( image ) );</span><br></pre></td></tr></table></figure>
<p>The image can be inserted into the document using the <code>QTextCursor</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QTextImageFormat imageFormat;</span><br><span class="line">imageFormat.setName ( <span class="string">"mydata://image.png"</span> );</span><br><span class="line">cursor.insertImage ( imageFormat );</span><br></pre></td></tr></table></figure>
<p>Alternatively, you can insert images using the <code>HTML</code> img tag:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">editor-&gt;append ( <span class="string">"&lt;img src=\"mydata://image.png\" /&gt;"</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QTextDocument::adjustSize()</code>: Adjusts the document to a reasonable size.</li>
<li><code>QVector&lt;QTextFormat&gt; QTextDocument::allFormats() const</code>: Returns a vector of text formats for all the formats used in the document.</li>
<li><code>int QTextDocument::availableRedoSteps() const</code>: Returns the number of available redo steps.</li>
<li><code>int QTextDocument::availableUndoSteps() const</code>: Returns the number of available undo steps.</li>
<li><code>QTextBlock QTextDocument::begin() const</code>: Returns the document’s first text block.</li>
<li><code>void QTextDocument::blockCountChanged(int newBlockCount) [signal]</code>: This signal is emitted when the total number of text blocks in the document changes. The value passed in <code>newBlockCount</code> is the new total.</li>
<li><code>QChar QTextDocument::characterAt(int pos) const</code>: Returns the character at position <code>pos</code>, or a null character if the position is out of range.</li>
<li><code>int QTextDocument::characterCount() const</code>: Returns the number of characters of this document.</li>
<li><code>void QTextDocument::clear() [virtual]</code>: Clears the document.</li>
<li><code>void QTextDocument::clearUndoRedoStacks(Stacks stacksToClear = UndoAndRedoStacks)</code>: Clears the stacks specified by <code>stacksToClear</code>. This method clears any commands on the undo stack, the redo stack, or both (the default). If commands are cleared, the appropriate signals are emitted, <code>QTextDocument::undoAvailable()</code> or <code>QTextDocument::redoAvailable()</code>.</li>
<li><code>QTextDocument * QTextDocument::clone(QObject * parent = 0) const</code>: Creates a new QTextDocument that is a copy of this text document. <code>parent</code> is the parent of the returned text document.</li>
<li><code>void QTextDocument::contentsChange(int position, int charsRemoved, int charsAdded) [signal]</code>: This signal is emitted whenever the document’s content changes; for example, when text is inserted or deleted, or when formatting is applied. Information is provided about the <code>position</code> of the character in the document where the change occurred, the number of characters removed (<code>charsRemoved</code>), and the number of characters added (<code>charsAdded</code>). The signal is emitted before the document’s layout manager is notified about the change. This hook allows you to implement syntax highlighting for the document.</li>
<li><code>void QTextDocument::contentsChanged() [signal]</code>: This signal is emitted whenever the document’s content changes; for example, when text is inserted or deleted, or when formatting is applied.</li>
<li><code>QTextObject * QTextDocument::createObject(const QTextFormat &amp; format) [virtual protected]</code>: Creates and returns a new document object (a <code>QTextObject</code>), based on the given <code>format</code>. <code>QTextObjects</code> will always get created through this method, so you must reimplement it if you use custom text objects inside your document.</li>
<li><code>void QTextDocument::cursorPositionChanged(const QTextCursor &amp; cursor) [signal]</code>: This signal is emitted whenever the position of a cursor changed due to an editing operation. The cursor that changed is passed in <code>cursor</code>. If you need a signal when the cursor is moved with the arrow keys, you can use the <code>cursorPositionChanged()</code> signal in <code>QTextEdit</code>.</li>
<li><code>Qt::CursorMoveStyle QTextDocument::defaultCursorMoveStyle() const</code>: The default cursor movement style is used by all <code>QTextCursor</code> objects created from the document. The default is <code>Qt::LogicalMoveStyle</code>.</li>
<li><code>QAbstractTextDocumentLayout * QTextDocument::documentLayout() const</code>: Returns the document layout for this document.</li>
<li><code>void QTextDocument::documentLayoutChanged() [signal]</code>: This signal is emitted when a new document layout is set.</li>
<li><code>void QTextDocument::drawContents(QPainter * p, const QRectF &amp; rect = QRectF())</code>: Draws the content of the document with painter <code>p</code>, clipped to <code>rect</code>. If <code>rect</code> is a null rectangle (default), then the document is painted unclipped.</li>
<li><code>QTextBlock QTextDocument::end() const</code>: This function returns a block to test for the end of the document while iterating over it.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( QTextBlock it = doc-&gt;begin(); it != doc-&gt;end(); it = it.next() ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it.text().toStdString() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The block returned is invalid and represents the block after the last block in the document. You can use <code>lastBlock()</code> to retrieve the last valid block of the document.</p>
<ul>
<li><code>QTextCursor QTextDocument::find(const QString &amp; subString, const QTextCursor &amp; cursor, FindFlags options = 0) const</code>: Finds the next occurrence of the string, <code>subString</code>, in the document. The search starts at the position of the given <code>cursor</code>, and proceeds forwards through the document unless specified otherwise in the search options. The <code>options</code> control the type of search performed. Returns a cursor with the match selected if <code>subString</code> was found; otherwise returns a null cursor. If the given <code>cursor</code> has a selection, the search begins after the selection; otherwise it begins at the cursor’s position. By default the search is <code>case-sensitive</code>, and can match text anywhere in the document.</li>
<li><code>QTextCursor QTextDocument::find(const QRegExp &amp; expr, const QTextCursor &amp; cursor, FindFlags options = 0) const</code>: Finds the next occurrence, matching the regular expression, <code>expr</code>, in the document. The search starts at the position of the given <code>cursor</code>, and proceeds forwards through the document unless specified otherwise in the search options. The <code>options</code> control the type of search performed. The <code>FindCaseSensitively</code> option is ignored for this overload, use <code>QRegExp::caseSensitivity</code> instead. Returns a cursor with the match selected if a match was found; otherwise returns a null cursor. If the given <code>cursor</code> has a selection, the search begins after the selection; otherwise it begins at the cursor’s position. By default the search is <code>case-sensitive</code>, and can match text anywhere in the document.</li>
<li><code>QTextCursor QTextDocument::find(const QString &amp; subString, int position = 0, FindFlags options = 0) const</code>: This is an overloaded function. Finds the next occurrence of the string, <code>subString</code>, in the document. The search starts at the given <code>position</code>, and proceeds forwards through the document unless specified otherwise in the search options. The <code>options</code> control the type of search performed. Returns a cursor with the match selected if <code>subString</code> was found; otherwise returns a null cursor. If the <code>position</code> is <code>0</code> (the default), the search begins from the beginning of the document; otherwise it begins at the specified <code>position</code>.</li>
<li><code>QTextCursor QTextDocument::find(const QRegExp &amp; expr, int position = 0, FindFlags options = 0) const</code>: This is an overloaded function. Finds the next occurrence, matching the regular expression, <code>expr</code>, in the document. The search starts at the given <code>position</code>, and proceeds forwards through the document unless specified otherwise in the search options. The <code>options</code> control the type of search performed. The <code>FindCaseSensitively</code> option is ignored for this overload, use <code>QRegExp::caseSensitivity</code> instead. Returns a cursor with the match selected if a match was found; otherwise returns a null cursor. If the <code>position</code> is <code>0</code> (the default) the search begins from the beginning of the document; otherwise it begins at the specified <code>position</code>.</li>
<li><code>QTextBlock QTextDocument::findBlock(int pos) const</code>: Returns the text block that contains the <code>pos-th</code> character.</li>
<li><code>QTextBlock QTextDocument::findBlockByLineNumber(int lineNumber) const</code>: Returns the text block that contains the specified <code>lineNumber</code>.</li>
<li><code>QTextBlock QTextDocument::findBlockByNumber(int blockNumber) const</code>: Returns the text block with the specified <code>blockNumber</code>.</li>
<li><code>QTextBlock QTextDocument::firstBlock() const</code>: Returns the document’s first text block.</li>
<li><code>qreal QTextDocument::idealWidth() const</code>: Returns the ideal width of the text document. The ideal width is the actually used width of the document without optional alignments taken into account. It is always <code>&lt;= size().width()</code>.</li>
<li><code>bool QTextDocument::isEmpty() const</code>: Returns <code>true</code> if the document is empty; otherwise returns <code>false</code>.</li>
<li><code>bool QTextDocument::isRedoAvailable() const</code>: Returns <code>true</code> if redo is available; otherwise returns <code>false</code>.</li>
<li><code>bool QTextDocument::isUndoAvailable() const</code>: Returns <code>true</code> if undo is available; otherwise returns <code>false</code>.</li>
<li><code>QTextBlock QTextDocument::lastBlock() const</code>: Returns the document’s last (valid) text block.</li>
<li><code>int QTextDocument::lineCount() const</code>: Returns the number of lines of this document (if the layout supports this). Otherwise, this is identical to the number of blocks.</li>
<li><code>QVariant QTextDocument::loadResource(int type, const QUrl &amp; name) [virtual protected]</code>: Loads data of the specified <code>type</code> from the resource with the given <code>name</code>. This function is called by the rich text engine to request data that isn’t directly stored by <code>QTextDocument</code>, but still associated with it. For example, images are referenced indirectly by the name attribute of a <code>QTextImageFormat</code> object. When called by <code>Qt</code>, <code>type</code> is one of the values of <code>QTextDocument::ResourceType</code>. If the <code>QTextDocument</code> is a child object of a <code>QTextEdit</code>, <code>QTextBrowser</code>, or a <code>QTextDocument</code> itself then the default implementation tries to retrieve the data from the parent.</li>
<li><code>void QTextDocument::markContentsDirty(int position, int length)</code>: Marks the contents specified by the given <code>position</code> and <code>length</code> as <code>dirty</code>, informing the document that it needs to be laid out again.</li>
<li><code>QString QTextDocument::metaInformation(MetaInformation info) const</code>: Returns meta information about the document of the type specified by <code>info</code>.</li>
<li><code>void QTextDocument::modificationChanged(bool changed) [signal]</code>: This signal is emitted whenever the content of the document changes in a way that affects the modification state. If <code>changed</code> is <code>true</code>, the document has been modified; otherwise it is <code>false</code>. For example, calling <code>setModified(false)</code> on a document and then inserting text causes the signal to get emitted. If you undo that operation, causing the document to return to its original unmodified state, the signal will get emitted again.</li>
<li><code>QTextObject * QTextDocument::object(int objectIndex) const</code>: Returns the text object associated with the given <code>objectIndex</code>.</li>
<li><code>QTextObject * QTextDocument::objectForFormat(const QTextFormat &amp; f) const</code>: Returns the text object associated with the format <code>f</code>.</li>
<li><code>int QTextDocument::pageCount() const</code>: Returns the number of pages in this document.</li>
<li><code>void QTextDocument::print(QPrinter * printer) const</code>: Prints the document to the given <code>printer</code>. The <code>QPrinter</code> must be set up before being used with this function. This is only a convenience method to print the whole document to the printer. If the document is already paginated through a specified height in the <code>pageSize()</code> property it is printed <code>as-is</code>. If the document is not paginated, like for example a document used in a <code>QTextEdit</code>, then a temporary copy of the document is created and the copy is broken into multiple pages according to the size of the <code>QPrinter&#39;s</code> <code>paperRect()</code>. By default a <code>2</code> cm margin is set around the document contents. In addition the current page number is printed at the bottom of each page. Note that <code>QPrinter::Selection</code> is not supported as print range with this function since the selection is a property of <code>QTextCursor</code>. If you have a <code>QTextEdit</code> associated with your <code>QTextDocument</code> then you can use <code>QTextEdit&#39;s</code> <code>print()</code> function because <code>QTextEdit</code> has access to the user’s selection.</li>
<li><code>void QTextDocument::redo(QTextCursor * cursor)</code>: Redoes the last editing operation on the document if redo is available. The provided <code>cursor</code> is positioned at the end of the location where the edition operation was redone.</li>
<li><code>void QTextDocument::redo() [slot]</code>: This is an overloaded function. Redoes the last editing operation on the document if redo is available.</li>
<li><code>void QTextDocument::redoAvailable(bool available) [signal]</code>: This signal is emitted whenever redo operations become available (<code>available</code> is <code>true</code>) or unavailable (<code>available</code> is <code>false</code>).</li>
<li><code>QVariant QTextDocument::resource(int type, const QUrl &amp; name) const</code>: Returns data of the specified <code>type</code> from the resource with the given <code>name</code>. This function is called by the rich text engine to request data that isn’t directly stored by <code>QTextDocument</code>, but still associated with it. For example, images are referenced indirectly by the name attribute of a <code>QTextImageFormat</code> object. Resources are cached internally in the document. If a resource can not be found in the cache, <code>loadResource</code> is called to try to load the resource. <code>loadResource</code> should then use <code>addResource</code> to add the resource to the cache.</li>
<li><code>int QTextDocument::revision() const</code>: Returns the document’s revision (if undo is enabled). The revision is guaranteed to increase when a document that is not modified is edited.</li>
<li><code>QTextFrame * QTextDocument::rootFrame() const</code>: Returns the document’s root frame.</li>
<li><code>void QTextDocument::setDefaultCursorMoveStyle(Qt::CursorMoveStyle style)</code>: Sets the default cursor movement style to the given <code>style</code>.</li>
<li><code>void QTextDocument::setDocumentLayout(QAbstractTextDocumentLayout * layout)</code>: Sets the document to use the given <code>layout</code>. The previous layout is deleted.</li>
<li><code>void QTextDocument::setHtml(const QString &amp; html)</code>: Replaces the entire contents of the document with the given <code>HTML-formatted</code> text in the <code>html</code> string. The <code>HTML</code> formatting is respected as much as possible; for example, <code>&lt;b&gt;bold&lt;/b&gt; text</code> will produce text where the first word has a font weight that gives it a bold appearance: <code>bold text</code>. <strong>Note</strong>: It is the responsibility of the caller to make sure that the text is correctly decoded when a <code>QString</code> containing <code>HTML</code> is created and passed to <code>setHtml()</code>.</li>
<li><code>void QTextDocument::setMetaInformation(MetaInformation info, const QString &amp; string)</code>: Sets the document’s meta information of the type specified by <code>info</code> to the given <code>string</code>.</li>
<li><code>void QTextDocument::setPlainText(const QString &amp; text)</code>: Replaces the entire contents of the document with the given plain <code>text</code>.</li>
<li><code>QString QTextDocument::toHtml(const QByteArray &amp; encoding = QByteArray()) const</code>: Returns a string containing an <code>HTML</code> representation of the document. The <code>encoding</code> parameter specifies the value for the charset attribute in the html header. For example if <code>utf-8</code> is specified then the beginning of the generated html will look like this:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>...</span><br></pre></td></tr></table></figure>
<p>If no encoding is specified then no such meta information is generated. If you later on convert the returned html string into a byte array for transmission over a network or when saving to disk you should specify the encoding you’re going to use for the conversion to a byte array here.</p>
<ul>
<li><code>QString QTextDocument::toPlainText() const</code>: Returns the plain text contained in the document. If you want formatting information use a <code>QTextCursor</code> instead.</li>
<li><code>void QTextDocument::undo(QTextCursor * cursor)</code>: Undoes the last editing operation on the document if undo is available. The provided <code>cursor</code> is positioned at the end of the location where the edition operation was undone.</li>
<li><code>void QTextDocument::undo() [slot]</code>: This is an overloaded function.</li>
<li><code>void QTextDocument::undoAvailable(bool available) [signal]</code>: This signal is emitted whenever undo operations become available (<code>available</code> is true) or unavailable (<code>available</code> is false).</li>
<li><code>void QTextDocument::undoCommandAdded() [signal]</code>: This signal is emitted every time a new level of undo is added to the <code>QTextDocument</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/01/Qt语法详解/Qt之拖放/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/01/Qt语法详解/Qt之拖放/" itemprop="url">Qt之拖放</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-01T18:27:48+08:00">
                2019-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;拖放是应用程序内或者多个应用程序之间传递信息的一种直观的操作方式。除了为剪贴板提供支持之外，通常还提供数据的移动和复制功能。<br>&emsp;&emsp;拖放操作包括两个截然不同的动作，即拖动、放下。<code>Qt</code>窗口部件可以作为拖动点(<code>drag site</code>)、放下点(<code>drop site</code>)或者同时作为拖动点和放下点。<br>&emsp;&emsp;下面介绍如何让一个<code>Qt</code>应用程序接收一个拖动操作，当用户从桌面或者文件资源管理器中拖动一个文件到这个应用程序上放下时，该应用程序就会将文件的信息显示出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabelView</span> :</span> <span class="keyword">public</span> QTableView &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TabelView</span> <span class="params">( QWidget *parent = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dragEnterEvent</span> <span class="params">( QDragEnterEvent *event )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dragMoveEvent</span> <span class="params">( QDragMoveEvent *event )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dropEvent</span> <span class="params">( QDropEvent *event )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">TabelView::TabelView ( QWidget *parent ) : QTableView ( parent ) &#123;</span><br><span class="line">    setAcceptDrops ( <span class="literal">true</span> );</span><br><span class="line">    setDragDropMode ( QAbstractItemView::DragDrop );</span><br><span class="line">    setDragEnabled ( <span class="literal">true</span> );</span><br><span class="line">    setDropIndicatorShown ( <span class="literal">true</span> );</span><br><span class="line">    <span class="keyword">this</span>-&gt;setWindowTitle ( <span class="string">"TableView"</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> TabelView::dragEnterEvent ( QDragEnterEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasFormat ( <span class="string">"text/uri-list"</span> ) ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"drag enter"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;以上通过自定义<code>QTableView</code>来实现拖放事件，首先需要设置<code>setAcceptDrops(true)</code>来接受放下事件，通过设置<code>setDropIndicatorShown(true)</code>则可以清晰地看到放下过程中的图标指示。然后实现<code>dragEnterEvent</code>、<code>dropEvent</code>方法，当用户把一个对象拖动到这个窗体上时，就会调用<code>dragEnterEvent</code>，如果对这个事件调用<code>acceptProposedAction</code>，就表明可以在这个窗体上拖放对象。默认情况下窗口部件是不接受拖动的，<code>Qt</code>会自动改变光标向用户说明这个窗口部件不是有效的放下点。<br>&emsp;&emsp;我们希望用户拖放的只能是文件，而非其他类型的东西。为了实现这一点，可以检查拖动的<code>MIME</code>类型。<code>MIME</code>类型中<code>text/uri-list</code>用于存储统一资源标识符，它们可以是文件名、统一资源定位器(例如<code>HTTP</code>、<code>FTP</code>路径)或者其它全局资源标识符。标准的<code>MIME</code>类型由国际因特网地址分配委员会<code>IANA</code>定义的，它们由类型、子类型信息以及分割两者的斜线组成。<code>MIME</code>类通常由剪贴板和拖放系统使用，以识别不同类型的数据。<br>&emsp;&emsp;当用户在窗口部件上放下一个对象时，就会调用<code>dropEvent</code>。我们调用函数<code>QMimeData::urls</code>来获得<code>QUrl</code>列表。通常情况下，用户一次只拖动一个选择区域来同时拖动多个文件也是可能的，如果要拖放的<code>URL</code>不止一个，或者要拖放的<code>URL</code>不是一个本地文件名，则会立即返回到原调用处。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TabelView::dragMoveEvent ( QDragMoveEvent *event ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"drag move"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>QWidget</code>也提供了<code>dragMoveEvent</code>和<code>dragLeveEvent</code>函数，但是绝大多数情况下并不需要重新实现，上面简单实现了<code>dragMoveEvent</code>函数。</p>
<hr>
<h3 id="Drag-and-Drop"><a href="#Drag-and-Drop" class="headerlink" title="Drag and Drop"></a>Drag and Drop</h3><p>&emsp;&emsp;Drag and drop provides a simple visual mechanism which users can use to transfer information between and within applications (In the literature this is referred to as a <code>direct manipulation model</code>). Drag and drop is similar in function to the clipboard’s cut and paste mechanism.<br>&emsp;&emsp;This document describes the basic drag and drop mechanism and outlines the approach used to enable it in custom widgets. Drag and drop operations are also supported by Qt’s item views and by the graphics view framework. More information is available in Using drag and drop with item views and <code>Graphics View Framework</code>.</p>
<h3 id="Drag-and-Drop-Classes"><a href="#Drag-and-Drop-Classes" class="headerlink" title="Drag and Drop Classes"></a>Drag and Drop Classes</h3><p>&emsp;&emsp;These classes deal with drag and drop and the necessary mime type encoding and decoding.</p>
<ul>
<li>QDragEnterEvent: Event which is sent to a widget when a drag and drop action enters it.</li>
<li>QDragLeaveEvent: Event that is sent to a widget when a drag and drop action leaves it.</li>
<li>QDragMoveEvent: Event which is sent while a drag and drop action is in progress.</li>
<li>QDropEvent: Event which is sent when a drag and drop action is completed.</li>
<li>QMacPasteboardMime: Converts between a <code>MIME</code> type and a <code>Uniform Type Identifier</code> (<code>UTI</code>) format.</li>
<li>QWindowsMime: Maps <code>open-standard</code> <code>MIME</code> to Window <code>Clipboard</code> formats.</li>
</ul>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><p>&emsp;&emsp;The <code>QApplication</code> object provides some properties that are related to drag and drop operations:</p>
<ul>
<li><code>QApplication::startDragTime</code> describes the amount of time in milliseconds that the user must hold down a mouse button over an object before a drag will begin.</li>
<li><code>QApplication::startDragDistance</code> indicates how far the user has to move the mouse while holding down a mouse button before the movement will be interpreted as dragging. Use of high values for this quantity prevents accidental dragging when the user only meant to click on an object.</li>
</ul>
<p>&emsp;&emsp;These quantities provide sensible default values for you to use if you provide drag and drop support in your widgets.</p>
<h3 id="Dragging"><a href="#Dragging" class="headerlink" title="Dragging"></a>Dragging</h3><p>&emsp;&emsp;To start a drag, create a <code>QDrag</code> object, and call its <code>exec()</code> function. In most applications, it is a good idea to begin a drag and drop operation only after a mouse button has been pressed and the cursor has been moved a certain distance. However, the simplest way to enable dragging from a widget is to reimplement the widget’s <code>mousePressEvent()</code> and start a drag and drop operation:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::mousePressEvent ( QMouseEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;button() == Qt::LeftButton</span><br><span class="line">         &amp;&amp; iconLabel-&gt;geometry().contains ( event-&gt;pos() ) ) &#123;</span><br><span class="line">        QDrag *drag = <span class="keyword">new</span> QDrag ( <span class="keyword">this</span> );</span><br><span class="line">        QMimeData *mimeData = <span class="keyword">new</span> QMimeData;</span><br><span class="line">        mimeData-&gt;setText ( commentEdit-&gt;toPlainText() );</span><br><span class="line">        drag-&gt;setMimeData ( mimeData );</span><br><span class="line">        drag-&gt;setPixmap ( iconPixmap );</span><br><span class="line">        Qt::DropAction dropAction = drag-&gt;exec();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Although the user may take some time to complete the dragging operation, as far as the application is concerned the <code>exec()</code> function is a blocking function that returns with one of several values. These indicate how the operation ended, and are described in more detail below.<br>&emsp;&emsp;Note that the <code>exec()</code> function does not block the main event loop.<br>&emsp;&emsp;For widgets that need to distinguish between mouse clicks and drags, it is useful to reimplement the widget’s <code>mousePressEvent()</code> function to record to start position of the drag:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DragWidget::mousePressEvent ( QMouseEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;button() == Qt::LeftButton ) &#123;</span><br><span class="line">        dragStartPosition = event-&gt;pos();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Later, in <code>mouseMoveEvent()</code>, we can determine whether a drag should begin, and construct a drag object to handle the operation:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DragWidget::mouseMoveEvent ( QMouseEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ! ( event-&gt;buttons() &amp; Qt::LeftButton ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( event-&gt;pos() - dragStartPosition ).manhattanLength() &lt; QApplication::startDragDistance() ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    QDrag *drag = <span class="keyword">new</span> QDrag ( <span class="keyword">this</span> );</span><br><span class="line">    QMimeData *mimeData = <span class="keyword">new</span> QMimeData;</span><br><span class="line">    mimeData-&gt;setData ( mimeType, data );</span><br><span class="line">    drag-&gt;setMimeData ( mimeData );</span><br><span class="line">    Qt::DropAction dropAction = drag-&gt;exec ( Qt::CopyAction | Qt::MoveAction );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This particular approach uses the <code>QPoint::manhattanLength()</code> function to get a rough estimate of the distance between where the mouse click occurred and the current cursor position. This function trades accuracy for speed, and is usually suitable for this purpose.</p>
<h3 id="Dropping"><a href="#Dropping" class="headerlink" title="Dropping"></a>Dropping</h3><p>&emsp;&emsp;To be able to receive media dropped on a widget, call <code>setAcceptDrops(true)</code> for the widget, and reimplement the <code>dragEnterEvent()</code> and <code>dropEvent()</code> event handler functions.<br>&emsp;&emsp;For example, the following code enables drop events in the constructor of a <code>QWidget</code> subclass, making it possible to usefully implement drop event handlers:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Window::Window ( QWidget *parent ) : QWidget ( parent ) &#123;</span><br><span class="line">    ...</span><br><span class="line">    setAcceptDrops ( <span class="literal">true</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>dragEnterEvent()</code> function is typically used to inform Qt about the types of data that the widget accepts. You must reimplement this function if you want to receive either <code>QDragMoveEvent</code> or <code>QDropEvent</code> in your reimplementations of <code>dragMoveEvent()</code> and <code>dropEvent()</code>.<br>&emsp;&emsp;The following code shows how <code>dragEnterEvent()</code> can be reimplemented to tell the drag and drop system that we can only handle plain text:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Window::dragEnterEvent ( QDragEnterEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasFormat ( <span class="string">"text/plain"</span> ) ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>dropEvent()</code> is used to unpack dropped data and handle it in way that is suitable for your application.<br>&emsp;&emsp;In the following code, the text supplied in the event is passed to a <code>QTextBrowser</code> and a <code>QComboBox</code> is filled with the list of <code>MIME</code> types that are used to describe the data:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Window::dropEvent ( QDropEvent *event ) &#123;</span><br><span class="line">    textBrowser-&gt;setPlainText ( event-&gt;mimeData()-&gt;text() );</span><br><span class="line">    mimeTypeCombo-&gt;clear();</span><br><span class="line">    mimeTypeCombo-&gt;addItems ( event-&gt;mimeData()-&gt;formats() );</span><br><span class="line">    event-&gt;acceptProposedAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;In this case, we accept the proposed action without checking what it is. In a real world application, it may be necessary to return from the <code>dropEvent()</code> function without accepting the proposed action or handling the data if the action is not relevant. For example, we may choose to ignore <code>Qt::LinkAction</code> actions if we do not support links to external sources in our application.</p>
<h3 id="Overriding-Proposed-Actions"><a href="#Overriding-Proposed-Actions" class="headerlink" title="Overriding Proposed Actions"></a>Overriding Proposed Actions</h3><p>&emsp;&emsp;We may also ignore the proposed action, and perform some other action on the data. To do this, we would call the event object’s <code>setDropAction()</code> with the preferred action from <code>Qt::DropAction</code> before calling <code>accept()</code>. This ensures that the replacement drop action is used instead of the proposed action.<br>&emsp;&emsp;For more sophisticated applications, reimplementing <code>dragMoveEvent()</code> and <code>dragLeaveEvent()</code> will let you make certain parts of your widgets sensitive to drop events, and give you more control over drag and drop in your application.</p>
<h3 id="Subclassing-Complex-Widgets"><a href="#Subclassing-Complex-Widgets" class="headerlink" title="Subclassing Complex Widgets"></a>Subclassing Complex Widgets</h3><p>&emsp;&emsp;Certain standard Qt widgets provide their own support for drag and drop. When subclassing these widgets, it may be necessary to reimplement <code>dragMoveEvent()</code> in addition to <code>dragEnterEvent()</code> and <code>dropEvent()</code> to prevent the base class from providing default drag and drop handling, and to handle any special cases you are interested in.</p>
<h3 id="Drag-and-Drop-Actions"><a href="#Drag-and-Drop-Actions" class="headerlink" title="Drag and Drop Actions"></a>Drag and Drop Actions</h3><p>&emsp;&emsp;In the simplest case, the target of a drag and drop action receives a copy of the data being dragged, and the source decides whether to delete the original. This is described by the <code>CopyAction</code> action. The target may also choose to handle other actions, specifically the <code>MoveAction</code> and <code>LinkAction</code> actions. If the source calls <code>QDrag::exec()</code>, and it returns <code>MoveAction</code>, the source is responsible for deleting any original data if it chooses to do so. The <code>QMimeData</code> and <code>QDrag</code> objects created by the source widget should not be deleted — they will be destroyed by Qt. The target is responsible for taking ownership of the data sent in the drag and drop operation; this is usually done by keeping references to the data.<br>&emsp;&emsp;If the target understands the <code>LinkAction</code> action, it should store its own reference to the original information; the source does not need to perform any further processing on the data. The most common use of drag and drop actions is when performing a <code>Move</code> within the same widget.<br>&emsp;&emsp;The other major use of drag actions is when using a reference type such as text/uri-list, where the dragged data are actually references to files or objects.</p>
<h3 id="Adding-New-Drag-and-Drop-Types"><a href="#Adding-New-Drag-and-Drop-Types" class="headerlink" title="Adding New Drag and Drop Types"></a>Adding New Drag and Drop Types</h3><p>&emsp;&emsp;Drag and drop is not limited to text and images. Any type of information can be transferred in a drag and drop operation. To drag information between applications, the applications must be able to indicate to each other which data formats they can accept and which they can produce. This is achieved using <code>MIME</code> types. The <code>QDrag</code> object constructed by the source contains a list of <code>MIME</code> types that it uses to represent the data (ordered from most appropriate to least appropriate), and the drop target uses one of these to access the data. For common data types, the convenience functions handle the <code>MIME</code> types used transparently but, for custom data types, it is necessary to state them explicitly.<br>&emsp;&emsp;To implement drag and drop actions for a type of information that is not covered by the <code>QDrag</code> convenience functions, the first and most important step is to look for existing formats that are appropriate: The <code>Internet Assigned Numbers Authority</code> (<code>IANA</code>) provides a hierarchical list of <code>MIME</code> media types at the <code>Information Sciences Institute</code> (<code>ISI</code>). Using standard <code>MIME</code> types maximizes the interoperability of your application with other software now and in the future.<br>&emsp;&emsp;To support an additional media type, simply set the data in the <code>QMimeData</code> object with the <code>setData()</code> function, supplying the full <code>MIME</code> type and a <code>QByteArray</code> containing the data in the appropriate format. The following code takes a pixmap from a label and stores it as a <code>Portable Network Graphics</code> (<code>PNG</code>) file in a <code>QMimeData</code> object:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QByteArray output;</span><br><span class="line"><span class="function">QBuffer <span class="title">outputBuffer</span> <span class="params">( &amp;output )</span></span>;</span><br><span class="line">outputBuffer.open ( QIODevice::WriteOnly );</span><br><span class="line">imageLabel-&gt;pixmap()-&gt;toImage().save ( &amp;outputBuffer, <span class="string">"PNG"</span> );</span><br><span class="line">mimeData-&gt;setData ( <span class="string">"image/png"</span>, output );</span><br></pre></td></tr></table></figure>
<p>Of course, for this case we could have simply used <code>setImageData()</code> instead to supply image data in a variety of formats:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimeData-&gt;setImageData ( QVariant ( *imageLabel-&gt;pixmap() ) );</span><br></pre></td></tr></table></figure>
<p>The <code>QByteArray</code> approach is still useful in this case because it provides greater control over the amount of data stored in the <code>QMimeData</code> object. Note that custom datatypes used in item views must be declared as meta objects and that stream operators for them must be implemented.</p>
<h3 id="Drop-Actions"><a href="#Drop-Actions" class="headerlink" title="Drop Actions"></a>Drop Actions</h3><p>&emsp;&emsp;In the clipboard model, the user can cut or copy the source information, then later paste it. Similarly in the drag and drop model, the user can drag a copy of the information or they can drag the information itself to a new place (moving it). The drag and drop model has an additional complication for the programmer: The program doesn’t know whether the user wants to cut or copy the information until the operation is complete. This often makes no difference when dragging information between applications, but within an application it is important to check which drop action was used.<br>&emsp;&emsp;We can reimplement the <code>mouseMoveEvent()</code> for a widget, and start a drag and drop operation with a combination of possible drop actions. For example, we may want to ensure that dragging always moves objects in the widget:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DragWidget::mouseMoveEvent ( QMouseEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ! ( event-&gt;buttons() &amp; Qt::LeftButton ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( event-&gt;pos() - dragStartPosition ).manhattanLength()</span><br><span class="line">         &lt; QApplication::startDragDistance() ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    QDrag *drag = <span class="keyword">new</span> QDrag ( <span class="keyword">this</span> );</span><br><span class="line">    QMimeData *mimeData = <span class="keyword">new</span> QMimeData;</span><br><span class="line">    mimeData-&gt;setData ( mimeType, data );</span><br><span class="line">    drag-&gt;setMimeData ( mimeData );</span><br><span class="line">    Qt::DropAction dropAction = drag-&gt;exec ( Qt::CopyAction | Qt::MoveAction );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The action returned by the <code>exec()</code> function may default to a <code>CopyAction</code> if the information is dropped into another application but, if it is dropped in another widget in the same application, we may obtain a different drop action.<br>&emsp;&emsp;The proposed drop actions can be filtered in a widget’s <code>dragMoveEvent()</code> function. However, it is possible to accept all proposed actions in the <code>dragEnterEvent()</code> and let the user decide which they want to accept later:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DragWidget::dragEnterEvent ( QDragEnterEvent *event ) &#123;</span><br><span class="line">    event-&gt;acceptProposedAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;When a drop occurs in the widget, the <code>dropEvent()</code> handler function is called, and we can deal with each possible action in turn. First, we deal with drag and drop operations within the same widget:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DragWidget::dropEvent ( QDropEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;source() == <span class="keyword">this</span> &amp;&amp; event-&gt;possibleActions() &amp; Qt::MoveAction )</span><br><span class="line">        <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;In this case, we refuse to deal with move operations. Each type of drop action that we accept is checked and dealt with accordingly:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ( event-&gt;proposedAction() == Qt::MoveAction ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">        <span class="comment">/* Process the data from the event */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( event-&gt;proposedAction() == Qt::CopyAction ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">        <span class="comment">/* Process the data from the event */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Ignore the drop */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that we checked for individual drop actions in the above code. As mentioned above in the section on <code>Overriding Proposed Actions</code>, it is sometimes necessary to override the proposed drop action and choose a different one from the selection of possible drop actions. To do this, you need to check for the presence of each action in the value supplied by the event’s <code>possibleActions()</code>, set the drop action with <code>setDropAction()</code>, and call <code>accept()</code>.</p>
<h3 id="Drop-Rectangles"><a href="#Drop-Rectangles" class="headerlink" title="Drop Rectangles"></a>Drop Rectangles</h3><p>&emsp;&emsp;The widget’s <code>dragMoveEvent()</code> can be used to restrict drops to certain parts of the widget by only accepting the proposed drop actions when the cursor is within those areas. For example, the following code accepts any proposed drop actions when the cursor is over a child widget (dropFrame):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Window::dragMoveEvent ( QDragMoveEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasFormat ( <span class="string">"text/plain"</span> ) &amp;&amp; \</span><br><span class="line">         event-&gt;answerRect().intersects ( dropFrame-&gt;geometry() ) ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>dragMoveEvent()</code> can also be used if you need to give visual feedback during a drag and drop operation, to scroll the window, or whatever is appropriate.</p>
<h3 id="The-Clipboard"><a href="#The-Clipboard" class="headerlink" title="The Clipboard"></a>The Clipboard</h3><p>&emsp;&emsp;Applications can also communicate with each other by putting data on the clipboard. To access this, you need to obtain a <code>QClipboard</code> object from the <code>QApplication</code> object:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clipboard = QApplication::clipboard();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>QMimeData</code> class is used to represent data that is transferred to and from the clipboard. To put data on the clipboard, you can use the <code>setText()</code>, <code>setImage()</code> and <code>setPixmap()</code> convenience functions for common data types. These functions are similar to those found in the <code>QMimeData</code> class, except that they also take an additional argument that controls where the data is stored: If <code>Clipboard</code> is specified, the data is placed on the clipboard; if <code>Selection</code> is specified, the data is placed in the mouse selection (on <code>X11</code> only). By default, data is put on the clipboard.<br>&emsp;&emsp;For example, we can copy the contents of a <code>QLineEdit</code> to the clipboard with the following code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clipboard-&gt;setText ( lineEdit-&gt;text(), QClipboard::Clipboard );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Data with different <code>MIME</code> types can also be put on the clipboard. Construct a <code>QMimeData</code> object and set data with <code>setData()</code> function in the way described in the previous section; this object can then be put on the clipboard with the <code>setMimeData()</code> function.<br>&emsp;&emsp;The <code>QClipboard</code> class can notify the application about changes to the data it contains via its <code>dataChanged()</code> signal. For example, we can monitor the clipboard by connecting this signal to a slot in a widget:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect ( clipboard, SIGNAL ( dataChanged() ), <span class="keyword">this</span>, SLOT ( updateClipboard() ) );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The slot connected to this signal can read the data on the clipboard using one of the <code>MIME</code> types that can be used to represent it:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ClipWindow::updateClipboard() &#123;</span><br><span class="line">    QStringList formats = clipboard-&gt;mimeData()-&gt;formats();</span><br><span class="line">    QByteArray data = clipboard-&gt;mimeData()-&gt;data ( format );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>selectionChanged()</code> signal can be used on <code>X11</code> to monitor the mouse selection.</p>
<h3 id="Interoperating-with-Other-Applications"><a href="#Interoperating-with-Other-Applications" class="headerlink" title="Interoperating with Other Applications"></a>Interoperating with Other Applications</h3><p>&emsp;&emsp;On <code>X11</code>, the public <code>XDND</code> protocol is used, while on <code>Windows</code> Qt uses the <code>OLE</code> standard, and Qt for <code>Mac OS X</code> uses the <code>Carbon Drag Manager</code>. On <code>X11</code>, <code>XDND</code> uses <code>MIME</code>, so no translation is necessary. The Qt API is the same regardless of the platform. On <code>Windows</code>, <code>MIME-aware</code> applications can communicate by using clipboard format names that are <code>MIME</code> types. Already some Windows applications use <code>MIME</code> naming conventions for their clipboard formats. Internally, Qt uses <code>QWindowsMime</code> and <code>QMacPasteboardMime</code> for translating proprietary clipboard formats to and from <code>MIME</code> types.<br><strong>Note</strong>: The <code>Motif Drag &amp; Drop Protocol</code> only allows receivers to request data in response to a <code>QDropEvent</code>. If you attempt to request data in response to e.g. a <code>QDragMoveEvent</code>, an empty <code>QByteArray</code> is returned.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/01/Qt语法详解/QString用法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/01/Qt语法详解/QString用法/" itemprop="url">QString用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-01T16:01:27+08:00">
                2019-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;从字符串<code>one, two, three, four</code>中获取第二个由<code>,</code>分隔的子串，即<code>two</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtCore/QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QString str = <span class="string">"one, two, three, four"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str.section ( <span class="string">','</span>, <span class="number">1</span>, <span class="number">1</span> ).trimmed().toStdString() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>trimmed</code>用于去掉字符串前后的<code>\t</code>、<code>\n</code>、<code>\v</code>、<code>\f</code>、<code>\r</code>和<code>空格</code>，这些字符用<code>QChar::isSpace</code>判断都返回<code>true</code>。<br>&emsp;&emsp;从字符串<code>one, two* three / four / five ^ six</code>中获取第四个由<code>,</code>、<code>*</code>、<code>/</code>和<code>^</code>分隔的子串，即<code>four</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtCore/QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QRegExp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QString str = <span class="string">"one, two* three / four / five ^ six"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str.section ( QRegExp ( <span class="string">"[,*/^]"</span> ), <span class="number">3</span>, <span class="number">3</span> ).trimmed().toStdString() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面用到了一个简单的正则表达式，在<code>Qt</code>中可以由类<code>QRegExp</code>构造，函数<code>section</code>支持使用正则表达式。</p>
<hr>
<p>&emsp;&emsp;<code>section</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString QString::section ( QChar sep, <span class="keyword">int</span> start, <span class="keyword">int</span> end = <span class="number">-1</span>, \</span><br><span class="line">                           SectionFlags flags = SectionDefault ) <span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<p>这个函数把字符串看成是几个块，这些块由<code>sep</code>分隔，<code>start</code>和<code>end</code>指定块号，返回的是<code>[start, end]</code>内的块组成的字符串。如果<code>start</code>和<code>end</code>都是负数，那么将从字符串的后面往前面数，返回<code>[-end, -start]</code>内的块组成的字符串。<code>SectionFlags</code>是一些标记，例如<code>SectionSkipEmpty</code>表示如果两个分隔符之间是空串，那么就会跳过。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QString str;</span><br><span class="line">QString csv = <span class="string">"forename,middlename,surname,phone"</span>;</span><br><span class="line">QString path = <span class="string">"/usr/local/bin/myapp"</span>; <span class="comment">// First field is empty</span></span><br><span class="line">QString::SectionFlag flag = QString::SectionSkipEmpty;</span><br><span class="line">​</span><br><span class="line">str = csv.section ( <span class="string">','</span>, <span class="number">2</span>, <span class="number">2</span> ); <span class="comment">// str == "surname"</span></span><br><span class="line">str = path.section ( <span class="string">'/'</span>, <span class="number">3</span>, <span class="number">4</span> ); <span class="comment">// str == "bin/myapp"</span></span><br><span class="line">str = path.section ( <span class="string">'/'</span>, <span class="number">3</span>, <span class="number">3</span>, flag ); <span class="comment">// str == "myapp"</span></span><br><span class="line">​</span><br><span class="line">str = csv.section ( <span class="string">','</span>, <span class="number">-3</span>, <span class="number">-2</span> ); <span class="comment">// str == "middlename,surname"</span></span><br><span class="line">str = path.section ( <span class="string">'/'</span>, <span class="number">-1</span> ); <span class="comment">// str == "myapp"</span></span><br></pre></td></tr></table></figure>
<p>这个函数的另两个重载函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString QString::section ( <span class="keyword">const</span> QString &amp;sep, <span class="keyword">int</span> start, <span class="keyword">int</span> end = <span class="number">-1</span>, \</span><br><span class="line">                           SectionFlags flags = SectionDefault ) <span class="keyword">const</span></span><br><span class="line">QString QString::section ( <span class="keyword">const</span> QRegExp &amp;reg, <span class="keyword">int</span> start, <span class="keyword">int</span> end = <span class="number">-1</span>, \</span><br><span class="line">                           SectionFlags flags = SectionDefault ) <span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>split</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QStringList QString::split ( <span class="keyword">const</span> QChar &amp;sep, SplitBehavior behavior = KeepEmptyParts, \</span><br><span class="line">                             Qt::CaseSensitivity cs = Qt::CaseSensitive ) <span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<p>这个函数把所有的由<code>sep</code>分隔的块装进一个<code>QStringList</code>中返回，这个函数同样有两个重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QStringList QString::split ( <span class="keyword">const</span> QString &amp;sep, SplitBehavior behavior = KeepEmptyParts, \</span><br><span class="line">                             Qt::CaseSensitivity cs = Qt::CaseSensitive ) <span class="keyword">const</span></span><br><span class="line">QStringList QString::split ( <span class="keyword">const</span> QRegExp &amp;rx, SplitBehavior behavior = KeepEmptyParts ) <span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<p>使用实例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtCore/QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QRegExp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QStringList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QString str = <span class="string">"one, two* three / four / five ^ six"</span>;</span><br><span class="line">    <span class="comment">/* 把每一个块装进一个QStringList中 */</span></span><br><span class="line">    QStringList sections = str.split ( QRegExp ( <span class="string">"[,*/^]"</span> ) );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sections.at ( <span class="number">3</span> ).trimmed().toStdString() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="QString与数字的相互转化"><a href="#QString与数字的相互转化" class="headerlink" title="QString与数字的相互转化"></a>QString与数字的相互转化</h3><h4 id="把QString转换为double类型"><a href="#把QString转换为double类型" class="headerlink" title="把QString转换为double类型"></a>把QString转换为double类型</h4><p>&emsp;&emsp;方法<code>1</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">"123.45"</span>;</span><br><span class="line"><span class="keyword">double</span> val = str.toDouble(); <span class="comment">/* val = 123.45 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;方法<code>2</code>很适合科学计数法形式转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="comment">/* ok is true, d is 12.3456 */</span></span><br><span class="line">d = QString ( <span class="string">"1234.56e-02"</span> ).toDouble ( &amp;ok );</span><br></pre></td></tr></table></figure>
<h4 id="把QString转换为float型"><a href="#把QString转换为float型" class="headerlink" title="把QString转换为float型"></a>把QString转换为float型</h4><p>&emsp;&emsp;方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方法1 */</span></span><br><span class="line">QString str = <span class="string">"123.45"</span>;</span><br><span class="line"><span class="keyword">float</span> d = str.toFloat(); <span class="comment">/* d = 123.45 */</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 方法2 */</span></span><br><span class="line">QString str = <span class="string">"R2D2"</span>;</span><br><span class="line"><span class="keyword">bool</span> ok;</span><br><span class="line"><span class="keyword">float</span> d = str.toFloat ( &amp;ok ); <span class="comment">/* 转换失败返回0.0，ok为false */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;把<code>double</code>型数据转换为<code>QString</code>类型：<code>double</code>类转换<code>QString</code>类型使用<code>QString::number</code>函数，第一个参数为需要转换的<code>double</code>数据；第二个参数为基数，即<code>10</code>、<code>2</code>、<code>8</code>等；第三个参数为精度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> intResult;</span><br><span class="line">QLabel *pornPropLabel;</span><br><span class="line">pornPropLabel-&gt;setText ( QString::number ( intResult, <span class="number">10</span>, <span class="number">4</span> ) );</span><br></pre></td></tr></table></figure>
<h3 id="把QString形转换为整型"><a href="#把QString形转换为整型" class="headerlink" title="把QString形转换为整型"></a>把QString形转换为整型</h3><p>&emsp;&emsp;1. 转换为十进制整型：基数默认为<code>10</code>。如果基数为<code>0</code>，若字符串是以<code>0x</code>开头的就会转换为<code>16</code>进制，若以<code>0</code>开头就转换为八进制，否则就转换为十进制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Qstring str = <span class="string">"FF"</span>;</span><br><span class="line"><span class="keyword">bool</span> ok;</span><br><span class="line"><span class="keyword">int</span> dec = str.toInt ( &amp;ok, <span class="number">10</span> ); <span class="comment">/* dec is 255, ok is true */</span></span><br><span class="line"><span class="keyword">int</span> hex = str.toInt ( &amp;ok, <span class="number">16</span> ); <span class="comment">/* hex is 255, ok is true */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 常整型转换为<code>Qstring</code>型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a = <span class="number">63</span>;</span><br><span class="line">QString str = QString::number ( a, <span class="number">16</span> ); <span class="comment">/* str = "3f" */</span></span><br><span class="line">QString str = QString::number ( a, <span class="number">16</span> ).toUpper(); <span class="comment">/* str = "3F" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>Qstring</code>转换为<code>char *</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方法一 */</span></span><br><span class="line"><span class="function">QString <span class="title">qstr</span> <span class="params">( <span class="string">"hello,word"</span> )</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = qstr.toLocal8Bit().data();</span><br><span class="line"><span class="comment">/* 方法二 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = qstr.toStdString().data(); <span class="comment">/* 转换过来的是常量 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;把当前时间转化为<code>QString</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QDateTime qdate = QDateTime::currentDateTime();</span><br><span class="line">datetime = qdate.toString ( <span class="string">"yyyy年MM月dd日ddddhh:mm:ss"</span> );</span><br></pre></td></tr></table></figure>
<hr>
<p>&emsp;&emsp;<code>QString</code>类提供了很方便的对字符串操作的接口。<br>&emsp;&emsp;1. 使某个字符填满字符串，也就是说字符串里的所有字符都用等长度的<code>ch</code>来代替：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString::fill ( QChar ch, <span class="keyword">int</span> size = <span class="number">-1</span> );</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">"Berlin"</span>;</span><br><span class="line">str.fill ( <span class="string">'z'</span> ); <span class="comment">/* str is "zzzzzz" */</span></span><br><span class="line">str.fill ( <span class="string">'A'</span>, <span class="number">2</span> ); <span class="comment">/* str is "AA" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 从字符串里查找相同的某个字符串<code>str</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QString::indexOf ( <span class="keyword">const</span> QString &amp;str, <span class="keyword">int</span> from = <span class="number">0</span>, \</span><br><span class="line">                       Qt::CaseSensitivity cs = Qt::CaseSensitive ) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QString x = <span class="string">"sticky question"</span>;</span><br><span class="line">QString y = <span class="string">"sti"</span>;</span><br><span class="line">x.indexOf ( y );  <span class="comment">/* returns 0 */</span></span><br><span class="line">x.indexOf ( y, <span class="number">1</span> ); <span class="comment">/* returns 10 */</span></span><br><span class="line">x.indexOf ( y, <span class="number">10</span> ); <span class="comment">/* returns 10 */</span></span><br><span class="line">x.indexOf ( y, <span class="number">11</span> ); <span class="comment">/* returns -1 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3. 指定位置插入字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString &amp;QString::insert ( <span class="keyword">int</span> position, <span class="keyword">const</span> QString &amp;str );</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">"Meal"</span>;</span><br><span class="line">str.insert ( <span class="number">1</span>, QString ( <span class="string">"ontr"</span> ) ); <span class="comment">/* str is "Montreal" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;4. 判断字符串是否为空：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> QString::isEmpty () <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString().isEmpty(); <span class="comment">/* returns true */</span></span><br><span class="line">QString ( <span class="string">""</span> ).isEmpty(); <span class="comment">/* returns true */</span></span><br><span class="line">QString ( <span class="string">"x"</span> ).isEmpty(); <span class="comment">/* returns false */</span></span><br><span class="line">QString ( <span class="string">"abc"</span> ).isEmpty(); <span class="comment">/* returns false */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;5. 判断字符串是否存在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> QString::isNull () <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString().isNull(); <span class="comment">/* returns true */</span></span><br><span class="line">QString ( <span class="string">""</span> ).isNull(); <span class="comment">/* returns false */</span></span><br><span class="line">QString ( <span class="string">"abc"</span> ).isNull(); <span class="comment">/* returns false */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;6. 从左向右截取字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString QString::left ( <span class="keyword">int</span> n ) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString x = <span class="string">"Pineapple"</span>;</span><br><span class="line">QString y = x.left ( <span class="number">4</span> ); <span class="comment">/* y is "Pine" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;7. 从中间截取字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString QString::mid ( <span class="keyword">int</span> position, <span class="keyword">int</span> n = <span class="number">-1</span> ) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString x = <span class="string">"Nine pineapples"</span>;</span><br><span class="line">QString y = x.mid ( <span class="number">5</span>, <span class="number">4</span> ); <span class="comment">/* y is "pine" */</span></span><br><span class="line">QString z = x.mid ( <span class="number">5</span> ); <span class="comment">/* z is "pineapples" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;8. 删除字符串中的某个字符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString &amp;QString::remove ( <span class="keyword">int</span> position, <span class="keyword">int</span> n );</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString s = <span class="string">"Montreal"</span>;</span><br><span class="line">s.remove ( <span class="number">1</span>, <span class="number">4</span> ); <span class="comment">/* s is "Meal" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;9. 替换字符串中的某些字符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString &amp;QString::replace ( <span class="keyword">int</span> position, <span class="keyword">int</span> n, <span class="keyword">const</span> QString &amp;after );</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString x = <span class="string">"Say yes!"</span>;</span><br><span class="line">QString y = <span class="string">"no"</span>;</span><br><span class="line">x.replace ( <span class="number">4</span>, <span class="number">3</span>, y ); <span class="comment">/* x is "Say no!" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;10. 把整型、浮点型或其他类型转化为<code>QString</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString &amp;QString::setNum ( uint n, <span class="keyword">int</span> base = <span class="number">10</span> );</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="QString与“char-”之间的转换"><a href="#QString与“char-”之间的转换" class="headerlink" title="QString与“char *”之间的转换"></a>QString与“char *”之间的转换</h3><p>&emsp;&emsp;1. <code>QString</code>转换为<code>char *</code>。<br>&emsp;&emsp;先将<code>QString</code>转换为<code>QByteArray</code>，再将<code>QByteArray</code>转换为<code>char *</code>。注意，不能用下面的转换形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *mm = str.toLatin1().data();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. <code>char *</code>转换为<code>QString</code>。<br>&emsp;&emsp;可以使用<code>QString</code>的构造函数进行转换，即<code>QString(const QLatin1String &amp;str);</code>，<code>QLatin1String</code>的构造函数为<code>QLatin1String(const char *str);</code>。如下语句是将<code>char * mm</code>转换为<code>QString str</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = QString ( QLatin1String ( mm ) );</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtGui/QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QString&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    QString str = “hello”; <span class="comment">/* QString转“char *” */</span></span><br><span class="line">    QByteArray ba = str.toLatin1();</span><br><span class="line">    <span class="keyword">char</span> *mm = ba.data();</span><br><span class="line">    qDebug() &lt;&lt; mm &lt;&lt; <span class="built_in">endl</span>; <span class="comment">/* 调试时，在console中输出 */</span></span><br><span class="line">    QString nn = QString ( QLatin1String ( mm ) ); <span class="comment">/* “char *”转QString */</span></span><br><span class="line">    qDebug() &lt;&lt; nn &lt;&lt; <span class="built_in">endl</span>; <span class="comment">/* 调试时，在console中输出 */</span></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="如何使用QString-arg？"><a href="#如何使用QString-arg？" class="headerlink" title="如何使用QString::arg？"></a>如何使用QString::arg？</h3><p>&emsp;&emsp;<code>QString::arg</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString QString::arg ( <span class="keyword">const</span> QString &amp;a, <span class="keyword">int</span> fieldWidth = <span class="number">0</span>, \</span><br><span class="line">                       <span class="keyword">const</span> QChar &amp;fillChar = QLatin1Char ( <span class="string">' '</span> ) ) <span class="keyword">const</span></span><br></pre></td></tr></table></figure>
<p>功能为<code>Returns a copy of this string with the lowest numbered place marker replaced by string a, i.e., %1, %2, ..., %99.</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QString i = <span class="string">"5"</span>; <span class="comment">/* current file's number */</span></span><br><span class="line">QString total = <span class="string">"10"</span>; <span class="comment">/* number of files to process */</span></span><br><span class="line">QString fileName = <span class="string">"lyc.txt"</span>; <span class="comment">/* current file's name */</span></span><br><span class="line">QString status = QString ( <span class="string">"Processing file %1 of %2: %3"</span> ).arg ( i ).arg ( total ).arg ( fileName );</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"status:"</span> &lt;&lt; status;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status: <span class="string">"Processing file 5 of 10: lyc.txt"</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="String和QString之间的转化"><a href="#String和QString之间的转化" class="headerlink" title="String和QString之间的转化"></a>String和QString之间的转化</h3><p>&emsp;&emsp;代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString qstr;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">str = qstr.toStdString();</span><br><span class="line">qstr = QString::fromStdString ( str );</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/31/Qt语法详解/Qt之QList/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/31/Qt语法详解/Qt之QList/" itemprop="url">Qt之QList</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-31T19:46:43+08:00">
                2019-01-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QList</code> class is a template class that provides lists.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QList</code></td>
<td><code>QItemSelection</code>, <code>QQueue</code>, <code>QSignalSpy</code>, <code>QStringList</code> and <code>QTestEventList</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QList()</code></td>
</tr>
<tr>
<td></td>
<td><code>QList(const QList&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td></td>
<td><code>QList(std::initializer_list&lt;T&gt; args)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QList()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>append(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>append(const QList&lt;T&gt; &amp; value)</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>at(int i) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>back()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>back() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>begin()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constBegin() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constEnd() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>contains(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>empty() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>end()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>endsWith(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator pos)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator begin, iterator end)</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>first()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>first() const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>front()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>front() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>indexOf(const T &amp; value, int from = 0) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insert(int i, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insert(iterator before, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>last()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>last() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lastIndexOf(const T &amp; value, int from = -1) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>length() const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>mid(int pos, int length = -1) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>move(int from, int to)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>pop_back()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>pop_front()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>prepend(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>push_back(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>push_front(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>removeAll(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeAt(int i)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeFirst()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeLast()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>removeOne(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>replace(int i, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>reserve(int alloc)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>startsWith(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(QList&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(int i, int j)</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>takeAt(int i)</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>takeFirst()</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>takeLast()</code></td>
</tr>
<tr>
<td><code>QSet&lt;T&gt;</code></td>
<td><code>toSet() const</code></td>
</tr>
<tr>
<td><code>std::list&lt;T&gt;</code></td>
<td><code>toStdList() const</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>toVector() const</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>value(int i) const</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>value(int i, const T &amp; defaultValue) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QList&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>operator+(const QList&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt; &amp;</code></td>
<td><code>operator+=(const QList&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt; &amp;</code></td>
<td><code>operator+=(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt; &amp;</code></td>
<td><code>operator&lt;&lt;(const QList&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt; &amp;</code></td>
<td><code>operator&lt;&lt;(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt; &amp;</code></td>
<td><code>operator=(const QList&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QList &amp;</code></td>
<td><code>operator=(QList &amp;&amp; other)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QList&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>operator[](int i)</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>operator[](int i) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Static-Public-Members"><a href="#Static-Public-Members" class="headerlink" title="Static Public Members"></a>Static Public Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>fromSet ( const QSet&lt;T&gt; &amp;set );</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>fromStdList ( const std::list&lt;T&gt; &amp;list );</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>fromVector ( const QVector&lt;T&gt; &amp;vector );</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&lt;&lt; ( QDataStream &amp;out, const QList&lt;T&gt; &amp;list );</code></td>
</tr>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&gt;&gt; ( QDataStream &amp;in, QList&lt;T&gt; &amp;list );</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QList</code> class is a template class that provides lists.<br>&emsp;&emsp;<code>QList&lt;T&gt;</code> is one of <code>Qt&#39;s</code> generic container classes. It stores a list of values and provides fast <code>index-based</code> access as well as fast insertions and removals.<br>&emsp;&emsp;<code>QList&lt;T&gt;</code>, <code>QLinkedList&lt;T&gt;</code>, and <code>QVector&lt;T&gt;</code> provide similar functionality. Here’s an overview:<br>&emsp;&emsp;For most purposes, <code>QList</code> is the right class to use. Its <code>index-based</code> <code>API</code> is more convenient than <code>QLinkedList&#39;s</code> <code>iterator-based</code> <code>API</code>, and it is usually faster than <code>QVector</code> because of the way it stores its items in memory. It also expands to less code in your executable.<br>&emsp;&emsp;If you need a real linked list, with guarantees of constant time insertions in the middle of the list and iterators to items rather than indexes, use <code>QLinkedList</code>.<br>&emsp;&emsp;If you want the items to occupy adjacent memory positions, use <code>QVector</code>.<br>&emsp;&emsp;Internally, <code>QList&lt;T&gt;</code> is represented as an array of pointers to items of type <code>T</code>. If <code>T</code> is itself a pointer type or a basic type that is no larger than a pointer, or if <code>T</code> is one of Qt’s shared classes, then <code>QList&lt;T&gt;</code> stores the items directly in the pointer array. For lists under a thousand items, this array representation allows for very fast insertions in the middle, and it allows <code>index-based</code> access. Furthermore, operations like <code>prepend()</code> and <code>append()</code> are very fast, because <code>QList</code> preallocates memory at both ends of its internal array. Note, however, that for unshared list items that are larger than a pointer, each append or insert of a new item requires allocating the new item on the heap, and this per item allocation might make <code>QVector</code> a better choice in cases that do lots of appending or inserting, since <code>QVector</code> allocates memory for its items in a single heap allocation.<br>&emsp;&emsp;Note that the internal array only ever gets bigger over the life of the list. It never shrinks. The internal array is deallocated by the destructor, by <code>clear()</code>, and by the assignment operator, when one list is assigned to another.<br>&emsp;&emsp;Here’s an example of a <code>QList</code> that stores integers and a <code>QList</code> that stores <code>QDate</code> values:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;<span class="keyword">int</span>&gt; integerList;</span><br><span class="line">QList&lt;QDate&gt; dateList;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Qt includes a <code>QStringList</code> class that inherits <code>QList&lt;QString&gt;</code> and adds a convenience function <code>QStringList::join()</code> (<code>QString::split()</code> creates <code>QStringLists</code> from strings).<br>&emsp;&emsp;<code>QList</code> stores a list of items. The default constructor creates an empty list. To insert items into the list, you can use <code>operator&lt;&lt;()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "one" &lt;&lt; "two" &lt;&lt; "three"; /* <span class="built_in">list</span>: ["one", "two", "three"] */</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>QList</code> provides these basic functions to add, move, and remove items: <code>insert()</code>, <code>replace()</code>, <code>removeAt()</code>, <code>move()</code>, and <code>swap()</code>. In addition, it provides the following convenience functions: <code>append()</code>, <code>prepend()</code>, <code>removeFirst()</code> and <code>removeLast()</code>.<br>&emsp;&emsp;<code>QList</code> uses <code>0-based</code> indexes, just like <code>C++</code> arrays. To access the item at a particular index position, you can use <code>operator[]()</code>. On <code>non-const</code> lists, <code>operator[]()</code> returns a reference to the item and can be used on the left side of an assignment:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">list</span>[<span class="number">0</span>] == <span class="string">"Bob"</span> ) &#123;</span><br><span class="line">    <span class="built_in">list</span>[<span class="number">0</span>] = <span class="string">"Robert"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Because <code>QList</code> is implemented as an array of pointers, this operation is very fast (constant time). For <code>read-only</code> access, an alternative syntax is to use <code>at()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">list</span>.at ( i ) == <span class="string">"Jane"</span> ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found Jane at position "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>at()</code> can be faster than <code>operator[]()</code>, because it never causes a deep copy to occur.<br>&emsp;&emsp;A common requirement is to remove an item from a list and do something with it. For this, <code>QList</code> provides <code>takeAt()</code>, <code>takeFirst()</code>, and <code>takeLast()</code>. Here’s a loop that removes the items from a list one at a time and calls delete on them:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QWidget *&gt; <span class="built_in">list</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( !<span class="built_in">list</span>.isEmpty() ) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">list</span>.takeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Inserting and removing items at either ends of the list is very fast (constant time in most cases), because <code>QList</code> preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.<br>&emsp;&emsp;If you want to find all occurrences of a particular value in a list, use <code>indexOf()</code> or <code>lastIndexOf()</code>. The former searches forward starting from a given index position, the latter searches backward. Both return the index of a matching item if they find it; otherwise, they return <code>-1</code>. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="built_in">list</span>.indexOf ( <span class="string">"Jane"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( i != <span class="number">-1</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"First occurrence of Jane is at position "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If you simply want to check whether a list contains a particular value, use <code>contains()</code>. If you want to find out how many times a particular value occurs in the list, use <code>count()</code>. If you want to replace all occurrences of a particular value with another, use <code>replace()</code>.<br>&emsp;&emsp;<code>QList&#39;s</code> value type must be an assignable data type. This covers most data types that are commonly used, but the compiler won’t let you, for example, store a <code>QWidget</code> as a value; instead, store a <code>QWidget *</code>. A few functions have additional requirements; for example, <code>indexOf()</code> and <code>lastIndexOf()</code> expect the value type to support <code>operator==()</code>. These requirements are documented on a <code>per-function</code> basis.<br>&emsp;&emsp;Like the other container classes, <code>QList</code> provides <code>Java-style</code> iterators (<code>QListIterator</code> and <code>QMutableListIterator</code>) and <code>STL-style</code> iterators (<code>QList::const_iterator</code> and <code>QList::iterator</code>). In practice, these are rarely used, because you can use indexes into the <code>QList</code>. <code>QList</code> is implemented in such a way that direct <code>index-based</code> access is just as fast as using iterators.<br>&emsp;&emsp;<code>QList</code> does not support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.<br>&emsp;&emsp;To make <code>QList</code> as efficient as possible, its member functions don’t validate their input before using it. Except for <code>isEmpty()</code>, member functions always assume the list is not empty. Member functions that take index values as parameters always assume their index value parameters are in the valid range. This means <code>QList</code> member functions can fail. If you define <code>QT_NO_DEBUG</code> when you compile, failures will not be detected. If you don’t define <code>QT_NO_DEBUG</code>, failures will be detected using <code>Q_ASSERT()</code> or <code>Q_ASSERT_X()</code> with an appropriate message.<br>&emsp;&emsp;To avoid failures when your list can be empty, call <code>isEmpty()</code> before calling other member functions. If you must pass an index value that might not be in the valid range, check that it is less than the value returned by <code>size()</code> but not less than <code>0</code>.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>typedef <code>QList::ConstIterator</code>: <code>Qt-style</code> synonym for <code>QList::const_iterator</code>.</li>
<li>typedef <code>QList::Iterator</code>: <code>Qt-style</code> synonym for <code>QList::iterator</code>.</li>
<li>typedef <code>QList::const_pointer</code>: Typedef for <code>const T *</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::const_reference</code>: Typedef for <code>const T &amp;</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::difference_type</code>: Typedef for <code>ptrdiff_t</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::pointer</code>: Typedef for <code>T *</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::reference</code>: Typedef for <code>T &amp;</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::size_type</code>: Typedef for <code>int</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::value_type</code>: Typedef for <code>T</code>. Provided for <code>STL</code> compatibility.</li>
</ul>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QList::QList()</code>: Constructs an empty list.</li>
<li><code>QList::QList(const QList&lt;T&gt; &amp; other)</code>: Constructs a copy of <code>other</code>. This operation takes constant time, because <code>QList</code> is implicitly shared. This makes returning a <code>QList</code> from a function very fast. If a shared instance is modified, it will be copied (<code>copy-on-write</code>), and that takes linear time.</li>
<li><code>QList::QList(std::initializer_list&lt;T&gt; args)</code>: Construct a list from the <code>std::initializer_list specified</code> by <code>args</code>. This constructor is only enabled if the compiler supports <code>C++0x</code>.</li>
<li><code>QList::~QList()</code>: Destroys the list. References to the values in the list and all iterators of this list become invalid.</li>
<li><code>void QList::append(const T &amp; value)</code>: Inserts <code>value</code> at the end of the list. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span>.append ( <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">list</span>.append ( <span class="string">"two"</span> );</span><br><span class="line"><span class="built_in">list</span>.append ( <span class="string">"three"</span> ); <span class="comment">/* list: ["one", "two", "three"] */</span></span><br></pre></td></tr></table></figure>
<p>This is the same as <code>list.insert(size(), value)</code>. This operation is typically very fast (constant time), because <code>QList</code> preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.</p>
<ul>
<li><code>void QList::append(const QList&lt;T&gt; &amp; value)</code>: This is an overloaded function. Appends the items of the <code>value</code> list to this list.</li>
<li><code>const T &amp; QList::at(int i) const</code>: Returns the item at index position <code>i</code> in the list. <code>i</code> must be a valid index position in the list (i.e., <code>0 &lt;= i &lt; size()</code>). This function is very fast (constant time).</li>
<li><code>T &amp; QList::back()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>last()</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>const T &amp; QList::back() const</code>: This is an overloaded function.</li>
<li><code>iterator QList::begin()</code>: Returns an <code>STL-style</code> iterator pointing to the first item in the list.</li>
<li><code>const_iterator QList::begin() const</code>: This is an overloaded function.</li>
<li><code>void QList::clear()</code>: Removes all items from the list.</li>
<li><code>const_iterator QList::constBegin() const</code>: Returns a const <code>STL-style</code> iterator pointing to the first item in the list.</li>
<li><code>const_iterator QList::constEnd() const</code>: Returns a const <code>STL-style</code> iterator pointing to the imaginary item after the last item in the list.</li>
<li><code>bool QList::contains(const T &amp; value) const</code>: Returns <code>true</code> if the list contains an occurrence of <code>value</code>; otherwise returns <code>false</code>. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>int QList::count(const T &amp; value) const</code>: Returns the number of occurrences of <code>value</code> in the list. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>int QList::count() const</code>: Returns the number of items in the list. This is effectively the same as <code>size()</code>.</li>
<li><code>bool QList::empty() const</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>isEmpty()</code> and returns <code>true</code> if the list is empty.</li>
<li><code>iterator QList::end()</code>: Returns an <code>STL-style</code> iterator pointing to the imaginary item after the last item in the list.</li>
<li><code>const_iterator QList::end() const</code>: This is an overloaded function.</li>
<li><code>bool QList::endsWith(const T &amp; value) const</code>: Returns <code>true</code> if this list is not empty and its last item is equal to <code>value</code>; otherwise returns <code>false</code>.</li>
<li><code>iterator QList::erase(iterator pos)</code>: Removes the item associated with the iterator <code>pos</code> from the list, and returns an iterator to the next item in the list (which may be <code>end()</code>).</li>
<li><code>iterator QList::erase(iterator begin, iterator end)</code>: This is an overloaded function. Removes all the items from <code>begin</code> up to (but not including) <code>end</code>. Returns an iterator to the same item that end referred to before the call.</li>
<li><code>T &amp; QList::first()</code>: Returns a reference to the first item in the list. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>const T &amp; QList::first() const</code>: This is an overloaded function.</li>
<li><code>QList&lt;T&gt; QList::fromSet(const QSet&lt;T&gt; &amp; set) [static]</code>: Returns a <code>QList</code> object with the data contained in <code>set</code>. The order of the elements in the <code>QList</code> is undefined. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QSet&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line"><span class="built_in">set</span> &lt;&lt; 20 &lt;&lt; 30 &lt;&lt; 40 &lt;&lt; ... &lt;&lt; 70;</span><br><span class="line">​</span><br><span class="line">QList&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span> = QList&lt;<span class="keyword">int</span>&gt;::fromSet ( <span class="built_in">set</span> );</span><br><span class="line">qSort ( <span class="built_in">list</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QList&lt;T&gt; QList::fromStdList(const std::list&lt;T&gt; &amp; list) [static]</code>: Returns a <code>QList</code> object with the data contained in <code>list</code>. The order of the elements in the <code>QList</code> is the same as in <code>list</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; stdlist;</span><br><span class="line"><span class="built_in">list</span>.push_back ( <span class="number">1.2</span> );</span><br><span class="line"><span class="built_in">list</span>.push_back ( <span class="number">0.5</span> );</span><br><span class="line"><span class="built_in">list</span>.push_back ( <span class="number">3.14</span> );</span><br><span class="line">​</span><br><span class="line">QList&lt;<span class="keyword">double</span>&gt; <span class="built_in">list</span> = QList&lt;<span class="keyword">double</span>&gt;::fromStdList ( stdlist );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QList&lt;T&gt; QList::fromVector(const QVector&lt;T&gt; &amp; vector) [static]</code>: Returns a <code>QList</code> object with the data contained in <code>vector</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">double</span>&gt; vect;</span><br><span class="line">vect &lt;&lt; <span class="number">20.0</span> &lt;&lt; <span class="number">30.0</span> &lt;&lt; <span class="number">40.0</span> &lt;&lt; <span class="number">50.0</span>;</span><br><span class="line">​</span><br><span class="line">QList&lt;<span class="keyword">double</span>&gt; <span class="built_in">list</span> = QVector&lt;T&gt;::fromVector ( vect ); <span class="comment">/* list: [20.0, 30.0, 40.0, 50.0] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>T &amp; QList::front()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>first()</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>const T &amp; QList::front() const</code>: This is an overloaded function.</li>
<li><code>int QList::indexOf(const T &amp; value, int from = 0) const</code>: Returns the index position of the first occurrence of <code>value</code> in the list, searching forward from index position <code>from</code>. Returns <code>-1</code> if no item matched. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "B" &lt;&lt; "A";</span><br><span class="line"><span class="built_in">list</span>.indexOf ( "B" ); /* returns 1 */</span><br><span class="line"><span class="built_in">list</span>.indexOf ( "B", 1 ); /* returns 1 */</span><br><span class="line"><span class="built_in">list</span>.indexOf ( "B", 2 ); /* returns 3 */</span><br><span class="line"><span class="built_in">list</span>.indexOf ( "X" ); /* returns -1 */</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>. Note that <code>QList</code> uses <code>0-based</code> indexes, just like <code>C++</code> arrays. Negative indexes are not supported with the exception of the value mentioned above.</p>
<ul>
<li><code>void QList::insert(int i, const T &amp; value)</code>: Inserts <code>value</code> at index position <code>i</code> in the list. If <code>i</code> is <code>0</code>, the <code>value</code> is prepended to the list. If <code>i</code> is <code>size()</code>, the <code>value</code> is appended to the list. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "alpha" &lt;&lt; "beta" &lt;&lt; "delta";</span><br><span class="line"><span class="built_in">list</span>.insert ( 2, "gamma" ); /* <span class="built_in">list</span>: ["alpha", "beta", "gamma", "delta"] */</span><br></pre></td></tr></table></figure>
<ul>
<li><code>iterator QList::insert(iterator before, const T &amp; value)</code>: This is an overloaded function. Inserts <code>value</code> in front of the item pointed to by the iterator <code>before</code>. Returns an iterator pointing at the inserted item. Note that the iterator passed to the function will be invalid after the call; the returned iterator should be used instead.</li>
<li><code>bool QList::isEmpty() const</code>: Returns <code>true</code> if the list contains no items; otherwise returns <code>false</code>.</li>
<li><code>T &amp; QList::last()</code>: Returns a reference to the last item in the list. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>const T &amp; QList::last() const</code>: This is an overloaded function.</li>
<li><code>int QList::lastIndexOf(const T &amp; value, int from = -1) const</code>: Returns the index position of the last occurrence of <code>value</code> in the list, searching backward from index position <code>from</code>. If <code>from</code> is <code>-1</code> (the default), the search starts at the last item. Returns <code>-1</code> if no item matched. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "B" &lt;&lt; "A";</span><br><span class="line"><span class="built_in">list</span>.lastIndexOf ( "B" ); /* returns 3 */</span><br><span class="line"><span class="built_in">list</span>.lastIndexOf ( "B", 3 ); /* returns 3 */</span><br><span class="line"><span class="built_in">list</span>.lastIndexOf ( "B", 2 ); /* returns 1 */</span><br><span class="line"><span class="built_in">list</span>.lastIndexOf ( "X" ); /* returns -1 */</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>. Note that <code>QList</code> uses <code>0-based</code> indexes, just like <code>C++</code> arrays. Negative indexes are not supported with the exception of the value mentioned above.</p>
<ul>
<li><code>int QList::length() const</code>: This function is identical to <code>count()</code>.</li>
<li><code>QList&lt;T&gt; QList::mid(int pos, int length = -1) const</code>: Returns a list whose elements are copied from this list, starting at position <code>pos</code>. If <code>length</code> is <code>-1</code> (the default), all elements from <code>pos</code> are copied; otherwise <code>length</code> elements (or all remaining elements if there are less than <code>length</code> elements) are copied.</li>
<li><code>void QList::move(int from, int to)</code>: Moves the item at index position <code>from</code> to index position <code>to</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "D" &lt;&lt; "E" &lt;&lt; "F";</span><br><span class="line"><span class="built_in">list</span>.move ( 1, 4 ); /* <span class="built_in">list</span>: ["A", "C", "D", "E", "B", "F"] */</span><br></pre></td></tr></table></figure>
<p>This is the same as <code>insert(to, takeAt(from))</code>. This function assumes that both from and to are at least <code>0</code> but less than <code>size()</code>. To avoid failure, test that both from and to are at least <code>0</code> and less than <code>size()</code>.</p>
<ul>
<li><code>void QList::pop_back()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>removeLast()</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>void QList::pop_front()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>removeFirst()</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>void QList::prepend(const T &amp; value)</code>: Inserts <code>value</code> at the beginning of the list. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span>.prepend ( <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">list</span>.prepend ( <span class="string">"two"</span> );</span><br><span class="line"><span class="built_in">list</span>.prepend ( <span class="string">"three"</span> ); <span class="comment">/* list: ["three", "two", "one"] */</span></span><br></pre></td></tr></table></figure>
<p>This is the same as <code>list.insert(0, value)</code>. This operation is usually very fast (constant time), because <code>QList</code> preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.</p>
<ul>
<li><code>void QList::push_back(const T &amp; value)</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>append(value)</code>.</li>
<li><code>void QList::push_front(const T &amp; value)</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>prepend(value)</code>.</li>
<li><code>int QList::removeAll(const T &amp; value)</code>: Removes all occurrences of <code>value</code> in the list and returns the number of entries removed. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "sun" &lt;&lt; "cloud" &lt;&lt; "sun" &lt;&lt; "rain";</span><br><span class="line"><span class="built_in">list</span>.removeAll("sun"); /* <span class="built_in">list</span>: ["cloud", "rain"] */</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>.</p>
<ul>
<li><code>void QList::removeAt(int i)</code>: Removes the item at index position <code>i</code>. <code>i</code> must be a valid index position in the list (i.e., <code>0 &lt;= i &lt; size()</code>).</li>
<li><code>void QList::removeFirst()</code>: Removes the first item in the list. Calling this function is equivalent to calling <code>removeAt(0)</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>void QList::removeLast()</code>: Removes the last item in the list. Calling this function is equivalent to calling <code>removeAt(size() - 1)</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>bool QList::removeOne(const T &amp; value)</code>: Removes the first occurrence of <code>value</code> in the list and returns <code>true</code> on success; otherwise returns <code>false</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "sun" &lt;&lt; "cloud" &lt;&lt; "sun" &lt;&lt; "rain";</span><br><span class="line"><span class="built_in">list</span>.removeOne("sun"); /* <span class="built_in">list</span>: ["cloud", ,"sun", "rain"] */</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>.</p>
<ul>
<li><code>void QList::replace(int i, const T &amp; value)</code>: Replaces the item at index position <code>i</code> with <code>value</code>. <code>i</code> must be a valid index position in the list (i.e., <code>0 &lt;= i &lt; size()</code>).</li>
<li><code>void QList::reserve(int alloc)</code>: Reserve space for <code>alloc</code> elements. If <code>alloc</code> is smaller than the current size of the list, nothing will happen. Use this function to avoid repetetive reallocation of <code>QList&#39;s</code> internal data if you can predict how many elements will be appended. Note that the reservation applies only to the internal pointer array.</li>
<li><code>int QList::size() const</code>: Returns the number of items in the list.</li>
<li><code>bool QList::startsWith(const T &amp; value) const</code>: Returns <code>true</code> if this list is not empty and its first item is equal to <code>value</code>; otherwise returns <code>false</code>.</li>
<li><code>void QList::swap(QList&lt;T&gt; &amp; other)</code>: Swaps list <code>other</code> with this list. This operation is very fast and never fails.</li>
<li><code>void QList::swap(int i, int j)</code>: Exchange the item at index position <code>i</code> with the item at index position <code>j</code>. This function assumes that both <code>i</code> and <code>j</code> are at least <code>0</code> but less than <code>size()</code>. To avoid failure, test that both <code>i</code> and <code>j</code> are at least <code>0</code> and less than <code>size()</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "D" &lt;&lt; "E" &lt;&lt; "F";</span><br><span class="line"><span class="built_in">list</span>.swap ( 1, 4 ); /* <span class="built_in">list</span>: ["A", "E", "C", "D", "B", "F"] */</span><br></pre></td></tr></table></figure>
<ul>
<li><code>T QList::takeAt(int i)</code>: Removes the item at index position <code>i</code> and returns it. <code>i</code> must be a valid index position in the list (i.e., <code>0 &lt;= i &lt; size()</code>). If you don’t use the return value, <code>removeAt()</code> is more efficient.</li>
<li><code>T QList::takeFirst()</code>: Removes the first item in the list and returns it. This is the same as <code>takeAt(0)</code>. This function assumes the list is not empty. To avoid failure, call <code>isEmpty()</code> before calling this function. This operation takes constant time. If you don’t use the return value, <code>removeFirst()</code> is more efficient.</li>
<li><code>T QList::takeLast()</code>: Removes the last item in the list and returns it. This is the same as <code>takeAt(size() - 1)</code>. This function assumes the list is not empty. To avoid failure, call <code>isEmpty()</code> before calling this function. This operation takes constant time. If you don’t use the return value, <code>removeLast()</code> is more efficient.</li>
<li><code>QSet&lt;T&gt; QList::toSet() const</code>: Returns a <code>QSet</code> object with the data contained in this <code>QList</code>. Since <code>QSet</code> doesn’t allow duplicates, the resulting <code>QSet</code> might be smaller than the original list was. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QStringList <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "Julia" &lt;&lt; "Mike" &lt;&lt; "Mike" &lt;&lt; "Julia" &lt;&lt; "Julia";</span><br><span class="line">​</span><br><span class="line">QSet&lt;QString&gt; <span class="built_in">set</span> = <span class="built_in">list</span>.toSet();</span><br><span class="line"><span class="built_in">set</span>.contains ( <span class="string">"Julia"</span> ); <span class="comment">/* returns true */</span></span><br><span class="line"><span class="built_in">set</span>.contains ( <span class="string">"Mike"</span> ); <span class="comment">/* returns true */</span></span><br><span class="line"><span class="built_in">set</span>.size(); <span class="comment">/* returns 2 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::list&lt;T&gt; QList::toStdList() const</code>: Returns a <code>std::list</code> object with the data contained in this <code>QList</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;<span class="keyword">double</span>&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; 1.2 &lt;&lt; 0.5 &lt;&lt; 3.14;</span><br><span class="line">​</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; stdlist = <span class="built_in">list</span>.toStdList();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QVector&lt;T&gt; QList::toVector() const</code>: Returns a <code>QVector</code> object with the data contained in this <code>QList</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QStringList <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "Sven" &lt;&lt; "Kim" &lt;&lt; "Ola";</span><br><span class="line">​</span><br><span class="line">QVector&lt;QString&gt; vect = <span class="built_in">list</span>.toVector(); <span class="comment">/* vect: ["Sven", "Kim", "Ola"] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>T QList::value(int i) const</code>: Returns the value at index position <code>i</code> in the list. If the index <code>i</code> is out of bounds, the function returns a <code>default-constructed</code> value. If you are certain that the index is going to be within bounds, you can use <code>at()</code> instead, which is slightly faster.</li>
<li><code>T QList::value(int i, const T &amp; defaultValue) const</code>: This is an overloaded function. If the index <code>i</code> is out of bounds, the function returns <code>defaultValue</code>.</li>
<li><code>bool QList::operator!=(const QList&lt;T&gt; &amp; other) const</code>: Returns <code>true</code> if other is not equal to this list; otherwise returns <code>false</code>. Two lists are considered equal if they contain the same values in the same order. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>QList&lt;T&gt; QList::operator+(const QList&lt;T&gt; &amp; other) const</code>: Returns a list that contains all the items in this list followed by all the items in the <code>other</code> list.</li>
<li><code>QList&lt;T&gt; &amp; QList::operator+=(const QList&lt;T&gt; &amp; other)</code>: Appends the items of the <code>other</code> list to this list and returns a reference to this list.</li>
<li><code>QList&lt;T&gt; &amp; QList::operator+=(const T &amp; value)</code>: This is an overloaded function. Appends <code>value</code> to the list.</li>
<li><code>QList&lt;T&gt; &amp; QList::operator&lt;&lt;(const QList&lt;T&gt; &amp; other)</code>: Appends the items of the <code>other</code> list to this list and returns a reference to this list.</li>
<li><code>QList&lt;T&gt; &amp; QList::operator&lt;&lt;(const T &amp; value)</code>: This is an overloaded function. Appends <code>value</code> to the list.</li>
<li><code>QList&lt;T&gt; &amp; QList::operator=(const QList&lt;T&gt; &amp; other)</code>: Assigns <code>other</code> to this list and returns a reference to this list.</li>
<li><code>bool QList::operator==(const QList&lt;T&gt; &amp; other) const</code>: Returns <code>true</code> if <code>other</code> is equal to this list; otherwise returns <code>false</code>. Two lists are considered equal if they contain the same values in the same order. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>T &amp; QList::operator[](int i)</code>: Returns the item at index position <code>i</code> as a modifiable reference. <code>i</code> must be a valid index position in the list (i.e., <code>0 &lt;= i &lt; size()</code>). This function is very fast (constant time).</li>
<li><code>const T &amp; QList::operator[](int i) const</code>: This is an overloaded function. Same as <code>at()</code>.</li>
</ul>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; out, const QList&lt;T&gt; &amp; list)</code>: Writes the <code>list</code> to stream <code>out</code>. This function requires the value type to implement <code>operator&lt;&lt;()</code>.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; in, QList&lt;T&gt; &amp; list)</code>: Reads a list from stream <code>in</code> into <code>list</code>. This function requires the value type to implement <code>operator&gt;&gt;()</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/30/Qt语法详解/Qt之QVector/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/30/Qt语法详解/Qt之QVector/" itemprop="url">Qt之QVector</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-30T20:04:17+08:00">
                2019-01-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QVector</code> class is a template class that provides a dynamic array.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QVector</code></td>
<td><code>Q3ValueVector</code>, <code>QPolygon</code>, <code>QPolygonF</code>, <code>QStack</code>, and <code>QXmlStreamAttributes</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QVector()</code></td>
</tr>
<tr>
<td></td>
<td><code>QVector(int size)</code></td>
</tr>
<tr>
<td></td>
<td><code>QVector(int size, const T &amp; value)</code></td>
</tr>
<tr>
<td></td>
<td><code>QVector(const QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td></td>
<td><code>QVector(std::initializer_list&lt;T&gt; args)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QVector()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>append(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>at(int i) const</code></td>
</tr>
<tr>
<td><code>reference</code></td>
<td><code>back()</code></td>
</tr>
<tr>
<td><code>const_reference</code></td>
<td><code>back() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>begin()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>capacity() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constBegin() const</code></td>
</tr>
<tr>
<td><code>const T *</code></td>
<td><code>constData() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constEnd() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>contains(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count() const</code></td>
</tr>
<tr>
<td><code>T *</code></td>
<td><code>data()</code></td>
</tr>
<tr>
<td><code>const T *</code></td>
<td><code>data() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>empty() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>end()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>endsWith(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator pos)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator begin, iterator end)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>fill(const T &amp; value, int size = -1)</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>first()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>first() const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>front()</code></td>
</tr>
<tr>
<td><code>const_reference</code></td>
<td><code>front() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>indexOf(const T &amp; value, int from = 0) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insert(int i, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insert(iterator before, int count, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insert(int i, int count, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insert(iterator before, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>last()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>last() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lastIndexOf(const T &amp; value, int from = -1) const</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>mid(int pos, int length = -1) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>pop_back()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>pop_front()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>prepend(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>push_back(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>push_front(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>remove(int i)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>remove(int i, int count)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>replace(int i, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>reserve(int size)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>resize(int size)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>squeeze()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>startsWith(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>toList() const</code></td>
</tr>
<tr>
<td><code>std::vector&lt;T&gt;</code></td>
<td><code>toStdVector() const</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>value(int i) const</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>value(int i, const T &amp; defaultValue) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QVector&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>operator+(const QVector&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator+=(const QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator+=(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator&lt;&lt;(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator&lt;&lt;(const QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator=(const QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>operator=(QVector&lt;T&gt; &amp;&amp; other)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QVector&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>operator[](int i)</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>operator[](int i) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Static-Public-Members"><a href="#Static-Public-Members" class="headerlink" title="Static Public Members"></a>Static Public Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>fromList(const QList&lt;T&gt; &amp; list)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>fromStdVector(const std::vector&lt;T&gt; &amp; vector)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&lt;&lt;(QDataStream &amp; out, const QVector&lt;T&gt; &amp; vector)</code></td>
</tr>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&gt;&gt;(QDataStream &amp; in, QVector&lt;T&gt; &amp; vector)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QVector</code> class is a template class that provides a dynamic array.<br>&emsp;&emsp;<code>QVector&lt;T&gt;</code> is one of Qt’s generic container classes. It stores its items in adjacent memory locations and provides fast <code>index-based</code> access.<br>&emsp;&emsp;<code>QList&lt;T&gt;</code>, <code>QLinkedList&lt;T&gt;</code>, and <code>QVarLengthArray&lt;T&gt;</code> provide similar functionality. Here’s an overview:</p>
<ul>
<li>For most purposes, <code>QList</code> is the right class to use. Operations like <code>prepend()</code> and <code>insert()</code> are usually faster than with <code>QVector</code> because of the way <code>QList</code> stores its items in memory, and its <code>index-based</code> <code>API</code> is more convenient than <code>QLinkedList&#39;s</code> <code>iterator-based</code> <code>API</code>. It also expands to less code in your executable.</li>
<li>If you need a real linked list, with guarantees of constant time insertions in the middle of the list and iterators to items rather than indexes, use <code>QLinkedList</code>.</li>
<li>If you want the items to occupy adjacent memory positions, or if your items are larger than a pointer and you want to avoid the overhead of allocating them on the heap individually at insertion time, then use <code>QVector</code>.</li>
<li>If you want a <code>low-level</code> <code>variable-size</code> array, <code>QVarLengthArray</code> may be sufficient.</li>
</ul>
<p>&emsp;&emsp;Here’s an example of a <code>QVector</code> that stores integers and a <code>QVector</code> that stores <code>QString</code> values:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; integerVector;</span><br><span class="line">QVector&lt;QString&gt; stringVector;</span><br></pre></td></tr></table></figure>
<p><code>QVector</code> stores a vector (or array) of items. Typically, vectors are created with an initial size. For example, the following code constructs a <code>QVector</code> with <code>200</code> elements:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span> ( <span class="number">200</span> );</span><br></pre></td></tr></table></figure>
<p>The elements are automatically initialized with a <code>default-constructed</code> value. If you want to initialize the vector with a different value, pass that value as the second argument to the constructor:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span> ( <span class="number">200</span>, <span class="string">"Pass"</span> );</span><br></pre></td></tr></table></figure>
<p>You can also call <code>fill()</code> at any time to fill the vector with a value.<br>&emsp;&emsp;<code>QVector</code> uses <code>0-based</code> indexes, just like <code>C++</code> arrays. To access the item at a particular index position, you can use <code>operator[]()</code>. On <code>non-const</code> vectors, <code>operator[]()</code> returns a reference to the item that can be used on the left side of an assignment:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">vector</span>[<span class="number">0</span>] == <span class="string">"Liz"</span> ) &#123;</span><br><span class="line">    <span class="built_in">vector</span>[<span class="number">0</span>] = <span class="string">"Elizabeth"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For <code>read-only</code> access, an alternative syntax is to use <code>at()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.size(); ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">vector</span>.at ( i ) == <span class="string">"Alfonso"</span> ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found Alfonso at position "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>at()</code> can be faster than <code>operator[]()</code>, because it never causes a deep copy to occur.<br>&emsp;&emsp;Another way to access the data stored in a <code>QVector</code> is to call <code>data()</code>. The function returns a pointer to the first item in the vector. You can use the pointer to directly access and modify the elements stored in the vector. The pointer is also useful if you need to pass a <code>QVector</code> to a function that accepts a plain <code>C++</code> array.<br>&emsp;&emsp;If you want to find all occurrences of a particular value in a vector, use <code>indexOf()</code> or <code>lastIndexOf()</code>. The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return <code>-1</code>. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="built_in">vector</span>.indexOf ( <span class="string">"Harumi"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( i != <span class="number">-1</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"First occurrence of Harumi is at position "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If you simply want to check whether a vector contains a particular value, use <code>contains()</code>. If you want to find out how many times a particular value occurs in the vector, use <code>count()</code>.<br>&emsp;&emsp;<code>QVector</code> provides these basic functions to add, move, and remove items: <code>insert()</code>, <code>replace()</code>, <code>remove()</code>, <code>prepend()</code>, <code>append()</code>. With the exception of <code>append()</code> and <code>replace()</code>, these functions can be slow (linear time) for large vectors, because they require moving many items in the vector by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use <code>QList</code> or <code>QLinkedList</code> instead.<br>&emsp;&emsp;Unlike plain <code>C++</code> arrays, <code>QVectors</code> can be resized at any time by calling <code>resize()</code>. If the new size is larger than the old size, <code>QVector</code> might need to reallocate the whole vector. <code>QVector</code> tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.<br>&emsp;&emsp;If you know in advance approximately how many items the <code>QVector</code> will contain, you can call <code>reserve()</code>, asking <code>QVector</code> to preallocate a certain amount of memory. You can also call <code>capacity()</code> to find out how much memory <code>QVector</code> actually allocated.<br>&emsp;&emsp;Note that using <code>non-const</code> operators and functions can cause <code>QVector</code> to do a deep copy of the data. This is due to implicit sharing.<br>&emsp;&emsp;<code>QVector&#39;s</code> value type must be an assignable data type. This covers most data types that are commonly used, but the compiler won’t let you, for example, store a <code>QWidget</code> as a value; instead, store a <code>QWidget *</code>. A few functions have additional requirements; for example, <code>indexOf()</code> and <code>lastIndexOf()</code> expect the value type to support <code>operator==()</code>. These requirements are documented on a <code>per-function</code> basis.<br>&emsp;&emsp;Like the other container classes, <code>QVector</code> provides <code>Java-style</code> iterators (<code>QVectorIterator</code> and <code>QMutableVectorIterator</code>) and <code>STL-style</code> iterators (<code>QVector::const_iterator</code> and <code>QVector::iterator</code>). In practice, these are rarely used, because you can use indexes into the <code>QVector</code>.<br>&emsp;&emsp;In addition to <code>QVector</code>, Qt also provides <code>QVarLengthArray</code>, a very <code>low-level</code> class with little functionality that is optimized for speed.<br>&emsp;&emsp;<code>QVector</code> does not support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>typedef <code>QVector::ConstIterator</code>: <code>Qt-style</code> synonym for <code>QVector::const_iterator</code>.</li>
<li>typedef <code>QVector::Iterator</code>: <code>Qt-style</code> synonym for <code>QVector::iterator</code>.</li>
<li>typedef <code>QVector::const_iterator</code>: The <code>QVector::const_iterator</code> typedef provides an <code>STL-style</code> const iterator for <code>QVector</code> and <code>QStack</code>. <code>QVector</code> provides both <code>STL-style</code> iterators and <code>Java-style</code> iterators. The <code>STL-style</code> const iterator is simply a typedef for <code>const T *</code> (pointer to <code>const T</code>).</li>
<li>typedef <code>QVector::const_pointer</code>: Typedef for <code>const T *</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::const_reference</code>: Typedef for <code>T &amp;</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::difference_type</code>: Typedef for <code>ptrdiff_t</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::iterator</code>: The <code>QVector::iterator</code> typedef provides an <code>STL-style</code> <code>non-const</code> iterator for <code>QVector</code> and <code>QStack</code>. <code>QVector</code> provides both <code>STL-style</code> iterators and <code>Java-style</code> iterators. The <code>STL-style</code> <code>non-const</code> iterator is simply a typedef for <code>T *</code> (pointer to <code>T</code>).</li>
<li>typedef <code>QVector::pointer</code>: Typedef for <code>T *</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::reference</code>: Typedef for <code>T &amp;</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::size_type</code>: Typedef for <code>int</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::value_type</code>: Typedef for <code>T</code>. Provided for <code>STL</code> compatibility.</li>
</ul>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QVector::QVector()</code>: Constructs an empty vector.</li>
<li><code>QVector::QVector(int size)</code>: Constructs a vector with an initial size of <code>size</code> elements. The elements are initialized with a <code>default-constructed</code> value.</li>
<li><code>QVector::QVector(int size, const T &amp; value)</code>: Constructs a vector with an initial size of <code>size</code> elements. Each element is initialized with <code>value</code>.</li>
<li><code>QVector::QVector(const QVector&lt;T&gt; &amp; other)</code>: Constructs a copy of <code>other</code>. This operation takes constant time, because <code>QVector</code> is implicitly shared. This makes returning a <code>QVector</code> from a function very fast. If a shared instance is modified, it will be copied (<code>copy-on-write</code>), and that takes linear time.</li>
<li><code>QVector::QVector(std::initializer_list&lt;T&gt; args)</code>: Construct a vector from the <code>std::initilizer_list</code> given by <code>args</code>. This constructor is only enabled if the compiler supports <code>C++0x</code>.</li>
<li><code>QVector::~QVector()</code>: Destroys the vector.</li>
<li><code>void QVector::append(const T &amp; value)</code>: Inserts <code>value</code> at the end of the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span> ( <span class="number">0</span> );</span><br><span class="line"><span class="built_in">vector</span>.append ( <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">vector</span>.append ( <span class="string">"two"</span> );</span><br><span class="line"><span class="built_in">vector</span>.append ( <span class="string">"three"</span> ); <span class="comment">/* vector: ["one", "two", "three"] */</span></span><br></pre></td></tr></table></figure>
<p>This is the same as calling <code>resize(size() + 1)</code> and assigning value to the new last element in the vector. This operation is relatively fast, because <code>QVector</code> typically allocates more memory than necessary, so it can grow without reallocating the entire vector each time.</p>
<ul>
<li><code>const T &amp; QVector::at(int i) const</code>: Returns the item at index position <code>i</code> in the vector. <code>i</code> must be a valid index position in the vector (i.e., <code>0 &lt;= i &lt; size()</code>).</li>
<li><code>reference QVector::back()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>last()</code>.</li>
<li><code>const_reference QVector::back() const</code>: This is an overloaded function.</li>
<li><code>iterator QVector::begin()</code>: Returns an <code>STL-style</code> iterator pointing to the first item in the vector.</li>
<li><code>const_iterator QVector::begin() const</code>: This is an overloaded function.</li>
<li><code>int QVector::capacity() const</code>: Returns the maximum number of items that can be stored in the vector without forcing a reallocation. The sole purpose of this function is to provide a means of fine tuning <code>QVector&#39;s</code> memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the vector, call <code>size()</code>.</li>
<li><code>void QVector::clear()</code>: Removes all the elements from the vector and releases the memory used by the vector.</li>
<li><code>const_iterator QVector::constBegin() const</code>: Returns a const <code>STL-style</code> iterator pointing to the first item in the vector.</li>
<li><code>const T * QVector::constData() const</code>: Returns a const pointer to the data stored in the vector. The pointer can be used to access the items in the vector. The pointer remains valid as long as the vector isn’t reallocated. This function is mostly useful to pass a vector to a function that accepts a plain <code>C++</code> array.</li>
<li><code>const_iterator QVector::constEnd() const</code>: Returns a const <code>STL-style</code> iterator pointing to the imaginary item after the last item in the vector.</li>
<li><code>bool QVector::contains(const T &amp; value) const</code>: Returns <code>true</code> if the vector contains an occurrence of <code>value</code>; otherwise returns <code>false</code>. This function requires the <code>value</code> type to have an implementation of <code>operator==()</code>.</li>
<li><code>int QVector::count(const T &amp; value) const</code>: Returns the number of occurrences of <code>value</code> in the vector. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>int QVector::count() const</code>: This is an overloaded function. Same as <code>size()</code>.</li>
<li><code>T * QVector::data()</code>: Returns a pointer to the data stored in the vector. The pointer can be used to access and modify the items in the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; <span class="built_in">vector</span> ( <span class="number">10</span> );</span><br><span class="line"><span class="keyword">int</span> *data = <span class="built_in">vector</span>.data();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i ) &#123;</span><br><span class="line">    data[i] = <span class="number">2</span> * i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The pointer remains valid as long as the vector isn’t reallocated. This function is mostly useful to pass a vector to a function that accepts a plain <code>C++</code> array.</p>
<ul>
<li><code>const T * QVector::data() const</code>: This is an overloaded function.</li>
<li><code>bool QVector::empty() const</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>isEmpty()</code>, returning <code>true</code> if the vector is empty; otherwise returns <code>false</code>.</li>
<li><code>iterator QVector::end()</code>: Returns an <code>STL-style</code> iterator pointing to the imaginary item after the last item in the vector.</li>
<li><code>const_iterator QVector::end() const</code>: This is an overloaded function.</li>
<li><code>bool QVector::endsWith(const T &amp; value) const</code>: Returns <code>true</code> if this vector is not empty and its last item is equal to <code>value</code>; otherwise returns <code>false</code>.</li>
<li><code>iterator QVector::erase(iterator pos)</code>: Removes the item pointed to by the iterator <code>pos</code> from the vector, and returns an iterator to the next item in the vector (which may be <code>end()</code>).</li>
<li><code>iterator QVector::erase(iterator begin, iterator end)</code>: This is an overloaded function. Removes all the items from <code>begin</code> up to (but not including) <code>end</code>. Returns an iterator to the same item that end referred to before the call.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::fill(const T &amp; value, int size = -1)</code>: Assigns <code>value</code> to all items in the vector. If <code>size</code> is different from <code>-1</code> (the default), the vector is resized to <code>size</code> beforehand. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span> ( <span class="number">3</span> );</span><br><span class="line"><span class="built_in">vector</span>.fill ( <span class="string">"Yes"</span> ); <span class="comment">/* vector: ["Yes", "Yes", "Yes"] */</span></span><br><span class="line"><span class="built_in">vector</span>.fill ( <span class="string">"oh"</span>, <span class="number">5</span> ); <span class="comment">/* vector: ["oh", "oh", "oh", "oh", "oh"] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>T &amp; QVector::first()</code>: Returns a reference to the first item in the vector. This function assumes that the vector isn’t empty.</li>
<li><code>const T &amp; QVector::first() const</code>: This is an overloaded function.</li>
<li><code>QVector&lt;T&gt; QVector::fromList(const QList&lt;T&gt; &amp; list) [static]</code>: Returns a <code>QVector</code> object with the data contained in <code>list</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QStringList <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "Sven" &lt;&lt; "Kim" &lt;&lt; "Ola";</span><br><span class="line">QVector&lt;QString&gt; vect = QVector&lt;QString&gt;::fromList ( <span class="built_in">list</span> ); <span class="comment">/* vect: ["Sven", "Kim", "Ola"] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>QVector&lt;T&gt; QVector::fromStdVector(const std::vector&lt;T&gt; &amp; vector) [static]</code>: Returns a <code>QVector</code> object with the data contained in <code>vector</code>. The order of the elements in the <code>QVector</code> is the same as in vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; stdvector;</span><br><span class="line"><span class="built_in">vector</span>.push_back ( <span class="number">1.2</span> );</span><br><span class="line"><span class="built_in">vector</span>.push_back ( <span class="number">0.5</span> );</span><br><span class="line"><span class="built_in">vector</span>.push_back ( <span class="number">3.14</span> );</span><br><span class="line">QVector&lt;<span class="keyword">double</span>&gt; <span class="built_in">vector</span> = QVector&lt;<span class="keyword">double</span>&gt;::fromStdVector ( stdvector );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>T &amp; QVector::front()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>first()</code>.</li>
<li><code>const_reference QVector::front() const</code>: This is an overloaded function.</li>
<li><code>int QVector::indexOf(const T &amp; value, int from = 0) const</code>: Returns the index position of the first occurrence of <code>value</code> in the vector, searching forward <code>from</code> index position <code>from</code>. Returns <code>-1</code> if no item matched. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "B" &lt;&lt; "A";</span><br><span class="line"><span class="built_in">vector</span>.indexOf ( "B" );    // returns 1</span><br><span class="line"><span class="built_in">vector</span>.indexOf ( "B", 1 ); // returns 1</span><br><span class="line"><span class="built_in">vector</span>.indexOf ( "B", 2 ); // returns 3</span><br><span class="line"><span class="built_in">vector</span>.indexOf ( "X" );    // returns -1</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>.</p>
<ul>
<li><code>void QVector::insert(int i, const T &amp; value)</code>: Inserts <code>value</code> at index position <code>i</code> in the vector. If <code>i</code> is <code>0</code>, the <code>value</code> is prepended to the vector. If <code>i</code> is <code>size()</code>, the <code>value</code> is appended to the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; "alpha" &lt;&lt; "beta" &lt;&lt; "delta";</span><br><span class="line"><span class="built_in">vector</span>.insert ( 2, "gamma" ); /* <span class="built_in">vector</span>: ["alpha", "beta", "gamma", "delta"] */</span><br></pre></td></tr></table></figure>
<p>For large vectors, this operation can be slow (linear time), because it requires moving all the items at indexes i and above by one position further in memory. If you want a container class that provides a fast <code>insert()</code> function, use <code>QLinkedList</code> instead.</p>
<ul>
<li><code>iterator QVector::insert(iterator before, int count, const T &amp; value)</code>: Inserts <code>count</code> copies of <code>value</code> in front of the item pointed to by the iterator <code>before</code>. Returns an iterator pointing at the first of the inserted items.</li>
<li><code>void QVector::insert(int i, int count, const T &amp; value)</code>: This is an overloaded function. Inserts <code>count</code> copies of <code>value</code> at index position <code>i</code> in the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">double</span>&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; 2.718 &lt;&lt; 1.442 &lt;&lt; 0.4342;</span><br><span class="line"><span class="built_in">vector</span>.insert ( 1, 3, 9.9 ); /* <span class="built_in">vector</span>: [2.718, 9.9, 9.9, 9.9, 1.442, 0.4342] */</span><br></pre></td></tr></table></figure>
<ul>
<li><code>iterator QVector::insert(iterator before, const T &amp; value)</code>: This is an overloaded function. Inserts <code>value</code> in front of the item pointed to by the iterator <code>before</code>. Returns an iterator pointing at the inserted item.</li>
<li><code>bool QVector::isEmpty() const</code>: Returns <code>true</code> if the vector has size <code>0</code>; otherwise returns <code>false</code>.</li>
<li><code>T &amp; QVector::last()</code>: Returns a reference to the last item in the vector. This function assumes that the vector isn’t empty.</li>
<li><code>const T &amp; QVector::last() const</code>: This is an overloaded function.</li>
<li><code>int QVector::lastIndexOf(const T &amp; value, int from = -1) const</code>: Returns the index position of the last occurrence of the <code>value</code> in the vector, searching backward from index position <code>from</code>. If <code>from</code> is <code>-1</code> (the default), the search starts at the last item. Returns <code>-1</code> if no item matched. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "B" &lt;&lt; "A";</span><br><span class="line"><span class="built_in">vector</span>.lastIndexOf ( "B" );    // returns 3</span><br><span class="line"><span class="built_in">vector</span>.lastIndexOf ( "B", 3 ); // returns 3</span><br><span class="line"><span class="built_in">vector</span>.lastIndexOf ( "B", 2 ); // returns 1</span><br><span class="line"><span class="built_in">vector</span>.lastIndexOf ( "X" );    // returns -1</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>.</p>
<ul>
<li><code>QVector&lt;T&gt; QVector::mid(int pos, int length = -1) const</code>: Returns a vector whose elements are copied from this vector, starting at position <code>pos</code>. If <code>length</code> is <code>-1</code> (the default), all elements after <code>pos</code> are copied; otherwise <code>length</code> elements (or all remaining elements if there are less than <code>length</code> elements) are copied.</li>
<li><code>void QVector::pop_back()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>erase(end() - 1)</code>.</li>
<li><code>void QVector::pop_front()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>erase(begin())</code>.</li>
<li><code>void QVector::prepend(const T &amp; value)</code>: Inserts <code>value</code> at the beginning of the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span>.prepend ( <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">vector</span>.prepend ( <span class="string">"two"</span> );</span><br><span class="line"><span class="built_in">vector</span>.prepend ( <span class="string">"three"</span> ); <span class="comment">/* vector: ["three", "two", "one"] */</span></span><br></pre></td></tr></table></figure>
<p>This is the same as <code>vector.insert(0, value)</code>. For large vectors, this operation can be slow (linear time), because it requires moving all the items in the vector by one position further in memory. If you want a container class that provides a fast <code>prepend()</code> function, use <code>QList</code> or <code>QLinkedList</code> instead.</p>
<ul>
<li><code>void QVector::push_back(const T &amp; value)</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>append(value)</code>.</li>
<li><code>void QVector::push_front(const T &amp; value)</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>prepend(value)</code>.</li>
<li><code>void QVector::remove(int i)</code>: This is an overloaded function. Removes the element at index position <code>i</code>.</li>
<li><code>void QVector::remove(int i, int count)</code>: This is an overloaded function. Removes <code>count</code> elements from the middle of the vector, starting at index position <code>i</code>.</li>
<li><code>void QVector::replace(int i, const T &amp; value)</code>: Replaces the item at index position <code>i</code> with <code>value</code>. <code>i</code> must be a valid index position in the vector (i.e., <code>0 &lt;= i &lt; size()</code>).</li>
<li><code>void QVector::reserve(int size)</code>: Attempts to allocate memory for at least <code>size</code> elements. If you know in advance how large the vector will be, you can call this function, and if you call <code>resize()</code> often you are likely to get better performance. If size is an underestimate, the worst that will happen is that the <code>QVector</code> will be a bit slower. The sole purpose of this function is to provide a means of fine tuning <code>QVector&#39;s</code> memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the vector, call <code>resize()</code>.</li>
<li><code>void QVector::resize(int size)</code>: Sets the size of the vector to <code>size</code>. If <code>size</code> is greater than the current size, elements are added to the end; the new elements are initialized with a <code>default-constructed</code> value. If <code>size</code> is less than the current size, elements are removed from the end.</li>
<li><code>int QVector::size() const</code>: Returns the number of items in the vector.</li>
<li><code>void QVector::squeeze()</code>: Releases any memory not required to store the items. The sole purpose of this function is to provide a means of fine tuning <code>QVector&#39;s</code> memory usage. In general, you will rarely ever need to call this function.</li>
<li><code>bool QVector::startsWith(const T &amp; value) const</code>: Returns <code>true</code> if this vector is not empty and its first item is equal to <code>value</code>; otherwise returns <code>false</code>.</li>
<li><code>void QVector::swap(QVector&lt;T&gt; &amp; other)</code>: Swaps vector <code>other</code> with this vector. This operation is very fast and never fails.</li>
<li><code>QList&lt;T&gt; QVector::toList() const</code>: Returns a <code>QList</code> object with the data contained in this <code>QVector</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; vect;</span><br><span class="line">vect &lt;&lt; <span class="string">"red"</span> &lt;&lt; <span class="string">"green"</span> &lt;&lt; <span class="string">"blue"</span> &lt;&lt; <span class="string">"black"</span>;</span><br><span class="line">QList&lt;QString&gt; <span class="built_in">list</span> = vect.toList(); <span class="comment">/* list: ["red", "green", "blue", "black"] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::vector&lt;T&gt; QVector::toStdVector() const</code>: Returns a <code>std::vector</code> object with the data contained in this <code>QVector</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">double</span>&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; 1.2 &lt;&lt; 0.5 &lt;&lt; 3.14;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; stdvector = <span class="built_in">vector</span>.toStdVector();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>T QVector::value(int i) const</code>: Returns the value at index position <code>i</code> in the vector. If the index <code>i</code> is out of bounds, the function returns a <code>default-constructed</code> value. If you are certain that <code>i</code> is within bounds, you can use <code>at()</code> instead, which is slightly faster.</li>
<li><code>T QVector::value(int i, const T &amp; defaultValue) const</code>: This is an overloaded function. If the index <code>i</code> is out of bounds, the function returns <code>defaultValue</code>.</li>
<li><code>bool QVector::operator!=(const QVector&lt;T&gt; &amp; other) const</code>: Returns <code>true</code> if <code>other</code> is not equal to this vector; otherwise returns <code>false</code>. Two vectors are considered equal if they contain the same values in the same order. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>QVector&lt;T&gt; QVector::operator+(const QVector&lt;T&gt; &amp; other) const</code>: Returns a vector that contains all the items in this vector followed by all the items in the <code>other</code> vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator+=(const QVector&lt;T&gt; &amp; other)</code>: Appends the items of the <code>other</code> vector to this vector and returns a reference to this vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator+=(const T &amp; value)</code>: This is an overloaded function. Appends <code>value</code> to the vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator&lt;&lt;(const T &amp; value)</code>: Appends <code>value</code> to the vector and returns a reference to this vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator&lt;&lt;(const QVector&lt;T&gt; &amp; other)</code>: Appends <code>other</code> to the vector and returns a reference to the vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator=(const QVector&lt;T&gt; &amp; other)</code>: Assigns <code>other</code> to this vector and returns a reference to this vector.</li>
<li><code>bool QVector::operator==(const QVector&lt;T&gt; &amp; other) const</code>: Returns <code>true</code> if <code>other</code> is equal to this vector; otherwise returns <code>false</code>. Two vectors are considered equal if they contain the same values in the same order. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>T &amp; QVector::operator[](int i)</code>: Returns the item at index position <code>i</code> as a modifiable reference. <code>i</code> must be a valid index position in the vector (i.e., <code>0 &lt;= i &lt; size()</code>). Note that using <code>non-const</code> operators can cause <code>QVector</code> to do a deep copy.</li>
<li><code>const T &amp; QVector::operator[](int i) const</code>: This is an overloaded function. Same as <code>at(i)</code>.</li>
</ul>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; out, const QVector&lt;T&gt; &amp; vector)</code>: Writes the <code>vector</code> to stream <code>out</code>. This function requires the value type to implement <code>operator&lt;&lt;()</code>.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; in, QVector&lt;T&gt; &amp; vector)</code>: Reads a vector from stream <code>in</code> into <code>vector</code>. This function requires the value type to implement <code>operator&gt;&gt;()</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/45/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/45/">45</a><span class="page-number current">46</span><a class="page-number" href="/page/47/">47</a><span class="space">&hellip;</span><a class="page-number" href="/page/95/">95</a><a class="extend next" rel="next" href="/page/47/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">943</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
