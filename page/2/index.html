<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="泥腿子出身">
<meta property="og:url" content="http://fukangwei.gitee.io/page/2/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="泥腿子出身">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/2/">





  <title>泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/21/外语/新版标准日本语初级词汇表_下册/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/21/外语/新版标准日本语初级词汇表_下册/" itemprop="url">新版标准日本语初级词汇表_下册</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-21T21:26:51+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第25课"><a href="#第25课" class="headerlink" title="第25课"></a>第25课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>すうがく</code> (数学)</td>
<td>名</td>
<td>数学</td>
<td><code>せんもん</code> (専門)</td>
<td>名</td>
<td>专门</td>
</tr>
<tr>
<td><code>じょゆう</code> (女優)</td>
<td>名</td>
<td>女演员</td>
<td><code>えいぎょうか</code> (営業課)</td>
<td>名</td>
<td>营业科</td>
</tr>
<tr>
<td><code>しがい</code> (市街)</td>
<td>名</td>
<td>市内，市街</td>
<td><code>どうろ</code> (道路)</td>
<td>名</td>
<td>道路，马路</td>
</tr>
<tr>
<td><code>こうつうりょう</code> (交通量)</td>
<td>名</td>
<td>交通流量</td>
<td><code>くうこう</code> (空港)</td>
<td>名</td>
<td>机场</td>
</tr>
<tr>
<td><code>こうそくどうろ</code> (高速道路)</td>
<td>名</td>
<td>高速公路</td>
<td><code>ぶひんこうじょう</code> (部品工場)</td>
<td>名</td>
<td>零件制造厂</td>
</tr>
<tr>
<td><code>エレベーター</code></td>
<td>名</td>
<td>电梯</td>
<td><code>えほん</code> (絵本)</td>
<td>名</td>
<td>连环画</td>
</tr>
<tr>
<td><code>しぜん</code> (自然)</td>
<td>名</td>
<td>大自然</td>
<td><code>きゅうりょう</code> (給料)</td>
<td>名</td>
<td>工资</td>
</tr>
<tr>
<td><code>こんや</code> (今夜)</td>
<td>名</td>
<td>今天晚上</td>
<td><code>けが</code></td>
<td>名</td>
<td>伤</td>
</tr>
<tr>
<td><code>とまります</code> (泊まります)</td>
<td>动1</td>
<td>过夜，住宿</td>
<td><code>むすびます</code> (結びます)</td>
<td>动1</td>
<td>连接</td>
</tr>
<tr>
<td><code>とります</code> (取ります)</td>
<td>动1</td>
<td>印，记下</td>
<td><code>うまれます</code> (生まれます)</td>
<td>动2</td>
<td>诞生</td>
</tr>
<tr>
<td><code>とうさんします</code> (倒産~)</td>
<td>动3</td>
<td>破产</td>
<td><code>じゅうたいします</code> (渋滞~)</td>
<td>动3</td>
<td>堵车，停滞</td>
</tr>
<tr>
<td><code>チエックします</code></td>
<td>动3</td>
<td>确认</td>
<td><code>ゆたか</code> (豊か)</td>
<td>形2</td>
<td>丰富</td>
</tr>
<tr>
<td><code>おおきな</code> (大きな)</td>
<td>连体</td>
<td>大的</td>
<td><code>ちいさな</code> (小さな)</td>
<td>连体</td>
<td>小的</td>
</tr>
<tr>
<td><code>べつに</code> (別に)</td>
<td>副</td>
<td>并不</td>
<td><code>たい</code> (戴)</td>
<td>专</td>
<td>戴</td>
</tr>
<tr>
<td><code>しゅう</code> (周)</td>
<td>专</td>
<td>周</td>
<td><code>とう</code> (唐)</td>
<td>专</td>
<td>唐</td>
</tr>
<tr>
<td><code>ちゅうごくこうくう</code> (中国航空)</td>
<td>专</td>
<td>中国航空</td>
<td><code>てんあんはんてん</code> (天安飯店)</td>
<td>专</td>
<td>天安饭店</td>
</tr>
<tr>
<td><code>さんかんろ</code> (三環路)</td>
<td>专</td>
<td>三环路</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>このあたり</code></td>
<td>这附近</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第26课"><a href="#第26课" class="headerlink" title="第26课"></a>第26课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>おおあめ</code> (大雨)</td>
<td>名</td>
<td>大雨</td>
<td><code>さくら</code> (桜)</td>
<td>名</td>
<td>樱花</td>
</tr>
<tr>
<td><code>かぜ</code> (風)</td>
<td>名</td>
<td>风</td>
<td><code>つき</code> (月)</td>
<td>名</td>
<td>月亮</td>
</tr>
<tr>
<td><code>ひょう</code> (表)</td>
<td>名</td>
<td>表</td>
<td><code>あくしゅ</code> (握手)</td>
<td>名</td>
<td>握手</td>
</tr>
<tr>
<td><code>しゅうかん</code> (習慣)</td>
<td>名</td>
<td>习惯</td>
<td><code>おじぎ</code> (お辞儀)</td>
<td>名</td>
<td>鞠躬</td>
</tr>
<tr>
<td><code>あいさつ</code></td>
<td>名</td>
<td>寒暄</td>
<td><code>て</code> (手)</td>
<td>名</td>
<td>手</td>
</tr>
<tr>
<td><code>おきゃくさん</code> (お客さん)</td>
<td>名</td>
<td>顾客，客人</td>
<td><code>ふつう</code> (普通)</td>
<td>名</td>
<td>一般，普通</td>
</tr>
<tr>
<td><code>つぎ</code> (次)</td>
<td>名</td>
<td>这回，下回</td>
<td><code>スーパー</code></td>
<td>名</td>
<td>超市</td>
</tr>
<tr>
<td><code>りょうきん</code> (料金)</td>
<td>名</td>
<td>费用</td>
<td><code>かいひ</code> (会費)</td>
<td>名</td>
<td>会费</td>
</tr>
<tr>
<td><code>バーデン</code></td>
<td>名</td>
<td>降价出售</td>
<td><code>クレジットカード</code></td>
<td>名</td>
<td>信用卡</td>
</tr>
<tr>
<td><code>いろえんぴつ</code> (色鉛筆)</td>
<td>名</td>
<td>彩色铅笔</td>
<td><code>ほうさく</code> (豊作)</td>
<td>名</td>
<td>丰收</td>
</tr>
<tr>
<td><code>なか</code> (仲)</td>
<td>名</td>
<td>关系，友情</td>
<td><code>わすれもの</code> (忘れ物)</td>
<td>名</td>
<td>遗忘的物品</td>
</tr>
<tr>
<td><code>ふせぎます</code> (防ぎます)</td>
<td>动1</td>
<td>防御，防守</td>
<td><code>まわります</code> (回ります)</td>
<td>动1</td>
<td>走访；转；绕弯</td>
</tr>
<tr>
<td><code>はしります</code> (走ります)</td>
<td>动1</td>
<td>跑</td>
<td><code>ふきます</code> (吹きます)</td>
<td>动1</td>
<td>吹</td>
</tr>
<tr>
<td><code>あげます</code> (挙げます)</td>
<td>动2</td>
<td>举起</td>
<td><code>たります</code> (足ります)</td>
<td>动2</td>
<td>够</td>
</tr>
<tr>
<td><code>スケッチします</code></td>
<td>动3</td>
<td>素描，写生</td>
<td><code>はつげんします</code> (発言~)</td>
<td>动3</td>
<td>发言</td>
</tr>
<tr>
<td><code>ゆうしょうします</code> (優勝~)</td>
<td>动3</td>
<td>得冠军</td>
<td><code>ごうかくします</code> (合格~)</td>
<td>动3</td>
<td>及格，合格</td>
</tr>
<tr>
<td><code>もしかしたら</code></td>
<td>副</td>
<td>也许</td>
<td><code>やくそくします</code> (約束~)</td>
<td>动3</td>
<td>约定</td>
</tr>
<tr>
<td><code>つい</code></td>
<td>副</td>
<td>无意中</td>
<td><code>すぐに</code></td>
<td>副</td>
<td>立刻，马上</td>
</tr>
<tr>
<td><code>ほとんど</code></td>
<td>副</td>
<td>大部分，几乎</td>
<td><code>それで</code></td>
<td>连</td>
<td>因此</td>
</tr>
<tr>
<td><code>すずき</code> (鈴木)</td>
<td>专</td>
<td>铃木</td>
<td><code>よう</code> (楊)</td>
<td>专</td>
<td>杨</td>
</tr>
<tr>
<td><code>かとう</code> (加藤)</td>
<td>专</td>
<td>加藤</td>
<td><code>ようこ</code> (葉子)</td>
<td>专</td>
<td>叶子</td>
</tr>
<tr>
<td><code>ひかりデパート</code> (光~)</td>
<td>专</td>
<td>阳光百货商店</td>
<td><code>ペキンタイガース</code> (北京~)</td>
<td>专</td>
<td>北京猛虎队</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>あいさつまわり</code> (あいさつ回り)</td>
<td>寒暄拜访</td>
<td><code>いけない</code></td>
<td>不行，不好，不可以</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第27课"><a href="#第27课" class="headerlink" title="第27课"></a>第27课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>けいざい</code> (経済)</td>
<td>名</td>
<td>经济</td>
<td><code>こくさいかんけいがく</code> (国際関係学)</td>
<td>名</td>
<td>国际关系学</td>
</tr>
<tr>
<td><code>おおぜい</code> (大勢)</td>
<td>名</td>
<td>许多</td>
<td><code>こうこう</code> (高校)</td>
<td>名</td>
<td>高中</td>
</tr>
<tr>
<td><code>にっき</code> (日記)</td>
<td>名</td>
<td>日记</td>
<td><code>きょうし</code> (教師)</td>
<td>名</td>
<td>教师</td>
</tr>
<tr>
<td><code>おとしより</code> (お年寄り)</td>
<td>名</td>
<td>老年人</td>
<td><code>ラジオたいそう</code> (~体操)</td>
<td>名</td>
<td>广播体操</td>
</tr>
<tr>
<td><code>しゃこうダンス</code> (社交~)</td>
<td>名</td>
<td>交际舞</td>
<td><code>たっきゅう</code> (卓球)</td>
<td>名</td>
<td>乒乓球</td>
</tr>
<tr>
<td><code>バスケットボール</code></td>
<td>名</td>
<td>篮球</td>
<td><code>スポーツセンター</code></td>
<td>名</td>
<td>体育中心</td>
</tr>
<tr>
<td><code>にゅうえんりょう</code> (入園料)</td>
<td>名</td>
<td>门票</td>
<td><code>ゆうりょう</code> (有料)</td>
<td>名</td>
<td>收费</td>
</tr>
<tr>
<td><code>しょう</code> (賞)</td>
<td>名</td>
<td>奖</td>
<td><code>きょく</code> (曲)</td>
<td>名</td>
<td>歌曲</td>
</tr>
<tr>
<td><code>し</code> (詩)</td>
<td>名</td>
<td>诗歌</td>
<td><code>しんごう</code> (信号)</td>
<td>名</td>
<td>红绿灯</td>
</tr>
<tr>
<td><code>はさみ</code></td>
<td>名</td>
<td>剪刀</td>
<td><code>ぶひん</code> (部品)</td>
<td>名</td>
<td>零部件</td>
</tr>
<tr>
<td><code>アルバイト</code></td>
<td>名</td>
<td>打工，副业，工读</td>
<td><code>スピーチ</code></td>
<td>名</td>
<td>演讲</td>
</tr>
<tr>
<td><code>グラフ</code></td>
<td>名</td>
<td>图表</td>
<td><code>きかく</code> (企画)</td>
<td>名</td>
<td>策划，计划</td>
</tr>
<tr>
<td><code>せつめい</code> (説明)</td>
<td>名</td>
<td>说明</td>
<td><code>ごはん</code> (ご飯)</td>
<td>名</td>
<td>饭</td>
</tr>
<tr>
<td><code>さとう</code> (砂糖)</td>
<td>名</td>
<td>砂糖</td>
<td><code>かいがいりょこう</code> (海外旅行)</td>
<td>名</td>
<td>海外旅行</td>
</tr>
<tr>
<td><code>こと</code></td>
<td>名</td>
<td>事情</td>
<td><code>おじいさん</code></td>
<td>代</td>
<td>爷爷；老大爷</td>
</tr>
<tr>
<td><code>おばあさん</code></td>
<td>代</td>
<td>奶奶；老奶奶</td>
<td><code>あね</code> (姉)</td>
<td>代</td>
<td>姐姐</td>
</tr>
<tr>
<td><code>かよいます</code> (通います)</td>
<td>动1</td>
<td>上学，来往</td>
<td><code>あつまります</code> (集まります)</td>
<td>动1</td>
<td>聚，集合</td>
</tr>
<tr>
<td><code>おどります</code> (踊ります)</td>
<td>动1</td>
<td>跳舞</td>
<td><code>いります</code> (要ります)</td>
<td>动1</td>
<td>要</td>
</tr>
<tr>
<td><code>こまります</code> (困ります)</td>
<td>动1</td>
<td>为难，难办</td>
<td><code>たたきます</code></td>
<td>动1</td>
<td>拍，敲，打</td>
</tr>
<tr>
<td><code>いれます</code> (入れます)</td>
<td>动2</td>
<td>放入，放进</td>
<td><code>かんびょうします</code> (看病~)</td>
<td>动3</td>
<td>护理</td>
</tr>
<tr>
<td><code>けんかします</code></td>
<td>动3</td>
<td>吵架，打架</td>
<td><code>りようします</code> (利用~)</td>
<td>动3</td>
<td>利用</td>
</tr>
<tr>
<td><code>そうだんします</code> (そうだん~)</td>
<td>动3</td>
<td>商谈</td>
<td><code>ほかに</code></td>
<td>副</td>
<td>另外</td>
</tr>
<tr>
<td><code>しばらく</code></td>
<td>副</td>
<td>好久；片刻</td>
<td><code>へえ</code></td>
<td>叹</td>
<td>哎呀</td>
</tr>
<tr>
<td><code>きのした</code> (木下)</td>
<td>专</td>
<td>木下</td>
<td><code>たむら</code> (田村)</td>
<td>专</td>
<td>田村</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>このまえ</code> (この前)</td>
<td>最近</td>
<td><code>そういえば</code> (そう言えば)</td>
<td>这么说来</td>
</tr>
<tr>
<td><code>きがつきます</code> (気がつきます)</td>
<td>察觉</td>
<td><code>しばらくです</code></td>
<td>好久不见</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第28课"><a href="#第28课" class="headerlink" title="第28课"></a>第28课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>マフラー</code></td>
<td>名</td>
<td>围巾</td>
<td><code>ネックレス</code></td>
<td>名</td>
<td>项链</td>
</tr>
<tr>
<td><code>かぐ</code> (家具)</td>
<td>名</td>
<td>家具</td>
<td><code>ぶんしょう</code> (文章)</td>
<td>名</td>
<td>文章</td>
</tr>
<tr>
<td><code>いみ</code> (意味)</td>
<td>名</td>
<td>意思</td>
<td><code>ふんいき</code> (雰囲気)</td>
<td>名</td>
<td>气氛</td>
</tr>
<tr>
<td><code>はつおん</code> (発音)</td>
<td>名</td>
<td>发音</td>
<td><code>ふどうさんや</code> (不動産屋)</td>
<td>名</td>
<td>房产公司</td>
</tr>
<tr>
<td><code>いんしょくてん</code> (飲食店)</td>
<td>名</td>
<td>饮食店</td>
<td><code>たいしかん</code> (大使館)</td>
<td>名</td>
<td>大使馆</td>
</tr>
<tr>
<td><code>しんきょ</code> (新居)</td>
<td>名</td>
<td>新居</td>
<td><code>ひっこし</code> (引っ越し)</td>
<td>名</td>
<td>搬家</td>
</tr>
<tr>
<td><code>きんじょ</code> (近所)</td>
<td>名</td>
<td>附近</td>
<td><code>まご</code> (孫)</td>
<td>名</td>
<td>孙子，孙女</td>
</tr>
<tr>
<td><code>かかり</code> (係)</td>
<td>名</td>
<td>工作人员</td>
<td><code>ししゃちょう</code> (支社長)</td>
<td>名</td>
<td>分公司经理</td>
</tr>
<tr>
<td><code>しゅうしょく</code> (就職)</td>
<td>名</td>
<td>就业</td>
<td><code>インターネット</code></td>
<td>名</td>
<td>互联网</td>
</tr>
<tr>
<td><code>ひろいます</code> (拾います)</td>
<td>动1</td>
<td>捡，拾</td>
<td><code>やくします</code> (訳します)</td>
<td>动1</td>
<td>翻译</td>
</tr>
<tr>
<td><code>くれます</code></td>
<td>动2</td>
<td>给</td>
<td><code>とどけます</code> (届けます)</td>
<td>动2</td>
<td>送到，送去</td>
</tr>
<tr>
<td><code>あんないします</code> (案内~)</td>
<td>动3</td>
<td>向导，导游</td>
<td><code>こうかんします</code> (交換~)</td>
<td>动3</td>
<td>换，交换</td>
</tr>
<tr>
<td><code>しょうかいします</code> (紹介~)</td>
<td>动3</td>
<td>介绍</td>
<td><code>すてき</code></td>
<td>形2</td>
<td>漂亮，极好</td>
</tr>
<tr>
<td><code>とくい</code> (得意)</td>
<td>形2</td>
<td>擅长</td>
<td><code>しんせん</code> (新鮮)</td>
<td>形2</td>
<td>新鲜</td>
</tr>
<tr>
<td><code>うまく</code></td>
<td>副</td>
<td>很好地</td>
<td><code>それに</code></td>
<td>连</td>
<td>而且</td>
</tr>
<tr>
<td><code>なかた</code> (中田)</td>
<td>专</td>
<td>中田</td>
<td><code>こくさいぼうえきセンター (国際貿易センター)</code></td>
<td>专</td>
<td>国际贸易中心</td>
</tr>
<tr>
<td><code>こくぼう</code> (国貿)</td>
<td>专</td>
<td>国贸</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>どういたしまして</code></td>
<td>没关系</td>
<td><code>どのへん</code> (どの辺)</td>
<td>哪儿</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第29课"><a href="#第29课" class="headerlink" title="第29课"></a>第29课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>しつもん</code> (質問)</td>
<td>名</td>
<td>提问，问题</td>
<td><code>ばあい</code> (場合)</td>
<td>名</td>
<td>场合，情况</td>
</tr>
<tr>
<td><code>めいわく</code> (迷惑)</td>
<td>名</td>
<td>麻烦</td>
<td><code>フジ</code></td>
<td>名</td>
<td>紫藤</td>
</tr>
<tr>
<td><code>カササギ</code></td>
<td>名</td>
<td>喜鹊</td>
<td><code>とり</code> (鳥)</td>
<td>名</td>
<td>鸟</td>
</tr>
<tr>
<td><code>マーク</code></td>
<td>名</td>
<td>符号</td>
<td><code>ひょうしき</code> (標識)</td>
<td>名</td>
<td>标记</td>
</tr>
<tr>
<td><code>おうだんきんし</code> (横断禁止)</td>
<td>名</td>
<td>禁止横穿</td>
<td><code>スピード</code></td>
<td>名</td>
<td>速度</td>
</tr>
<tr>
<td><code>めんきょしょう</code> (免許証)</td>
<td>名</td>
<td>许可证</td>
<td><code>きかくしょ</code> (企画書)</td>
<td>名</td>
<td>计划书</td>
</tr>
<tr>
<td><code>やきゅうじょう</code> (野球場)</td>
<td>名</td>
<td>棒球场</td>
<td><code>テレビこうざ</code> (~講座)</td>
<td>名</td>
<td>电视讲座</td>
</tr>
<tr>
<td><code>かんじ</code> (漢字)</td>
<td>名</td>
<td>汉字</td>
<td><code>せんそう</code> (戦争)</td>
<td>名</td>
<td>战争</td>
</tr>
<tr>
<td><code>けいかん</code> (警官)</td>
<td>名</td>
<td>警察</td>
<td><code>としうえ</code> (年上)</td>
<td>名</td>
<td>年长者</td>
</tr>
<tr>
<td><code>とまります</code> (止まります)</td>
<td>动1</td>
<td>停住</td>
<td><code>かわります</code> (変わります)</td>
<td>动1</td>
<td>变，转变</td>
</tr>
<tr>
<td><code>がんばります</code> (頑張ります)</td>
<td>动1</td>
<td>拼命努力</td>
<td><code>あやまります</code> (謝ります)</td>
<td>动1</td>
<td>道歉</td>
</tr>
<tr>
<td><code>サボります</code></td>
<td>动1</td>
<td>逃学，怠工</td>
<td><code>やぶります</code> (破ります)</td>
<td>动1</td>
<td>爽约，打破</td>
</tr>
<tr>
<td><code>ひきます</code> (引きます)</td>
<td>动1</td>
<td>拉，抽</td>
<td><code>まもります</code> (守ります)</td>
<td>动1</td>
<td>遵守，保护</td>
</tr>
<tr>
<td><code>こたえます</code> (答えます)</td>
<td>动2</td>
<td>回答</td>
<td><code>にげます</code> (逃げます)</td>
<td>动2</td>
<td>逃跑</td>
</tr>
<tr>
<td><code>たすけます</code> (助けます)</td>
<td>动2</td>
<td>救助，帮助</td>
<td><code>つけます</code> (付けます)</td>
<td>动2</td>
<td>添加，附加</td>
</tr>
<tr>
<td><code>おぼえます</code> (覚えます)</td>
<td>动2</td>
<td>记住，掌握</td>
<td><code>ていしゅつします</code> (提出~)</td>
<td>动3</td>
<td>提交，提出</td>
</tr>
<tr>
<td><code>えんりょします</code> (遠慮~)</td>
<td>动3</td>
<td>客气</td>
<td><code>ちゅういします</code> (注意~)</td>
<td>动3</td>
<td>注意</td>
</tr>
<tr>
<td><code>シュートします</code></td>
<td>动3</td>
<td>射门，投篮</td>
<td><code>したしい</code> (親しい)</td>
<td>形1</td>
<td>熟悉，亲密</td>
</tr>
<tr>
<td><code>らんぼう</code> (乱暴)</td>
<td>形2</td>
<td>粗暴</td>
<td><code>しつれい</code> (失礼)</td>
<td>形2</td>
<td>不礼貌</td>
</tr>
<tr>
<td><code>おなじ</code> (同じ)</td>
<td>形2</td>
<td>相同</td>
<td><code>きけん</code> (危険)</td>
<td>形2</td>
<td>危险</td>
</tr>
<tr>
<td><code>そんな</code></td>
<td>连体</td>
<td>那样的</td>
<td><code>ていねいに</code> (丁寧に)</td>
<td>副</td>
<td>恭敬地；细心地</td>
</tr>
<tr>
<td><code>おい</code></td>
<td>叹</td>
<td>哎，喂</td>
<td><code>まこと</code> (誠)</td>
<td>专</td>
<td>诚，阿诚</td>
</tr>
<tr>
<td><code>しゅうおんらい</code> (周恩来)</td>
<td>专</td>
<td>周恩来</td>
<td><code>ろじん</code> (魯迅)</td>
<td>专</td>
<td>鲁迅</td>
</tr>
<tr>
<td><code>せたがや</code> (世田谷)</td>
<td>专</td>
<td>世田谷</td>
<td><code>ふじ</code> (富士)</td>
<td>专</td>
<td>富士</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>かわった (変わった)</code></td>
<td>怪</td>
<td><code>かぜをひきます</code> (風邪を引きます)</td>
<td>感冒</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第30课"><a href="#第30课" class="headerlink" title="第30课"></a>第30课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>たくはいびん</code> (宅配便)</td>
<td>名</td>
<td>送货上门服务</td>
<td><code>ほうこくしょ</code> (報告書)</td>
<td>名</td>
<td>报告书</td>
</tr>
<tr>
<td><code>つゆ</code> (梅雨)</td>
<td>名</td>
<td>梅雨</td>
<td><code>あき</code> (秋)</td>
<td>名</td>
<td>秋季</td>
</tr>
<tr>
<td><code>ピクニック</code></td>
<td>名</td>
<td>郊游</td>
<td><code>こうらくち</code> (行楽地)</td>
<td>名</td>
<td>景点</td>
</tr>
<tr>
<td><code>ピザ</code></td>
<td>名</td>
<td>比萨饼</td>
<td><code>しゅうでん</code> (終電)</td>
<td>名</td>
<td>末班电车</td>
</tr>
<tr>
<td><code>まちあいしつ</code> (待合室)</td>
<td>名</td>
<td>候诊室，等候室</td>
<td><code>かんじゃ</code> (患者)</td>
<td>名</td>
<td>病人</td>
</tr>
<tr>
<td><code>はいざら</code> (灰皿)</td>
<td>名</td>
<td>烟灰缸</td>
<td><code>すいがら</code> (吸殻)</td>
<td>名</td>
<td>烟头，烟灰</td>
</tr>
<tr>
<td><code>は</code> (歯)</td>
<td>名</td>
<td>牙齿</td>
<td><code>かれ</code> (彼)</td>
<td>代</td>
<td>他</td>
</tr>
<tr>
<td><code>そろいます</code></td>
<td>动1</td>
<td>到齐，齐全</td>
<td><code>よります</code> (寄ります)</td>
<td>动1</td>
<td>顺便去，靠近</td>
</tr>
<tr>
<td><code>ひらきます</code> (開きます)</td>
<td>动1</td>
<td>开，开张</td>
<td><code>むかえます</code> (迎えます)</td>
<td>动2</td>
<td>迎接</td>
</tr>
<tr>
<td><code>ひっこします</code> (引っ越します)</td>
<td>动1</td>
<td>搬迁</td>
<td><code>こわれます</code> (壊れます)</td>
<td>动2</td>
<td>出故障，坏</td>
</tr>
<tr>
<td><code>まちがえます</code> (間違えます)</td>
<td>动2</td>
<td>搞错</td>
<td><code>しゅっぱつします</code> (出発~)</td>
<td>动3</td>
<td>出发</td>
</tr>
<tr>
<td><code>てんしょくします</code> (転職~)</td>
<td>动3</td>
<td>换工作</td>
<td><code>パンクします</code></td>
<td>动3</td>
<td>轮胎爆裂，撑破</td>
</tr>
<tr>
<td><code>さびしい</code> (寂しい)</td>
<td>形1</td>
<td>寂寞</td>
<td><code>たのしみ</code> (楽しみ)</td>
<td>形2</td>
<td>愉快，期待</td>
</tr>
<tr>
<td><code>とくべつ</code> (特別)</td>
<td>形2</td>
<td>特别</td>
<td><code>それでは/それじゃ</code></td>
<td>连</td>
<td>那么</td>
</tr>
<tr>
<td><code>そうか</code></td>
<td>叹</td>
<td>是吗</td>
<td><code>まあ</code></td>
<td>叹</td>
<td>嗯，嘿</td>
</tr>
<tr>
<td><code>パク</code></td>
<td>专</td>
<td>朴</td>
<td><code>ちょうこうくだり</code> (長江下り)</td>
<td>专</td>
<td>坐船浏览长江两岸风光</td>
</tr>
<tr>
<td><code>こうざん</code> (香山)</td>
<td>专</td>
<td>香山</td>
<td><code>ペキンしょくぶつえん</code> (北京植物園)</td>
<td>专</td>
<td>北京植物园</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>しかたない</code> (仕方ない)</td>
<td>没有办法</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第31课"><a href="#第31课" class="headerlink" title="第31课"></a>第31课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ボタン</code></td>
<td>名</td>
<td>按钮；纽扣</td>
<td><code>ブローチ</code></td>
<td>名</td>
<td>胸针</td>
</tr>
<tr>
<td><code>カーテン</code></td>
<td>名</td>
<td>窗帘，帘子</td>
<td><code>コンクリート</code></td>
<td>名</td>
<td>水泥</td>
</tr>
<tr>
<td><code>プラスチック</code></td>
<td>名</td>
<td>塑胶，塑料</td>
<td><code>ひすい</code></td>
<td>名</td>
<td>翡翠</td>
</tr>
<tr>
<td><code>サービスセンター</code></td>
<td>名</td>
<td>维修服务中心</td>
<td><code>かいいん</code> (会員)</td>
<td>名</td>
<td>会员</td>
</tr>
<tr>
<td><code>とくてん</code> (特典)</td>
<td>名</td>
<td>优惠</td>
<td><code>おてあらい</code> (お手洗い)</td>
<td>名</td>
<td>厕所</td>
</tr>
<tr>
<td><code>かいだん</code> (階段)</td>
<td>名</td>
<td>楼梯，台阶</td>
<td><code>いこう</code> (以降)</td>
<td>名</td>
<td>以后</td>
</tr>
<tr>
<td><code>そば</code></td>
<td>名</td>
<td>旁边</td>
<td><code>たっきゅうだい</code> (卓球台)</td>
<td>名</td>
<td>乒乓球桌</td>
</tr>
<tr>
<td><code>サイズ</code></td>
<td>名</td>
<td>尺寸</td>
<td><code>にんげん</code> (人間)</td>
<td>名</td>
<td>人类</td>
</tr>
<tr>
<td><code>はくちょう</code> (白鳥)</td>
<td>名</td>
<td>鹅</td>
<td><code>でんげん</code> (電源)</td>
<td>名</td>
<td>电源</td>
</tr>
<tr>
<td><code>スイカ</code></td>
<td>名</td>
<td>西瓜</td>
<td><code>おします</code> (押します)</td>
<td>动1</td>
<td>按，推，挤</td>
</tr>
<tr>
<td><code>つきます</code></td>
<td>动1</td>
<td>灯亮，灯开</td>
<td><code>さがります</code> (下がります)</td>
<td>动1</td>
<td>下降，降低</td>
</tr>
<tr>
<td><code>おこります</code> (怒ります)</td>
<td>动1</td>
<td>生气</td>
<td><code>まわします</code> (回します)</td>
<td>动1</td>
<td>转，传送，传递</td>
</tr>
<tr>
<td><code>うごきます</code> (動きます)</td>
<td>动1</td>
<td>运转，转动</td>
<td><code>いきます</code> (生きます)</td>
<td>动2</td>
<td>活，生存</td>
</tr>
<tr>
<td><code>おります</code> (下ります)</td>
<td>动2</td>
<td>下，下来</td>
<td><code>フリーズします</code></td>
<td>动3</td>
<td>死机</td>
</tr>
<tr>
<td><code>こしょうします</code> (故障~)</td>
<td>动3</td>
<td>故障</td>
<td><code>うつくしい</code> (美しい)</td>
<td>形1</td>
<td>美丽</td>
</tr>
<tr>
<td><code>うまい</code></td>
<td>形1</td>
<td>高明，好吃</td>
<td><code>くわしい</code> (詳しい)</td>
<td>形1</td>
<td>详细</td>
</tr>
<tr>
<td><code>じゆう</code> (自由)</td>
<td>形2</td>
<td>随便，自由</td>
<td><code>ていねい</code> (丁寧)</td>
<td>形2</td>
<td>精心，细心，恭敬</td>
</tr>
<tr>
<td><code>きちんと</code></td>
<td>副</td>
<td>好好地</td>
<td><code>ただし</code></td>
<td>连</td>
<td>不过</td>
</tr>
<tr>
<td><code>しかし</code></td>
<td>连</td>
<td>可是</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>きもちわるい</code> (気持ち悪い)</td>
<td>不舒服</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第32课"><a href="#第32课" class="headerlink" title="第32课"></a>第32课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>れっしゃ</code> (列車)</td>
<td>名</td>
<td>火车</td>
<td><code>こうそくバス</code> (高速~)</td>
<td>名</td>
<td>高速公共汽车</td>
</tr>
<tr>
<td><code>しゅっぱつじこく</code> (出発時刻)</td>
<td>名</td>
<td>出发时间</td>
<td><code>りょこうよてい</code> (旅行予定)</td>
<td>名</td>
<td>旅行计划</td>
</tr>
<tr>
<td><code>てんきよほう</code> (天気予報)</td>
<td>名</td>
<td>天气预报</td>
<td><code>たいふう</code> (台風)</td>
<td>名</td>
<td>台风</td>
</tr>
<tr>
<td><code>うわさ</code></td>
<td>名</td>
<td>传说，风言风语</td>
<td><code>せんでん</code> (宣伝)</td>
<td>名</td>
<td>宣传</td>
</tr>
<tr>
<td><code>ばんぐみ</code> (番組)</td>
<td>名</td>
<td>节目</td>
<td><code>しんがた</code> (新型)</td>
<td>名</td>
<td>新型</td>
</tr>
<tr>
<td><code>ボーナス</code></td>
<td>名</td>
<td>奖金</td>
<td><code>ラーメン</code></td>
<td>名</td>
<td>面条</td>
</tr>
<tr>
<td><code>ぎゅうにゅう</code> (牛乳)</td>
<td>名</td>
<td>牛奶</td>
<td><code>ギョーザパーテイー</code> (饺子~)</td>
<td>名</td>
<td>饺子宴</td>
</tr>
<tr>
<td><code>しょうがつやすみ</code> (正月休み)</td>
<td>名</td>
<td>新年假日</td>
<td><code>スポーツようひん</code> (~用品)</td>
<td>名</td>
<td>体育用品</td>
</tr>
<tr>
<td><code>インフルエンザ</code></td>
<td>名</td>
<td>流感</td>
<td><code>してん</code> (支店)</td>
<td>名</td>
<td>分店，分公司</td>
</tr>
<tr>
<td><code>しょうがっこう</code> (小学校)</td>
<td>名</td>
<td>小学</td>
<td><code>ゆうえんち</code> (遊園地)</td>
<td>名</td>
<td>游乐园</td>
</tr>
<tr>
<td><code>しゅしょう</code> (首相)</td>
<td>名</td>
<td>首相</td>
<td><code>れきし</code> (歴史)</td>
<td>名</td>
<td>历史</td>
</tr>
<tr>
<td><code>かのじょ</code> (彼女)</td>
<td>代</td>
<td>她</td>
<td><code>おこないます</code> (行います)</td>
<td>动1</td>
<td>开，举行</td>
</tr>
<tr>
<td><code>あがります</code> (上がります)</td>
<td>动1</td>
<td>提高，涨</td>
<td><code>のりかえます</code> (乗り換えます</td>
<td>动2</td>
<td>换乘</td>
</tr>
<tr>
<td><code>やめます</code> (辞めます)</td>
<td>动2</td>
<td>辞去</td>
<td><code>りゅうがくします</code> (留学~)</td>
<td>动3</td>
<td>留学</td>
</tr>
<tr>
<td><code>にゅうがくします</code> (入学~)</td>
<td>动3</td>
<td>入学</td>
<td><code>りゅうこうします</code> (流行~)</td>
<td>动3</td>
<td>流行</td>
</tr>
<tr>
<td><code>にゅういんします</code> (入院~)</td>
<td>动3</td>
<td>住院</td>
<td><code>おじゃまします</code> (お邪魔~)</td>
<td>动3</td>
<td>打扰，拜访</td>
</tr>
<tr>
<td><code>たんとうします</code> (担当~)</td>
<td>动3</td>
<td>承担</td>
<td><code>つよい</code> (強い)</td>
<td>形1</td>
<td>强，坚强</td>
</tr>
<tr>
<td><code>きさく</code> (気さく)</td>
<td>形2</td>
<td>爽快，坦率</td>
<td><code>いろんな</code></td>
<td>连体</td>
<td>各种各样的</td>
</tr>
<tr>
<td><code>ずっと</code></td>
<td>副</td>
<td>一直，始终</td>
<td><code>りゅうえい</code> (劉英)</td>
<td>专</td>
<td>刘英</td>
</tr>
<tr>
<td><code>タイ</code></td>
<td>专</td>
<td>泰国</td>
<td><code>きょうとホテル</code> (京都~)</td>
<td>专</td>
<td>京都宾馆</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>おじゃましました</code> (お邪魔しました)</td>
<td>打扰了</td>
<td><code>かぜがつよい</code> (風が強い)</td>
<td>风大</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第33课"><a href="#第33课" class="headerlink" title="第33课"></a>第33课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>スーツケース</code></td>
<td>名</td>
<td>旅行箱</td>
<td><code>トランク</code></td>
<td>名</td>
<td>后备箱；手提箱，皮箱</td>
</tr>
<tr>
<td><code>スーツ</code></td>
<td>名</td>
<td>西服，女套装</td>
<td><code>ズボン</code></td>
<td>名</td>
<td>裤子</td>
</tr>
<tr>
<td><code>テイーシャツ</code> (T~)</td>
<td>名</td>
<td>T恤衫</td>
<td><code>サンダル</code></td>
<td>名</td>
<td>凉鞋</td>
</tr>
<tr>
<td><code>ぼうし</code> (帽子)</td>
<td>名</td>
<td>帽子</td>
<td><code>うでどけい</code> (腕時計)</td>
<td>名</td>
<td>手表</td>
</tr>
<tr>
<td><code>こもの</code> (小物)</td>
<td>名</td>
<td>小东西，细小的附件</td>
<td><code>うんてんしゅ</code> (運転手)</td>
<td>名</td>
<td>司机</td>
</tr>
<tr>
<td><code>から</code> (空)</td>
<td>名</td>
<td>空</td>
<td><code>うんどうかい</code> (運動会)</td>
<td>名</td>
<td>运动会</td>
</tr>
<tr>
<td><code>チーム</code></td>
<td>名</td>
<td>队，团体</td>
<td><code>さいご</code> (最後)</td>
<td>名</td>
<td>最后</td>
</tr>
<tr>
<td><code>さいかい</code> (再会)</td>
<td>名</td>
<td>重逢，再会</td>
<td><code>ひさしぶり</code> (久しぶり)</td>
<td>名</td>
<td>好久不见</td>
</tr>
<tr>
<td><code>カキ</code></td>
<td>名</td>
<td>柿子</td>
<td><code>せいりょういんりょうすい</code> (清涼飲料水)</td>
<td>名</td>
<td>清凉饮料</td>
</tr>
<tr>
<td><code>しまります</code> (閉まります)</td>
<td>动1</td>
<td>关闭，关</td>
<td><code>こわします</code> (壊します)</td>
<td>动1</td>
<td>弄坏</td>
</tr>
<tr>
<td><code>わります</code> (割ります)</td>
<td>动1</td>
<td>割开，打破，打坏</td>
<td><code>つきます</code> (付きます)</td>
<td>动1</td>
<td>附带，附加</td>
</tr>
<tr>
<td><code>かかります</code> (掛かります)</td>
<td>动1</td>
<td>挂，悬挂</td>
<td><code>よごします</code> (汚します)</td>
<td>动1</td>
<td>弄脏</td>
</tr>
<tr>
<td><code>やみます</code></td>
<td>动1</td>
<td>停止</td>
<td><code>たちます</code> (建ちます)</td>
<td>动1</td>
<td>盖，建</td>
</tr>
<tr>
<td><code>ならびます</code> (並びます)</td>
<td>动1</td>
<td>排队，排</td>
<td><code>つきます</code> (着きます)</td>
<td>动1</td>
<td>到，到达</td>
</tr>
<tr>
<td><code>かぶります</code></td>
<td>动1</td>
<td>戴</td>
<td><code>はきます</code></td>
<td>动1</td>
<td>穿(鞋，裤子)</td>
</tr>
<tr>
<td><code>かいます</code> (飼います)</td>
<td>动1</td>
<td>饲养</td>
<td><code>きえます</code> (消えます)</td>
<td>动2</td>
<td>熄灭，消失</td>
</tr>
<tr>
<td><code>かけます</code> (掛けます)</td>
<td>动2</td>
<td>挂</td>
<td><code>おちます</code> (落ちます)</td>
<td>动2</td>
<td>落下，掉</td>
</tr>
<tr>
<td><code>われます</code> (割れます)</td>
<td>动2</td>
<td>裂开，破裂</td>
<td><code>たてます</code> (建てます)</td>
<td>动2</td>
<td>盖，建造</td>
</tr>
<tr>
<td><code>まけます</code> (負けます)</td>
<td>动2</td>
<td>输，败</td>
<td><code>よごれます</code> (汚れます)</td>
<td>动2</td>
<td>脏</td>
</tr>
<tr>
<td><code>えらい</code> (偉い)</td>
<td>形1</td>
<td>了不起，伟大</td>
<td><code>らく</code> (楽)</td>
<td>形2</td>
<td>容易，简易；快乐，轻松</td>
</tr>
<tr>
<td><code>ざんねん</code> (残念)</td>
<td>形2</td>
<td>可惜，遗憾</td>
<td><code>きゅうに</code> (急に)</td>
<td>副</td>
<td>突然</td>
</tr>
<tr>
<td><code>ぜんぶ</code> (全部)</td>
<td>副</td>
<td>全部</td>
<td><code>あいかわらず</code> (相変わらず)</td>
<td>副</td>
<td>依然</td>
</tr>
<tr>
<td><code>うっかり</code></td>
<td>副</td>
<td>不留神，不注意</td>
<td><code>それにすても</code></td>
<td>连</td>
<td>即便那样，话虽如此</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>おひさしぶりです</code> (お久しぶりです)</td>
<td>好久不见</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第34课"><a href="#第34课" class="headerlink" title="第34课"></a>第34课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>カレンダー</code></td>
<td>名</td>
<td>日历</td>
<td><code>ポスター</code></td>
<td>名</td>
<td>海报</td>
</tr>
<tr>
<td><code>ハードスケジュール</code></td>
<td>名</td>
<td>紧张的日程</td>
<td><code>カレーライス</code></td>
<td>名</td>
<td>咖喱饭</td>
</tr>
<tr>
<td><code>よっておき</code></td>
<td>名</td>
<td>珍藏，私藏</td>
<td><code>ほんば</code> (本場)</td>
<td>名</td>
<td>原产地，发源地</td>
</tr>
<tr>
<td><code>げんかん</code> (玄関)</td>
<td>名</td>
<td>门口，玄关</td>
<td><code>ロッカー</code></td>
<td>名</td>
<td>橱柜，文件柜</td>
</tr>
<tr>
<td><code>バッグ</code></td>
<td>名</td>
<td>包，手提包</td>
<td><code>りょこうしゃ</code> (旅行者)</td>
<td>名</td>
<td>旅行社</td>
</tr>
<tr>
<td><code>しさつだん</code> (視察団)</td>
<td>名</td>
<td>视察团</td>
<td><code>とうちゃく</code> (到着)</td>
<td>名</td>
<td>到达，抵达</td>
</tr>
<tr>
<td><code>かえり</code> (帰り)</td>
<td>名</td>
<td>回程，返回，回家</td>
<td><code>もちかえり</code> (持ち帰り)</td>
<td>名</td>
<td>打包，带回</td>
</tr>
<tr>
<td><code>じこ</code> (事故)</td>
<td>名</td>
<td>事故</td>
<td><code>はなたば</code> (花束)</td>
<td>名</td>
<td>花束</td>
</tr>
<tr>
<td><code>はっぴょうかい</code> (発表会)</td>
<td>名</td>
<td>发布会</td>
<td><code>ろんぶん</code> (論文)</td>
<td>名</td>
<td>论文</td>
</tr>
<tr>
<td><code>ダイエット</code></td>
<td>名</td>
<td>减肥</td>
<td><code>オリンピック</code></td>
<td>名</td>
<td>奥运会，奥林匹克</td>
</tr>
<tr>
<td><code>あちこち/あっちこっち</code></td>
<td>代</td>
<td>到处，处处</td>
<td><code>やきます</code> (焼きます)</td>
<td>动1</td>
<td>烤，烧，烧毁</td>
</tr>
<tr>
<td><code>かせぎます</code> (稼ぎます)</td>
<td>动1</td>
<td>挣钱，赚钱</td>
<td><code>のこります</code> (残ります)</td>
<td>动1</td>
<td>剩余，剩下</td>
</tr>
<tr>
<td><code>つつみます</code> (包みます)</td>
<td>动1</td>
<td>卷，包裹</td>
<td><code>たのみます</code> (頼みます)</td>
<td>动1</td>
<td>点(菜)；请求；托付</td>
</tr>
<tr>
<td><code>はります</code></td>
<td>动1</td>
<td>粘，贴</td>
<td><code>かざります</code> (飾ります)</td>
<td>动1</td>
<td>装饰</td>
</tr>
<tr>
<td><code>しまいます</code></td>
<td>动1</td>
<td>收拾起来</td>
<td><code>あいます</code> (合います)</td>
<td>动1</td>
<td>合适，适合</td>
</tr>
<tr>
<td><code>もどします</code> (戻します)</td>
<td>动1</td>
<td>返还，返回</td>
<td><code>ためます</code></td>
<td>动2</td>
<td>积攒，储存</td>
</tr>
<tr>
<td><code>ならべます</code> (並べます)</td>
<td>动2</td>
<td>排列</td>
<td><code>あずけます</code> (預けます)</td>
<td>动2</td>
<td>寄存，托付</td>
</tr>
<tr>
<td><code>つづけます</code> (続けます)</td>
<td>动2</td>
<td>继续，持续</td>
<td><code>やせます</code></td>
<td>动2</td>
<td>瘦</td>
</tr>
<tr>
<td><code>ほうもんします</code> (訪問~)</td>
<td>动3</td>
<td>拜访，访问</td>
<td><code>ちょきんします</code> (貯金~)</td>
<td>动3</td>
<td>存钱，储蓄</td>
</tr>
<tr>
<td><code>かんげいします</code> (歓迎~)</td>
<td>动3</td>
<td>欢迎</td>
<td><code>よういします</code> (用意~)</td>
<td>动3</td>
<td>准备</td>
</tr>
<tr>
<td><code>おかしい</code></td>
<td>形1</td>
<td>奇怪，可笑，不正常</td>
<td><code>ひどい</code></td>
<td>形1</td>
<td>严重，厉害</td>
</tr>
<tr>
<td><code>もったいない</code></td>
<td>形1</td>
<td>可惜，浪费，过分</td>
<td><code>ゆうしゅう</code> (優秀)</td>
<td>形2</td>
<td>优秀，优异</td>
</tr>
<tr>
<td><code>さいこう</code> (最高)</td>
<td>形2</td>
<td>最好，最高</td>
<td><code>しっかり</code></td>
<td>副</td>
<td>充分，充足</td>
</tr>
<tr>
<td><code>ひじょうに</code> (非常に)</td>
<td>副</td>
<td>非常</td>
<td><code>こんなに</code></td>
<td>副</td>
<td>这么，这样地</td>
</tr>
<tr>
<td><code>いっしょうけんめい</code> (一生懸命)</td>
<td>副</td>
<td>拼命地，努力地</td>
<td><code>うわあ</code></td>
<td>叹</td>
<td>哇</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>いただきます</code></td>
<td>我开始吃了</td>
<td><code>えんりょなく</code> (遠慮なく)</td>
<td>不客气</td>
</tr>
<tr>
<td><code>このまま</code></td>
<td>就这样，如此</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第35课"><a href="#第35课" class="headerlink" title="第35课"></a>第35课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>マラソンたいかい</code> (~大会)</td>
<td>名</td>
<td>马拉松大会</td>
<td><code>ホームパーテイー</code></td>
<td>名</td>
<td>家庭聚会</td>
</tr>
<tr>
<td><code>ゴーカート</code></td>
<td>名</td>
<td>游戏汽车，玩具汽车</td>
<td><code>テレビゲーム</code></td>
<td>名</td>
<td>电子游戏</td>
</tr>
<tr>
<td><code>ちゅうし</code> (中止)</td>
<td>名</td>
<td>中止，中顿</td>
<td><code>ひょうげん</code> (表現)</td>
<td>名</td>
<td>表达，表现</td>
</tr>
<tr>
<td><code>はんたい</code> (反対)</td>
<td>名</td>
<td>反对</td>
<td><code>えいぎょう</code> (営業)</td>
<td>名</td>
<td>营业</td>
</tr>
<tr>
<td><code>ざいこ</code> (在庫)</td>
<td>名</td>
<td>库存，存货</td>
<td><code>おとな</code> (大人)</td>
<td>名</td>
<td>成人</td>
</tr>
<tr>
<td><code>おじ</code></td>
<td>名</td>
<td>叔叔，伯伯，舅舅</td>
<td><code>しょうがくせい</code> (小学生)</td>
<td>名</td>
<td>小学生</td>
</tr>
<tr>
<td><code>うちゅうひこうし</code> (宇宙飛行士)</td>
<td>名</td>
<td>宇航员</td>
<td><code>カタログ</code></td>
<td>名</td>
<td>目录</td>
</tr>
<tr>
<td><code>たからくじ</code> (宝くじ)</td>
<td>名</td>
<td>彩票</td>
<td><code>せいせき</code> (成績)</td>
<td>名</td>
<td>成绩</td>
</tr>
<tr>
<td><code>けいさん</code> (計算)</td>
<td>名</td>
<td>计算</td>
<td><code>けしゴム</code> (消し~)</td>
<td>名</td>
<td>橡皮</td>
</tr>
<tr>
<td><code>は</code> (歯)</td>
<td>名</td>
<td>叶子</td>
<td><code>ビタミンざい</code> (~剤)</td>
<td>名</td>
<td>维生素片剂</td>
</tr>
<tr>
<td><code>ちゅうこ</code> (中古)</td>
<td>名</td>
<td>二手货，旧货</td>
<td><code>きかい</code> (機会)</td>
<td>名</td>
<td>机会</td>
</tr>
<tr>
<td><code>きゅうじつ</code> (休日)</td>
<td>名</td>
<td>休息日，假日</td>
<td><code>こんかい</code> (今回)</td>
<td>名</td>
<td>这次，这回</td>
</tr>
<tr>
<td><code>こんげつ</code> (今月)</td>
<td>名</td>
<td>这个月</td>
<td><code>さいしゅうてんけん</code> (最終点検)</td>
<td>名</td>
<td>最终检查</td>
</tr>
<tr>
<td><code>ききます</code> (効きます)</td>
<td>动1</td>
<td>有效</td>
<td><code>いわいます</code> (祝います)</td>
<td>动1</td>
<td>祝贺</td>
</tr>
<tr>
<td><code>あたります</code> (当たります)</td>
<td>动1</td>
<td>中(彩)，抽中</td>
<td><code>あきます</code> (空きます)</td>
<td>动1</td>
<td>空，有空</td>
</tr>
<tr>
<td><code>くさります</code> (腐ります)</td>
<td>动1</td>
<td>腐烂，腐败</td>
<td><code>みつけます</code> (見つけます)</td>
<td>动2</td>
<td>找到，发现，看见</td>
</tr>
<tr>
<td><code>はれます</code> (晴れます)</td>
<td>动2</td>
<td>晴朗，天晴</td>
<td><code>たずねます</code> (訪ねます)</td>
<td>动2</td>
<td>访问，拜访</td>
</tr>
<tr>
<td><code>たいざいします</code> (滞在~)</td>
<td>动3</td>
<td>停留，滞留</td>
<td><code>きゅうけいします</code> (休憩~)</td>
<td>动3</td>
<td>休息</td>
</tr>
<tr>
<td><code>さんかします</code> (参加~)</td>
<td>动3</td>
<td>参加</td>
<td><code>かんぱいします</code> (乾杯~)</td>
<td>动3</td>
<td>干杯</td>
</tr>
<tr>
<td><code>へん</code></td>
<td>形2</td>
<td>不恰当，奇怪，反常</td>
<td><code>かんぜん</code> (完全)</td>
<td>形2</td>
<td>充分，完全</td>
</tr>
<tr>
<td><code>ひつよう</code> (必要)</td>
<td>形2</td>
<td>必要，必须</td>
<td><code>だんだん</code></td>
<td>副</td>
<td>渐渐地，逐渐地</td>
</tr>
<tr>
<td><code>もし</code></td>
<td>副</td>
<td>如果，假如</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第36课"><a href="#第36课" class="headerlink" title="第36课"></a>第36课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>さいしょ</code> (最初)</td>
<td>名</td>
<td>最初</td>
<td><code>しゅっしん</code> (出身)</td>
<td>名</td>
<td>出生地</td>
</tr>
<tr>
<td><code>こうじょう</code> (工場)</td>
<td>名</td>
<td>工厂</td>
<td><code>えんとつ</code> (煙突)</td>
<td>名</td>
<td>烟筒</td>
</tr>
<tr>
<td><code>フライパン</code></td>
<td>名</td>
<td>平底锅</td>
<td><code>たまごやき</code> (卵焼き)</td>
<td>名</td>
<td>煎鸡蛋</td>
</tr>
<tr>
<td><code>グラウンド</code></td>
<td>名</td>
<td>操场</td>
<td><code>おくじょう</code> (屋上)</td>
<td>名</td>
<td>屋顶</td>
</tr>
<tr>
<td><code>たこ</code> (凧)</td>
<td>名</td>
<td>风筝</td>
<td><code>テープ</code></td>
<td>名</td>
<td>磁带</td>
</tr>
<tr>
<td><code>どくしょ</code> (読書)</td>
<td>名</td>
<td>读书</td>
<td><code>しんせい</code> (申請)</td>
<td>名</td>
<td>申请</td>
</tr>
<tr>
<td><code>かんさいべん</code> (関西弁)</td>
<td>名</td>
<td>关西话</td>
<td><code>にちじょうかいわ</code> (日常会話)</td>
<td>名</td>
<td>日常会话</td>
</tr>
<tr>
<td><code>にほんぶんか</code> (日本文化)</td>
<td>名</td>
<td>日本文化</td>
<td><code>せいさんコスト</code> (生産~)</td>
<td>名</td>
<td>生产成本</td>
</tr>
<tr>
<td><code>こうつうじこ</code> (交通事故)</td>
<td>名</td>
<td>交通事故</td>
<td><code>ごしゅじん</code> (ご主人)</td>
<td>名</td>
<td>您丈夫</td>
</tr>
<tr>
<td><code>はかりうり</code> (量り売り)</td>
<td>名</td>
<td>论重量卖</td>
<td><code>わらいごえ</code> (笑い声)</td>
<td>名</td>
<td>笑声</td>
</tr>
<tr>
<td><code>もちあるきます</code> (持ち歩きます)</td>
<td>动1</td>
<td>携带</td>
<td><code>くりかえします</code> (繰り返します)</td>
<td>动1</td>
<td>反复</td>
</tr>
<tr>
<td><code>さわぎます</code> (騒ぎます)</td>
<td>动1</td>
<td>吵闹</td>
<td><code>まにあいます</code> (間に合います)</td>
<td>动1</td>
<td>来得及</td>
</tr>
<tr>
<td><code>なきます</code> (鳴きます)</td>
<td>动1</td>
<td>叫，鸣</td>
<td><code>ねむります</code> (眠ります)</td>
<td>动1</td>
<td>睡觉</td>
</tr>
<tr>
<td><code>なります</code> (鳴ります)</td>
<td>动1</td>
<td>响起</td>
<td><code>よろこびます</code> (喜びます)</td>
<td>动1</td>
<td>喜悦，高兴</td>
</tr>
<tr>
<td><code>やくだちます</code> (役立ちます)</td>
<td>动1</td>
<td>有用</td>
<td><code>やといます</code> (雇います)</td>
<td>动1</td>
<td>雇佣</td>
</tr>
<tr>
<td><code>なきます</code> (泣きます)</td>
<td>动1</td>
<td>哭</td>
<td><code>ふります</code> (振ります)</td>
<td>动1</td>
<td>挥动，摆动</td>
</tr>
<tr>
<td><code>みえます</code> (見えます)</td>
<td>动2</td>
<td>看得见</td>
<td><code>きこえます</code> (聞こえます)</td>
<td>动2</td>
<td>听得见</td>
</tr>
<tr>
<td><code>つうじます</code> (通じます)</td>
<td>动2</td>
<td>通过，相通</td>
<td><code>あげます</code> (揚げます)</td>
<td>动2</td>
<td>放(风筝)；扬起</td>
</tr>
<tr>
<td><code>なれます</code> (慣れます)</td>
<td>动2</td>
<td>习惯</td>
<td><code>ぬれます</code></td>
<td>动2</td>
<td>淋湿，打湿</td>
</tr>
<tr>
<td><code>やけます</code> (焼けます)</td>
<td>动2</td>
<td>着火，燃烧</td>
<td><code>さげます</code> (下げます)</td>
<td>动2</td>
<td>降低，下降</td>
</tr>
<tr>
<td><code>しっぱいします</code> (失敗~)</td>
<td>动3</td>
<td>出岔子，失败</td>
<td><code>くろうします</code> (苦労~)</td>
<td>动3</td>
<td>辛苦，辛劳</td>
</tr>
<tr>
<td><code>びっくりします</code></td>
<td>动3</td>
<td>吃惊，吓一跳</td>
<td><code>しゅっせきします</code> (出席~)</td>
<td>动3</td>
<td>出席</td>
</tr>
<tr>
<td><code>かなしい</code> (悲しい)</td>
<td>形1</td>
<td>悲伤</td>
<td><code>ほんと</code></td>
<td>形2</td>
<td>真的</td>
</tr>
<tr>
<td><code>とにかく</code></td>
<td>副</td>
<td>特别是，总之</td>
<td><code>まだまだ</code></td>
<td>副</td>
<td>还，尚，仍</td>
</tr>
<tr>
<td><code>ぺらぺら</code></td>
<td>副</td>
<td>流利地</td>
<td><code>ワンワン</code></td>
<td>副</td>
<td>汪汪叫</td>
</tr>
<tr>
<td><code>ザーザー</code></td>
<td>副</td>
<td>雨哗啦哗啦</td>
<td><code>すやすや</code></td>
<td>副</td>
<td>香甜地，安静地</td>
</tr>
<tr>
<td><code>くねくね</code></td>
<td>副</td>
<td>弯弯曲曲</td>
<td><code>メキシコ</code></td>
<td>专</td>
<td>墨西哥</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第37课"><a href="#第37课" class="headerlink" title="第37课"></a>第37课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ようじ</code> (用事)</td>
<td>名</td>
<td>事情</td>
<td><code>たいかい</code> (大会)</td>
<td>名</td>
<td>大会</td>
</tr>
<tr>
<td><code>きぼ</code> (規模)</td>
<td>名</td>
<td>规模</td>
<td><code>けいかく</code> (計画)</td>
<td>名</td>
<td>计划</td>
</tr>
<tr>
<td><code>きそく</code> (規則)</td>
<td>名</td>
<td>规则</td>
<td><code>ひよう</code> (費用)</td>
<td>名</td>
<td>费用</td>
</tr>
<tr>
<td><code>しお</code> (塩)</td>
<td>名</td>
<td>盐</td>
<td><code>メダル</code></td>
<td>名</td>
<td>纪念章，奖牌</td>
</tr>
<tr>
<td><code>ソフト</code></td>
<td>名</td>
<td>软件</td>
<td><code>かわ</code> (川)</td>
<td>名</td>
<td>河，河流</td>
</tr>
<tr>
<td><code>てつどう</code> (鉄道)</td>
<td>名</td>
<td>火车，铁路</td>
<td><code>ぜんちょう</code> (全長)</td>
<td>名</td>
<td>全长</td>
</tr>
<tr>
<td><code>ばんごう</code> (番号)</td>
<td>名</td>
<td>号码，番号</td>
<td><code>たんい</code> (単位)</td>
<td>名</td>
<td>计量单位</td>
</tr>
<tr>
<td><code>こさじ</code> (小さじ)</td>
<td>名</td>
<td>小勺</td>
<td><code>ボリューム</code></td>
<td>名</td>
<td>音量</td>
</tr>
<tr>
<td><code>ちょくつうれっしゃ</code> (直通列車)</td>
<td>名</td>
<td>直达列车</td>
<td><code>せかいいさん</code> (世界遺産)</td>
<td>名</td>
<td>世界遗产</td>
</tr>
<tr>
<td><code>かんこうスポット</code> (観光~)</td>
<td>名</td>
<td>旅游点</td>
<td><code>こえます</code> (超えます)</td>
<td>动2</td>
<td>超过</td>
</tr>
<tr>
<td><code>しゅつじょうします</code> (出場~)</td>
<td>动3</td>
<td>参加，出场</td>
<td><code>つまみぐいします</code> (つまみ食い~)</td>
<td>动3</td>
<td>偷吃</td>
</tr>
<tr>
<td><code>かんさんします</code> (換算~)</td>
<td>动3</td>
<td>换算</td>
<td><code>ふくしゅうします</code> (復習~)</td>
<td>动3</td>
<td>复习</td>
</tr>
<tr>
<td><code>せいこうします</code> (成功~)</td>
<td>动3</td>
<td>成功</td>
<td><code>よわい</code> (弱い)</td>
<td>形1</td>
<td>弱，脆弱，柔弱</td>
</tr>
<tr>
<td><code>きびしい</code> (厳しい)</td>
<td>形1</td>
<td>严厉，严格</td>
<td><code>ぜいたく</code></td>
<td>形2</td>
<td>奢望，奢侈，过分</td>
</tr>
<tr>
<td><code>こっそり</code></td>
<td>副</td>
<td>悄悄地</td>
<td><code>さすが</code></td>
<td>副</td>
<td>不愧是，果然</td>
</tr>
<tr>
<td><code>じっさいに</code> (実際に)</td>
<td>副</td>
<td>实际上</td>
<td><code>とうだい</code> (東大)</td>
<td>专</td>
<td>东京大学</td>
</tr>
<tr>
<td><code>はったつれい</code> (八達嶺)</td>
<td>专</td>
<td>八达岭</td>
<td><code>ペキンきたえき</code> (北京北駅)</td>
<td>专</td>
<td>北京北站</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第38课"><a href="#第38课" class="headerlink" title="第38课"></a>第38课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>しょうひん</code> (商品)</td>
<td>名</td>
<td>商品</td>
<td><code>ごみばこ</code> (ごみ箱)</td>
<td>名</td>
<td>垃圾箱</td>
</tr>
<tr>
<td><code>コップ</code></td>
<td>名</td>
<td>杯子</td>
<td><code>ペットボトル</code></td>
<td>名</td>
<td>塑料瓶</td>
</tr>
<tr>
<td><code>エンジン</code></td>
<td>名</td>
<td>发动机</td>
<td><code>タイヤ</code></td>
<td>名</td>
<td>轮胎</td>
</tr>
<tr>
<td><code>フートン</code> (胡同)</td>
<td>名</td>
<td>胡同</td>
<td><code>ろじ</code> (路地)</td>
<td>名</td>
<td>弄堂</td>
</tr>
<tr>
<td><code>ヨウテイアオ</code> (油条)</td>
<td>名</td>
<td>油条</td>
<td><code>にほんしょく</code> (日本食)</td>
<td>名</td>
<td>日本食品</td>
</tr>
<tr>
<td><code>さしみ</code> (刺身)</td>
<td>名</td>
<td>生鲜鱼</td>
<td><code>たな</code> (棚)</td>
<td>名</td>
<td>橱柜，搁板</td>
</tr>
<tr>
<td><code>たたみ</code> (畳)</td>
<td>名</td>
<td>草席，草垫</td>
<td><code>きもの</code> (着物)</td>
<td>名</td>
<td>和服，衣服</td>
</tr>
<tr>
<td><code>ぐあい</code> (具合)</td>
<td>名</td>
<td>情况</td>
<td><code>ひらがな</code> (平仮名)</td>
<td>名</td>
<td>平假名</td>
</tr>
<tr>
<td><code>あかちゃん</code> (赤ちゃん)</td>
<td>名</td>
<td>婴儿，幼儿</td>
<td><code>はんぶん</code> (半分)</td>
<td>名</td>
<td>一半</td>
</tr>
<tr>
<td><code>さいしゅう</code> (最終)</td>
<td>名</td>
<td>最终</td>
<td><code>しあい</code> (試合)</td>
<td>名</td>
<td>比赛</td>
</tr>
<tr>
<td><code>えいじしんぶん</code> (英字新聞)</td>
<td>名</td>
<td>英文报纸</td>
<td><code>えいせいほうそう</code> (衛星放送)</td>
<td>名</td>
<td>卫星广播</td>
</tr>
<tr>
<td><code>ストレス</code></td>
<td>名</td>
<td>精神紧张状态</td>
<td><code>でんとうてき</code> (伝統的)</td>
<td>名</td>
<td>传统的</td>
</tr>
<tr>
<td><code>いりくみます</code> (入り組みます)</td>
<td>动1</td>
<td>错综复杂</td>
<td><code>へります</code> (減ります)</td>
<td>动1</td>
<td>减少</td>
</tr>
<tr>
<td><code>うごかします</code> (動かします)</td>
<td>动1</td>
<td>开动，移动，摇动</td>
<td><code>かちます</code> (勝ちます)</td>
<td>动1</td>
<td>取胜，获胜</td>
</tr>
<tr>
<td><code>とおりぬけます</code> (通り抜けます)</td>
<td>动2</td>
<td>走得出去，穿过，通过</td>
<td><code>かんじます</code> (感じます)</td>
<td>动2</td>
<td>感觉</td>
</tr>
<tr>
<td><code>とりかえます</code> (取り替えます)</td>
<td>动2</td>
<td>更换，交换</td>
<td><code>てつやします</code> (徹夜~)</td>
<td>动3</td>
<td>熬通宵，彻夜</td>
</tr>
<tr>
<td><code>やけどします</code> (火傷~)</td>
<td>动3</td>
<td>烫伤，烧伤</td>
<td><code>なんだか</code></td>
<td>副</td>
<td>总觉得，总有点</td>
</tr>
<tr>
<td><code>うえのどうぶつえん</code> (上野動物園)</td>
<td>专</td>
<td>上野动物园</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>このへん</code> (この辺)</td>
<td>这附近</td>
<td><code>いそいで</code> (急いで)</td>
<td>匆忙地</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第39课"><a href="#第39课" class="headerlink" title="第39课"></a>第39课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>むら</code> (村)</td>
<td>名</td>
<td>村子，村庄</td>
<td><code>いね</code> (稲)</td>
<td>名</td>
<td>稻子</td>
</tr>
<tr>
<td><code>きり</code> (霧)</td>
<td>名</td>
<td>雾</td>
<td><code>もん</code> (門)</td>
<td>名</td>
<td>城门，门</td>
</tr>
<tr>
<td><code>ぶたい</code> (舞台)</td>
<td>名</td>
<td>舞台</td>
<td><code>やね</code> (屋根)</td>
<td>名</td>
<td>屋顶</td>
</tr>
<tr>
<td><code>るりがわら</code> (瑠璃瓦)</td>
<td>名</td>
<td>琉璃瓦</td>
<td><code>きいろ</code> (黄色)</td>
<td>名</td>
<td>黄色</td>
</tr>
<tr>
<td><code>そら</code> (空)</td>
<td>名</td>
<td>天空</td>
<td><code>バック</code></td>
<td>名</td>
<td>背景</td>
</tr>
<tr>
<td><code>かしきり</code> (貸し切り)</td>
<td>名</td>
<td>包租</td>
<td><code>いっぱん</code> (一般)</td>
<td>名</td>
<td>一般</td>
</tr>
<tr>
<td><code>そぼ</code> (祖母)</td>
<td>名</td>
<td>祖母，外婆</td>
<td><code>おんがくかい</code> (音楽会)</td>
<td>名</td>
<td>音乐会</td>
</tr>
<tr>
<td><code>ジャズ</code></td>
<td>名</td>
<td>爵士乐</td>
<td><code>やがいコンサート</code> (野外~)</td>
<td>名</td>
<td>露天音乐会</td>
</tr>
<tr>
<td><code>えんだか</code> (円高)</td>
<td>名</td>
<td>日元升值</td>
<td><code>ゆしゅつ</code> (輸出)</td>
<td>名</td>
<td>出口，输出</td>
</tr>
<tr>
<td><code>えいきょう</code> (影響)</td>
<td>名</td>
<td>影响</td>
<td><code>しげん</code> (資源)</td>
<td>名</td>
<td>资源</td>
</tr>
<tr>
<td><code>きおん</code> (気温)</td>
<td>名</td>
<td>气温</td>
<td><code>おき</code> (沖)</td>
<td>名</td>
<td>海上，湖心</td>
</tr>
<tr>
<td><code>かいがい</code> (海外)</td>
<td>名</td>
<td>海外</td>
<td><code>クジラ</code></td>
<td>名</td>
<td>鲸</td>
</tr>
<tr>
<td><code>サメ</code></td>
<td>名</td>
<td>鲨鱼</td>
<td><code>ユーフォー</code> (UFO)</td>
<td>名</td>
<td>不明飞行物</td>
</tr>
<tr>
<td><code>むかし</code> (昔)</td>
<td>名</td>
<td>以前</td>
<td><code>べつめい</code> (別名)</td>
<td>名</td>
<td>别名</td>
</tr>
<tr>
<td><code>ほう</code> (方)</td>
<td>名</td>
<td>方面</td>
<td><code>どうろこうじ</code> (道路工事)</td>
<td>名</td>
<td>道路施工</td>
</tr>
<tr>
<td><code>つうきんラッシュ</code> (通勤~)</td>
<td>名</td>
<td>上下班高峰</td>
<td><code>つうこうきんし</code> (通行禁止)</td>
<td>名</td>
<td>禁止通行</td>
</tr>
<tr>
<td><code>とおく</code> (遠く)</td>
<td>名</td>
<td>远处，远方</td>
<td><code>みわたします</code> (見渡します)</td>
<td>动1</td>
<td>眺望</td>
</tr>
<tr>
<td><code>つづきます</code> (続きます)</td>
<td>动1</td>
<td>继续，持续</td>
<td><code>なくなります</code></td>
<td>动1</td>
<td>完，丢失</td>
</tr>
<tr>
<td><code>そだちます</code> (育ちます)</td>
<td>动1</td>
<td>生长，成长</td>
<td><code>ふえます</code> (増えます)</td>
<td>动2</td>
<td>增加</td>
</tr>
<tr>
<td><code>つれます</code> (連れます)</td>
<td>动2</td>
<td>带，领</td>
<td><code>けっせきします</code> (欠席~)</td>
<td>动3</td>
<td>缺席</td>
</tr>
<tr>
<td><code>ゆにゅうします</code> (輸入~)</td>
<td>动3</td>
<td>进口，输入</td>
<td><code>せっかく</code></td>
<td>副</td>
<td>好(不)容易，特意</td>
</tr>
<tr>
<td><code>ぜったい</code> (絶対)</td>
<td>副</td>
<td>一定</td>
<td><code>そうそう</code></td>
<td>叹</td>
<td>是的是的</td>
</tr>
<tr>
<td><code>しきんじょう</code> (紫禁城)</td>
<td>专</td>
<td>紫禁城</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第40课"><a href="#第40课" class="headerlink" title="第40课"></a>第40课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>モノレール</code></td>
<td>名</td>
<td>单轨铁路</td>
<td><code>オイル</code></td>
<td>名</td>
<td>油，润滑油</td>
</tr>
<tr>
<td><code>ダンス</code></td>
<td>名</td>
<td>跳舞</td>
<td><code>じだい</code> (時代)</td>
<td>名</td>
<td>时代</td>
</tr>
<tr>
<td><code>やくしゃ</code> (役者)</td>
<td>名</td>
<td>演员</td>
<td><code>むすめ</code> (娘)</td>
<td>名</td>
<td>女儿</td>
</tr>
<tr>
<td><code>こいぬ</code> (子犬)</td>
<td>名</td>
<td>小狗</td>
<td><code>げきじょう</code> (劇場)</td>
<td>名</td>
<td>剧场</td>
</tr>
<tr>
<td><code>ししゃかい</code> (試写会)</td>
<td>名</td>
<td>试映会</td>
<td><code>みみ</code> (耳)</td>
<td>名</td>
<td>耳朵</td>
</tr>
<tr>
<td><code>おく</code> (奥)</td>
<td>名</td>
<td>内部；深处</td>
<td><code>きげん</code> (機嫌)</td>
<td>名</td>
<td>情绪，心情</td>
</tr>
<tr>
<td><code>せんじつ</code> (先日)</td>
<td>名</td>
<td>前几天</td>
<td><code>コピーき</code> (~機)</td>
<td>名</td>
<td>复印机</td>
</tr>
<tr>
<td><code>けん</code> (券)</td>
<td>名</td>
<td>券，票</td>
<td><code>さいしゅうびん</code> (最終便)</td>
<td>名</td>
<td>最晚航班</td>
</tr>
<tr>
<td><code>にゅじょうけん</code> (入場券)</td>
<td>名</td>
<td>入场，门票</td>
<td><code>しょうたいけん</code> (招待券)</td>
<td>名</td>
<td>招待券，请帖</td>
</tr>
<tr>
<td><code>かいすうけん</code> (回数券)</td>
<td>名</td>
<td>回数券</td>
<td><code>むかいます</code> (向かいます)</td>
<td>动1</td>
<td>往~去</td>
</tr>
<tr>
<td><code>そろえます</code></td>
<td>动2</td>
<td>凑齐；使一致</td>
<td><code>もれます</code> (漏れます)</td>
<td>动2</td>
<td>泄漏</td>
</tr>
<tr>
<td><code>まとめます</code></td>
<td>动2</td>
<td>汇集；总结</td>
<td><code>かいつうします</code> (開通~)</td>
<td>动3</td>
<td>开通</td>
</tr>
<tr>
<td><code>かいちくします</code> (改築~)</td>
<td>动3</td>
<td>改建</td>
<td><code>かんせいします</code> (完成~)</td>
<td>动3</td>
<td>完成</td>
</tr>
<tr>
<td><code>にゅうしゃします</code> (入社~)</td>
<td>动3</td>
<td>入社</td>
<td><code>しん</code> (清)</td>
<td>专</td>
<td>清代</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>おまたせしました</code> (お待たせしました)</td>
<td>让您久等了</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第41课"><a href="#第41课" class="headerlink" title="第41课"></a>第41课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ことり</code> (小鳥)</td>
<td>名</td>
<td>小鸟</td>
<td><code>ばんぱく</code> (万博)</td>
<td>名</td>
<td>世博会</td>
</tr>
<tr>
<td><code>いせき</code> (遺跡)</td>
<td>名</td>
<td>遗址，遗迹</td>
<td><code>じょうし</code> (上司)</td>
<td>名</td>
<td>上司</td>
</tr>
<tr>
<td><code>すり</code></td>
<td>名</td>
<td>小偷</td>
<td><code>せだい</code> (世代)</td>
<td>名</td>
<td>世代；一代</td>
</tr>
<tr>
<td><code>しじょう</code> (市場)</td>
<td>名</td>
<td>市场</td>
<td><code>ちょうさ</code> (調査)</td>
<td>名</td>
<td>调查</td>
</tr>
<tr>
<td><code>しゅっか</code> (出荷)</td>
<td>名</td>
<td>上市，运出货物</td>
<td><code>せいちょう</code> (成長)</td>
<td>名</td>
<td>成长</td>
</tr>
<tr>
<td><code>あらし</code> (嵐)</td>
<td>名</td>
<td>暴风雨，风暴</td>
<td><code>ダイナマイト</code></td>
<td>名</td>
<td>炸药</td>
</tr>
<tr>
<td><code>ネーミング</code></td>
<td>名</td>
<td>名称，命名</td>
<td><code>コストグウン</code></td>
<td>名</td>
<td>降低成本</td>
</tr>
<tr>
<td><code>ていかかく</code> (低価格)</td>
<td>名</td>
<td>低价(格)</td>
<td><code>ぎゅうにく</code> (牛肉)</td>
<td>名</td>
<td>牛肉</td>
</tr>
<tr>
<td><code>いっさくねん</code> (一昨年)/<code>おととし</code></td>
<td>名</td>
<td>前年</td>
<td><code>さくねん</code> (昨年)</td>
<td>名</td>
<td>去年</td>
</tr>
<tr>
<td><code>こんご</code> (今後)</td>
<td>名</td>
<td>今后</td>
<td><code>すべて</code></td>
<td>名</td>
<td>全部</td>
</tr>
<tr>
<td><code>びしょぬれ</code></td>
<td>名</td>
<td>落汤鸡，湿透</td>
<td><code>みりょく</code> (魅力)</td>
<td>名</td>
<td>吸引力</td>
</tr>
<tr>
<td><code>おしょくじけん</code> (汚職事件)</td>
<td>名</td>
<td>贪污事件</td>
<td><code>しじょうちょうさ</code> (市場調査)</td>
<td>名</td>
<td>市场调查</td>
</tr>
<tr>
<td><code>こうつうじじょう</code> (交通事情)</td>
<td>名</td>
<td>交通状况</td>
<td><code>ごうべんがいしゃ</code> (合弁会社)</td>
<td>名</td>
<td>合资公司</td>
</tr>
<tr>
<td><code>しかります</code></td>
<td>动1</td>
<td>责备</td>
<td><code>かみます</code></td>
<td>动1</td>
<td>咬，嚼</td>
</tr>
<tr>
<td><code>さそいます</code> (誘います)</td>
<td>动1</td>
<td>邀请</td>
<td><code>まきこみます</code> (巻き込みます)</td>
<td>动1</td>
<td>卷入</td>
</tr>
<tr>
<td><code>いたります</code> (至ります)</td>
<td>动1</td>
<td>到达，达到</td>
<td><code>みつかります</code> (見つかります)</td>
<td>动1</td>
<td>找到，发现</td>
</tr>
<tr>
<td><code>ふみます</code> (踏みます)</td>
<td>动1</td>
<td>踩，踏</td>
<td><code>はかります</code> (図ります)</td>
<td>动1</td>
<td>谋求；考虑</td>
</tr>
<tr>
<td><code>みこみます</code> (見込みます)</td>
<td>动1</td>
<td>预料，估计</td>
<td><code>ぬすみます</code> (盗みます)</td>
<td>动1</td>
<td>盗取，偷盗</td>
</tr>
<tr>
<td><code>おこします</code> (起こします)</td>
<td>动1</td>
<td>叫醒，唤醒</td>
<td><code>ほめます</code></td>
<td>动2</td>
<td>表扬，赞扬</td>
</tr>
<tr>
<td><code>もとめます</code> (求めます)</td>
<td>动2</td>
<td>要求；寻求</td>
<td><code>いじめます</code></td>
<td>动2</td>
<td>欺负，折磨，欺侮</td>
</tr>
<tr>
<td><code>ぶつけます</code></td>
<td>动2</td>
<td>碰上，扔，投</td>
<td><code>はっけんします</code> (発見~)</td>
<td>动3</td>
<td>发现</td>
</tr>
<tr>
<td><code>じしょくします</code> (辞職~)</td>
<td>动3</td>
<td>辞职</td>
<td><code>そうりつします</code> (創立~)</td>
<td>动3</td>
<td>成立，创立</td>
</tr>
<tr>
<td><code>いらいします</code> (依頼~)</td>
<td>动3</td>
<td>委托，请求</td>
<td><code>はつばいします</code> (発売~)</td>
<td>动3</td>
<td>上市，发售，出售</td>
</tr>
<tr>
<td><code>かいはつします</code> (開発~)</td>
<td>动3</td>
<td>开发</td>
<td><code>せいぞうします</code> (製造~)</td>
<td>动3</td>
<td>生产，制造</td>
</tr>
<tr>
<td><code>かんりします</code> (管理~)</td>
<td>动3</td>
<td>管理</td>
<td><code>じつげんします</code> (実現~)</td>
<td>动3</td>
<td>实现</td>
</tr>
<tr>
<td><code>せんれんします</code> (洗練~)</td>
<td>动3</td>
<td>精炼</td>
<td><code>ほうそうします</code> (放送~)</td>
<td>动3</td>
<td>广播，播送</td>
</tr>
<tr>
<td><code>せいさんします</code> (生産~)</td>
<td>动3</td>
<td>生产</td>
<td><code>ほんやくします</code> (翻訳~)</td>
<td>动3</td>
<td>翻译</td>
</tr>
<tr>
<td><code>はつめいします</code> (発明~)</td>
<td>动3</td>
<td>发明</td>
<td><code>はばひろい</code> (幅広い)</td>
<td>形1</td>
<td>广泛，宽广，辽阔</td>
</tr>
<tr>
<td><code>おおはば</code> (大幅)</td>
<td>形2</td>
<td>大幅度，广泛</td>
<td><code>たいりょう</code> (大量)</td>
<td>形2</td>
<td>大量</td>
</tr>
<tr>
<td><code>もっとも</code> (最も)</td>
<td>副</td>
<td>最</td>
<td><code>いやあ</code></td>
<td>叹</td>
<td>哎呀</td>
</tr>
<tr>
<td><code>ニュートン</code></td>
<td>专</td>
<td>牛顿</td>
<td><code>ノーベル</code></td>
<td>专</td>
<td>诺贝尔</td>
</tr>
<tr>
<td><code>オーストラリア</code></td>
<td>专</td>
<td>澳大利亚</td>
<td><code>シーエスコンス</code> (CS公司)</td>
<td>专</td>
<td>CS公司</td>
</tr>
<tr>
<td><code>チンタオビール</code> (青岛~)</td>
<td>专</td>
<td>青岛啤酒</td>
<td><code>あキューせいでん</code> (阿Q正伝)</td>
<td>专</td>
<td>阿Q正传</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>まいりました</code> (参りました)</td>
<td>真糟糕，真倒霉</td>
<td><code>ばんゆういんりょくのほうそく</code> (万有引力の法則)</td>
<td>万有引力定律</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第42课"><a href="#第42课" class="headerlink" title="第42课"></a>第42课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>せきにんしゃ</code> (責任者)</td>
<td>名</td>
<td>负责人</td>
<td><code>どうりょう</code> (同僚)</td>
<td>名</td>
<td>同事</td>
</tr>
<tr>
<td><code>かんきゃく</code> (観客)</td>
<td>名</td>
<td>观众</td>
<td><code>くうふく</code> (空腹)</td>
<td>名</td>
<td>空腹，饿</td>
</tr>
<tr>
<td><code>かんき</code> (換気)</td>
<td>名</td>
<td>换气</td>
<td><code>るす</code> (留守)</td>
<td>名</td>
<td>不在家</td>
</tr>
<tr>
<td><code>こうどう</code> (講堂)</td>
<td>名</td>
<td>讲堂</td>
<td><code>ひるま</code> (昼間)</td>
<td>名</td>
<td>白天，白日</td>
</tr>
<tr>
<td><code>にってい</code> (日程)</td>
<td>名</td>
<td>日程</td>
<td><code>じかい</code> (次回)</td>
<td>名</td>
<td>下次</td>
</tr>
<tr>
<td><code>めざまし</code> (目覚まし)</td>
<td>名</td>
<td>闹钟；叫醒</td>
<td><code>アラーム</code></td>
<td>名</td>
<td>闹钟，闹铃</td>
</tr>
<tr>
<td><code>きかくあん</code> (企画案)</td>
<td>名</td>
<td>策划方案</td>
<td><code>おへんじ</code> (お返事)</td>
<td>名</td>
<td>回信</td>
</tr>
<tr>
<td><code>いきさき</code> (行き先)</td>
<td>名</td>
<td>目的地</td>
<td><code>あずかります</code> (預かります)</td>
<td>动1</td>
<td>保管</td>
</tr>
<tr>
<td><code>きづきます</code> (気づきます)</td>
<td>动1</td>
<td>发觉，发现</td>
<td><code>ひやします</code> (冷やします)</td>
<td>动1</td>
<td>冰镇，冷却</td>
</tr>
<tr>
<td><code>おもいだします</code> (思い出します)</td>
<td>动1</td>
<td>想起，想出</td>
<td><code>つげます</code> (告げます)</td>
<td>动2</td>
<td>告诉</td>
</tr>
<tr>
<td><code>ひえます</code> (冷えます)</td>
<td>动2</td>
<td>变冷；感觉凉</td>
<td><code>しんじます</code> (信じます)</td>
<td>动2</td>
<td>相信</td>
</tr>
<tr>
<td><code>おれます</code> (折れます)</td>
<td>动2</td>
<td>折，断；拐弯</td>
<td><code>しゅっきんします</code> (出勤~)</td>
<td>动3</td>
<td>上班，出勤</td>
</tr>
<tr>
<td><code>セットします</code></td>
<td>动3</td>
<td>设置</td>
<td><code>けんとうします</code> (検討~)</td>
<td>动3</td>
<td>讨论</td>
</tr>
<tr>
<td><code>ただしい</code> (正しい)</td>
<td>形1</td>
<td>正确的</td>
<td><code>とうぜん</code> (当然)</td>
<td>形2</td>
<td>当然，应当</td>
</tr>
<tr>
<td><code>たしか</code> (確か)</td>
<td>形2</td>
<td>确实；大概</td>
<td><code>じょうぶ</code> (丈夫)</td>
<td>形2</td>
<td>牢固，结实</td>
</tr>
<tr>
<td><code>さっそく</code> (早速)</td>
<td>副</td>
<td>立即</td>
<td><code>ちょくせつ</code> (直接)</td>
<td>副</td>
<td>直接</td>
</tr>
<tr>
<td><code>きっと</code></td>
<td>副</td>
<td>一定</td>
<td><code>だって</code></td>
<td>连</td>
<td>但是</td>
</tr>
<tr>
<td><code>にしちょうあんがい</code> (西長安街)</td>
<td>专</td>
<td>西长安街</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>るすにします</code> (留守にします)</td>
<td>不在家，无人在家</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第43课"><a href="#第43课" class="headerlink" title="第43课"></a>第43课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>おてつだい</code> (お手伝い)</td>
<td>名</td>
<td>帮忙</td>
<td><code>のりかえ</code> (乗り換え)</td>
<td>名</td>
<td>换车，换乘</td>
</tr>
<tr>
<td><code>かんがえ</code> (考え)</td>
<td>名</td>
<td>想法，思想</td>
<td><code>じょせいむけ</code> (女性向け)</td>
<td>名</td>
<td>女性专用</td>
</tr>
<tr>
<td><code>もうしで</code> (申し出)</td>
<td>名</td>
<td>申请，提议</td>
<td><code>かんじ</code> (感じ)</td>
<td>名</td>
<td>感觉</td>
</tr>
<tr>
<td><code>おおく</code> (多く)</td>
<td>名</td>
<td>多，多数</td>
<td><code>ぶか</code> (部下)</td>
<td>名</td>
<td>部下</td>
</tr>
<tr>
<td><code>かんとく</code> (監督)</td>
<td>名</td>
<td>教练，领队</td>
<td><code>せんしゅ</code> (選手)</td>
<td>名</td>
<td>运动员，选手</td>
</tr>
<tr>
<td><code>しょうひしゃ</code> (消費者)</td>
<td>名</td>
<td>消费者</td>
<td><code>あんないやく</code> (案内役)</td>
<td>名</td>
<td>向导</td>
</tr>
<tr>
<td><code>おや</code> (親)</td>
<td>名</td>
<td>双亲，父母</td>
<td><code>アルファベット</code></td>
<td>名</td>
<td>英语字母，拉丁字母</td>
</tr>
<tr>
<td><code>プレゼンテーション</code>/<code>プレゼン</code></td>
<td>名</td>
<td>策划方案说明(会)</td>
<td><code>イメージ</code></td>
<td>名</td>
<td>形象，印象</td>
</tr>
<tr>
<td><code>インパクト</code></td>
<td>名</td>
<td>冲击力，力量感</td>
<td><code>ガラス</code></td>
<td>名</td>
<td>玻璃，玻璃杯</td>
</tr>
<tr>
<td><code>きぶん</code> (気分)</td>
<td>名</td>
<td>情绪；(身体)舒适(与否)</td>
<td><code>しんきんかん</code> (親近感)</td>
<td>名</td>
<td>亲切感</td>
</tr>
<tr>
<td><code>ひんしつ</code> (品質)</td>
<td>名</td>
<td>质量，品质</td>
<td><code>ぶっか</code> (物価)</td>
<td>名</td>
<td>物价</td>
</tr>
<tr>
<td><code>めんぜいてん</code> (免税店)</td>
<td>名</td>
<td>免税店</td>
<td><code>せつめいしょ</code> (説明書)</td>
<td>名</td>
<td>说明书</td>
</tr>
<tr>
<td><code>じゅく</code> (塾)</td>
<td>名</td>
<td>私塾，补习学校</td>
<td><code>れいぶん</code> (例文)</td>
<td>名</td>
<td>例句</td>
</tr>
<tr>
<td><code>かいじょう</code> (会場)</td>
<td>名</td>
<td>会场</td>
<td><code>せつび</code> (設備)</td>
<td>名</td>
<td>设备</td>
</tr>
<tr>
<td><code>せんたくもの</code> (洗濯物)</td>
<td>名</td>
<td>洗的衣服</td>
<td><code>もの</code></td>
<td>名</td>
<td>东西，事物</td>
</tr>
<tr>
<td><code>じ</code> (字)</td>
<td>名</td>
<td>字</td>
<td><code>つま</code> (妻)</td>
<td>名</td>
<td>妻子</td>
</tr>
<tr>
<td><code>われわれ</code> (我々)</td>
<td>代</td>
<td>我们</td>
<td><code>ひっぱります</code> (引っ張ります)</td>
<td>动1</td>
<td>拉，拽</td>
</tr>
<tr>
<td><code>うかびます</code> (浮かびます)</td>
<td>动1</td>
<td>想起，浮</td>
<td><code>ととのいます</code> (整います)</td>
<td>动1</td>
<td>齐备，完备</td>
</tr>
<tr>
<td><code>かわきます</code> (乾きます)</td>
<td>动1</td>
<td>干，干燥</td>
<td><code>くらします</code> (暮らします)</td>
<td>动1</td>
<td>生活</td>
</tr>
<tr>
<td><code>さけます</code> (避けます)</td>
<td>动2</td>
<td>回避，避免</td>
<td><code>うれます</code> (売れます)</td>
<td>动2</td>
<td>好卖，畅销</td>
</tr>
<tr>
<td><code>うけます</code> (受けます)</td>
<td>动2</td>
<td>感受，受到</td>
<td><code>あたためます</code> (温めます)</td>
<td>动2</td>
<td>热，温</td>
</tr>
<tr>
<td><code>りかいします</code> (理解~)</td>
<td>动3</td>
<td>理解</td>
<td><code>ていあんします</code> (提案~)</td>
<td>动3</td>
<td>建议，提案</td>
</tr>
<tr>
<td><code>しさくします</code> (試作~)</td>
<td>动3</td>
<td>试作，试制</td>
<td><code>けいけんします</code> (経験~)</td>
<td>动3</td>
<td>经验，经历</td>
</tr>
<tr>
<td><code>あんきします</code> (暗記~)</td>
<td>动3</td>
<td>熟记，背诵</td>
<td><code>そうたいします</code> (早退~)</td>
<td>动3</td>
<td>早退</td>
</tr>
<tr>
<td><code>きゅうしょくします</code> (休職~)</td>
<td>动3</td>
<td>(暂时)停职</td>
<td><code>ちからづよい</code> (力強い)</td>
<td>形1</td>
<td>强有力；心里踏实</td>
</tr>
<tr>
<td><code>やわらかい</code> (柔らかい)</td>
<td>形1</td>
<td>柔软</td>
<td><code>かたい</code> (硬い)</td>
<td>形1</td>
<td>硬</td>
</tr>
<tr>
<td><code>あつい</code> (厚い)</td>
<td>形1</td>
<td>厚</td>
<td><code>じゅうよう</code> (重要)</td>
<td>形2</td>
<td>重要</td>
</tr>
<tr>
<td><code>たんじゅん</code> (単純)</td>
<td>形2</td>
<td>单纯</td>
<td><code>りそうてき</code> (理想的)</td>
<td>形2</td>
<td>理想</td>
</tr>
<tr>
<td><code>ぐたいてき</code> (具体的)</td>
<td>形2</td>
<td>具体</td>
<td><code>ざんしん</code> (斬新)</td>
<td>形2</td>
<td>新颖，崭新</td>
</tr>
<tr>
<td><code>ぐっと</code></td>
<td>副</td>
<td>更加；用力</td>
<td><code>たとえば</code> (例えば)</td>
<td>副</td>
<td>比如，例如</td>
</tr>
<tr>
<td><code>しかも</code></td>
<td>连</td>
<td>而且</td>
<td><code>そこで</code></td>
<td>连</td>
<td>因此，于是</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>いうまでもなく</code> (言うまでもなく)</td>
<td>不言而喻</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第44课"><a href="#第44课" class="headerlink" title="第44课"></a>第44课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>しゃいんりょこう</code> (社員旅行)</td>
<td>名</td>
<td>全社旅行</td>
<td><code>しんにゅうしゃいん</code> (新入社員)</td>
<td>名</td>
<td>新来的职员</td>
</tr>
<tr>
<td><code>かいぎじょう</code> (会議場)</td>
<td>名</td>
<td>会场</td>
<td><code>こくさいかいぎ</code> (国際会議)</td>
<td>名</td>
<td>国际会议</td>
</tr>
<tr>
<td><code>ビアガーデン</code></td>
<td>名</td>
<td>庭院式的啤酒店</td>
<td><code>おおがたスーパー</code> (大型~)</td>
<td>名</td>
<td>大型超市</td>
</tr>
<tr>
<td><code>みずうみ</code> (湖)</td>
<td>名</td>
<td>湖</td>
<td><code>パトカー</code></td>
<td>名</td>
<td>警车，巡逻车</td>
</tr>
<tr>
<td><code>サイレン</code></td>
<td>名</td>
<td>警笛，警报器</td>
<td><code>アニメ</code></td>
<td>名</td>
<td>动画片</td>
</tr>
<tr>
<td><code>パワー</code></td>
<td>名</td>
<td>能力，力量</td>
<td><code>こころ</code> (心)</td>
<td>名</td>
<td>心</td>
</tr>
<tr>
<td><code>たいど</code> (態度)</td>
<td>名</td>
<td>态度</td>
<td><code>せいかく</code> (性格)</td>
<td>名</td>
<td>性格</td>
</tr>
<tr>
<td><code>ひょうばん</code> (評判)</td>
<td>名</td>
<td>评价，评论</td>
<td><code>ぎょうれつ</code> (行列)</td>
<td>名</td>
<td>行列，队伍</td>
</tr>
<tr>
<td><code>ようき</code> (容器)</td>
<td>名</td>
<td>容器</td>
<td><code>ないよう</code> (内容)</td>
<td>名</td>
<td>内容</td>
</tr>
<tr>
<td><code>うれゆき</code> (売れ行き)</td>
<td>名</td>
<td>销路，销售情况</td>
<td><code>のりもの</code> (乗り物)</td>
<td>名</td>
<td>乘坐物</td>
</tr>
<tr>
<td><code>あせ</code> (汗)</td>
<td>名</td>
<td>汗</td>
<td><code>ばい</code> (倍)</td>
<td>名</td>
<td>倍，加倍</td>
</tr>
<tr>
<td><code>たて</code> (縦)</td>
<td>名</td>
<td>纵，竖</td>
<td><code>ちゅうごくぜんど</code> (中国全土)</td>
<td>名</td>
<td>全中国</td>
</tr>
<tr>
<td><code>ちょうきよほう</code> (長期予報)</td>
<td>名</td>
<td>长期预报</td>
<td><code>わらい</code> (笑い)</td>
<td>名</td>
<td>笑</td>
</tr>
<tr>
<td><code>あつさ</code> (暑さ)</td>
<td>名</td>
<td>暑热，暑气</td>
<td><code>うつくしさ</code> (美しさ)</td>
<td>名</td>
<td>美好，美丽程度</td>
</tr>
<tr>
<td><code>おもしろさ</code></td>
<td>名</td>
<td>趣味，有趣程度</td>
<td><code>おおきさ</code> (大きさ)</td>
<td>名</td>
<td>大小</td>
</tr>
<tr>
<td><code>たかさ</code> (高さ)</td>
<td>名</td>
<td>高度</td>
<td><code>ふかさ</code> (深さ)</td>
<td>名</td>
<td>深度</td>
</tr>
<tr>
<td><code>ながさ</code> (長さ)</td>
<td>名</td>
<td>长度</td>
<td><code>ひろさ</code> (広さ)</td>
<td>名</td>
<td>面积</td>
</tr>
<tr>
<td><code>ふとさ</code> (太さ)</td>
<td>名</td>
<td>粗(度)</td>
<td><code>おもさ</code> (重さ)</td>
<td>名</td>
<td>重量</td>
</tr>
<tr>
<td><code>あつさ</code> (厚さ)</td>
<td>名</td>
<td>厚度</td>
<td><code>はやさ</code> (速さ)</td>
<td>名</td>
<td>速度</td>
</tr>
<tr>
<td><code>べんりさ</code> (便利さ)</td>
<td>名</td>
<td>方便程度</td>
<td><code>ふくざつさ</code> (複雑さ)</td>
<td>名</td>
<td>复杂程度</td>
</tr>
<tr>
<td><code>おいしさ</code></td>
<td>名</td>
<td>美味，好吃程度</td>
<td><code>じゅうようさ</code> (重要さ)</td>
<td>名</td>
<td>重要性，重要程度</td>
</tr>
<tr>
<td><code>あまさ</code> (甘さ)</td>
<td>名</td>
<td>甜度</td>
<td><code>ひろがります</code> (広がります)</td>
<td>动1</td>
<td>蔓延，拓宽</td>
</tr>
<tr>
<td><code>もどります</code> (戻ります)</td>
<td>动1</td>
<td>返回，回到</td>
<td><code>おどろきます</code> (驚きます)</td>
<td>动1</td>
<td>惊讶，吃惊</td>
</tr>
<tr>
<td><code>しゃれます</code></td>
<td>动2</td>
<td>别致，风趣；打扮得漂亮</td>
<td><code>じっかんします</code> (実感~)</td>
<td>动3</td>
<td>切实感受，真切感受</td>
</tr>
<tr>
<td><code>ふかい</code> (深い)</td>
<td>形1</td>
<td>深</td>
<td><code>おとなしい</code></td>
<td>形1</td>
<td>温顺，老实</td>
</tr>
<tr>
<td><code>はずかしい</code> (恥ずかしい)</td>
<td>形1</td>
<td>害羞，难为情</td>
<td><code>めずらしい</code> (珍しい)</td>
<td>形1</td>
<td>珍奇，新奇</td>
</tr>
<tr>
<td><code>ごうか</code> (豪華)</td>
<td>形2</td>
<td>豪华，奢华</td>
<td><code>こうちょう</code> (好調)</td>
<td>形2</td>
<td>顺利，情况良好</td>
</tr>
<tr>
<td><code>ひかえめ</code> (控えめ)</td>
<td>形2</td>
<td>分量少，节制，控制；拘谨</td>
<td><code>こうひょう</code> (好評)</td>
<td>形2</td>
<td>好评，称赞</td>
</tr>
<tr>
<td><code>だいじ</code> (大事)</td>
<td>形2</td>
<td>重要，宝贵</td>
<td><code>かなり</code></td>
<td>副</td>
<td>颇，相当</td>
</tr>
<tr>
<td><code>けっこう</code></td>
<td>副</td>
<td>很，相当</td>
<td><code>ささき</code> (佐々木)</td>
<td>专</td>
<td>佐佐木</td>
</tr>
<tr>
<td><code>びわこ</code> (琵琶湖)</td>
<td>专</td>
<td>琵琶湖</td>
<td><code>のぞみ</code></td>
<td>专</td>
<td>希望号</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>おかげさまで</code></td>
<td>托您的福</td>
<td><code>なんといっても</code> (何と言っても)</td>
<td>首先是，无论如何</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第45课"><a href="#第45课" class="headerlink" title="第45课"></a>第45课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>しょうしか</code> (少子化)</td>
<td>名</td>
<td>孩子减少现象</td>
<td><code>じんこう</code> (人口)</td>
<td>名</td>
<td>人口</td>
</tr>
<tr>
<td><code>へいきんねんれい</code> (平均年齢)</td>
<td>名</td>
<td>平均年龄</td>
<td><code>こうつう</code> (交通)</td>
<td>名</td>
<td>交通</td>
</tr>
<tr>
<td><code>べん</code> (便)</td>
<td>名</td>
<td>方便，便利</td>
<td><code>アクセス</code></td>
<td>名</td>
<td>连接，衔接</td>
</tr>
<tr>
<td><code>リニアモーターカー</code></td>
<td>名</td>
<td>磁悬浮列车</td>
<td><code>びん</code> (便)</td>
<td>名</td>
<td>航班</td>
</tr>
<tr>
<td><code>しない</code> (市内)</td>
<td>名</td>
<td>市内</td>
<td><code>いなか</code> (田舎)</td>
<td>名</td>
<td>农村</td>
</tr>
<tr>
<td><code>ちゅうしんち</code> (中心地)</td>
<td>名</td>
<td>中心地区</td>
<td><code>きんだいか</code> (近代化)</td>
<td>名</td>
<td>现代化</td>
</tr>
<tr>
<td><code>げんだいじん</code> (現代人)</td>
<td>名</td>
<td>现代人</td>
<td><code>じかんたい</code> (時間帯)</td>
<td>名</td>
<td>时间段</td>
</tr>
<tr>
<td><code>ちょうし</code> (調子)</td>
<td>名</td>
<td>情况，状况；势头</td>
<td><code>よさ</code></td>
<td>名</td>
<td>长处，好处</td>
</tr>
<tr>
<td><code>へやだい</code> (部屋代)</td>
<td>名</td>
<td>房租</td>
<td><code>しんりん</code> (森林)</td>
<td>名</td>
<td>森林</td>
</tr>
<tr>
<td><code>ちきゅう</code> (地球)</td>
<td>名</td>
<td>地球</td>
<td><code>へいきんきおん</code> (平均気温)</td>
<td>名</td>
<td>平均气温</td>
</tr>
<tr>
<td><code>ちきゅうおんだんか</code> (地球温暖化)</td>
<td>名</td>
<td>地球变暖现象</td>
<td><code>れいとうしょくひん</code> (冷凍食品)</td>
<td>名</td>
<td>冷冻食品</td>
</tr>
<tr>
<td><code>こうれいしゃ</code> (高齢者)</td>
<td>名</td>
<td>高龄者</td>
<td><code>きつえんしゃ</code> (喫煙者)</td>
<td>名</td>
<td>吸烟者</td>
</tr>
<tr>
<td><code>りょこうしゃ</code> (旅行者)</td>
<td>名</td>
<td>旅行者</td>
<td><code>りようしゃ</code> (利用者)</td>
<td>名</td>
<td>利用者</td>
</tr>
<tr>
<td><code>なやみ</code> (悩み)</td>
<td>名</td>
<td>烦恼</td>
<td><code>まちなみ</code> (町並み)</td>
<td>名</td>
<td>市容，街道，街景</td>
</tr>
<tr>
<td><code>うりあげ</code> (うりあげ)</td>
<td>名</td>
<td>销售额，营业额</td>
<td><code>あこがれ</code></td>
<td>名</td>
<td>憧憬</td>
</tr>
<tr>
<td><code>すすみます</code> (進みます)</td>
<td>动1</td>
<td>加重，前进</td>
<td><code>みがきます</code> (磨きます)</td>
<td>动1</td>
<td>刷，擦</td>
</tr>
<tr>
<td><code>くもります</code> (曇ります)</td>
<td>动1</td>
<td>天阴</td>
<td><code>にます</code> (似ます)</td>
<td>动2</td>
<td>像，相似</td>
</tr>
<tr>
<td><code>ライトアップします</code></td>
<td>动3</td>
<td>景观照明</td>
<td><code>ふきゅうします</code> (普及~)</td>
<td>动3</td>
<td>普及</td>
</tr>
<tr>
<td><code>あまやどりします</code> (雨宿り~)</td>
<td>动3</td>
<td>避雨</td>
<td><code>ひどい</code></td>
<td>形1</td>
<td>残酷，过分；激烈</td>
</tr>
<tr>
<td><code>てがる</code> (手軽)</td>
<td>形2</td>
<td>简便，简单，轻便</td>
<td><code>きゅうそく</code> (急速)</td>
<td>形2</td>
<td>迅速</td>
</tr>
<tr>
<td><code>いぜん</code> (以前)</td>
<td>副</td>
<td>以前</td>
<td><code>どんどん</code></td>
<td>副</td>
<td>连接不断地</td>
</tr>
<tr>
<td><code>ますます</code></td>
<td>副</td>
<td>更加</td>
<td><code>なんか</code></td>
<td>副</td>
<td>总觉得</td>
</tr>
<tr>
<td><code>ねんねん</code> (年々)</td>
<td>副</td>
<td>逐年，每年</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>かるいもの</code> (軽い物)</td>
<td>清淡的或少量的食物</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第46课"><a href="#第46课" class="headerlink" title="第46课"></a>第46课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>けがわ</code> (毛皮)</td>
<td>名</td>
<td>毛皮</td>
<td><code>ほんもの</code> (本物)</td>
<td>名</td>
<td>真货</td>
</tr>
<tr>
<td><code>がら</code> (柄)</td>
<td>名</td>
<td>花纹，花样</td>
<td><code>レモン</code></td>
<td>名</td>
<td>柠檬</td>
</tr>
<tr>
<td><code>みそしる</code> (みそ汁)</td>
<td>名</td>
<td>酱汤</td>
<td><code>おまつり</code> (お祭り)</td>
<td>名</td>
<td>祭日，节日</td>
</tr>
<tr>
<td><code>オートバイ</code></td>
<td>名</td>
<td>摩托车</td>
<td><code>インタビュー</code></td>
<td>名</td>
<td>采访</td>
</tr>
<tr>
<td><code>プラン</code></td>
<td>名</td>
<td>计划</td>
<td><code>ずつう</code> (頭痛)</td>
<td>名</td>
<td>头疼</td>
</tr>
<tr>
<td><code>さむけ</code> (寒気)</td>
<td>名</td>
<td>寒气，寒战</td>
<td><code>はきけ</code> (吐き気)</td>
<td>名</td>
<td>恶心，想要呕吐</td>
</tr>
<tr>
<td><code>かじ</code> (家事)</td>
<td>名</td>
<td>家务活</td>
<td><code>めんせつ</code> (面接)</td>
<td>名</td>
<td>面试</td>
</tr>
<tr>
<td><code>できごと</code> (出来事)</td>
<td>名</td>
<td>事情，事件</td>
<td><code>いけん</code> (意見)</td>
<td>名</td>
<td>意见</td>
</tr>
<tr>
<td><code>かいせつ</code> (開設)</td>
<td>名</td>
<td>开设</td>
<td><code>こうほち</code> (候補地)</td>
<td>名</td>
<td>候选地</td>
</tr>
<tr>
<td><code>まわり</code> (周り)</td>
<td>名</td>
<td>一带，周围</td>
<td><code>あかるさ</code> (明るさ)</td>
<td>名</td>
<td>明朗，快活</td>
</tr>
<tr>
<td><code>におい</code></td>
<td>名</td>
<td>味道，气味</td>
<td><code>せっけん</code></td>
<td>名</td>
<td>肥皂</td>
</tr>
<tr>
<td><code>こうすい</code> (香水)</td>
<td>名</td>
<td>香水</td>
<td><code>ラン</code></td>
<td>名</td>
<td>兰花</td>
</tr>
<tr>
<td><code>すえ</code> (末)</td>
<td>名</td>
<td>末尾，末了</td>
<td><code>はじめ</code> (初め)</td>
<td>名</td>
<td>最初</td>
</tr>
<tr>
<td><code>はんつき</code> (半月)</td>
<td>名</td>
<td>半月，半个月</td>
<td><code>モデル</code></td>
<td>名</td>
<td>模特儿</td>
</tr>
<tr>
<td><code>けいさつかん</code> (警察官)</td>
<td>名</td>
<td>警察</td>
<td><code>おすもうさん</code> (お相撲さん)</td>
<td>名</td>
<td>相扑选手</td>
</tr>
<tr>
<td><code>かぶきやくしゃ</code> (歌舞伎役者)</td>
<td>名</td>
<td>歌舞伎演员</td>
<td><code>すいえいせんしゅ</code> (水泳選手)</td>
<td>名</td>
<td>游泳选手</td>
</tr>
<tr>
<td><code>すみます</code> (済みます)</td>
<td>动1</td>
<td>结束，完了</td>
<td><code>つもります</code> (積もります)</td>
<td>动1</td>
<td>堆积；积攒</td>
</tr>
<tr>
<td><code>すごします</code> (過ごします)</td>
<td>动1</td>
<td>度过；生活</td>
<td><code>ほほえみます</code></td>
<td>动1</td>
<td>微笑</td>
</tr>
<tr>
<td><code>のばします</code> (延ばします)</td>
<td>动1</td>
<td>延长</td>
<td><code>すませます</code> (済ませます)</td>
<td>动2</td>
<td>搞完，办完</td>
</tr>
<tr>
<td><code>かれます</code> (枯れます)</td>
<td>动2</td>
<td>枯萎；干燥</td>
<td><code>はっそうします</code> (発送~)</td>
<td>动3</td>
<td>发送，寄送</td>
</tr>
<tr>
<td><code>きんちょうします</code> (緊張~)</td>
<td>动3</td>
<td>紧张</td>
<td><code>さわやか</code></td>
<td>形2</td>
<td>清爽，爽快</td>
</tr>
<tr>
<td><code>まるで</code></td>
<td>副</td>
<td>好像，就像</td>
<td><code>いかにも</code></td>
<td>副</td>
<td>典型的；的确</td>
</tr>
<tr>
<td><code>ワイタン</code> (外灘)</td>
<td>专</td>
<td>外滩</td>
<td><code>おきなわ</code> (沖縄)</td>
<td>专</td>
<td>冲绳</td>
</tr>
<tr>
<td><code>ナンキンろ</code> (南京路)</td>
<td>专</td>
<td>南京路</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>このごろ</code></td>
<td>最近，近来，最近时期</td>
<td><code>じむしょさがし</code> (事務所探し)</td>
<td>寻找事务所</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第47课"><a href="#第47课" class="headerlink" title="第47课"></a>第47课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>したみ</code> (下見)</td>
<td>名</td>
<td>视察</td>
<td><code>スタッフ</code></td>
<td>名</td>
<td>职员，同事</td>
</tr>
<tr>
<td><code>おこさん</code> (お子さん)</td>
<td>名</td>
<td>您的孩子</td>
<td><code>めしあがります</code> (召し上がります)</td>
<td>动1</td>
<td>(尊他) 吃，喝</td>
</tr>
<tr>
<td><code>ごらんになります</code> (ご覧になります)</td>
<td>动1</td>
<td>(尊他) 看，读</td>
<td><code>おっしゃいます</code></td>
<td>动1</td>
<td>(尊他) 说，讲</td>
</tr>
<tr>
<td><code>いっしゃいます</code></td>
<td>动1</td>
<td>(尊他) 去，来，在</td>
<td><code>おいでになります</code></td>
<td>动1</td>
<td>(尊他) 去，来，在</td>
</tr>
<tr>
<td><code>なさいます</code></td>
<td>动1</td>
<td>(尊他) 做，干</td>
<td><code>くださいます</code></td>
<td>动1</td>
<td>(尊他) 给</td>
</tr>
<tr>
<td><code>チェックインします</code></td>
<td>动3</td>
<td>办理入住手续</td>
<td><code>ちょっこうします</code> (直行~)</td>
<td>动3</td>
<td>直接去，直达</td>
</tr>
<tr>
<td><code>さきほど</code> (先ほど)</td>
<td>副</td>
<td>刚才，方才</td>
<td><code>きむら</code> (木村)</td>
<td>专</td>
<td>木村</td>
</tr>
<tr>
<td><code>こう</code> (黄)</td>
<td>专</td>
<td>黄</td>
<td><code>ペキンくうこう</code> (北京空港)</td>
<td>专</td>
<td>北京机场</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ごぞんじです</code></td>
<td>(ご存じです)(尊他) 知道</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第48课"><a href="#第48课" class="headerlink" title="第48课"></a>第48课</h3><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>解释</th>
<th>单词</th>
<th>词性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>みょうにち</code> (明日)</td>
<td>名</td>
<td>明天</td>
<td><code>あす</code> (明日)</td>
<td>名</td>
<td>明天</td>
</tr>
<tr>
<td><code>さくじつ</code> (昨日)</td>
<td>名</td>
<td>昨天</td>
<td><code>このたび</code> (この度)</td>
<td>名</td>
<td>这次，这回</td>
</tr>
<tr>
<td><code>わくし</code> (私)</td>
<td>代</td>
<td>我</td>
<td><code>わたくしども</code> (私ども)</td>
<td>代</td>
<td>我们</td>
</tr>
<tr>
<td><code>しゃ</code> (社)</td>
<td>名</td>
<td>公司</td>
<td><code>もの</code> (者)</td>
<td>名</td>
<td>人，~的人</td>
</tr>
<tr>
<td><code>へいしゃ</code> (弊社)</td>
<td>名</td>
<td>敝公司</td>
<td><code>しんしゃ</code> (新車)</td>
<td>名</td>
<td>新车</td>
</tr>
<tr>
<td><code>きず</code> (傷)</td>
<td>名</td>
<td>瑕疵；创伤</td>
<td><code>しどう</code> (指導)</td>
<td>名</td>
<td>指教，指导</td>
</tr>
<tr>
<td><code>おつり</code></td>
<td>名</td>
<td>找的零钱</td>
<td><code>おうせつしつ</code> (応接室)</td>
<td>名</td>
<td>会客室</td>
</tr>
<tr>
<td><code>あんないじょう</code> (案内状)</td>
<td>名</td>
<td>通知，请帖</td>
<td><code>にゅうがくあんない</code> (入学案内)</td>
<td>名</td>
<td>入学指南</td>
</tr>
<tr>
<td><code>うかがいます</code> (伺います)</td>
<td>动1</td>
<td>(自谦) 去；来；问；拜访；请教</td>
<td><code>いたします</code></td>
<td>动1</td>
<td>(自谦) 做，干</td>
</tr>
<tr>
<td><code>まいります</code> (参ります)</td>
<td>动1</td>
<td>(自谦) 来，去</td>
<td><code>いただきます</code></td>
<td>动1</td>
<td>(自谦) 吃，喝；得到</td>
</tr>
<tr>
<td><code>おります</code></td>
<td>动1</td>
<td>在</td>
<td><code>ございます</code></td>
<td>动1</td>
<td>在，有，是</td>
</tr>
<tr>
<td><code>さしあげます</code> (差し上げます)</td>
<td>动2</td>
<td>(自谦) 给</td>
<td><code>ぞんじています</code> (存じています)</td>
<td>动2</td>
<td>(自谦) 知道</td>
</tr>
<tr>
<td><code>すすめます</code> (進めます)</td>
<td>动2</td>
<td>推进，使前进</td>
<td><code>はいけんします</code> (拝見~)</td>
<td>动3</td>
<td>(自谦) 看</td>
</tr>
<tr>
<td><code>しょうちします</code> (承知~)</td>
<td>动3</td>
<td>知道</td>
<td><code>きたいします</code> (期待~)</td>
<td>动3</td>
<td>希望，期待</td>
</tr>
<tr>
<td><code>せわします</code> (世話~)</td>
<td>动3</td>
<td>帮助；照顾</td>
<td><code>きちょう</code> (貴重)</td>
<td>形2</td>
<td>贵重</td>
</tr>
<tr>
<td><code>しょうしょう</code> (少々)</td>
<td>副</td>
<td>稍稍，一点儿</td>
<td><code>ただいま</code> (ただ今)</td>
<td>副</td>
<td>这会儿；立刻</td>
</tr>
<tr>
<td><code>とつぜん</code> (突然)</td>
<td>副</td>
<td>突然</td>
<td><code>じつは</code> (実は)</td>
<td>副</td>
<td>实际上</td>
</tr>
<tr>
<td><code>とうきょうりょうりスクール</code> (東京料理~)</td>
<td>专</td>
<td>东京厨师学校</td>
<td><code>ペキンにほんごがっこう</code> (北京日本語学校)</td>
<td>专</td>
<td>北京日语学校</td>
</tr>
<tr>
<td><code>ジェーシーじどうしゃ</code> (JC自動車)</td>
<td>专</td>
<td>JC汽车公司</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>句子</th>
<th>解释</th>
<th>句子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>なんのおかまいもしませんで</code> (何のお構いもしませんで)</td>
<td>招待不周</td>
<td><code>もうしわけございません</code> (申し訳ございません)</td>
<td>非常抱歉</td>
</tr>
</tbody>
</table>
</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/21/Linux驱动程序/Linux设备驱动基础/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/21/Linux驱动程序/Linux设备驱动基础/" itemprop="url">Linux设备驱动基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-21T17:39:00+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="驱动程序介绍"><a href="#驱动程序介绍" class="headerlink" title="驱动程序介绍"></a>驱动程序介绍</h3><p>&emsp;&emsp;设备驱动分为：字符设备驱动、网络接口驱动和块设备驱动。</p>
<ul>
<li>字符设备：字符设备是一种按字节来访问的设备，字符驱动则负责驱动字符设备，这样的驱动通常实现<code>open</code>、<code>close</code>、<code>read</code>和<code>write</code>系统调用。</li>
<li>块设备：在大部分的<code>Unix</code>系统，块设备不能按字节处理数据，只能一次传送一个或多个长度是<code>512</code>字节(或一个更大的<code>2</code>次幂的数)的整块数据，而<code>Linux</code>则允许块设备传送任意数目的字节。因此，块和字符设备的区别仅仅是驱动的与内核的接口不同。</li>
<li>网络接口：任何网络事务都通过一个接口来进行，一个接口通常是一个硬件设备(<code>eth0</code>)，但是它也可以是一个纯粹的软件设备，比如回环接口(<code>lo</code>)。一个网络接口负责发送和接收数据报文。</li>
</ul>
<p>&emsp;&emsp;<code>Linux</code>用户程序通过设备文件(又称为<code>设备节点</code>)来使用驱动程序操作字符设备和块设备。</p>
<p><img src="/2019/03/21/Linux驱动程序/Linux设备驱动基础/1.png" height="243" width="449"></p>
<h3 id="字符设备驱动程序"><a href="#字符设备驱动程序" class="headerlink" title="字符设备驱动程序"></a>字符设备驱动程序</h3><h4 id="主次设备号"><a href="#主次设备号" class="headerlink" title="主次设备号"></a>主次设备号</h4><p>&emsp;&emsp;字符设备通过字符设备文件来存取。字符设备文件由使用<code>ls -l</code>的输出的第一列的<code>c</code>标识。如果使用<code>ls -l</code>命令，会看到在设备文件项中有<code>2</code>个数(由一个逗号分隔)。这些数字就是设备文件的主次设备编号。</p>
<h4 id="设备号作用"><a href="#设备号作用" class="headerlink" title="设备号作用"></a>设备号作用</h4><p>&emsp;&emsp;主设备号用来标识与设备文件相连的驱动程序，次编号被驱动程序用来辨别操作的是哪个设备。主设备号用来反映设备类型，次设备号用来区分同类型的设备。内核中使用<code>dev_t</code>类型描述设备号，<code>dev_t</code>其实质为<code>unsigned int</code>的<code>32</code>位整数，其中高<code>12</code>位为主设备号，低<code>20</code>位为次设备号。可以使用<code>MAJOR(dev_t dev)</code>从<code>dev_t</code>中分解出主设备号，使用<code>MINOR(dev_t dev)</code>从<code>dev_t</code>中分解出次设备号。</p>
<h4 id="分配主设备号"><a href="#分配主设备号" class="headerlink" title="分配主设备号"></a>分配主设备号</h4><p>&emsp;&emsp;<code>Linux</code>内核可以采用静态申请、动态分配两种方法给设备分配主设备号。</p>
<h4 id="静态申请"><a href="#静态申请" class="headerlink" title="静态申请"></a>静态申请</h4><p>&emsp;&emsp;方法主要有：根据<code>Documentation/devices.txt</code>，确定一个没有使用的主设备号；使用<code>register_chrdev_region</code>函数注册设备号。优点是简单，缺点是一旦驱动被广泛使用，这个随机选定的主设备号可能会导致设备号冲突，而使驱动程序无法注册。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_chrdev_region</span> <span class="params">( <span class="keyword">dev_t</span> from, <span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br></pre></td></tr></table></figure>
<p>申请使用从<code>from</code>开始的<code>count</code>个设备号(主设备号不变，次设备号增加)。</p>
<ul>
<li><code>from</code>：希望申请使用的设备号。</li>
<li><code>count</code>：希望申请使用设备号数目。</li>
<li><code>name</code>：设备名(体现在<code>/proc/devices</code>)。</li>
</ul>
<h4 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h4><p>&emsp;&emsp;使用<code>alloc_chrdev_region</code>分配设备号。优点是简单，易于驱动推广。缺点是无法在安装驱动前创建设备文件(因为安装前还没有分配到主设备号)。解决办法：安装驱动后，从<code>/proc/devices</code>中查询设备号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_chrdev_region</span> <span class="params">( <span class="keyword">dev_t</span> *dev, <span class="keyword">unsigned</span> baseminor, <span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br></pre></td></tr></table></figure>
<p>请求内核动态分配<code>count</code>个设备号，且次设备号从<code>baseminor</code>开始。</p>
<ul>
<li><code>dev</code>：分配到的设备号。</li>
<li><code>baseminor</code>：起始次设备号。</li>
<li><code>count</code>：需要分配的设备号数目。</li>
<li><code>name</code>：设备名(体现在<code>/proc/devices</code>)。</li>
</ul>
<h4 id="注销设备号"><a href="#注销设备号" class="headerlink" title="注销设备号"></a>注销设备号</h4><p>&emsp;&emsp;不论使用何种方法分配设备号，都应该在不再使用它们时释放这些设备号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister_chrdev_region</span> <span class="params">( <span class="keyword">dev_t</span> from, <span class="keyword">unsigned</span> count )</span></span>;</span><br></pre></td></tr></table></figure>
<p>释放从<code>from</code>开始的<code>count</code>个设备号。</p>
<h4 id="创建设备文件"><a href="#创建设备文件" class="headerlink" title="创建设备文件"></a>创建设备文件</h4><p>&emsp;&emsp;<code>2</code>种方法分别是：使用<code>mknod</code>命令手工创建；自动创建。</p>
<h4 id="手工创建"><a href="#手工创建" class="headerlink" title="手工创建"></a>手工创建</h4><p>&emsp;&emsp;<code>mknod</code>用法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod filename <span class="built_in">type</span> major minor</span><br></pre></td></tr></table></figure>
<ul>
<li><code>filename</code>：设备文件名。</li>
<li><code>type</code>：设备文件类型。</li>
<li><code>major</code>：主设备号。</li>
<li><code>minor</code>：次设备号。</li>
</ul>
<p>&emsp;&emsp;使用范例为<code>mknod serial0 c 100 0</code>。</p>
<h4 id="重要结构"><a href="#重要结构" class="headerlink" title="重要结构"></a>重要结构</h4><p>&emsp;&emsp;在<code>Linux</code>字符设备驱动程序设计中，有<code>3</code>种非常重要的数据结构：<code>struct file</code>、<code>struct inode</code>和<code>struct file_operations</code>。</p>
<h4 id="Struct-File"><a href="#Struct-File" class="headerlink" title="Struct File"></a>Struct File</h4><p>&emsp;&emsp;代表一个打开的文件。系统中每个打开的文件在内核空间都有一个关联的<code>struct file</code>。它由内核在打开文件时创建，在文件关闭后释放。重要成员有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loff_t</span> f_pos; <span class="comment">/* 文件读写位置 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span></span><br></pre></td></tr></table></figure>
<h4 id="Struct-Inode"><a href="#Struct-Inode" class="headerlink" title="Struct Inode"></a>Struct Inode</h4><p>&emsp;&emsp;用来记录文件的物理上的信息。因此，它和代表打开文件的<code>file</code>结构是不同的。一个文件可以对应多个<code>file</code>结构，但只有一个<code>inode</code>结构。重要成员有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dev_t</span> i_rdev; <span class="comment">/* 设备号 */</span></span><br></pre></td></tr></table></figure>
<h4 id="Struct-file-operations"><a href="#Struct-file-operations" class="headerlink" title="Struct file_operations"></a>Struct file_operations</h4><p>&emsp;&emsp;一个函数指针的集合，定义能在设备上进行的操作。结构中的成员指向驱动中的函数，这些函数实现一个特别的操作，对于不支持的操作保留为<code>NULL</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mem_fops</span> = &#123;</span></span><br><span class="line">    .owner   = THIS_MODULE,</span><br><span class="line">    .llseek  = mem_seek,</span><br><span class="line">    .read    = mem_read,</span><br><span class="line">    .write   = mem_write,</span><br><span class="line">    .ioctl   = mem_ioctl,</span><br><span class="line">    .open    = mem_open,</span><br><span class="line">    .release = mem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="设备注册"><a href="#设备注册" class="headerlink" title="设备注册"></a>设备注册</h4><p>&emsp;&emsp;在<code>linux 2.6</code>内核中，字符设备使用<code>struct cdev</code>来描述。字符设备的注册可分为如下<code>3</code>个步骤：</p>
<ol>
<li>分配<code>cdev</code>。</li>
<li>初始化<code>cdev</code>。</li>
<li>添加<code>cdev</code>。</li>
</ol>
<p>&emsp;&emsp;<code>Struct cdev</code>的分配可使用<code>cdev_alloc</code>函数来完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct cdev *<span class="title">cdev_alloc</span> <span class="params">( <span class="keyword">void</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>Struct cdev</code>的初始化使用<code>cdev_init</code>函数来完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span> <span class="params">( struct cdev *cdev, <span class="keyword">const</span> struct file_operations *fops )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cdev</code>：待初始化的<code>cdev</code>结构。</li>
<li><code>fops</code>：设备对应的操作函数集</li>
</ul>
<p>&emsp;&emsp;<code>struct cdev</code>的注册使用<code>cdev_add</code>函数来完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span> <span class="params">( struct cdev *p, <span class="keyword">dev_t</span> dev, <span class="keyword">unsigned</span> count )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>p</code>：待添加到内核的字符设备结构。</li>
<li><code>dev</code>：设备号。</li>
<li><code>count</code>：添加的设备个数。</li>
</ul>
<h4 id="设备操作"><a href="#设备操作" class="headerlink" title="设备操作"></a>设备操作</h4><ul>
<li><code>int ( *open ) ( struct inode *, struct file * );</code>：在设备文件上的第一个操作，并不要求驱动程序一定要实现这个方法。如果该项为NULL，设备的打开操作永远成功。</li>
<li><code>void ( *release ) ( struct inode *, struct file * );</code>：当设备文件被关闭时调用这个操作。与<code>open</code>相仿，<code>release</code>也可以没有。</li>
<li><code>ssize_t ( *read ) ( struct file *, char __user *, size_t, loff_t * );</code>：从设备中读取数据。函数返回一个非负值，表示成功地从设备中读取多少字节。</li>
<li><code>ssize_t ( *write ) ( struct file *, const char __user *, size_t, loff_t * );</code>：向设备发送数据。</li>
<li><code>unsigned int ( *poll ) ( struct file *, struct poll_table_struct * );</code>：对应<code>select</code>系统调用。</li>
<li><code>int ( *ioctl ) ( struct inode *, struct file *, unsigned int, unsigned long );</code>：控制设备。</li>
<li><code>int ( *mmap ) ( struct file *, struct vm_area_struct * );</code>：将设备映射到进程虚拟地址空间中。</li>
<li><code>off_t ( *llseek ) ( struct file *, loff_t, int );</code>：修改文件的当前读写位置，并将新位置作为返回值。</li>
<li><code>int ( *select ) ( struct inode *, struct file *, int, select_table * );</code>：一般用于程序询问设备是否可读或可写。</li>
</ul>
<h4 id="Open方法"><a href="#Open方法" class="headerlink" title="Open方法"></a>Open方法</h4><p>&emsp;&emsp;<code>Open</code>方法是驱动程序用来为以后的操作完成初始化准备工作的。在大部分驱动程序中，<code>open</code>完成如下工作：初始化设备；标明次设备号。</p>
<h4 id="Release方法"><a href="#Release方法" class="headerlink" title="Release方法"></a>Release方法</h4><p>&emsp;&emsp;<code>Release</code>方法的作用正好与<code>open</code>相反。这个设备方法有时也称为<code>close</code>，它关闭设备。</p>
<h4 id="读和写"><a href="#读和写" class="headerlink" title="读和写"></a>读和写</h4><p>&emsp;&emsp;读和写方法都完成类似的工作：从设备中读取数据到用户空间；将数据传递给驱动程序。它们的原型也相当相似：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> xxx_read ( struct file *filp, <span class="keyword">char</span> __user *buff, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *offp );</span><br><span class="line"><span class="keyword">ssize_t</span> xxx_write ( struct file *filp, <span class="keyword">char</span> __user *buff, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *offp );</span><br></pre></td></tr></table></figure>
<p><code>filp</code>是文件指针，<code>count</code>是请求传输的数据量，<code>buff</code>参数指向数据缓存，<code>offp</code>指出文件当前的访问位置。<br>&emsp;&emsp;<code>Read</code>和<code>Write</code>方法的<code>buff</code>参数是用户空间指针。因此，它不能被内核代码直接引用，理由如下：用户空间指针在内核空间时可能根本是无效的，这是因为没有那个地址的映射。内核提供了专门的函数用于访问用户空间的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_from_user</span> <span class="params">( <span class="keyword">void</span> *to, <span class="keyword">const</span> <span class="keyword">void</span> __user *from, <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_to_user</span> <span class="params">( <span class="keyword">void</span> __user *to, <span class="keyword">const</span> <span class="keyword">void</span> *from, <span class="keyword">int</span> n )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="读数据模型"><a href="#读数据模型" class="headerlink" title="读数据模型"></a>读数据模型</h4><p>&emsp;&emsp;读数据模型如下：</p>
<p><img src="/2019/03/21/Linux驱动程序/Linux设备驱动基础/2.png" height="252" width="480"></p>
<h4 id="设备注消"><a href="#设备注消" class="headerlink" title="设备注消"></a>设备注消</h4><p>&emsp;&emsp;字符设备的注销使用<code>cdev_del</code>函数来完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_del</span> <span class="params">( struct cdev *p )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>p</code>：要注销的字符设备结构。</li>
</ul>
<h3 id="驱动调试技术"><a href="#驱动调试技术" class="headerlink" title="驱动调试技术"></a>驱动调试技术</h3><h4 id="调试技术分类"><a href="#调试技术分类" class="headerlink" title="调试技术分类"></a>调试技术分类</h4><p>&emsp;&emsp;对于驱动程序设计来说，核心问题之一就是如何完成调试。当前常用的驱动调试技术可分为：打印调试、调试器调试和查询调试。</p>
<h4 id="打印调试"><a href="#打印调试" class="headerlink" title="打印调试"></a>打印调试</h4><p>&emsp;&emsp;在调试应用程序时，最常用的调试技术是打印，就是在应用程序中合适的点调用<code>printf</code>。当调试内核代码的时候，可以用<code>printk</code>完成类似任务。</p>
<h4 id="合理使用Printk"><a href="#合理使用Printk" class="headerlink" title="合理使用Printk"></a>合理使用Printk</h4><p>&emsp;&emsp;在驱动开发时，<code>printk</code>非常有助于调试。但当正式发行驱动程序时，应当去掉这些打印语句。但你有可能很快又发现，你又需要在驱动程序中实现一个新功能(或者修复一个<code>bug</code>)，这时你又要用到那些被删除的打印语句。这里介绍一种使用<code>printk</code>的合理方法，可以全局地打开或关闭它们，而不是简单地删除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PDEBUG</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> PLOG(fmt, args...) printk(KERN_DEBUG <span class="meta-string">"scull:"</span>fmt, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> PLOG(fmt, args...) <span class="comment">/* do nothing */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>Makefile</code>作如下修改：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEBUG = y</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>, y)</span><br><span class="line">   DEBFLAGS = -O2 -g -DPDEBUG</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   DEBFLAGS = -O2</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">CFLAGS += <span class="variable">$(DEBFLAGS)</span></span><br></pre></td></tr></table></figure>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><h4 id="并发与竞态"><a href="#并发与竞态" class="headerlink" title="并发与竞态"></a>并发与竞态</h4><p>&emsp;&emsp;并发是指多个执行单元同时被执行；竞态是指并发的执行单元对共享资源(硬件资源和软件上的全局变量等)的访问导致的竞争状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( copy_from_user ( &amp; ( dev-&gt;data[pos] ), buf, count ) ) &#123;</span><br><span class="line">   ret = -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有<code>2</code>个进程试图同时向一个设备的相同位置写入数据，就会造成数据混乱。<br>&emsp;&emsp;处理并发的常用技术是加锁或者互斥，即确保在任何时间只有一个执行单元可以操作共享资源。在<code>Linux</code>内核中主要通过<code>semaphore</code>机制和<code>spin_lock</code>机制实现。</p>
<p>&emsp;&emsp;<code>linux</code>内核什么时候会发生竞态？</p>
<ul>
<li>对称多<code>cpu</code>(<code>SMP</code>)的多个<code>cpu</code>之间的竞态。</li>
<li>单<code>CPU</code>内进程间的竞态。</li>
<li>中断(硬中断、软中断、<code>Tasklet</code>、底半部)与进程之间的竞态。</li>
</ul>
<h4 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h4><p>&emsp;&emsp;可解决中断与进程之间的并发；也可解决内核抢占进程之间的并发。</p>
<ul>
<li><code>local_irq_disable()</code>：禁止中断。</li>
<li><code>local_irq_enable()</code>：打开中断。</li>
<li><code>local_irq_save(flags)</code>：禁止中断并保存中断寄存器信息到<code>flags</code>。</li>
<li><code>local_irq_restore(flags)</code>：打开中断并恢复<code>flags</code>值到中断寄存器信息。</li>
<li><code>loacl_bh_disable()</code>：仅禁止中断底半部中断。</li>
<li><code>loacl_bh_enable()</code>：打开中断底半部中断。</li>
</ul>
<p>&emsp;&emsp;使用范例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local_irq_disbale(); <span class="comment">/* 屏蔽中断 */</span></span><br><span class="line">...                  <span class="comment">/* 临界资源 */</span></span><br><span class="line">local_irq_enbale();  <span class="comment">/* 打开中断 */</span></span><br></pre></td></tr></table></figure>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>&emsp;&emsp;<code>Linux</code>内核的信号量在概念和原理上与用户态的信号量是一样的，但是它不能在内核之外使用，它是一种睡眠锁。如果有一个任务想要获得已经被占用的信号量时，信号量会将这个进程放入一个等待队列，然后让其睡眠。当持有信号量的进程将信号释放后，处于等待队列中的任务将被唤醒，并让其获得信号量。<br>&emsp;&emsp;信号量在创建时需要设置一个初始值，表示允许有几个任务同时访问该信号量保护的共享资源，初始值为<code>1</code>就变成互斥锁(<code>Mutex</code>)，即同时只能有一个任务可以访问信号量保护的共享资源。当任务访问完被信号量保护的共享资源后，必须释放信号量，释放信号量通过把信号量的值加<code>1</code>实现，如果释放后信号量的值为非正数，表明有任务等待当前信号量，因此要唤醒等待该信号量的任务。<br>&emsp;&emsp;信号量的实现也是与体系结构相关的，定义在<code>&lt;asm/semaphore.h&gt;</code>中，<code>struct semaphore</code>类型用来表示信号量。<br>&emsp;&emsp;1. 定义信号量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 初始化信号量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 该函用于数初始化设置信号量的初值，它设置信号量sem的值为val */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_init</span> <span class="params">( struct semaphore *sem, <span class="keyword">int</span> val )</span></span>;</span><br><span class="line"><span class="comment">/* 该函数用于初始化一个互斥锁，即它把信号量sem的值设置为1 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_MUTEX</span> <span class="params">( struct semaphore *sem )</span></span>;</span><br><span class="line"><span class="comment">/* 该函数也用于初始化一个互斥锁，但它把信号量sem的值设置为0，即一开始就处在已锁状态 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_MUTEX_LOCKED</span> <span class="params">( struct semaphore *sem )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;定义与初始化的工作可由如下宏一步完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义一个信号量name，并初始化它的值为1 */</span></span><br><span class="line">DECLARE_MUTEX ( name );</span><br><span class="line"><span class="comment">/* 定义一个信号量name，但把它的初始值设置为0，即锁在创建时就处在已锁状态 */</span></span><br><span class="line">DECLARE_MUTEX_LOCKED ( name );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3. 获取信号量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取信号量sem，可能会导致进程睡眠，因此不能在中断上下文使用该函数。该函数将把sem的值减1，</span></span><br><span class="line"><span class="comment">   如果信号量sem的值非负，就直接返回，否则调用者将被挂起，直到别的任务释放该信号量才能继续运行 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span> <span class="params">( struct semaphore *sem )</span></span>;</span><br><span class="line"><span class="comment">/* 获取信号量sem。如果信号量不可用，进程将被置为TASK_INTERRUPTIBLE类型的睡眠状态。</span></span><br><span class="line"><span class="comment">   该函数由返回值来区分是正常返回还是被信号中断返回，如果返回0，</span></span><br><span class="line"><span class="comment">   表示获得信号量正常返回，如果被信号打断，返回“-EINTR” */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">down_interruptible</span> <span class="params">( struct semaphore *sem )</span></span>;</span><br><span class="line"><span class="comment">/* 获取信号量sem。如果信号量不可用，进程将被置为TASK_KILLABLE类型的睡眠状态 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">down_killable</span> <span class="params">( struct semaphore *sem )</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意，<code>down</code>函数现已不建议继续使用。建议使用<code>down_killable</code>或<code>down_interruptible</code>函数。<br>&emsp;&emsp;4. 释放信号量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 该函数释放信号量sem，即把sem的值加1，如果sem的值为非正数，</span></span><br><span class="line"><span class="comment">   表明有任务等待该信号量，因此唤醒这些等待者 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span> <span class="params">( struct semaphore *sem )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;信号量使用模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_MUTEX ( sem )</span><br><span class="line"><span class="keyword">if</span> ( down_interruptible ( &amp;sem ) ) &#123;</span><br><span class="line">   <span class="keyword">return</span> -ERESTARTSYS;</span><br><span class="line">&#125;</span><br><span class="line">... <span class="comment">/* 临界资源 */</span></span><br><span class="line">up ( &amp;sem );</span><br></pre></td></tr></table></figure>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>&emsp;&emsp;自旋锁最多只能被一个可执行单元持有。自旋锁不会引起调用者睡眠，如果一个执行线程试图获得一个已经被持有的自旋锁，那么线程就会一直进行忙循环，一直等待下去，在那里看是否该自旋锁的保持者已经释放了锁，<code>自旋</code>就是这个意思。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 该宏用于初始化自旋锁x，自旋锁在使用前必须先初始化 */</span></span><br><span class="line">spin_lock_init ( x );</span><br><span class="line"><span class="comment">/* 获取自旋锁lock，如果成功，立即获得锁，并马上返回，否则它将一直自旋在那里，直到该自旋锁的保持者释放 */</span></span><br><span class="line">spin_lock ( lock );</span><br><span class="line"><span class="comment">/* 试图获取自旋锁lock，如果能立即获得锁，并返回真，否则立即返回假。它不会一直等待被释放 */</span></span><br><span class="line">spin_trylock ( lock );</span><br><span class="line">spin_unlock ( lock ); <span class="comment">/* 释放自旋锁lock，它与spin_trylock或spin_lock配对使用 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读写自旋锁示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">rwlock_t</span> rwlock;</span><br><span class="line">rwlock_init ( &amp;rwlock );</span><br><span class="line">read_lock ( &amp;rwlock );</span><br><span class="line"><span class="comment">/* 临界资源 */</span></span><br><span class="line">read_unlock ( &amp;rwlock );</span><br><span class="line">write_lock_irqsave ( &amp;rwlock, flags );</span><br><span class="line"><span class="comment">/* 临界资源 */</span></span><br><span class="line">write_unlock_irqrestore ( &amp;rwlock, flags );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;自旋锁模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">spinlock_t</span> lock;</span><br><span class="line">spin_lock_init ( &amp;lock );</span><br><span class="line">spin_lock ( &amp;lock );</span><br><span class="line"><span class="comment">/* 临界资源 */</span></span><br><span class="line">spin_unlock ( &amp;lock );</span><br></pre></td></tr></table></figure>
<h4 id="读入者-写入者信号量"><a href="#读入者-写入者信号量" class="headerlink" title="读入者/写入者信号量"></a>读入者/写入者信号量</h4><p>&emsp;&emsp;读操作并发，写操作互斥，即一个<code>rwsem</code>可允许一个写入者或无数个读取者拥有该信号量。写入者的级别更高，当有大量写入者竞争该信号量时，会导致读取者饿死，即长时间拒绝读取者的访问。但是驱动程序很少用该机制，一般在很少需要写访问且写入者只会短期拥有信号量的时候使用<code>rwsem</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rw_semaphere_t</span> rw_sem;</span><br><span class="line">init_rwsem ( &amp;rw_sem );</span><br><span class="line"><span class="comment">/* 读时获取信号量 */</span></span><br><span class="line">down_read ( &amp;rw_sem );</span><br><span class="line"><span class="comment">/* 临界资源 */</span></span><br><span class="line">up_read ( &amp;rw_sem );</span><br><span class="line"><span class="comment">/* 写时获取信号量 */</span></span><br><span class="line">down_write ( &amp;rw_sem );</span><br><span class="line"><span class="comment">/* 临界资源 */</span></span><br><span class="line">up_write ( &amp;rw_sem );</span><br></pre></td></tr></table></figure>
<h4 id="信号量-PK-自旋锁"><a href="#信号量-PK-自旋锁" class="headerlink" title="信号量 PK 自旋锁"></a>信号量 PK 自旋锁</h4><p>&emsp;&emsp;信号量可能允许有多个持有者，而自旋锁在任何时候只能允许一个持有者。当然也有信号量叫互斥信号量(只能一个持有者)，允许有多个持有者的信号量叫计数信号量。信号量适合于保持时间较长的情况；而自旋锁适合于保持时间非常短的情况，在实际应用中自旋锁控制的代码只有几行，而持有自旋锁的时间也一般不会超过两次上下文切换的时间，因为线程一旦要进行切换，就至少花费切出切入两次，自旋锁的占用时间如果远远长于两次上下文切换，我们就应该选择信号量。<br>&emsp;&emsp;开销成本：</p>
<ul>
<li>使用信号量的开销是进程上下文切换时间。</li>
<li>自旋锁的开销是忙等待获取自旋锁。</li>
</ul>
<p>&emsp;&emsp;等待时机不同：</p>
<ul>
<li>信号量可能导致阻塞，所以在不允许阻塞的代码中不能用可能引起阻塞的信号量处理方式。</li>
<li>自旋锁是忙等待。</li>
</ul>
<h3 id="设备Ioctl控制"><a href="#设备Ioctl控制" class="headerlink" title="设备Ioctl控制"></a>设备Ioctl控制</h3><h4 id="ioctl功能"><a href="#ioctl功能" class="headerlink" title="ioctl功能"></a>ioctl功能</h4><p>&emsp;&emsp;大部分驱动除了需要具备读写设备的能力外，还需要具备对硬件控制的能力。例如，要求设备报告错误信息，改变波特率，这些操作常常通过<code>ioctl</code>方法来实现。</p>
<h4 id="用户使用方法"><a href="#用户使用方法" class="headerlink" title="用户使用方法"></a>用户使用方法</h4><p>&emsp;&emsp;在用户空间，使用<code>ioctl</code>系统调用来控制设备：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span> <span class="params">( <span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> cmd, ... )</span></span>;</span><br></pre></td></tr></table></figure>
<p>原型中的点表示这是一个可选的参数，存在与否依赖于控制命令(第<code>2</code>个参数)是否涉及到与设备的数据交互。</p>
<h4 id="驱动ioctl方法"><a href="#驱动ioctl方法" class="headerlink" title="驱动ioctl方法"></a>驱动ioctl方法</h4><p>&emsp;&emsp;<code>ioctl</code>驱动方法有和用户空间版本不同的原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ( *ioctl ) ( struct inode *inode, struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg );</span><br></pre></td></tr></table></figure>
<p><code>cmd</code>参数从用户空间传下来，可选的参数<code>arg</code>以一个<code>unsigned long</code>的形式传递，不管它是一个整数或一个指针。如果<code>cmd</code>命令不涉及数据传输，则参数<code>arg</code>的值无任何意义。</p>
<h4 id="定义命令"><a href="#定义命令" class="headerlink" title="定义命令"></a>定义命令</h4><p>&emsp;&emsp;在编写<code>ioctl</code>代码之前，首先需要定义命令。为了防止对错误的设备使用正确的命令，命令号应该在系统范围内是唯一的。<code>ioctl</code>命令编码被划分为几个位段，<code>include/asm/ioctl.h</code>中定义了这些位字段：类型(幻数)、序号、传送方向、参数的大小。<code>Documentation/ioctl-number.txt</code>文件中罗列了在内核中已经使用了的幻数。定义<code>ioctl</code>命令的正确方法是使用<code>4</code>个位段，这个列表中介绍的符号定义在<code>linux/ioctl.h</code>中：</p>
<ul>
<li><code>Type</code>：幻数(类型)，表明哪个设备的命令，在参考了<code>ioctlnumber.txt</code>之后选出，<code>8</code>位宽。</li>
<li><code>Number</code>：序号，表明设备命令中的第几个，<code>8</code>位宽。</li>
<li><code>Direction</code>：数据传送的方向，可能的值是<code>_IOC_NONE</code>(没有数据传输)、<code>_IOC_READ</code>或<code>_IOC_WRITE</code>。数据传送是从应用程序的观点来看待的，<code>_IOC_READ</code>意思是从设备读。</li>
<li><code>Size</code>：用户数据的大小(<code>13/14</code>位宽，视处理器而定)。</li>
</ul>
<p>&emsp;&emsp;内核提供了下列宏来帮助定义命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO   ( type, nr )           <span class="comment">/* 没有参数的命令 */</span></span><br><span class="line">_IOR  ( type, nr, datatype ) <span class="comment">/* 从驱动中读数据 */</span></span><br><span class="line">_IOW  ( type, nr, datatype ) <span class="comment">/* 写数据到驱动 */</span></span><br><span class="line">_IOWR ( type, nr, datatype ) <span class="comment">/* 双向传送，type和number成员作为参数被传递 */</span></span><br></pre></td></tr></table></figure>
<h4 id="定义命令示例"><a href="#定义命令示例" class="headerlink" title="定义命令示例"></a>定义命令示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_IOC_MAGIC <span class="meta-string">'m'</span> <span class="comment">/* 定义幻数 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_IOCSET    _IOW ( MEM_IOC_MAGIC, 0, int ) <span class="comment">/* int是指传递参数的类型 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_IOCGQSET  _IOR ( MEM_IOC_MAGIC, 1, int )</span></span><br></pre></td></tr></table></figure>
<h4 id="Ioctl函数实现"><a href="#Ioctl函数实现" class="headerlink" title="Ioctl函数实现"></a>Ioctl函数实现</h4><p>&emsp;&emsp;定义好了命令，下一步就是要实现<code>Ioctl</code>函数了，<code>Ioctl</code>函数的实现包括如下<code>3</code>个技术环节：返回值、参数使用和命令操作。<br>&emsp;&emsp;<code>Ioctl</code>函数的实现通常是根据命令执行的一个<code>switch</code>语句。但是，当命令号不能匹配任何一个设备所支持的命令时，通常返回<code>-EINVAL</code>，意思是非法参数。<br>&emsp;&emsp;如何使用<code>Ioctl</code>中的参数？如果是一个整数，可以直接使用。如果是指针，我们必须确保这个用户地址是有效的，因此使用前需进行正确的检查。</p>
<h4 id="Ioctl函数实现-参数检查"><a href="#Ioctl函数实现-参数检查" class="headerlink" title="Ioctl函数实现(参数检查)"></a>Ioctl函数实现(参数检查)</h4><p>&emsp;&emsp;不需要检测的函数由<code>copy_from_user</code>(等价于<code>get_user</code>)、<code>copy_to_user</code>(等价于<code>put_user</code>)、<code>get_user</code>和<code>put_user</code>，需要检测的函数有<code>__get_user</code>和<code>__put_user</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( _IOC_DIR ( cmd ) &amp; _IOC_READ ) &#123; <span class="comment">/* “_IOC_DIR”是用来提取命令的方向 */</span></span><br><span class="line">   err = !access_ok ( VERIFY_WRITE, ( <span class="keyword">void</span> __user * ) arg, _IOC_SIZE ( cmd ) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( _IOC_DIR ( cmd ) &amp; _IOC_WRITE ) &#123;</span><br><span class="line">   err = !access_ok ( VERIFY_READ, ( <span class="keyword">void</span> __user * ) arg, _IOC_SIZE ( cmd ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( err ) &#123;</span><br><span class="line">   <span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Ioctl函数实现-命令操作"><a href="#Ioctl函数实现-命令操作" class="headerlink" title="Ioctl函数实现(命令操作)"></a>Ioctl函数实现(命令操作)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( cmd ) &#123;</span><br><span class="line">   <span class="keyword">case</span> MEM_IOCSQUANTUM: <span class="comment">/* Set: arg points to the value */</span></span><br><span class="line">      retval = __get_user ( scull_quantum, ( <span class="keyword">int</span> * ) arg );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> MEM_IOCGQUANTUM: <span class="comment">/* Get: arg is pointer to result */</span></span><br><span class="line">      retval = __put_user ( scull_quantum, ( <span class="keyword">int</span> * ) arg );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> –EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内核等待队列"><a href="#内核等待队列" class="headerlink" title="内核等待队列"></a>内核等待队列</h3><h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>&emsp;&emsp;在<code>Linux</code>驱动程序设计中，可以使用等待队列来实现进程的阻塞，等待队列可看作保存进程的容器，在阻塞进程时，将进程放入等待队列，当唤醒进程时，从等待等列中取出进程。<code>Linux 2.6</code>内核提供了如下关于等待队列的操作：<br>&emsp;&emsp;1. 定义等待队列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wait_queue_head_t</span> my_queue;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 初始化等待队列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_waitqueue_head ( &amp;my_queue );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3. 定义并初始化等待队列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WAIT_QUEUE_HEAD ( my_queue );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;4. 有条件睡眠：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当condition(一个布尔表达式)为真时，立即返回；否则让进程进入</span></span><br><span class="line"><span class="comment">   TASK_UNINTERRUPTIBLE模式的睡眠，并挂在queue参数所指定的等待队列上 */</span></span><br><span class="line">wait_event(<span class="built_in">queue</span>, condition);</span><br><span class="line"><span class="comment">/* 当condition(一个布尔表达式)为真时，立即返回；否则让进程进入</span></span><br><span class="line"><span class="comment">   TASK_INTERRUPTIBLE的睡眠，并挂在queue参数所指定的等待队列上 */</span></span><br><span class="line">wait_event_interruptible(<span class="built_in">queue</span>, condition);</span><br><span class="line"><span class="comment">/* 当condition(一个布尔表达式)为真时，立即返回；否则让进程进入</span></span><br><span class="line"><span class="comment">   TASK_KILLABLE的睡眠，并挂在queue参数所指定的等待队列上 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wait_event_killable</span><span class="params">(<span class="keyword">wait_queue_t</span> <span class="built_in">queue</span>, condition)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;5. 无条件睡眠(老版本，建议不再使用):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sleep_on ( <span class="keyword">wait_queue_head_t</span> *q ); <span class="comment">/* 让进程进入不可中断的睡眠，并把它放入等待队列q */</span></span><br><span class="line">interruptible_sleep_on ( <span class="keyword">wait_queue_head_t</span> *q ); <span class="comment">/* 让进程进入可中断的睡眠，并把它放入等待队列q */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;6. 从等待队列中唤醒进程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从等待队列q中唤醒状态为TASK_UNINTERRUPTIBLE、TASK_INTERRUPTIBLE和TASK_KILLABLE的所有进程 */</span></span><br><span class="line">wake_up ( <span class="keyword">wait_queue_t</span> *q );</span><br><span class="line"><span class="comment">/* 从等待队列q中唤醒状态为TASK_INTERRUPTIBLE的进程 */</span></span><br><span class="line">wake_up_interruptible ( <span class="keyword">wait_queue_t</span> *q );</span><br></pre></td></tr></table></figure>
<h3 id="阻塞型字符设备驱动"><a href="#阻塞型字符设备驱动" class="headerlink" title="阻塞型字符设备驱动"></a>阻塞型字符设备驱动</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>&emsp;&emsp;前一节我们在设计简单字符驱动程序时，跳过了一个重要的问题：当一个设备无法立刻满足用户的读写请求时应当如何处理？例如，调用<code>read</code>时没有数据可读，但以后可能会有；或者一个进程试图向设备写入数据，但是设备暂时没有准备好接收数据。应用程序通常不关心这种问题，应用程序只是调用<code>read</code>或<code>write</code>并得到返回值。驱动程序应当(缺省地)阻塞进程，使它进入睡眠，直到请求可以得到满足。</p>
<h4 id="阻塞方式"><a href="#阻塞方式" class="headerlink" title="阻塞方式"></a>阻塞方式</h4><p>&emsp;&emsp;在阻塞型驱动程序中，<code>Read</code>实现方式如下：如果进程调用<code>read</code>，但设备没有数据或数据不足，进程阻塞。当新数据到达后，唤醒被阻塞进程。<br>&emsp;&emsp;在阻塞型驱动程序中，<code>Write</code>实现方式如下：如果进程调用了<code>write</code>，但设备没有足够的空间供其写入数据，进程阻塞。当设备中的数据被读走后，缓冲区中空出部分空间，则唤醒进程。</p>
<h4 id="非阻塞方式"><a href="#非阻塞方式" class="headerlink" title="非阻塞方式"></a>非阻塞方式</h4><p>&emsp;&emsp;阻塞方式是文件读写操作的默认方式，但应用程序员可通过使用<code>O_NONBLOCK</code>标志来人为的设置读写操作为非阻塞方式(该标志定义在<code>linux/fcntl.h</code>中，在打开文件时指定)。<br>&emsp;&emsp;如果设置了<code>O_NONBLOCK</code>标志，<code>read</code>和<code>write</code>的行为是不同的。如果进程在没有数据就绪时调用了<code>read</code>，或者在缓冲区没有空间时调用了<code>write</code>，系统只是简单地返回<code>-EAGAIN</code>，而不会阻塞进程。</p>
<h4 id="Poll设备操作"><a href="#Poll设备操作" class="headerlink" title="Poll设备操作"></a>Poll设备操作</h4><p>&emsp;&emsp;什么是<code>Poll</code>方法，功能是什么？</p>
<h4 id="Select系统调用-功能"><a href="#Select系统调用-功能" class="headerlink" title="Select系统调用(功能)"></a>Select系统调用(功能)</h4><p>&emsp;&emsp;<code>Select</code>系统调用用于多路监控，当没有一个文件满足要求时，<code>select</code>将阻塞调用进程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">int</span> maxfd, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">   fe_set *exceptfds, <span class="keyword">const</span> struct timeval *timeout )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Maxfd</code>：文件描述符的范围，比待检测的最大文件描述符大<code>1</code>。</li>
<li><code>Readfds</code>：被读监控的文件描述符集。</li>
<li><code>Writefds</code>：被写监控的文件描述符集。</li>
<li><code>Exceptfds</code>：被异常监控的文件描述符集。</li>
<li><code>Timeout</code>：定时器。</li>
</ul>
<p>&emsp;&emsp;<code>Timeout</code>取不同的值，该调用有不同的表现：</p>
<ul>
<li><code>Timeout</code>值为<code>0</code>，不管是否有文件满足要求，都立刻返回，无文件满足要求返回<code>0</code>，有文件满足要求返回一个正值。</li>
<li><code>Timeout</code>为<code>NULL</code>，<code>select</code>将阻塞进程，直到某个文件满足要求。</li>
<li><code>Timeout</code>值为正整数，就是等待的最长时间，即<code>select</code>在<code>timeout</code>时间内阻塞进程。</li>
</ul>
<p>&emsp;&emsp;<code>Select</code>调用返回时，返回值有如下情况：</p>
<ul>
<li>正常情况下返回满足要求的文件描述符个数；</li>
<li>经过了<code>timeout</code>等待后仍无文件满足要求，返回值为<code>0</code>；</li>
<li>如果<code>select</code>被某个信号中断，它将返回<code>-1</code>，并设置<code>errno</code>为<code>EINTR</code>。</li>
<li>如果出错，返回<code>-1</code>并设置相应的<code>errno</code>。</li>
</ul>
<h4 id="Select系统调用-使用方法"><a href="#Select系统调用-使用方法" class="headerlink" title="Select系统调用(使用方法)"></a>Select系统调用(使用方法)</h4><ol>
<li>将要监控的文件添加到文件描述符集。</li>
<li>调用<code>Select</code>开始监控。</li>
<li>判断文件是否发生变化。</li>
</ol>
<p>&emsp;&emsp;系统提供了<code>4</code>个宏对描述符集进行操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span> <span class="params">( <span class="keyword">int</span> fd, fd_set *fdset )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span> <span class="params">( <span class="keyword">int</span> fd, fd_set *fdset )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span> <span class="params">( fd_set *fdset )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ISSET</span> <span class="params">( <span class="keyword">int</span> fd, fd_set *fdset )</span></span>;</span><br></pre></td></tr></table></figure>
<p>宏<code>FD_SET</code>将文件描述符<code>fd</code>添加到文件描述符集<code>fdset</code>中；宏<code>FD_CLR</code>从文件描述符集<code>fdset</code>中清除文件描述符<code>fd</code>；宏<code>FD_ZERO</code>清空文件描述符集<code>fdset</code>；在调用<code>select</code>后使用<code>FD_ISSET</code>来检测文件描述符集<code>fdset</code>中的文件<code>fd</code>发生了变化。<br>&emsp;&emsp;使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FD_ZERO ( &amp;fds ); <span class="comment">/* 清空集合 */</span></span><br><span class="line">FD_SET ( fd1, &amp;fds ); <span class="comment">/* 设置描述符 */</span></span><br><span class="line">FD_SET ( fd2, &amp;fds ); <span class="comment">/* 设置描述符 */</span></span><br><span class="line">maxfdp = fd1 + <span class="number">1</span>; <span class="comment">/* 描述符最大值加1，假设fd1大于fd2 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ( select ( maxfdp, &amp;fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout ) ) &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">      <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">/* select错误，退出程序 */</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">if</span> ( FD_ISSET ( fd1, &amp;fds ) ) &#123; <span class="comment">/* 测试fd1是否可读 */</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Poll方法"><a href="#Poll方法" class="headerlink" title="Poll方法"></a>Poll方法</h4><p>&emsp;&emsp;<code>Poll</code>设备方法负责完成：</p>
<ol>
<li>使用<code>poll_wait</code>将等待队列添加到<code>poll_table</code>中。</li>
<li>返回描述设备是否可读或可写的掩码。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>位掩码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>POLLIN</code></td>
<td>设备可读</td>
</tr>
<tr>
<td><code>POLLRDNORM</code></td>
<td>数据可读</td>
</tr>
<tr>
<td><code>POLLOUT</code></td>
<td>设备可写</td>
</tr>
<tr>
<td><code>POLLWRNORM</code></td>
<td>数据可写</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;设备可读通常返回<code>(POLLIN | POLLRDNORM)</code>，设备可写通常返回<code>(POLLOUT | POLLWRNORM)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mem_poll</span> <span class="params">( struct file *filp, poll_table *wait )</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">scull_pipe</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   poll_wait ( filp, &amp;dev-&gt;inq, wait ); <span class="comment">/* 把进程添加到等待队列 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 返回掩码 */</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="comment">/* 有数据可读 */</span> ) &#123;</span><br><span class="line">      mask = POLLIN | POLLRDNORM; <span class="comment">/* 设备可读 */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Poll</code>方法只是做一个登记，真正的阻塞发生在<code>select.c</code>中的<code>do_select</code>函数。</p>
<h3 id="自动创建设备文件"><a href="#自动创建设备文件" class="headerlink" title="自动创建设备文件"></a>自动创建设备文件</h3><h4 id="自动创建-2-4内核"><a href="#自动创建-2-4内核" class="headerlink" title="自动创建(2.4内核)"></a>自动创建(2.4内核)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devfs_register (</span><br><span class="line">   <span class="keyword">devfs_handle_t</span> dir, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> major, <span class="keyword">unsigned</span> <span class="keyword">int</span> minor,</span><br><span class="line">   <span class="keyword">umode_t</span> mode, <span class="keyword">void</span> *ops, <span class="keyword">void</span> *info );</span><br></pre></td></tr></table></figure>
<p>在指定的目录中创建设备文件。</p>
<ul>
<li><code>dir</code>：目录名，为空表示在<code>/dev</code>目录下创建。</li>
<li><code>name</code>：文件名。</li>
<li><code>flags</code>：创建标志。</li>
<li><code>major</code>：主设备号。</li>
<li><code>minor</code>：次设备号。</li>
<li><code>mode</code>：创建模式。</li>
<li><code>ops</code>：操作函数集。</li>
<li><code>info</code>：通常为空。</li>
</ul>
<h4 id="自动创建-2-6内核"><a href="#自动创建-2-6内核" class="headerlink" title="自动创建(2.6内核)"></a>自动创建(2.6内核)</h4><p>&emsp;&emsp;从<code>Linux 2.6.13</code>开始，<code>devfs</code>不复存在，<code>udev</code>成为<code>devfs</code>的替代。相比<code>devfs</code>，<code>udev(mdev)</code>存在于应用层。利用<code>udev(mdev)</code>来实现设备文件的自动创建很简单，在驱动初始化的代码里调用<code>class_create</code>为该设备创建一个<code>class</code>，再为每个设备调用<code>device_create</code>创建对应的设备。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">myclass</span> = <span class="title">class_create</span> ( <span class="title">THIS_MODULE</span>, "<span class="title">my_device_driver</span>" );</span></span><br><span class="line">device_create ( myclass, <span class="literal">NULL</span>, MKDEV ( major_num, <span class="number">0</span> ), <span class="literal">NULL</span>, <span class="string">"my_device"</span> );</span><br></pre></td></tr></table></figure>
<p>当驱动被加载时，<code>udev(mdev)</code>就会自动在<code>/dev</code>下创建<code>my_device</code>设备文件。注意，应先配置<code>busybox</code>，使它支持<code>mdev</code>。</p>
<h3 id="mmap设备操作"><a href="#mmap设备操作" class="headerlink" title="mmap设备操作"></a>mmap设备操作</h3><h4 id="mmap系统调用-功能"><a href="#mmap系统调用-功能" class="headerlink" title="mmap系统调用(功能)"></a>mmap系统调用(功能)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset )</span></span>;</span><br></pre></td></tr></table></figure>
<p>内存映射函数<code>mmap</code>，负责把文件内容映射到进程的虚拟内存空间，通过对这段内存的读取和修改，来实现对文件的读取和修改，而不需要再调用<code>read</code>、<code>write</code>等操作。<code>mmap</code>不影响原文件的长度。</p>
<p><img src="/2019/03/21/Linux驱动程序/Linux设备驱动基础/3.png" height="251" width="394"></p>
<ul>
<li><code>addr</code>：指定映射的起始地，通常设为<code>NULL</code>，由系统指定。</li>
<li><code>len</code>：映射到内存的文件长度。</li>
<li><code>prot</code>：映射区的保护方式：</li>
</ul>
<ol>
<li><code>PROT_EXEC</code>：映射区可被执行。</li>
<li><code>PROT_READ</code>：映射区可被读取。</li>
<li><code>PROT_WRITE</code>：映射区可被写入。</li>
<li><code>PROT_NONE</code>：映射区不能存取。</li>
</ol>
<ul>
<li><code>flags</code>：映射区的特性：</li>
</ul>
<p><code>MAP_SHARED</code>：写入映射区的数据会复制回文件，且允许其他映射该文件的进程共享)。<br><code>MAP_PRIVATE</code>：对映射区的写入操作会产生一个映射区的复制(<code>copy-on-write</code>)，对此区域所做的修改不会写回原文件。即使映射区的数据被修改，也要复制回文件，修改文件内容。</p>
<ul>
<li><code>fd</code>：由<code>open</code>返回的文件描述符，代表要映射的文件。</li>
<li><code>offset</code>：以文件开始处的偏移量，必须是分页大小的整数倍，通常为<code>0</code>，表示从文件头开始映射。</li>
</ul>
<h4 id="解除映射"><a href="#解除映射" class="headerlink" title="解除映射"></a>解除映射</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span> <span class="params">( <span class="keyword">void</span> *start, <span class="keyword">size_t</span> length )</span></span>;</span><br></pre></td></tr></table></figure>
<p>取消参数<code>start</code>所指向的映射内存(<code>start</code>源于<code>mmap</code>的返回值)，参数<code>length</code>表示欲取消的内存大小。<br>&emsp;&emsp;返回值：解除成功返回<code>0</code>，否则返回<code>-1</code>，错误原因存于<code>errno</code>中。<br>&emsp;&emsp;当进行结束时，映射内存会自动解除，但关闭对应的文件描述词时不会解除映射。</p>
<h4 id="虚拟内存区域"><a href="#虚拟内存区域" class="headerlink" title="虚拟内存区域"></a>虚拟内存区域</h4><p>&emsp;&emsp;虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围(可以理解为<code>具有自己属性的内存对象</code>)。一个进程的内存映象由下面几部分组成：程序代码、数据、<code>BSS</code>和栈区域，以及内存映射的区域。一个进程的内存区域可以通过查看文件<code>/proc/pid/maps</code>(如<code>/proc/643/maps</code>)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">08048000</span><span class="number">-0804f</span>000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">573748</span> /sbin/rpc.statd <span class="meta">#text</span></span><br><span class="line"><span class="number">0804f</span>000<span class="number">-08050000</span> rw-p <span class="number">00007000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">573748</span> /sbin/rpc.statd <span class="meta">#data</span></span><br><span class="line"><span class="number">08050000</span><span class="number">-08055000</span> rwxp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> <span class="meta">#bss</span></span><br><span class="line"><span class="number">040000000</span><span class="number">-40015000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">933965</span> /lib/ld2<span class="number">.3</span><span class="number">.2</span>.so <span class="meta">#text</span></span><br><span class="line"><span class="number">40015000</span><span class="number">-40016000</span> rw-p <span class="number">00014000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">933965</span> /lib/ld<span class="number">-2.3</span><span class="number">.2</span>.so <span class="meta">#data</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;每一行的域为<code>start_end perm offset major:minor inode</code>：</p>
<ul>
<li><code>Start</code>：该区域起始虚拟地址。</li>
<li><code>End</code>：该区域结束虚拟地址。</li>
<li><code>Perm</code>：读、写和执行权限；表示对这个区域，允许进程做什么。这个域的最后一个字符要么是<code>p</code>表示私有的，要么是<code>s</code>表示共享的。</li>
<li><code>Offset</code>：被映射部分在文件中的起始地址。</li>
<li><code>Major</code>、<code>minor</code>：主次设备号。</li>
<li><code>Inode</code>：索引结点。</li>
</ul>
<h4 id="vm-area-struct"><a href="#vm-area-struct" class="headerlink" title="vm_area_struct"></a>vm_area_struct</h4><p>&emsp;&emsp;<code>Linux</code>内核使用结构<code>vm_area_struct</code>(<code>linux/mm_types.h</code>)来描述虚拟内存区域，其中几个主要成员如下：</p>
<ul>
<li><code>unsigned long vm_start</code>：虚拟内存区域起始地址。</li>
<li><code>unsigned long vm_end</code>：虚拟内存区域结束地址(一个<code>VMA</code>描述的区别介于<code>VMA-&gt;vm_start</code>和<code>VMA-&gt;vm_end</code>之间)。</li>
<li><code>unsigned long vm_flags</code>：该区域的标记，如<code>VM_IO</code>和<code>VM_RESERVED</code>。<code>VM_IO</code>将该<code>VMA</code>标记为内存映射的<code>IO</code>区域，<code>VM_IO</code>会阻止系统将该区域包含在进程的存放转存(<code>core dump</code>)中，<code>VM_RESERVED</code>标志内存区域不能被换出(用户程序用于虚拟地址，设备用的是实际地址)。</li>
</ul>
<h4 id="mmap设备操作-使用方法"><a href="#mmap设备操作-使用方法" class="headerlink" title="mmap设备操作(使用方法)"></a>mmap设备操作(使用方法)</h4><p>&emsp;&emsp;映射一个设备是指把用户空间的一段地址关联到设备内存上。当程序读写这段用户空间的地址时，它实际上是在访问设备。但并不是每个设备都适合<code>mmap</code>，例如对于串口或其他面向流的设备来说，它的确没有意义。<br>&emsp;&emsp;<code>mmap</code>设备方法需要完成什么功能？<code>mmap</code>方法是<code>file_oprations</code>结构的成员，在<code>mmap</code>系统调用发出时被调用。在此之前，内核已经完成了很多工作。<code>mmap</code>设备方法所需要做的就是建立虚拟地址到物理地址的页表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ( *mmap ) ( struct file *, struct vm_area_struct * );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mmap</code>如何完成页表的建立？方法有两个：</p>
<ul>
<li>使用<code>remap_pfn_range</code>一次建立所有页表。</li>
<li>使用<code>nopage VMA</code>方法每次建立一个页表。</li>
</ul>
<p>&emsp;&emsp;构造页表的工作可由<code>remap_pfn_range</code>函数完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remap_pfn_range</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">unsigned</span> <span class="keyword">long</span> pfn, <span class="keyword">unsigned</span> <span class="keyword">long</span> size, <span class="keyword">pgprot_t</span> prot )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="硬件访问"><a href="#硬件访问" class="headerlink" title="硬件访问"></a>硬件访问</h3><h4 id="寄存器与内存"><a href="#寄存器与内存" class="headerlink" title="寄存器与内存"></a>寄存器与内存</h4><p>&emsp;&emsp;寄存器与内存的区别在哪里呢？寄存器和<code>RAM</code>的主要不同在于寄存器操作有副作用(<code>side effect</code>或边际效果)：读取某个地址时可能导致该地址内容发生变化，比如很多设备的中断状态寄存器只要一读取，便自动清零。</p>
<h4 id="内存与I-O"><a href="#内存与I-O" class="headerlink" title="内存与I/O"></a>内存与I/O</h4><p>&emsp;&emsp;在<code>X86</code>处理器中存在<code>I/O</code>空间的概念，<code>I/O</code>空间是相对内存空间而言的，它们是彼此独立的地址空间，在<code>32</code>位的<code>x86</code>系统中，<code>I/O</code>空间大小为<code>64K</code>，内存空间大小为<code>4G</code>。</p>
<p><img src="/2019/03/21/Linux驱动程序/Linux设备驱动基础/4.png" height="271" width="565"></p>
<ul>
<li><code>X86</code>：支持内存空间、<code>IO</code>空间。</li>
<li><code>ARM</code>：只支持内存空间。</li>
<li><code>MIPS</code>：只支持内存空间。</li>
<li><code>PowerPC</code>：只支持内存空间。</li>
</ul>
<h4 id="IO端口与IO内存"><a href="#IO端口与IO内存" class="headerlink" title="IO端口与IO内存"></a>IO端口与IO内存</h4><ul>
<li><code>IO</code>端口：当一个寄存器或内存位于<code>IO</code>空间时，称其为<code>IO</code>端口。</li>
<li><code>IO</code>内存：当一个寄存器或内存位于内存空间时，称其为<code>IO</code>内存。</li>
</ul>
<h4 id="操作I-O端口"><a href="#操作I-O端口" class="headerlink" title="操作I/O端口"></a>操作I/O端口</h4><p>&emsp;&emsp;对<code>I/O</code>端口的操作需按如下步骤完成：申请、访问和释放。</p>
<h4 id="申请I-O端口"><a href="#申请I-O端口" class="headerlink" title="申请I/O端口"></a>申请I/O端口</h4><p>&emsp;&emsp;内核提供了一套函数来允许驱动申请它需要的I/O端口，其中核心的函数是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct resource *<span class="title">request_region</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">long</span> first, <span class="keyword">unsigned</span> <span class="keyword">long</span> n, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数告诉内核，你要使用从<code>first</code>开始的<code>n</code>个端口，<code>name</code>参数是设备的名字。如果申请成功，返回非<code>NULL</code>；申请失败，返回<code>NULL</code>。<br>&emsp;&emsp;系统中端口的分配情况记录在<code>/proc/ioports</code>中。如果不能分配需要的端口，可以来这里查看谁在使用。</p>
<h4 id="访问I-O端口"><a href="#访问I-O端口" class="headerlink" title="访问I/O端口"></a>访问I/O端口</h4><p>&emsp;&emsp;<code>I/O</code>端口可分为<code>8</code>位、<code>16</code>位和<code>32</code>位端口。<code>Linux</code>内核头文件(体系依赖的头文件<code>asm/io.h</code>)定义了下列内联函数来访问<code>I/O</code>端口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inb</span> <span class="params">( <span class="keyword">unsigned</span> port )</span></span>; <span class="comment">/* 读字节端口(8位宽) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outb</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">char</span> byte, <span class="keyword">unsigned</span> port )</span></span>; <span class="comment">/* 写字节端口(8位宽) */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inw</span> <span class="params">( <span class="keyword">unsigned</span> port )</span></span>; <span class="comment">/* 读字节端口(16位宽) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outw</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">short</span> word, <span class="keyword">unsigned</span> port )</span></span>; <span class="comment">/* 写字节端口(16位宽) */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inl</span> <span class="params">( <span class="keyword">unsigned</span> port )</span></span>; <span class="comment">/* 读字节端口(32位宽) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outl</span> <span class="params">( <span class="keyword">unsigned</span> longword, <span class="keyword">unsigned</span> port )</span></span>; <span class="comment">/* 写字节端口(32位宽) */</span></span><br></pre></td></tr></table></figure>
<h4 id="释放I-O端口"><a href="#释放I-O端口" class="headerlink" title="释放I/O端口"></a>释放I/O端口</h4><p>&emsp;&emsp;当用完一组<code>I/O</code>端口(通常在驱动卸载时)，应使用如下函数把它们返还给系统：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_region</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> n )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="操作I-O内存"><a href="#操作I-O内存" class="headerlink" title="操作I/O内存"></a>操作I/O内存</h4><p>&emsp;&emsp;对<code>I/O</code>内存的操作需按如下步骤完成：申请、映射、访问和释放。</p>
<h4 id="申请I-O内存"><a href="#申请I-O内存" class="headerlink" title="申请I/O内存"></a>申请I/O内存</h4><p>&emsp;&emsp;内核提供了一套函数来允许驱动申请它需要的<code>I/O</code>内存，其中核心的函数是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct resource *<span class="title">request_mem_region</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">char</span> *name )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数申请一个从<code>start</code>开始，长度为<code>len</code>字节的内存区。如果成功，返回非<code>NULL</code>；否则返回<code>NULL</code>，所有已经在使用的<code>I/O</code>内存在<code>/proc/iomem</code>中列出。</p>
<h4 id="映射I-O内存"><a href="#映射I-O内存" class="headerlink" title="映射I/O内存"></a>映射I/O内存</h4><p>&emsp;&emsp;在访问<code>I/O</code>内存之前，必须进行物理地址到虚拟地址的映射，<code>ioremap</code>函数具有此功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ioremap</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">long</span> phys_addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> size )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="访问I-O内存"><a href="#访问I-O内存" class="headerlink" title="访问I/O内存"></a>访问I/O内存</h4><p>&emsp;&emsp;访问<code>I/O</code>内存的正确方法是通过一系列内核提供的函数：<br>&emsp;&emsp;1. 从<code>I/O</code>内存读，使用下列之一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">ioread8</span> <span class="params">( <span class="keyword">void</span> *addr )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">ioread16</span> <span class="params">( <span class="keyword">void</span> *addr )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">ioread32</span> <span class="params">( <span class="keyword">void</span> *addr )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 写<code>I/O</code>内存，使用下列之一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iowrite8</span> <span class="params">( u8 value, <span class="keyword">void</span> *addr )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iowrite16</span> <span class="params">( u16 value, <span class="keyword">void</span> *addr )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iowrite32</span> <span class="params">( u32 value, <span class="keyword">void</span> *addr )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3. 老版本的<code>I/O</code>内存访问函数：从<code>I/O</code>内存读，使用下列之一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">readb</span> <span class="params">( address )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">readw</span> <span class="params">( address )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">readl</span> <span class="params">( address )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;写<code>I/O</code>内存，使用下列之一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">writeb</span> <span class="params">( <span class="keyword">unsigned</span> value, address )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">writew</span> <span class="params">( <span class="keyword">unsigned</span> value, address )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">writel</span> <span class="params">( <span class="keyword">unsigned</span> value, address )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="释放I-O内存"><a href="#释放I-O内存" class="headerlink" title="释放I/O内存"></a>释放I/O内存</h4><p>&emsp;&emsp;<code>I/O</code>内存不再需要使用时应当释放，步骤如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iounmap</span> <span class="params">( <span class="keyword">void</span> *addr )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_mem_region</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> len )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="混杂设备驱动"><a href="#混杂设备驱动" class="headerlink" title="混杂设备驱动"></a>混杂设备驱动</h3><p>&emsp;&emsp;在<code>Linux</code>系统中，存在一类字符设备，它们共享一个主设备号(<code>10</code>)，但次设备号不同，我们称这类设备为混杂设备(<code>miscdevice</code>)。所有的混杂设备形成一个链表，对设备访问时内核根据次设备号查找到相应的<code>miscdevice</code>设备。使用混杂设备时，要用<code>.minor = MISC_DYNAMIC_MINOR</code>，让系统自动分配设备号。</p>
<h4 id="设备描述"><a href="#设备描述" class="headerlink" title="设备描述"></a>设备描述</h4><p>&emsp;&emsp;<code>Linux</code>内核使用<code>struct miscdevice</code>来描述一个混杂设备。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> minor; <span class="comment">/* 次设备号 */</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/* 设备名 */</span></span><br><span class="line">   <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span> <span class="comment">/* 文件操作 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>Linux</code>内核使用<code>misc_register</code>函数来注册一个混杂设备驱动。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">misc_register</span> <span class="params">( struct miscdevice *misc )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="Kobject-amp-Kset"><a href="#Kobject-amp-Kset" class="headerlink" title="Kobject &amp; Kset"></a>Kobject &amp; Kset</h3><h4 id="Sysfs文件系统"><a href="#Sysfs文件系统" class="headerlink" title="Sysfs文件系统"></a>Sysfs文件系统</h4><p>&emsp;&emsp;<code>sysfs</code> is a <code>ram-based</code> filesystem initially based on ramfs. It provides a means to export kernel data structures, their attributes, and the linkages between them to userspace.<br>&emsp;&emsp;<code>Linux 2.6</code>内核引入了<code>sysfs</code>文件系统。<code>sysfs</code>被看成是与<code>proc</code>同类别的文件系统。<code>sysfs</code>把连接在系统上的设备和总线组织成分级的文件，使其从用户空间可以访问到。<code>Sysfs</code>被加载在<code>/sys</code>目录下，它的子目录包括：</p>
<ul>
<li><code>Block</code>：在系统中发现的每个块设备在该目录下对应一个子目录。每个子目录中又包含一些属性文件，它们描述了这个块设备的各方面属性，如设备大小(<code>loop</code>块设备是使用文件来模拟的)。</li>
<li><code>Bus</code>：在内核中注册的每条总线在该目录下对应一个子目录，如<code>ide</code>、<code>pci</code>、<code>scsi</code>、<code>usb</code>和<code>pcmcia</code>，其中每个总线目录内又包含两个子目录：<code>devices</code>和<code>drivers</code>。<code>devices</code>目录包含了在整个系统中发现的属于该总线类型的设备，<code>drivers</code>目录包含了注册到该总线的所有驱动。</li>
<li><code>Class</code>：将设备按照功能进行的分类，如<code>/sys/class/net</code>目录下包含了所有网络接口。</li>
<li><code>Devices</code>：包含系统所有的设备。</li>
<li><code>Kernel</code>：内核中的配置参数。</li>
<li><code>Module</code>：系统中所有模块的信息。</li>
<li><code>Firmware</code>：系统中的固件。</li>
<li><code>Fs</code>：描述系统中的文件系统。</li>
<li><code>Power</code>：系统中电源选项。</li>
</ul>
<h4 id="Kobject"><a href="#Kobject" class="headerlink" title="Kobject"></a>Kobject</h4><p>&emsp;&emsp;<code>Kobject</code>实现了基本的面向对象管理机制，是构成<code>Linux 2.6</code>设备模型的核心结构。它与<code>sysfs</code>文件系统紧密相连，在内核中注册的每个<code>kobject</code>对象对应<code>sysfs</code>文件系统中的一个目录。<code>kobject</code>在<code>/sys</code>目录下创建目录，<code>kobject</code>充当父类角色。<br>&emsp;&emsp;类似于<code>C++</code>中的基类，<code>Kobject</code>常被嵌入于其他类型(即容器)中，如<code>bus</code>、<code>devices</code>和<code>drivers</code>都是典型的容器。这些容器通过<code>kobject</code>连接起来，形成了一个树状结构。<code>kobject_init_and_add(&amp;kobj, &amp;type, NULL, &quot;kobject_test&quot;)</code>，<code>NULL</code>表明在<code>/sys</code>下创建文件夹。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">parent</span>;</span> <span class="comment">/* 指向父对象 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">kset</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> *<span class="title">ktype</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_dirent</span> *<span class="title">sd</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span> <span class="comment">/* 对象引用计数 */</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized: <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs: <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent: <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent: <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Kobject操作"><a href="#Kobject操作" class="headerlink" title="Kobject操作"></a>Kobject操作</h4><ul>
<li><code>void kobject_init ( struct kobject *kobj );</code>：初始化<code>kobject</code>结构。</li>
<li><code>int kobject_add ( struct kobject *kobj );</code>：将<code>kobject</code>对象注册到<code>Linux</code>系统。</li>
<li><code>int kobject_init_and_add ( struct kobject *kobj, struct kobj_type *ktype, struct kobject *parent, const char *fmt, ... );</code>：初始化<code>kobject</code>，并将其注册到<code>Linux</code>系统。</li>
<li><code>void kobject_del ( struct kobject *kobj );</code>：从<code>Linux</code>系统中删除<code>kobject</code>对象。</li>
<li><code>struct kobject *kobject_get ( struct kobject *kobj );</code>：将<code>kobject</code>对象的引用计数加<code>1</code>，同时返回该对象指针。</li>
<li><code>void kobject_put ( struct kobject *kobj );</code>：将<code>kobject</code>对象的引用计数减<code>1</code>，如果引用计数降为<code>0</code>，则调用<code>release</code>方法释放该<code>kobject</code>对象。</li>
</ul>
<h4 id="Struct-kobj-type"><a href="#Struct-kobj-type" class="headerlink" title="Struct kobj_type"></a>Struct kobj_type</h4><p>&emsp;&emsp;<code>Kobject</code>的<code>ktype</code>成员是一个指向<code>kobj_type</code>结构的指针，该结构中记录了<code>kobject</code>对象的一些属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">   <span class="keyword">void</span> ( *release ) ( struct kobject *kobj );</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>release</code>用于释放<code>kobject</code>占用的资源，当<code>kobject</code>的引用计数为<code>0</code>时被调用。</p>
<h4 id="Struct-attribute"><a href="#Struct-attribute" class="headerlink" title="Struct attribute"></a>Struct attribute</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">   <span class="keyword">char</span> *name; <span class="comment">/* 属性文件名 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">   <span class="keyword">mode_t</span> mode; <span class="comment">/* 属性的保护位 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct attribute</code>(属性)对应于<code>kobject</code>的目录下的一个文件，<code>Name</code>成员就是文件名。</p>
<h4 id="Struct-sysfs-ops"><a href="#Struct-sysfs-ops" class="headerlink" title="Struct sysfs_ops"></a>Struct sysfs_ops</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> &#123;</span></span><br><span class="line">   <span class="keyword">ssize_t</span> ( *show ) ( struct kobject *, struct attribute *, <span class="keyword">char</span> * );</span><br><span class="line">   <span class="keyword">ssize_t</span> ( *store ) ( struct kobject *, struct attribute *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Show</code>：当用户读属性文件时，该函数被调用，该函数将属性值存入<code>buffer</code>中返回给用户态。</li>
<li><code>Store</code>：当用户写属性文件时，该函数被调用，用于存储用户传入的属性值。</li>
</ul>
<h4 id="Kset"><a href="#Kset" class="headerlink" title="Kset"></a>Kset</h4><p>&emsp;&emsp;<code>kset</code>是具有相同类型的<code>kobject</code>的集合，在<code>sysfs</code>中体现成一个目录。<code>kobject</code>是<code>kset</code>的一个子目录，<code>kset_c.kobj.k_set = &amp;kset_p</code>，<code>kset_c</code>目录的属性由kobj来指定，kset_c的父目录为kset_p。在内核中用kset数据结构表示，定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">/* 连接该kset中所有kobject的链表头 */</span></span><br><span class="line">   <span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span> <span class="comment">/* 内嵌的kobject */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span> <span class="comment">/* 处理热插拔事件的操作集合 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/21/Linux驱动程序/Linux设备驱动基础/5.png"></p>
<h4 id="Kset操作"><a href="#Kset操作" class="headerlink" title="Kset操作"></a>Kset操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kset_register</span> <span class="params">( struct kset *kset )</span></span>; <span class="comment">/* 在内核中注册一个kset */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kset_unregister</span> <span class="params">( struct kset *kset )</span></span>; <span class="comment">/* 从内核中注销一个kset */</span></span><br></pre></td></tr></table></figure>
<h4 id="热插拔事件"><a href="#热插拔事件" class="headerlink" title="热插拔事件"></a>热插拔事件</h4><p>&emsp;&emsp;在<code>Linux</code>系统中，当系统配置发生变化时，如添加<code>kset</code>到系统、移动<code>kobject</code>，一个通知会从内核空间发送到用户空间，这就是热插拔事件。热插拔事件会导致用户空间中相应的处理程序(如<code>udev</code>、<code>mdev</code>)被调用，这些处理程序会通过加载驱动程序，创建设备节点等来响应热插拔事件。</p>
<h4 id="操作集合"><a href="#操作集合" class="headerlink" title="操作集合"></a>操作集合</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> ( *filter ) ( struct kset *kset, struct kobject *kobj );</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> * ( *name ) ( struct kset *kset, struct kobject *kobj );</span><br><span class="line">   <span class="keyword">int</span> ( *uevent ) ( struct kset *kset, struct kobject *kobj, struct kobj_uevent_env *env );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三个函数什么时候调用？当该<code>kset</code>所管理的<code>kobject</code>和<code>kset</code>状态发生变化时(如被加入、移动)，这三个函数将被调用(例如<code>kobject_uevent</code>调用)。</p>
<ul>
<li><code>filter</code>：决定是否将事件传递到用户空间。如果<code>filter</code>返回<code>0</code>，将不传递事件(例如<code>uevent_filter</code>)。</li>
<li><code>name</code>：用于将字符串传递给用户空间的热插拔处理程序。</li>
<li><code>uevent</code>：将用户空间需要的参数添加到环境变量中(例如<code>dev_uevent</code>)。</li>
</ul>
<h3 id="设备驱动模型"><a href="#设备驱动模型" class="headerlink" title="设备驱动模型"></a>设备驱动模型</h3><h4 id="设备模型"><a href="#设备模型" class="headerlink" title="设备模型"></a>设备模型</h4><p>&emsp;&emsp;随着技术的不断进步，系统的拓扑结构也越来越复杂，对智能电源管理、热插拔的支持要求也越来越高，<code>2.4</code>内核已经难以满足这些需求。为适应这种形势的需要，<code>Linux 2.6</code>内核提供了全新的内核设备模型。<br>&emsp;&emsp;设备模型元素有总线、驱动和设备。</p>
<h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>&emsp;&emsp;总线是处理器和设备之间的通道，在设备模型中，所有的设备都通过总线相连，甚至是内部的虚拟<code>platform</code>总线。在<code>Linux</code>设备模型中，总线由<code>bus_type</code>结构表示，定义在<code>linux/device.h</code>。</p>
<h4 id="总线描述"><a href="#总线描述" class="headerlink" title="总线描述"></a>总线描述</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/* 总线名称 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">bus_attribute</span> *<span class="title">bus_attrs</span>;</span> <span class="comment">/* 总线属性 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> *<span class="title">dev_attrs</span>;</span> <span class="comment">/* 设备属性 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">driver_attribute</span> *<span class="title">drv_attrs</span>;</span> <span class="comment">/* 驱动属性 */</span></span><br><span class="line">   <span class="keyword">int</span> ( *match ) ( struct device *dev, struct device_driver *drv );</span><br><span class="line">   <span class="keyword">int</span> ( *uevent ) ( struct device *dev, struct kobj_uevent_env *env );</span><br><span class="line">   <span class="keyword">int</span> ( *probe ) ( struct device *dev );</span><br><span class="line">   <span class="keyword">int</span> ( *remove ) ( struct device *dev );</span><br><span class="line">   <span class="keyword">void</span> ( *shutdown ) ( struct device *dev );</span><br><span class="line">   <span class="keyword">int</span> ( *suspend ) ( struct device *dev, <span class="keyword">pm_message_t</span> state );</span><br><span class="line">   <span class="keyword">int</span> ( *suspend_late ) ( struct device *dev, <span class="keyword">pm_message_t</span> state );</span><br><span class="line">   <span class="keyword">int</span> ( *resume_early ) ( struct device *dev );</span><br><span class="line">   <span class="keyword">int</span> ( *resume ) ( struct device *dev );</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">bus_type_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总线注册-删除"><a href="#总线注册-删除" class="headerlink" title="总线注册/删除"></a>总线注册/删除</h4><p>&emsp;&emsp;总线的注册使用<code>bus_register(struct bus_type * bus);</code>。若成功，新的总线将被添加进系统，并可在<code>sysfs</code>的<code>/sys/bus</code>下看到。总线的删除使用<code>void bus_unregister(struct bus_type *bus);</code>。</p>
<h4 id="总线方法"><a href="#总线方法" class="headerlink" title="总线方法"></a>总线方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ( *match ) ( struct device *dev, struct device_driver *drv );</span><br></pre></td></tr></table></figure>
<p>当一个新设备或者驱动被添加到这个总线时，该方法被调用。用于判断指定的驱动程序是否能处理指定的设备。若可以，则返回非零值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ( *uevent ) (</span><br><span class="line">   struct device *dev, <span class="keyword">char</span> **envp, <span class="keyword">int</span> num_envp,</span><br><span class="line">   <span class="keyword">char</span> *buffer, <span class="keyword">int</span> buffer_size );</span><br></pre></td></tr></table></figure>
<p>在为用户空间产生热插拔事件之前，这个方法允许总线添加环境变量。</p>
<h4 id="总线属性"><a href="#总线属性" class="headerlink" title="总线属性"></a>总线属性</h4><p>&emsp;&emsp;总线属性由结构<code>bus_attribute</code>描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_attribute</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">   <span class="keyword">ssize_t</span> ( *show ) ( struct bus_type *, <span class="keyword">char</span> *buf );</span><br><span class="line">   <span class="keyword">ssize_t</span> ( *store ) ( struct bus_type *, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_create_file</span> <span class="params">( struct bus_type *bus, struct bus_attribute *attr )</span></span>; <span class="comment">/* 创建属性 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bus_remove_file</span> <span class="params">( struct bus_type *bus, struct bus_attribute *attr )</span></span>; <span class="comment">/* 删除属性 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>Linux</code>系统中的每个设备由一个<code>struct device</code>描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">   <span class="keyword">char</span> bus_id[BUS_ID_SIZE]; <span class="comment">/* 在总线上唯一标识该设备的字符串 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span> <span class="comment">/* 设备所在总线 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span> <span class="comment">/* 管理该设备的驱动 */</span></span><br><span class="line">   <span class="keyword">void</span> *driver_data; <span class="comment">/* 该设备驱动使用的私有数据成员 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_class</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">   <span class="keyword">void</span> ( *release ) ( struct device *dev );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设备注册使用如下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_register</span> <span class="params">( struct device *dev )</span></span>; <span class="comment">/* 注册设备 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_unregister</span> <span class="params">( struct device *dev )</span></span>; <span class="comment">/* 注销设备 */</span></span><br></pre></td></tr></table></figure>
<p>一条总线也是个设备，也必须按设备注册。</p>
<h4 id="设备属性"><a href="#设备属性" class="headerlink" title="设备属性"></a>设备属性</h4><p>&emsp;&emsp;设备属性由<code>struct device_attribute</code>描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">   <span class="keyword">ssize_t</span> ( *show ) ( struct device *dev, struct device_attribute *attr, <span class="keyword">char</span> *buf );</span><br><span class="line">   <span class="keyword">ssize_t</span> ( *store ) ( struct device *dev, struct device_attribute *attr, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_create_file</span> <span class="params">( struct device *device, struct device_attribute *entry )</span></span>; <span class="comment">/* 创建属性 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_remove_file</span> <span class="params">( struct device *dev, struct device_attribute *attr )</span></span>; <span class="comment">/* 删除属性 */</span></span><br></pre></td></tr></table></figure>
<h4 id="驱动描述"><a href="#驱动描述" class="headerlink" title="驱动描述"></a>驱动描述</h4><p>&emsp;&emsp;驱动程序由<code>struct device_driver</code>描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> &#123;</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/* 驱动程序的名字(体现在sysfs中) */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span> <span class="comment">/* 驱动程序所在的总线 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *mod_name;</span><br><span class="line">   <span class="keyword">int</span> ( *probe ) ( struct device *dev );</span><br><span class="line">   <span class="keyword">int</span> ( *remove ) ( struct device *dev );</span><br><span class="line">   <span class="keyword">void</span> ( *shutdown ) ( struct device *dev );</span><br><span class="line">   <span class="keyword">int</span> ( *suspend ) ( struct device *dev, <span class="keyword">pm_message_t</span> state );</span><br><span class="line">   <span class="keyword">int</span> ( *resume ) ( struct device *dev );</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="驱动注册-注销"><a href="#驱动注册-注销" class="headerlink" title="驱动注册/注销"></a>驱动注册/注销</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_register</span> <span class="params">( struct device_driver *drv )</span></span>; <span class="comment">/* 注册驱动 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">driver_unregister</span> <span class="params">( struct device_driver *drv )</span></span>; <span class="comment">/* 注销驱动 */</span></span><br></pre></td></tr></table></figure>
<h4 id="驱动属性"><a href="#驱动属性" class="headerlink" title="驱动属性"></a>驱动属性</h4><p>&emsp;&emsp;驱动的属性使用<code>struct driver_attribute</code>来描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">driver_attribute</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">   <span class="keyword">ssize_t</span> ( *show ) ( struct device_driver *drv, <span class="keyword">char</span> *buf );</span><br><span class="line">   <span class="keyword">ssize_t</span> ( *store ) ( struct device_driver *drv, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_create_file</span> <span class="params">( struct device_driver *drv, struct driver_attribute *attr )</span></span>; <span class="comment">/* 创建属性 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">driver_remove_file</span> <span class="params">( struct device_driver *drv, struct driver_attribute *attr )</span></span>; <span class="comment">/* 删除属性 */</span></span><br></pre></td></tr></table></figure>
<h3 id="Platform驱动程序"><a href="#Platform驱动程序" class="headerlink" title="Platform驱动程序"></a>Platform驱动程序</h3><h4 id="Platform总线"><a href="#Platform总线" class="headerlink" title="Platform总线"></a>Platform总线</h4><p>&emsp;&emsp;<code>Platform</code>总线是<code>linux 2.6</code>内核加入的一种虚拟总线。<code>platform</code>机制的本身使用并不复杂，由两部分组成：<code>platform_device</code>和<code>platform_driver</code>。<code>Platform</code>驱动与传统的设备驱动模型相比，优势在于<code>platform</code>机制将设备本身的资源注册进内核，由内核统一管理，在驱动程序使用这些资源时使用统一的接口，这样提高了程序的可移植性。<br>&emsp;&emsp;通过<code>Platform</code>机制开发底层设备驱动的流程图：定义<code>platform_device -&gt; 注册platform_device -&gt; 定义platform_driver -&gt; 注册platform_driver</code>。</p>
<h4 id="平台设备描述"><a href="#平台设备描述" class="headerlink" title="平台设备描述"></a>平台设备描述</h4><p>&emsp;&emsp;平台设备使用<code>Struct Platform_device</code>来描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/* 设备名 */</span></span><br><span class="line">   <span class="keyword">int</span> id; <span class="comment">/* 设备编号，配合设备名使用 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line">   u32 num_resources;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">resource</span>;</span> <span class="comment">/* 设备资源 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>Struct Platform_device</code>的分配使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct platform_device *<span class="title">platform_device_alloc</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> id )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code>：设备名。</li>
<li><code>id</code>：设备<code>id</code>，一般为<code>-1</code>。</li>
</ul>
<h4 id="平台设备注册"><a href="#平台设备注册" class="headerlink" title="平台设备注册"></a>平台设备注册</h4><p>&emsp;&emsp;注册平台设备，使用函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">platform_device_add</span> <span class="params">( struct platform_device *pdev )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="设备资源"><a href="#设备资源" class="headerlink" title="设备资源"></a>设备资源</h4><p>&emsp;&emsp;平台设备资源使用<code>struct resource</code>来描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">   <span class="keyword">resource_size_t</span> start; <span class="comment">/* 资源的起始物理地址 */</span></span><br><span class="line">   <span class="keyword">resource_size_t</span> end; <span class="comment">/* 资源的结束物理地址 */</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/* 资源的名称 */</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> flags; <span class="comment">/* 资源的类型，比如MEM、IO、IRQ类型 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span> <span class="comment">/* 资源链表指针 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="设备资源示例"><a href="#设备资源示例" class="headerlink" title="设备资源示例"></a>设备资源示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">s3c_wdt_resource1</span> = &#123;</span></span><br><span class="line">   .start = <span class="number">0x44100000</span>, <span class="comment">/* 基地址(设备地址为0x44100000至0x44200000) */</span></span><br><span class="line">   .end = <span class="number">0x44200000</span>,</span><br><span class="line">   .flags = IORESOURCE_MEM,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> struct resource s3c_wdt_resource2 = &#123;</span><br><span class="line">   .start = <span class="number">20</span>, <span class="comment">/*中断号(20号中断) */</span></span><br><span class="line">   .end = <span class="number">20</span>,</span><br><span class="line">   .flags = IORESOURCE_IRQ,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct resource *<span class="title">platform_get_resource</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   struct platform_device *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> num )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>dev</code>：资源所属的设备。</li>
<li><code>type</code>：获取的资源类型；</li>
<li><code>num</code>：获取的资源数。</li>
</ul>
<p>&emsp;&emsp;例如<code>platform_get_resource(pdev, IORESOURCE_IRQ, 0);</code>是获取中断号，<code>0</code>指的是第一个资源。</p>
<h4 id="平台驱动描述"><a href="#平台驱动描述" class="headerlink" title="平台驱动描述"></a>平台驱动描述</h4><p>&emsp;&emsp;平台驱动使用<code>struct platform_driver</code>描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> ( *probe ) ( struct platform_device * );</span><br><span class="line">   <span class="keyword">int</span> ( *remove ) ( struct platform_device * );</span><br><span class="line">   <span class="keyword">void</span> ( *shutdown ) ( struct platform_device * );</span><br><span class="line">   <span class="keyword">int</span> ( *suspend ) ( struct platform_device *, <span class="keyword">pm_message_t</span> state );</span><br><span class="line">   <span class="keyword">int</span> ( *suspend_late ) ( struct platform_device *, <span class="keyword">pm_message_t</span> state );</span><br><span class="line">   <span class="keyword">int</span> ( *resume_early ) ( struct platform_device * );</span><br><span class="line">   <span class="keyword">int</span> ( *resume ) ( struct platform_device * );</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="平台驱动注册"><a href="#平台驱动注册" class="headerlink" title="平台驱动注册"></a>平台驱动注册</h4><p>&emsp;&emsp;平台驱动注册使用函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">platform_driver_register</span> <span class="params">( struct platform_driver * )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><h4 id="中断概念"><a href="#中断概念" class="headerlink" title="中断概念"></a>中断概念</h4><p>&emsp;&emsp;为什么需要中断？主要是因为：</p>
<ul>
<li>外设的处理速度一般慢于<code>CPU</code>。</li>
<li><code>CPU</code>不能一直等待外部事件。</li>
</ul>
<p>所以设备必须有一种方法来通知<code>CPU</code>它的工作进度，这种方法就是中断。</p>
<h4 id="中断实现"><a href="#中断实现" class="headerlink" title="中断实现"></a>中断实现</h4><p>&emsp;&emsp;在<code>Linux</code>驱动程序中，为设备实现一个中断包含两个步骤：向内核注册中断和实现中断处理函数。</p>
<h4 id="中断注册"><a href="#中断注册" class="headerlink" title="中断注册"></a>中断注册</h4><p>&emsp;&emsp;<code>request_irq</code>用于实现中断的注册功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_irq</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> ( *handler ) ( <span class="keyword">int</span>, <span class="keyword">void</span> *, struct pt_regs * ),</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">void</span> *dev_id )</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回<code>0</code>表示成功，或者返回一个错误码。</p>
<ul>
<li><code>irq</code>：中断号。</li>
<li><code>handler</code>：中断处理函数。</li>
<li><code>flags</code>：与中断管理有关的各种选项。</li>
<li><code>devname</code>：设备名(用于在<code>/proc/interrupts</code>中显示中断拥有者)。</li>
<li><code>dev_id</code>：共享中断时使用(用于标示一个唯一的设备)。</li>
</ul>
<p>&emsp;&emsp;在<code>flags</code>参数中，可以选择一些与中断管理有关的选项：</p>
<ul>
<li><code>IRQF_DISABLED(SA_INTERRUPT)</code>：如果设置该位，表示是一个<code>快速</code>中断处理程序；如果没有设置这位，那么是一个<code>慢速</code>中断处理程序。</li>
<li><code>IRQF_SHARED(SA_SHIRQ)</code>：该位表明中断可以在设备间共享。</li>
<li>为<code>0</code>表示普通外部中断。</li>
</ul>
<h4 id="快速-慢速中断"><a href="#快速-慢速中断" class="headerlink" title="快速/慢速中断"></a>快速/慢速中断</h4><p>&emsp;&emsp;这两种类型的中断处理程序的主要区别在于：快速中断保证中断处理的原子性(不被打断)，而慢速中断则不保证。换句话说，也就是<code>开启中断</code>标志位(处理器<code>IF</code>)在运行快速中断处理程序时是关闭的，因此在服务该中断时，不会被其他类型的中断打断；而调用慢速中断处理时，其它类型的中断仍可以得到服务。</p>
<h4 id="共享中断"><a href="#共享中断" class="headerlink" title="共享中断"></a>共享中断</h4><p>&emsp;&emsp;共享中断就是将不同的设备挂到同一个中断信号线上。<code>Linux</code>对共享的支持主要是为<code>PCI</code>设备服务，也可以用于<code>ISA</code>卡。共享中断也是通过<code>request_irq</code>函数来注册的，但有三个特别之处：</p>
<ul>
<li>申请共享中断时，必须在<code>flags</code>参数中指定<code>IRQF_SHARED</code>位。</li>
<li><code>dev_id</code>参数必须是唯一的。任何驱动中定义的全局指针都可以，<code>dev_id</code>一定不能设为<code>NULL</code>。</li>
<li>共享中断的处理程序中，不能使用<code>disable_irq(unsigned int irq)</code>和<code>enable_irq()</code>。为什么？如果使用了这个函数，共享中断信号线的其它设备将同样无法使用中断，也就无法正常工作了。</li>
</ul>
<h4 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h4><p>&emsp;&emsp;什么是中断处理程序，有何特别之处？中断处理程序就是普通的<code>C</code>语言代码。特别之处在于中断处理程序是在中断上下文中运行的，它的行为受到某些限制：</p>
<ul>
<li>不能向用户空间发送或接受数据，因为它不属于任何进程上下文。用户程序的<code>read</code>和<code>write</code>属于进程上下文。用户空间与进程对应，进程变，用户程序也变。</li>
<li>不能使用可能引起阻塞的函数。</li>
<li>不能使用可能引起调度的函数。</li>
</ul>
<h4 id="中断处理函数流程"><a href="#中断处理函数流程" class="headerlink" title="中断处理函数流程"></a>中断处理函数流程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">short_sh_interrupt</span> <span class="params">( <span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id, struct pt_regs *regs )</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 判断是否是本设备产生了中断 */</span></span><br><span class="line">   value = inb ( short_base );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ( ! ( value &amp; <span class="number">0x80</span> ) ) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 清除中断位(如果设备支持自动清除，则不需要这步) */</span></span><br><span class="line">   outb ( value &amp; <span class="number">0x7F</span>, short_base );</span><br><span class="line">   <span class="comment">/* 中断处理,通常是数据接收 */</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">/* 唤醒等待数据的进程 */</span></span><br><span class="line">   wake_up_interruptible ( &amp;short_queue );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果某个共享中断线上的某个设备发生了中断，则这个共享中断线上的所有设备的中断函数都发送响应。</p>
<h4 id="释放中断"><a href="#释放中断" class="headerlink" title="释放中断"></a>释放中断</h4><p>&emsp;&emsp;当设备不再需要使用中断时(通常在驱动卸载时)，应当把它们返还给系统：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_irq</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="Linux网络体系架构"><a href="#Linux网络体系架构" class="headerlink" title="Linux网络体系架构"></a>Linux网络体系架构</h3><h4 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h4><p>&emsp;&emsp;<code>Linux</code>的优点之一在于它丰富而稳定的网络协议栈。其范围从协议无关层(例如通用<code>socket</code>层接口或设备层)到各种具体的网络协议实现。<br>&emsp;&emsp;对于网络的理论介绍一般都采用<code>OSI</code>(<code>Open Systems Interconnection</code>)模型，但是<code>Linux</code>中网络栈的介绍一般分为四层的Internet模型。</p>
<h4 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h4><p>&emsp;&emsp;网络接口层把数据链路层和物理层合并在了一起，提供访问物理设备的驱动程序，对应的网络协议主要是以太网协议。</p>
<h4 id="网际层"><a href="#网际层" class="headerlink" title="网际层"></a>网际层</h4><p>&emsp;&emsp;网络层协议管理离散的计算机间的数据传输，如<code>IP</code>协议为用户和远程计算机提供了信息包的传输方法，确保信息包能正确地到达目的机器。重要的网络层协议包括<code>ARP</code>(地址解析协议)、<code>ICMP</code>(<code>Internet</code>控制消息协议)和<code>IP</code>协议(网际协议)等。</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>&emsp;&emsp;传输层的功能包括：格式化信息流、提供可靠传输。传输层包括<code>TCP</code>(<code>Transmission Control Protocol</code>，传输控制协议)和<code>UDP</code>(<code>User Datagram Protocol</code>，用户数据报协议)，它们是传输层中最主要的协议。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>&emsp;&emsp;应用层位于协议栈的顶端，它的主要任务是服务于应用，如利用<code>FTP</code>(文件传输协议)传输一个文件。常见的应用层协议有：<code>HTTP</code>、<code>FTP</code>和<code>Telnet</code>等。应用层是<code>Linux</code>网络设定很关键的一层，<code>Linux</code>服务器的配置文档主要针对应用层中的协议。</p>
<h4 id="Linux网络子系统"><a href="#Linux网络子系统" class="headerlink" title="Linux网络子系统"></a>Linux网络子系统</h4><p>&emsp;&emsp;<code>Linux</code>网络子系统的顶部是系统调用接口层。它为用户空间的应用程序提供了一种访问内核网络子系统的方法。位于其下面的是一个协议无关层，它提供了一种通用方法来使用传输层协议。然后是具体协议的实现，在<code>Linux</code>中包括内嵌的<code>TCP</code>、<code>UDP</code>协议，当然还有<code>IP</code>。然后是设备无关层，它提供了协议与设备驱动通信的通用接口，最下面是设备驱动程序。</p>
<p><img src="/2019/03/21/Linux驱动程序/Linux设备驱动基础/6.png" height="280" width="324"></p>
<h4 id="系统调用接口"><a href="#系统调用接口" class="headerlink" title="系统调用接口"></a>系统调用接口</h4><p>&emsp;&emsp;为应用程序提供访问内核网络子系统的方法：<code>Socket</code>系统调用。</p>
<h4 id="协议无关接口"><a href="#协议无关接口" class="headerlink" title="协议无关接口"></a>协议无关接口</h4><p>&emsp;&emsp;<code>Linux</code>中的<code>socket</code>使用<code>struct sock</code>来描述，这个结构包含了特定<code>socket</code>所需要的所有状态信息，还包括<code>socket</code>所使用的特定协议和在<code>socket</code>上可以执行的一些操作。</p>
<h4 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h4><p>&emsp;&emsp;网络协议层用于实现各种具体的网络协议，如<code>TCP</code>、<code>UDP</code>等。</p>
<h4 id="设备无关接口"><a href="#设备无关接口" class="headerlink" title="设备无关接口"></a>设备无关接口</h4><p>&emsp;&emsp;设备无关接口将协议与各种网络设备驱动连接在一起。这一层提供一组通用函数供底层网络设备驱动程序使用，让它们可以对高层协议栈进行操作。首先，设备驱动程序可能会通过调用<code>register_netdevice</code>或<code>unregister_netdevice</code>在内核中进行注册或注销。调用者首先填写<code>net_device</code>结构，然后传递这个结构进行注册。内核调用它的<code>init</code>函数(如果定义了这种函数)，然后执行一组健全性检查，并将新设备添加到设备列表中(内核中的活动设备链表)。<br>&emsp;&emsp;要从协议层向设备发送数据，需要使用<code>dev_queue_xmit</code>函数，这个函数对数据进行排队，并交由底层设备驱动程序进行最终传输报文的接收通常是使用<code>netif_rx</code>执行的。当底层设备驱动程序接收到一个报文(包含在所分配的<code>sk_buff</code>中)时，就会通过调用<code>netif_rx</code>将数据上传至设备无关层。然后，这个函数通过<code>netif_rx_schedule</code>将<code>sk_buff</code>在上层协议队列中进行排队，供以后进行处理。</p>
<h4 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h4><p>&emsp;&emsp;网络体系结构的最底部是负责管理物理网络设备的设备驱动程序层。</p>
<h3 id="网卡驱动设计"><a href="#网卡驱动设计" class="headerlink" title="网卡驱动设计"></a>网卡驱动设计</h3><p>&emsp;&emsp;每个网络接口都由一个<code>net_device</code>(在<code>linux/netdevice.h</code>中定义)结构来描述，该结构可使用如下内核函数动态分配：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct net_device *<span class="title">alloc_netdev</span> <span class="params">( <span class="keyword">int</span> sizeof_priv, <span class="keyword">const</span> <span class="keyword">char</span> *mask, <span class="keyword">void</span> ( *setup ) ( struct net_device * ) )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sizeof_priv</code>：私有数据区大小。</li>
<li><code>mask</code>：设备名。</li>
<li><code>setup</code>：初始化函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct net_device *<span class="title">alloc_etherdev</span> <span class="params">( <span class="keyword">int</span> sizeof_priv )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数分配一个网络设备，它提供了自己的初始化函数(<code>ether_setup</code>)来设置几个<code>net_device</code>的部分字段，使用的针对以太网设备的值。</p>
<h4 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h4><p>&emsp;&emsp;设备驱动没有主次编号。驱动为每个探测到的接口在一个全局的网络设备列表里插入一个数据结构。网络子系统为各种接口提供了一些帮助函数，包裹着<code>alloc_netdev</code>。最常用的是<code>alloc_etherdev</code>，定义在<code>linux/etherdevdevice.h</code>。一旦<code>net_device</code>结构完成了初始化，完成注册的过程就交给<code>register_netdev</code>。在调用<code>register_netdev</code>时，驱动会马上被用来调用来操作设备。<code>unregister_netdev</code>调用从系统中去除接口。</p>
<h4 id="net-device"><a href="#net-device" class="headerlink" title="net_device"></a>net_device</h4><p>&emsp;&emsp;结构<code>net_device</code>的主要成员包括：</p>
<ul>
<li><code>char name[IFNAMSIZ]</code>：设备名如<code>eth%d</code>(<code>eth0</code>、<code>eth1</code>等)。如果名字由设备驱动设置，通常包含一个<code>%d</code>字符串，<code>register_netdev</code>用一个数替换他来形成一个唯一的名字，分配的编号从零开始。</li>
<li><code>unsigned long state</code>：设备状态。这个成员包括几个标志，驱动正常情况下不直接操作这些标志，而是利用了一套函数操作。</li>
<li><code>unsigned char dma</code>：设备分配的<code>DMA</code>通道。</li>
<li><code>unsigned long base_addr</code>：<code>I/O</code>基地址。</li>
<li><code>unsigned int irq</code>：中断号。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ( *init ) ( struct net_device *dev ); <span class="comment">/* 初始化函数 */</span></span><br></pre></td></tr></table></figure>
<p>该函数在<code>register_netdev</code>时被调用来完成对<code>net_device</code>结构的初始化。<br>&emsp;&emsp;和字符驱动一样, 网络设备也要声明能操作它的函数。有些操作可以保留为<code>NULL</code>，有的可以通过<code>ether_setup</code>来使用默认设置。网络接口的设备方法可分为两组：基本的和可选的，基本方法包括那些使用接口所必需的；可选的方法实现更多高级的功能。</p>
<h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><ul>
<li><code>int ( *open ) ( struct net_device *dev );</code>：打开接口，<code>ifconfig</code>激活时，接口将被打开。<code>open</code>方法应当注册它需要的系统资源(<code>I/O</code>口、<code>IRQ</code>、<code>DMA</code>等)，打开硬件，进行任何别的你的设备要求的设置。</li>
<li><code>int ( *stop ) ( struct net_device *dev );</code>：停止接口。</li>
<li><code>int ( *hard_start_xmit ) ( struct sk_buff *skb, struct net_device *dev );</code>：数据发送函数。</li>
</ul>
<p>完整的报头包含在一个<code>socket</code>缓冲区(<code>sk_buff</code>)结构中。</p>
<h4 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ( *do_ioctl ) ( struct net_device *dev, struct ifreq *ifr, <span class="keyword">int</span> cmd ); <span class="comment">/* 处理特定于接口的ioctl命令 */</span></span><br><span class="line"><span class="comment">/* 改变Mac地址的函数，需要硬件支持该功能。如果接口支持改变它的硬件地址的能力，可以实现这个函数 */</span></span><br><span class="line"><span class="keyword">int</span> ( *set_mac_address ) ( struct net_device *dev, <span class="keyword">void</span> *addr );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;网络接口驱动的注册方式与字符驱动不同之处在于它没有主次设备号，并使用如下函数注册：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_netdev</span> <span class="params">( struct net_device *dev )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注销：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister_netdev</span><span class="params">(struct net_device *dev)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="sk-buff"><a href="#sk-buff" class="headerlink" title="sk_buff"></a>sk_buff</h4><p>&emsp;&emsp;<code>Linux</code>内核中的每个网络数据包都由一个套接字缓冲区结构<code>struct sk_buff</code>描述，即一个<code>sk_buff</code>结构就是一个包，指向<code>sk_buff</code>的指针通常被称做<code>skb</code>。该结构包含如下重要成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>  <span class="comment">/* 处理该包的设备 */</span></span><br><span class="line">__u32 saddr;         <span class="comment">/* IP源地址      */</span></span><br><span class="line">__u32 daddr;         <span class="comment">/* IP目的地址    */</span></span><br><span class="line">__u32 raddr;         <span class="comment">/* IP路由器地址  */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *head; <span class="comment">/* 分配空间的开始 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data; <span class="comment">/* 有效数据的开始 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *tail; <span class="comment">/* 有效数据的结束 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *end;  <span class="comment">/* 分配空间的结束 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> len;   <span class="comment">/* 有效数据的长度 */</span></span><br></pre></td></tr></table></figure>
<h4 id="Skb操作函数"><a href="#Skb操作函数" class="headerlink" title="Skb操作函数"></a>Skb操作函数</h4><p>&emsp;&emsp;操作<code>sk_buff</code>的内核函数如下：</p>
<ul>
<li><code>struct sk_buff *alloc_skb ( unsigned int len, int priority );</code>：分配一个<code>sk_buff</code>结构，供协议栈代码使用。</li>
<li><code>struct sk_buff *dev_alloc_skb ( unsigned int len );</code>：分配一个<code>sk_buff</code>结构，供驱动代码使用。</li>
<li><code>unsigned char *skb_push ( struct sk_buff *skb, int len );</code>：向后移动<code>skb</code>的<code>tail</code>指针，并返回<code>tail</code>移动之前的值。</li>
<li><code>unsigned char *skb_put ( struct sk_buff *skb, int len );</code>：向前移动<code>skb</code>的<code>head</code>指针，并返回<code>head</code>移动之后的值。</li>
<li><code>kfree_skb ( struct sk_buff *skb );</code>：释放一个<code>sk_buff</code>结构，供协议栈代码使用。</li>
<li><code>dev_kfree_skb ( struct sk_buff *skb );</code>：释放一个<code>sk_buff</code>结构，供驱动代码使用。</li>
</ul>
<h4 id="设备打开"><a href="#设备打开" class="headerlink" title="设备打开"></a>设备打开</h4><p>&emsp;&emsp;<code>Open</code>请求任何它需要的系统资源并且启动接口：</p>
<ul>
<li>注册中断、<code>DMA</code>等。</li>
<li>设置寄存器，启动设备。</li>
<li>启动发送队列。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">net_open</span> <span class="params">( struct net_device *dev )</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 申请中断 */</span></span><br><span class="line">   request_irq ( dev-&gt;irq, &amp;net_interrupt, SA_SHIRQ, <span class="string">"dm9000"</span>, dev );</span><br><span class="line">   <span class="comment">/* 设置寄存器，启动设备 */</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">/* 启动发送队列 */</span></span><br><span class="line">   netif_start_queue ( dev );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据发送和接收"><a href="#数据发送和接收" class="headerlink" title="数据发送和接收"></a>数据发送和接收</h4><p>&emsp;&emsp;当核心需要发送一个数据包时，它调用<code>hard_start_transmit</code>函数，该函数将最终调用到<code>net_device</code>结构中的<code>hard_start_xmit</code>函数指针。网络接口驱动可以实现两种方式的报文接收：中断和查询，<code>Linux</code>中驱动多采用中断方式。</p>
<h4 id="接收流程"><a href="#接收流程" class="headerlink" title="接收流程"></a>接收流程</h4><ol>
<li>分配<code>Skb</code>，即<code>skb = dev_alloc_skb(pkt-&gt;datalen + 2)</code>。</li>
<li>从硬件中读取数据到<code>Skb</code>。</li>
<li>调用<code>netif_rx</code>将数据交给协议栈，即<code>netif_rx(skb)</code>。</li>
</ol>
<h4 id="网络接口中断"><a href="#网络接口中断" class="headerlink" title="网络接口中断"></a>网络接口中断</h4><p>&emsp;&emsp;网络接口通常支持<code>3</code>种类型的中断：新报文到达中断、报文发送完成中断和出错中断。中断处理程序可通过查看网卡中的中断状态寄存器，来分辨出中断类型。</p>
<h3 id="Dm9000网卡驱动分析"><a href="#Dm9000网卡驱动分析" class="headerlink" title="Dm9000网卡驱动分析"></a>Dm9000网卡驱动分析</h3><h4 id="芯片介绍"><a href="#芯片介绍" class="headerlink" title="芯片介绍"></a>芯片介绍</h4><p>&emsp;&emsp;<code>Dm9000</code>在收到由上层发来的以太网帧后，开始侦听网络线路，如果线路忙，就等到线路空闲为止，否则立即发送该数据帧。接收时，它将从以太网收到的数据包在经过解码、去掉帧头和地址检验等步骤后缓存在片内。在<code>CRC</code>校验通过后，它会通知<code>CPU</code>收到了数据帧。</p>
<h4 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h4><p>&emsp;&emsp;以太网帧如下：</p>
<p><img src="/2019/03/21/Linux驱动程序/Linux设备驱动基础/7.png" height="248" width="601"></p>
<h3 id="Linux输入子系统"><a href="#Linux输入子系统" class="headerlink" title="Linux输入子系统"></a>Linux输入子系统</h3><h4 id="输入子系统"><a href="#输入子系统" class="headerlink" title="输入子系统"></a>输入子系统</h4><p>&emsp;&emsp;前面章节讲解按键设备驱动，实际上在<code>Linux</code>系统中，一种更值得推荐的实现这类设备驱动的方法是利用<code>input</code>子系统。<code>Linux</code>系统提供了<code>input</code>子系统，按键、触摸屏、鼠标等都可以利用<code>input</code>接口函数来实现设备驱动。输入子系统由驱动层、输入子系统核心层(<code>Input Core</code>)和事件处理层(<code>Event Handler</code>)三部分处理。一个输入事件，如鼠标移动、键盘按键按下，通过<code>Driver -&gt; Input Core -&gt;Event handler -&gt; userspace</code>达到用户空间的应用程序。</p>
<ul>
<li>驱动层：将底层的硬件输入转化为统一事件形式，向输入核心(<code>Input Core</code>)汇报。</li>
<li>输入核心层：为驱动层提供输入设备注册于操作接口，如<code>input_register_device</code>；通知事件处理层对事件进行处理；在<code>/proc</code>下产生相应的设备信息。</li>
<li>事件处理层：主要作用是和用户交互，我们知道<code>linux</code>在用户空间将所有设备当成文件来处理。在一般的设备驱动程序中都有提供<code>fops</code>接口，以及在<code>/dev</code>下生成相应功的设备文件<code>nod</code>，而在输入子系统中，这些工作都是由事件处理层完成的。</li>
</ul>
<h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p>&emsp;&emsp;体系结构如下：</p>
<p><img src="/2019/03/21/Linux驱动程序/Linux设备驱动基础/8.png" height="295" width="356"></p>
<p>&emsp;&emsp;在<code>Linux</code>内核中，<code>input</code>设备用<code>input_dev</code>结构体描述，使用<code>input</code>子系统实现输入设备驱动的时候，驱动的核心工作是向系统报告按键、触摸屏、键盘、鼠标等输入事件(<code>event</code>，通过<code>input_event</code>结构体描述)，不再需要关心文件操作接口，因为<code>input</code>子系统已经完成了文件操作接口。驱动报告的事件经过<code>Input Core</code>和<code>Event handler</code>最终到达用户空间。</p>
<h4 id="设备注册-注销"><a href="#设备注册-注销" class="headerlink" title="设备注册/注销"></a>设备注册/注销</h4><p>&emsp;&emsp;注册输入设备的函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_device</span> <span class="params">( struct input_dev *dev )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注销输入设备的函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_unregister_device</span> <span class="params">( struct input_dev *dev )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="驱动实现-事件支持"><a href="#驱动实现-事件支持" class="headerlink" title="驱动实现-事件支持"></a>驱动实现-事件支持</h4><p>&emsp;&emsp;设备驱动通过<code>set_bit</code>告诉<code>input</code>子系统它支持哪些事件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_bit ( EV_KEY, button_dev.evbit );</span><br></pre></td></tr></table></figure>
<p><code>Struct iput_dev</code>中有两个成员，一个是<code>evbit</code>，另一个是<code>keybit</code>，分别用来表示设备所支持的事件类型和按键类型。<br>&emsp;&emsp;事件类型如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EV_RST</code></td>
<td><code>Reset</code></td>
</tr>
<tr>
<td><code>EV_KEY</code></td>
<td>按键</td>
</tr>
<tr>
<td><code>EV_REL</code></td>
<td>相对坐标</td>
</tr>
<tr>
<td><code>EV_ABS</code></td>
<td>绝对坐标</td>
</tr>
<tr>
<td><code>EV_MSC</code></td>
<td>其它</td>
</tr>
<tr>
<td><code>EV_LED</code></td>
<td><code>LED</code></td>
</tr>
<tr>
<td><code>EV_SND</code></td>
<td>声音</td>
</tr>
<tr>
<td><code>EV_REP</code></td>
<td><code>Repeat</code></td>
</tr>
<tr>
<td><code>EV_FF</code></td>
<td>力反馈</td>
</tr>
</tbody>
</table>
</div>
<p>但事件类型为<code>EV_KEY</code>时，还需要指明按键类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BTN_LEFT</code></td>
<td>鼠标左键</td>
</tr>
<tr>
<td><code>BTN_RIGHT</code></td>
<td>鼠标右键</td>
</tr>
<tr>
<td><code>BTN_MIDDLE</code></td>
<td>鼠标中键</td>
</tr>
<tr>
<td><code>BTN_0</code></td>
<td>数字<code>0</code>键</td>
</tr>
<tr>
<td><code>BTN_1</code></td>
<td>数字<code>1</code>键</td>
</tr>
</tbody>
</table>
</div>
<h4 id="驱动实现-报告事件"><a href="#驱动实现-报告事件" class="headerlink" title="驱动实现-报告事件"></a>驱动实现-报告事件</h4><p>&emsp;&emsp;用于报告<code>EV_KEY</code>、<code>EV_REL</code>和<code>EV_ABS</code>事件的函数分别为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_report_key</span> <span class="params">( struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_report_rel</span> <span class="params">( struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_report_abs</span> <span class="params">( struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>code</code>：事件的代码。如果事件的类型是<code>EV_KEY</code>，该代码<code>code</code>为设备键盘代码。代码值<code>0</code>至<code>127</code>为键盘上的按键代码，<code>0x110</code>至<code>0x116</code>为鼠标上按键代码，其中<code>0x110</code>(<code>BTN_LEFT</code>)为鼠标左键，<code>0x111</code>(<code>BTN_RIGHT</code>)为鼠标右键，<code>0x112</code>(<code>BTN_MIDDLE</code>)为鼠标中键。其它代码含义请参看<code>include/linux/input.h</code>文件。</li>
<li><code>value</code>：事件的值。如果事件的类型是<code>EV_KEY</code>，当按键按下时值为<code>1</code>，松开时值为<code>0</code>。</li>
</ul>
<p>&emsp;&emsp;<code>input_sync</code>用于事件同步，它告知事件的接收者：驱动已经发出了一个完整的报告。例如在触摸屏设备驱动中，一次坐标及按下状态的整个报告过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input_report_abs ( input_dev, ABS_X, x ); <span class="comment">/* X坐标 */</span></span><br><span class="line">input_report_abs ( input_dev, ABS_Y, y ); <span class="comment">/* Y坐标 */</span></span><br><span class="line">input_report_abs ( input_dev, ABS_PRESSURE, pres ); <span class="comment">/* 压力 */</span></span><br><span class="line">input_sync ( input_dev ); <span class="comment">/* 同步 */</span></span><br></pre></td></tr></table></figure>
<h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在按键中断中报告事件 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">button_interrupt</span> <span class="params">( <span class="keyword">int</span> irq, <span class="keyword">void</span> *dummy, struct pt_regs *fp )</span> </span>&#123;</span><br><span class="line">   input_report_key ( &amp;button_dev, BTN_0, inb ( BUTTON_PORT0 ) );</span><br><span class="line">   input_report_key ( &amp;button_dev, BTN_0, inb ( BUTTON_PORT1 ) );</span><br><span class="line">   input_sync ( &amp;button_dev );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _ _<span class="function">init <span class="title">button_init</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 申请中断 */</span></span><br><span class="line">   <span class="keyword">if</span> ( request_irq ( BUTTON_IRQ, button_interrupt, <span class="number">0</span>, <span class="string">"button"</span>, <span class="literal">NULL</span> ) ) &#123;</span><br><span class="line">      <span class="keyword">return</span> - EBUSY;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   set_bit ( EV_KEY, button_dev.evbit ) <span class="comment">/* 支持EV_KEY事件 */</span></span><br><span class="line">   set_bit ( BTN_0, button_dev.keybit ); <span class="comment">/* 设备支持两个键 */</span></span><br><span class="line">   set_bit ( BTN_1, button_dev.keybit );</span><br><span class="line">   input_register_device ( &amp;button_dev ); <span class="comment">/* 注册input设备 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span> <span class="comment">/* 按键时间 */</span></span><br><span class="line">   __u16 type; <span class="comment">/* 类型，在下面有定义 */</span></span><br><span class="line">   __u16 code; <span class="comment">/* 要模拟成什么按键 */</span></span><br><span class="line">   __s32 value; <span class="comment">/* 是按下还是释放 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">ev_mouse</span>[2];</span></span><br><span class="line">fd = open ( <span class="string">"/dev/input/event3"</span>, O_RDWR );</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">   count = read ( fd, ev_mouse, <span class="keyword">sizeof</span> ( struct input_event ) );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; ( <span class="keyword">int</span> ) count / <span class="keyword">sizeof</span> ( struct input_event ); i++ ) &#123;</span><br><span class="line">      <span class="keyword">if</span> ( EV_REL == ev_mouse[i].type ) &#123;</span><br><span class="line">         <span class="built_in">printf</span> ( <span class="string">"time: % ld. % d"</span>, ev_mouse[i].time.tv_sec, ev_mouse[i].time.tv_usec );</span><br><span class="line">         <span class="built_in">printf</span> ( <span class="string">"type: % d code: % d value: % d\n"</span>, ev_mouse[i].type, ev_mouse[i].code, ev_mouse[i].value );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ( EV_KEY == ev_mouse[i].type ) &#123;</span><br><span class="line">         <span class="built_in">printf</span> ( <span class="string">"time: % ld. % d"</span>, ev_mouse[i].time.tv_sec, ev_mouse[i].time.tv_usec );</span><br><span class="line">         <span class="built_in">printf</span> ( <span class="string">" type: % d code: % d value: % d\n"</span>, ev_mouse[i].type, ev_mouse[i].code, ev_mouse[i].value );</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/20/嵌入式笔记/ARM基础教程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/20/嵌入式笔记/ARM基础教程/" itemprop="url">ARM基础教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-20T09:42:52+08:00">
                2019-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ARM工作模式"><a href="#ARM工作模式" class="headerlink" title="ARM工作模式"></a>ARM工作模式</h3><h4 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h4><p>&emsp;&emsp;从编程的角度看，<code>ARM</code>微处理器的工作状态一般有两种，并可在两种状态之间切换：</p>
<ul>
<li><code>ARM</code>状态：此时处理器执行<code>32</code>位的，字对齐的<code>ARM</code>指令。</li>
<li><code>Thumb</code>状态：此时处理器执行<code>16</code>位的，半字对齐的<code>Thumb</code>指令。</li>
</ul>
<p>当<code>ARM</code>微处理器执行<code>32</code>位的<code>ARM</code>指令集时，工作在<code>ARM</code>状态；当<code>ARM</code>微处理器执行<code>16</code>位的<code>Thumb</code>指令集时，工作在<code>Thumb</code>状态。在程序的执行过程中，微处理器可以随时在两种工作状态之间切换，并且处理器工作状态的转变并不影响处理器的工作模式和相应寄存器中的内容。</p>
<h4 id="存储器格式"><a href="#存储器格式" class="headerlink" title="存储器格式"></a>存储器格式</h4><p>&emsp;&emsp;<code>ARM</code>体系结构将存储器看作是从零地址开始的字节的线性组合。从零字节到三字节放置第一个存储的字(<code>32</code>位)数据，从第四个字节到第七个字节放置第二个存储的字数据，依次排列。作为<code>32</code>位的微处理器，<code>ARM</code>体系结构所支持的最大寻址空间为<code>4GB</code>。<code>ARM</code>体系结构可以用两种方法存储字数据，称之为<code>大端格式</code>和<code>小端格式</code>。</p>
<ul>
<li>大端格式：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。</li>
<li>小端格式：与大端存储格式相反，在小端存储格式中，低地址中存放的是字数据的低字节，高地址存放的是字数据的高字节。</li>
</ul>
<p><img src="/2019/03/20/嵌入式笔记/ARM基础教程/1.png"></p>
<h4 id="指令长度"><a href="#指令长度" class="headerlink" title="指令长度"></a>指令长度</h4><p>&emsp;&emsp;<code>ARM</code>微处理器的指令长度可以是<code>32</code>位(在<code>ARM</code>状态下)，也可以为<code>16</code>位(在<code>Thumb</code>状态下)。<code>ARM</code>微处理器支持字节(<code>8</code>位)、半字(<code>16</code>位)、字(<code>32</code>位)三种数据类型。其中，字需要<code>4</code>字节对齐(地址的低两位为<code>0</code>)、半字需要<code>2</code>字节对齐(地址的最低位为<code>0</code>)。</p>
<h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><p>&emsp;&emsp;<code>ARM</code>微处理器支持<code>7</code>种工作模式：</p>
<ul>
<li>用户模式(<code>Usr</code>)：用于正常执行程序。</li>
<li>快速中断模式(<code>FIQ</code>)：用于高速数据传输。</li>
<li>外部中断模式(<code>IRQ</code>)：用于通常的中断处理。</li>
<li>管理模式(<code>svc</code>)：操作系统使用的保护模式。</li>
<li>数据访问终止模式(<code>abt</code>)：当数据或指令预取终止时进入该模式，可用于虚拟存储及存储保护。</li>
<li>系统模式(<code>sys</code>)：运行具有特权的操作系统任务。</li>
<li>未定义指令中止模式(<code>und</code>)：当未定义的指令执行时进入该模式，可用于支持硬件。</li>
</ul>
<p>&emsp;&emsp;<code>ARM</code>微处理器的运行模式可以通过软件改变，也可以通过外部中断或异常处理改变。应用程序运行在用户模式下，当处理器运行在用户模式下时，某些被保护的系统资源是不能被访问的。除用户模式以外，其余的所有<code>6</code>种模式称之为<code>非用户模式</code>，或<code>特权模式</code>(<code>Privileged Modes</code>)；其中除去用户模式和系统模式以外的<code>5</code>种又称为<code>异常模式</code>(<code>Exception Modes</code>)，常用于处理中断或异常，以及需要访问受保护的系统资源等情况。</p>
<h3 id="ARM寄存器"><a href="#ARM寄存器" class="headerlink" title="ARM寄存器"></a>ARM寄存器</h3><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>&emsp;&emsp;<code>ARM</code>微处理器共有<code>37</code>个<code>32</code>位寄存器，其中<code>31</code>个为通用寄存器，<code>6</code>个为状态寄存器。但是这些寄存器不能被同时访问，具体哪些寄存器是可以访问的，取决<code>ARM</code>处理器的工作状态及具体的运行模式。但在任何时候，通用寄存器<code>R14</code>至<code>R0</code>、程序计数器<code>PC</code>、一个状态寄存器都是可访问的。</p>
<h4 id="寄存器-ARM状态"><a href="#寄存器-ARM状态" class="headerlink" title="寄存器(ARM状态)"></a>寄存器(ARM状态)</h4><p>&emsp;&emsp;在<code>ARM</code>工作状态下，任一时刻可以访问<code>16</code>个通用寄存器和一到两个状态寄存器。在非用户模式(特权模式)下，则可访问到特定模式分组寄存器，具体见下页图：</p>
<p><img src="/2019/03/20/嵌入式笔记/ARM基础教程/2.png" height="254" width="334"></p>
<h4 id="寄存器-Thumb状态"><a href="#寄存器-Thumb状态" class="headerlink" title="寄存器(Thumb状态)"></a>寄存器(Thumb状态)</h4><p>&emsp;&emsp;<code>Thumb</code>状态下的寄存器集是<code>ARM</code>状态下寄存器集的一个子集，程序可以直接访问<code>8</code>个通用寄存器(<code>R7</code>至<code>R0</code>)、程序计数器(<code>PC</code>)、堆栈指针(<code>SP</code>)、连接寄存器(<code>LR</code>)和<code>CPSR</code>。</p>
<p><img src="/2019/03/20/嵌入式笔记/ARM基础教程/4.png" height="278" width="336"></p>
<h4 id="寄存器对应"><a href="#寄存器对应" class="headerlink" title="寄存器对应"></a>寄存器对应</h4><p>&emsp;&emsp;<code>Thumb</code>状态下的寄存器组织与ARM状态下的寄存器组织的关系：</p>
<ul>
<li><code>Thumb</code>状态下和<code>ARM</code>状态下的<code>R0</code>至<code>R7</code>是相同的。</li>
<li><code>Thumb</code>状态下和<code>ARM</code>状态下的<code>CPSR</code>和<code>SPSR</code>是相同的。</li>
<li><code>Thumb</code>状态下的<code>SP</code>对应于<code>ARM</code>状态下的<code>R13</code>。</li>
<li><code>Thumb</code>状态下的<code>LR</code>对应于<code>ARM</code>状态下的<code>R14</code>。</li>
<li><code>Thumb</code>状态下的程序计数器<code>PC</code>对应于<code>ARM</code>状态下的<code>R15</code>。</li>
</ul>
<p><img src="/2019/03/20/嵌入式笔记/ARM基础教程/3.png" height="254" width="334"></p>
<h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>&emsp;&emsp;通用寄存器如下：</p>
<ul>
<li><code>R0</code>至<code>R15</code></li>
<li><code>R13_svc</code>、<code>R14_svc</code></li>
<li><code>R13_abt</code>、<code>R14_abt</code></li>
<li><code>R13_und</code>、<code>R14_und</code></li>
<li><code>R13_irq</code>、<code>R14_irq</code></li>
<li><code>R8_fiq</code>至<code>R14_fiq</code></li>
</ul>
<p>不分组寄存器(<code>The unbanked registers</code>)是<code>R0</code>至<code>R7</code>，分组寄存器(<code>The banked registers</code>)是<code>R8</code>至<code>R14</code>，程序计数器是<code>R15</code>(<code>PC</code>)。</p>
<h4 id="不分组通用寄存器"><a href="#不分组通用寄存器" class="headerlink" title="不分组通用寄存器"></a>不分组通用寄存器</h4><p>&emsp;&emsp;<code>R0</code>至<code>R7</code>是不分组寄存器，这意味着在所有处理器模式下，访问的都是同一个物理寄存器。未分组寄存器没有被系统用于特别的用途，任何可采用通用寄存器的应用场合都可以使用未分组寄存器。</p>
<h4 id="分组通用寄存器"><a href="#分组通用寄存器" class="headerlink" title="分组通用寄存器"></a>分组通用寄存器</h4><ul>
<li>分组寄存器<code>R8</code>至<code>R12</code>：<code>FIQ</code>模式分组寄存器<code>R8</code>至<code>R12</code>；<code>FIQ</code>以外的分组寄存器<code>R8</code>至<code>R12</code>。</li>
<li>分组寄存器<code>R13</code>、<code>R14</code>：寄存器<code>R13</code>通常用做堆栈指针<code>SP</code>；寄存器<code>R14</code>用作子程序链接寄存器(<code>Link Register</code>，<code>LR</code>)，指向函数的返回地址。</li>
</ul>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>&emsp;&emsp;寄存器<code>R15</code>被用作程序计数器，也称为<code>PC</code>。其值等于<code>当前正在执行的指令的地址 + 8</code>(因为在取址和执行之间多了一个译码的阶段)。</p>
<h4 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h4><p>&emsp;&emsp;状态寄存如下：</p>
<ul>
<li><code>CPSR</code></li>
<li><code>SPSR_svc</code></li>
<li><code>SPSR_abt</code></li>
<li><code>SPSR_und</code></li>
<li><code>SPSR_irq</code></li>
<li><code>SPSR_fiq</code></li>
</ul>
<p>&emsp;&emsp;<code>ARM</code>所有工作模式下都可以访问程序状态寄存器<code>CPSR</code>。<code>CPSR</code>包含条件码标志、中断禁止位、当前处理器模式以及其它状态和控制信息。<code>CPSR</code>在每种异常模式下都有一个对应的物理寄存器，即程序状态保存寄存器<code>SPSR</code>。当异常出现时，<code>SPSR</code>用于保存<code>CPSR</code>的值，以便异常返回后恢复异常发生时的工作状态。<br>&emsp;&emsp;只有异常模式下才有<code>SPSR</code>，<code>SPSR</code>是<code>CPSR</code>的一个备份。<code>CPSR</code>保存的是程序运行的状态，处理器是运行在<code>ARM</code>状态还是<code>Thumb</code>转态都将被记录在<code>CPSR</code>中。当异常情况发生时，<code>CPSR</code>可能被破坏，程序中断结束后不能返回原来的现场。有<code>SPSR</code>后，当异常情况到来时，<code>CPSR</code>的值保存在<code>SPSR</code>中；当把异常处理完之后，再把<code>SPSR</code>的值还给<code>CPSR</code>，这样现场就能恢复。<code>CPSR</code>和<code>SPSR</code>有着相同的格式。</p>
<p><img src="/2019/03/20/嵌入式笔记/ARM基础教程/5.png" height="256" width="454"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>CPSR[4:0]</th>
<th>模式</th>
<th>用途</th>
<th>可访问的寄存器</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>10000</code></td>
<td><code>用户</code></td>
<td>正常用户模式，程序正常执行模式</td>
<td><code>PC</code>，<code>R0</code>至<code>R14</code>，<code>CPSR</code></td>
</tr>
<tr>
<td><code>10001</code></td>
<td><code>FIQ</code></td>
<td>处理快速中断，支持高速数据传送或通道处理</td>
<td><code>PC</code>，<code>R8_fiq</code>至<code>R14_fiq</code>，<code>R0</code>至<code>R7</code>，<code>CPSR</code>，<code>SPSR_fiq</code></td>
</tr>
<tr>
<td><code>10010</code></td>
<td><code>IRQ</code></td>
<td>处理普通中断</td>
<td><code>PC</code>，<code>R13_irq</code>至<code>R14_irq</code>，<code>R0</code>至<code>R12</code>，<code>CPSR</code>，<code>SPSR_irq</code></td>
</tr>
<tr>
<td><code>10011</code></td>
<td><code>SVC</code></td>
<td>操作系统保护模式，处理软件中断(<code>SWI</code>)</td>
<td><code>PC</code>，<code>R13_svc</code>至<code>R14_svc</code>，<code>R0</code>至<code>R12</code>，<code>CPSR</code>，<code>SPSR_svc</code></td>
</tr>
<tr>
<td><code>10111</code></td>
<td><code>中止</code></td>
<td>处理存储器故障，实现虚拟存储器和存储器保护</td>
<td><code>PC</code>，<code>R13_abt</code>至<code>R14_abt</code>，<code>R0</code>至<code>R12</code>，<code>CPSR</code>，<code>SPSR_abt</code></td>
</tr>
<tr>
<td><code>11011</code></td>
<td><code>未定义</code></td>
<td>处理未定义的指令陷阱，支持硬件协处理器的软件仿真</td>
<td><code>PC</code>，<code>R13_und</code>至<code>R14_und</code>，<code>R0</code>至<code>R12</code>，<code>CPSR</code>，<code>SPSR_und</code></td>
</tr>
<tr>
<td><code>11111</code></td>
<td><code>系统</code></td>
<td>运行特权操作系统任务</td>
<td><code>PC</code>，<code>R0</code>至<code>R14</code>，<code>CPSR</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="ARM寻址方式"><a href="#ARM寻址方式" class="headerlink" title="ARM寻址方式"></a>ARM寻址方式</h3><h4 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h4><p>&emsp;&emsp;所谓寻址方式就是处理器根据指令中给出的地址信息来寻找物理地址的方式。</p>
<h4 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h4><p>&emsp;&emsp;立即寻址也叫立即数寻址，这是一种特殊的寻址方式，操作数本身就在指令中给出，只要取出指令也就取到了操作数。这个操作数被称为立即数，对应的寻址方式也就叫做立即寻址。例如以下指令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD R0, R0, #<span class="number">1</span>    ; R0 &lt;- R0 + <span class="number">1</span></span><br><span class="line">ADD R0, R0, #<span class="number">0x3f</span> ; R0 &lt;- R0 + <span class="number">0x3f</span></span><br></pre></td></tr></table></figure>
<p>在以上两条指令中，第二个源操作数即为立即数，要求以<code>#</code>为前缀，对于以十六进制表示的立即数，还要求在<code>#</code>后加上<code>0x</code>或<code>&amp;</code>。</p>
<h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><p>&emsp;&emsp;寄存器寻址就是利用寄存器中的数值作为操作数，这种寻址方式是各类微处理器经常采用的一种方式，也是一种执行效率较高的寻址方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD R0, R1, R2 ; R0 &lt;- R1 + R2</span><br></pre></td></tr></table></figure>
<p>该指令的执行效果是将寄存器<code>R1</code>和<code>R2</code>的内容相加，其结果存放在寄存器<code>R0</code>中。</p>
<h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p>&emsp;&emsp;寄存器间接寻址就是以寄存器中的值作为操作数的地址，而操作数本身存放在存储器中。例如以下指令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD R0, R1, [R2] ; R0 &lt;- R1 + [R2]</span><br><span class="line">LDR R0, [R1]     ; R0 &lt;- [R1]</span><br></pre></td></tr></table></figure>
<p>在第一条指令中，以寄存器<code>R2</code>的值作为操作数的地址，在存储器中取得一个操作数后与<code>R1</code>相加，结果存入寄存器<code>R0</code>中。第二条指令将以<code>R1</code>的值为地址的存储器中的数据传送到<code>R0</code>中。</p>
<h4 id="基址变址寻址"><a href="#基址变址寻址" class="headerlink" title="基址变址寻址"></a>基址变址寻址</h4><p>&emsp;&emsp;基址变址寻址就是将寄存器(该寄存器一般称作基址寄存器)的内容与指令中给出的地址偏移量相加，从而得到一个操作数的有效地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, [R1, #<span class="number">4</span>]  ; R0 &lt;- [R1 + <span class="number">4</span>]</span><br><span class="line">LDR R0, [R1, #<span class="number">4</span>]! ; R0 &lt;- [R1 + <span class="number">4</span>]、R1 &lt;- R1 + <span class="number">4</span></span><br><span class="line">LDR R0, [R1], #<span class="number">4</span>  ; R0 &lt;- [R1]、R1 &lt;- R1 + <span class="number">4</span></span><br><span class="line">LDR R0, [R1, R2]  ; R0 &lt;- [R1 + R2]</span><br></pre></td></tr></table></figure>
<h4 id="多寄存器寻址"><a href="#多寄存器寻址" class="headerlink" title="多寄存器寻址"></a>多寄存器寻址</h4><p>&emsp;&emsp;采用多寄存器寻址方式，一条指令可以完成多个寄存器值的传送。这寻址方式可以用一条指令完成传送最多<code>16</code>个通用寄存器的值。例如以下指令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LDMIA R0, &#123;R1, R2, R3, R4&#125; ; R1 &lt;- [R0]</span><br><span class="line">                           ; R2 &lt;- [R0 + <span class="number">4</span>]</span><br><span class="line">                           ; R3 &lt;- [R0 + <span class="number">8</span>]</span><br><span class="line">                           ; R4 &lt;- [R0 + <span class="number">12</span>]</span><br></pre></td></tr></table></figure>
<p>该指令的后缀<code>IA</code>表示在每次执行完<code>加载/存储</code>操作后，<code>R0</code>按字长度增加，因此，指令可将连续存储单元的值传送到<code>R1</code>至<code>R4</code>。</p>
<h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><p>&emsp;&emsp;与基址变址寻址方式相类似，相对寻址以程序计数器<code>PC</code>的当前值为基地址，指令中的地址标号作为偏移量，将两者相加之后得到操作数的有效地址。以下程序段完成子程序的调用和返回，跳转指令<code>BL</code>采用了相对寻址方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BL NEXT ; 跳转到子程序NEXT处执行</span><br><span class="line">...</span><br><span class="line">NEXT</span><br><span class="line">...</span><br><span class="line">MOV PC, LR ; 从子程序返回</span><br></pre></td></tr></table></figure>
<h4 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h4><p>&emsp;&emsp;堆栈是一种数据结构，按先进后出(<code>First In Last Out</code>，<code>FILO</code>)的方式工作，使用一个称作堆栈指针的专用寄存器指示当前的操作位置，堆栈指针总是指向栈顶。</p>
<ul>
<li>递增堆栈：向高地址方向生长。</li>
<li>递减堆栈：向低地址方向生长。</li>
<li>满堆栈：堆栈指针指向最后压入堆栈的有效数据项。</li>
<li>空堆栈：堆栈指针指向下一个要放入数据的空位置。</li>
</ul>
<h3 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h3><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p>&emsp;&emsp;跳转指令用于实现程序流程的跳转，在<code>ARM</code>程序中有两种方法可以实现程序流程的跳转：</p>
<ul>
<li>使用专门的跳转指令。</li>
<li>直接向程序计数器<code>PC</code>写入跳转地址值，通过向程序计数器<code>PC</code>写入跳转地址值，可以实现在<code>4GB</code>的地址空间中的任意跳转，在跳转之前结合使用：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV LR, PC</span><br></pre></td></tr></table></figure>
<p>等类似指令，可以保存将来的返回地址值，从而实现在<code>4GB</code>连续的线性地址空间的子程序调用。<br>&emsp;&emsp;<code>ARM</code>指令集中的跳转指令可以完成从当前指令向前或向后的<code>32MB</code>的地址空间的跳转，包括以下<code>4</code>条指令：</p>
<ul>
<li><code>B</code>：跳转指令。</li>
<li><code>BL</code>：带返回的跳转指令。</li>
<li><code>BLX</code>：带返回和状态切换的跳转指令。</li>
<li><code>BX</code>：带状态切换的跳转指令。</li>
</ul>
<p>&emsp;&emsp;<code>B</code>指令的格式为<code>B{条件} 目标地址</code>，<code>B</code>指令是最简单的跳转指令。一旦遇到一个<code>B</code>指令，<code>ARM</code>处理器将立即跳转到给定的目标地址，从那里继续执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B Label ; 程序无条件跳转到标号Label处执行</span><br><span class="line">CMP R1, #<span class="number">0</span></span><br><span class="line">BEQ Label ; 当CPSR寄存器中的Z条件码置位时，程序跳转到标号Label处执行</span><br></pre></td></tr></table></figure>
<h4 id="指令条件"><a href="#指令条件" class="headerlink" title="指令条件"></a>指令条件</h4><div class="table-container">
<table>
<thead>
<tr>
<th>指令条件</th>
<th>标志位</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EQ</code></td>
<td><code>Z</code>置位</td>
<td>相等</td>
</tr>
<tr>
<td><code>NE</code></td>
<td><code>Z</code>清零</td>
<td>不相等</td>
</tr>
<tr>
<td><code>CS</code></td>
<td><code>C</code>置位</td>
<td>无符号数大于或等于</td>
</tr>
<tr>
<td><code>CC</code></td>
<td><code>C</code>清零</td>
<td>无符号数小于</td>
</tr>
<tr>
<td><code>MI</code></td>
<td><code>N</code>置位</td>
<td>负数</td>
</tr>
<tr>
<td><code>PL</code></td>
<td><code>N</code>清零</td>
<td>正数或零</td>
</tr>
<tr>
<td><code>VS</code></td>
<td><code>V</code>置位</td>
<td>溢出</td>
</tr>
<tr>
<td><code>VC</code></td>
<td><code>V</code>清零</td>
<td>未溢出</td>
</tr>
<tr>
<td><code>HI</code></td>
<td><code>C</code>置位<code>Z</code>清零</td>
<td>无符号数大于</td>
</tr>
<tr>
<td><code>LS</code></td>
<td><code>C</code>清零<code>Z</code>置位</td>
<td>无符号数小于或等于</td>
</tr>
<tr>
<td><code>GE</code></td>
<td><code>N</code>等于<code>V</code></td>
<td>带符号数大于或等于</td>
</tr>
<tr>
<td><code>LT</code></td>
<td><code>N</code>不等于<code>V</code></td>
<td>带符号数小于</td>
</tr>
<tr>
<td><code>GT</code></td>
<td><code>Z</code>清零且(<code>N</code>等于<code>V</code>)</td>
<td>带符号数大于</td>
</tr>
<tr>
<td><code>LE</code></td>
<td><code>Z</code>置位或(<code>N</code>不等于<code>V</code>)</td>
<td>带符号数小于或等于</td>
</tr>
<tr>
<td><code>AL</code></td>
<td>忽略</td>
<td>无条件执行</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;<code>BL</code>指令的格式为<code>BL{条件} 目标地址</code>，<code>BL</code>是另一个跳转指令，但跳转之前，会在寄存器<code>R14</code>中保存<code>PC</code>当前值，因此可以通过将<code>R14</code>的内容重新加载到<code>PC</code>中，来返回到跳转指令之后的那个指令处执行。该指令是实现子程序调用的一个基本但常用的手段。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; 当程序无条件跳转到标号Label处执行时，同时将当前的PC值保存到R14中</span><br><span class="line">BL Label</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>BLX</code>指令的格式为<code>BLX 目标地址</code>，<code>BLX</code>指令从<code>ARM</code>指令集跳转到指令中所指定的目标地址，并将处理器的工作状态有<code>ARM</code>状态切换到<code>Thumb</code>状态，该指令同时将<code>PC</code>的当前内容保存到寄存器<code>R14</code>中。因此，当子程序使用<code>Thumb</code>指令集，而调用者使用<code>ARM</code>指令集时，可以通过<code>BLX</code>指令实现子程序的调用和处理器工作状态的切换。同时，子程序的返回可以通过将寄存器<code>R14</code>值复制到<code>PC</code>中来完成。<br>&emsp;&emsp;<code>BX</code>指令的格式为<code>BX{条件} 目标地址</code>，<code>BX</code>指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是<code>ARM</code>指令，也可以是<code>Thumb</code>指令。</p>
<h4 id="数据处理指令"><a href="#数据处理指令" class="headerlink" title="数据处理指令"></a>数据处理指令</h4><p>&emsp;&emsp;数据处理指令可分为数据传送指令、算术逻辑运算指令和比较指令等。数据传送指令用于在寄存器和存储器之间进行数据的双向传输。算术逻辑运算指令完成常用的算术与逻辑的运算，该类指令不但将运算结果保存在目的寄存器中，同时更新<code>CPSR</code>中的相应条件标志位。</p>
<h4 id="MOV指令"><a href="#MOV指令" class="headerlink" title="MOV指令"></a>MOV指令</h4><p>&emsp;&emsp;<code>MOV</code>指令的格式为<code>MOV{条件}{S} 目的寄存器, 源操作数</code>，<code>MOV</code>指令完成从另一个寄存器、被移位的寄存器或将一个立即数加载到目的寄存器。其中<code>S</code>选项决定指令的操作是否影响<code>CPSR</code>中条件标志位的值，当没有<code>S</code>时，指令不更新<code>CPSR</code>中条件标志位的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV R1, R0        ; 将寄存器R0的值传送到寄存器R1</span><br><span class="line">MOV PC, R14       ; 将寄存器R14的值传送到PC，常用于子程序返回</span><br><span class="line">MOV R1, R0, LSL#<span class="number">3</span> ; 将寄存器R0的值左移<span class="number">3</span>位后传送到R1</span><br></pre></td></tr></table></figure>
<h4 id="MVN指令"><a href="#MVN指令" class="headerlink" title="MVN指令"></a>MVN指令</h4><p>&emsp;&emsp;<code>MVN</code>指令的格式为<code>MVN{条件}{S} 目的寄存器, 源操作数</code>，<code>MVN</code>指令可完成从另一个寄存器、被移位的寄存器、或将一个立即数加载到目的寄存器。与<code>MOV</code>指令不同之处是在传送之前按位被取反了，即把一个被取反的值传送到目的寄存器中。其中<code>S</code>决定指令的操作是否影响<code>CPSR</code>中条件标志位的值，当没有<code>S</code>时，指令不更新<code>CPSR</code>中条件标志位的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MVN R0, #<span class="number">0xff</span> ; 将<span class="number">0xffffff00</span>赋给R0</span><br></pre></td></tr></table></figure>
<h4 id="CMP指令"><a href="#CMP指令" class="headerlink" title="CMP指令"></a>CMP指令</h4><p>&emsp;&emsp;<code>CMP</code>指令的格式为<code>CMP{条件} 操作数1, 操作数2</code>，<code>CMP</code>指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较，同时更新<code>CPSR</code>中条件标志位的值。该指令进行一次减法运算，但不存储结果，只更改条件标志位。标志位表示的是<code>操作数1</code>与<code>操作数2</code>的关系(大、小、相等)。例如，当<code>操作数1</code>大于操作<code>操作数2</code>，则此后的有<code>GT</code>后缀的指令将可以执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMP R1, R0   ; 将寄存器R1的值与寄存器R0的值相减，并根据结果设置CPSR的标志位</span><br><span class="line">CMP R1, #<span class="number">100</span> ; 将寄存器R1的值与立即数<span class="number">100</span>相减，并根据结果设置CPSR的标志位</span><br></pre></td></tr></table></figure>
<h4 id="TST指令"><a href="#TST指令" class="headerlink" title="TST指令"></a>TST指令</h4><p>&emsp;&emsp;<code>TST</code>指令的格式为<code>TST{条件} 操作数1, 操作数2</code>，<code>TST</code>指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位的与运算，并根据运算结果更新<code>CPSR</code>中条件标志位的值。<code>操作数1</code>是要测试的数据，而<code>操作数2</code>是一个位掩码，根据测试结果设置相应标志位。当位与结果为<code>0</code>时，<code>EQ</code>位被设置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TST R1, #%<span class="number">1</span> ; 用于测试在寄存器R1中是否设置了最低位(“%”表示二进制数)</span><br></pre></td></tr></table></figure>
<h4 id="ADD指令"><a href="#ADD指令" class="headerlink" title="ADD指令"></a>ADD指令</h4><p>&emsp;&emsp;<code>ADD</code>指令的格式为<code>ADD{条件}{S} 目的寄存器, 操作数1, 操作数2</code>，<code>ADD</code>指令用于把两个操作数相加，并将结果存放到目的寄存器中。<code>操作数1</code>应是一个寄存器，<code>操作数2</code>可以是一个寄存器，被移位的寄存器，或一个立即数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD R0, R1, R2        ; R0 = R1 + R2</span><br><span class="line">ADD R0, R1, #<span class="number">256</span>      ; R0 = R1 + <span class="number">256</span></span><br><span class="line">ADD R0, R2, R3, LSL#<span class="number">1</span> ; R0 = R2 + (R3 &lt;&lt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="SUB指令"><a href="#SUB指令" class="headerlink" title="SUB指令"></a>SUB指令</h4><p>&emsp;&emsp;<code>SUB</code>指令的格式为<code>SUB{条件}{S} 目的寄存器, 操作数1, 操作数2</code>，<code>SUB</code>指令用于把<code>操作数1</code>减去<code>操作数2</code>，并将结果存放到目的寄存器中。<code>操作数1</code>应是一个寄存器，<code>操作数2</code>可以是一个寄存器，被移位的寄存器，或一个立即数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SUB R0, R1, R2        ; R0 = R1 - R2</span><br><span class="line">SUB R0, R1, #<span class="number">256</span>      ; R0 = R1 - <span class="number">256</span></span><br><span class="line">SUB R0, R2, R3, LSL#<span class="number">1</span> ; R0 = R2 - (R3 &lt;&lt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="AND指令"><a href="#AND指令" class="headerlink" title="AND指令"></a>AND指令</h4><p>&emsp;&emsp;<code>AND</code>指令的格式为<code>AND{条件}{S} 目的寄存器, 操作数1, 操作数2</code>，<code>AND</code>指令用于在两个操作数上进行逻辑与运算，并把结果放置到目的寄存器中。<code>操作数1</code>应是一个寄存器，<code>操作数2</code>可以是一个寄存器，被移位的寄存器，或一个立即数。该指令常用于屏蔽<code>操作数1</code>的某些位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND R0, R0, #<span class="number">3</span> ; 该指令保持R0的<span class="number">0</span>、<span class="number">1</span>位，其余位清零</span><br></pre></td></tr></table></figure>
<h4 id="ORR指令"><a href="#ORR指令" class="headerlink" title="ORR指令"></a>ORR指令</h4><p>&emsp;&emsp;<code>ORR</code>指令的格式为<code>ORR{条件}{S} 目的寄存器, 操作数1, 操作数2</code>，<code>ORR</code>指令用于在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。<code>操作数1</code>应是一个寄存器，<code>操作数2</code>可以是一个寄存器，被移位的寄存器，或一个立即数。该指令常用于设置<code>操作数1</code>的某些位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORR R0, R0, #<span class="number">3</span> ; 该指令设置R0的<span class="number">0</span>、<span class="number">1</span>位，其余位保持不变</span><br></pre></td></tr></table></figure>
<h4 id="BIC指令"><a href="#BIC指令" class="headerlink" title="BIC指令"></a>BIC指令</h4><p>&emsp;&emsp;<code>BIC</code>指令的格式为<code>BIC{cond}{S} Rd, Rn, operand2</code>，<code>BIC</code>指令用于清除<code>Rn</code>中的某些位，并把结果存放在<code>Rd</code>中，操作数<code>operand2</code>为<code>32</code>位的掩码，如果掩码中设置了某一位为<code>1</code>，则清除这一位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BIC R0, R0, #%<span class="number">1011</span> ; 将R0的<span class="number">0</span>、<span class="number">1</span>、<span class="number">3</span>位清零，其余位不变</span><br></pre></td></tr></table></figure>
<h4 id="MUL指令"><a href="#MUL指令" class="headerlink" title="MUL指令"></a>MUL指令</h4><p>&emsp;&emsp;<code>MUL</code>指令的格式为<code>MUL{条件}{S} 目的寄存器, 操作数1, 操作数2</code>，<code>MUL</code>指令完成将<code>操作数1</code>与<code>操作数2</code>的乘法运算，并把结果放置到目的寄存器中，同时可以根据运算结果设置<code>CPSR</code>中相应的条件标志位。其中，<code>操作数1</code>和<code>操作数2</code>均为<code>32</code>位的有符号数或无符号数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MUL R0, R1, R2  ; R0 = R1 * R2</span><br><span class="line">MULS R0, R1, R2 ; R0 = R1 * R2，同时设置CPSR中的相关条件标志位</span><br></pre></td></tr></table></figure>
<h4 id="程序状态寄存器访问指令"><a href="#程序状态寄存器访问指令" class="headerlink" title="程序状态寄存器访问指令"></a>程序状态寄存器访问指令</h4><p>&emsp;&emsp;<code>ARM</code>微处理器支持程序状态寄存器访问指令，用于在程序状态寄存器和通用寄存器之间传送数据。</p>
<h4 id="MRS指令"><a href="#MRS指令" class="headerlink" title="MRS指令"></a>MRS指令</h4><p>&emsp;&emsp;<code>MRS</code>指令的格式为<code>MRS{条件} 通用寄存器, 程序状态寄存器(CPSR或SPSR)</code>，<code>MRS</code>指令用于将程序状态寄存器的内容传送到通用寄存器中(注意，<code>MOV</code>指令无法直接传送一个值到程序状态寄存器中)。该指令一般用在以下几种情况：</p>
<ul>
<li>当需要改变程序状态寄存器的内容时，可用<code>MRS</code>将程序状态寄存器的内容读入通用寄存器，修改后再写回程序状态寄存器。</li>
<li>当在异常处理或进程切换时，需要保存程序状态寄存器的值，可先用该指令读出程序状态寄存器的值，然后保存。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MRS R0, CPSR ; 传送CPSR的内容到R0</span><br><span class="line">MRS R0, SPSR ; 传送SPSR的内容到R0</span><br></pre></td></tr></table></figure>
<h4 id="MSR指令"><a href="#MSR指令" class="headerlink" title="MSR指令"></a>MSR指令</h4><p>&emsp;&emsp;<code>MSR</code>指令的格式为<code>MSR{条件} 程序状态寄存器(CPSR或SPSR)_&lt;域&gt;, 操作数</code>，<code>MSR</code>指令用于将操作数的内容传送到程序状态寄存器的特定域中。其中，操作数可以为通用寄存器或立即数。<code>域</code>用于设置程序状态寄存器中需要操作的位，<code>32</code>位的程序状态寄存器可分为<code>4</code>个域：</p>
<ul>
<li>位<code>[31:24]</code>为条件标志位域，用<code>f</code>表示。</li>
<li>位<code>[23:16]</code>为状态位域，用<code>s</code>表示。</li>
<li>位<code>[15:8]</code>为扩展位域，用<code>x</code>表示。</li>
<li>位<code>[7:0]</code>为控制位域，用<code>c</code>表示。</li>
</ul>
<p>该指令通常用于恢复或改变程序状态寄存器的内容，在使用时，一般要在<code>MSR</code>指令中指明将要操作的域。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MSR CPSR, R0   ; 传送R0的内容到CPSR</span><br><span class="line">MSR SPSR, R0   ; 传送R0的内容到SPSR</span><br><span class="line">MSR CPSR_c, R0 ; 传送R0的内容到SPSR，但仅仅修改CPSR中的控制位域</span><br></pre></td></tr></table></figure>
<h4 id="加载-存储指令"><a href="#加载-存储指令" class="headerlink" title="加载/存储指令"></a>加载/存储指令</h4><p>&emsp;&emsp;<code>ARM</code>微处理器支持加载/存储指令用于在寄存器和存储器之间传送数据，加载指令用于将存储器中的数据传送到寄存器，存储指令则完成相反的操作。</p>
<h4 id="LDR指令"><a href="#LDR指令" class="headerlink" title="LDR指令"></a>LDR指令</h4><p>&emsp;&emsp;<code>LDR</code>指令的格式为<code>LDR{条件} 目的寄存器, &lt;存储器地址&gt;</code>，<code>LDR</code>指令用于从存储器中将一个<code>32</code>位的字数据传送到目的寄存器中。该指令通常用于从存储器中读取<code>32</code>位的字数据到通用寄存器，然后对数据进行处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, [R1]             ; 将存储器地址为R1的字数据读入寄存器R0</span><br><span class="line">LDR R0, [R1, R2]         ; 将存储器地址为“R1 + R2”的字数据读入寄存器R0</span><br><span class="line">LDR R0, [R1, #<span class="number">8</span>]         ; 将存储器地址为“R1 + <span class="number">8</span>”的字数据读入寄存器R0</span><br><span class="line">LDR R0, [R1, R2]!        ; 将存储器地址为“R1 + R2”的字数据读入寄存器R0，并将新地址“R1 + R2”写入R1</span><br><span class="line">LDR R0, [R1, #<span class="number">8</span>]!        ; 将存储器地址为“R1 + <span class="number">8</span>”的字数据读入寄存器R0，并将新地址“R1 + <span class="number">8</span>”写入R1</span><br><span class="line">LDR R0, [R1], R2         ; 将存储器地址为R1的字数据读入寄存器R0，并将新地址“R1 + R2”写入R1</span><br><span class="line">LDR R0, [R1, R2, LSL#<span class="number">2</span>]! ; 将存储器地址为“R1 + R2 * <span class="number">4</span>”的字数据读入寄存器R0，并将新地址“R1 + R2 * <span class="number">4</span>”写入R1</span><br><span class="line">LDR R0, [R1], R2, LSL#<span class="number">2</span>  ; 将存储器地址为R1的字数据读入寄存器R0，并将新地址“R1 + R2 * <span class="number">4</span>”写入R1</span><br></pre></td></tr></table></figure>
<p>注意如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; 将<span class="number">0x30003100</span>赋给R1。这是个伪指令，不是加载指令，它的作用相当于MOV。判断的方法是看立即数的前面是否有“=”号</span><br><span class="line">LDR R1, =<span class="number">0x30003100</span></span><br></pre></td></tr></table></figure>
<h4 id="LDRB指令"><a href="#LDRB指令" class="headerlink" title="LDRB指令"></a>LDRB指令</h4><p>&emsp;&emsp;<code>LDRB</code>指令的格式为<code>LDR{条件}B 目的寄存器, &lt;存储器地址&gt;</code>，<code>LDRB</code>指令用于从存储器中将一个<code>8</code>位的字节数据传送到目的寄存器中，同时将寄存器的高<code>24</code>位清零。该指令通常用于从存储器中读取<code>8</code>位的字节数据到通用寄存器，然后对数据进行处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDRB R0, [R1]     ; 将存储器地址为R1的字节数据读入寄存器R0，并将R0的高<span class="number">24</span>位清零</span><br><span class="line">LDRB R0, [R1, #<span class="number">8</span>] ; 将存储器地址为“R1 + <span class="number">8</span>”的字节数据读入寄存器R0，并将R0的高<span class="number">24</span>位清零</span><br></pre></td></tr></table></figure>
<h4 id="LDRH指令"><a href="#LDRH指令" class="headerlink" title="LDRH指令"></a>LDRH指令</h4><p>&emsp;&emsp;<code>LDRH</code>指令的格式为<code>LDR{条件}H 目的寄存器, &lt;存储器地址&gt;</code>，<code>LDRH</code>指令用于从存储器中将一个<code>16</code>位的半字数据传送到目的寄存器中，同时将寄存器的高<code>16</code>位清零。该指令通常用于从存储器中读取<code>16</code>位的半字数据到通用寄存器，然后对数据进行处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDRH R0, [R1]     ; 将存储器地址为R1的半字数据读入寄存器R0，并将R0的高<span class="number">16</span>位清零</span><br><span class="line">LDRH R0, [R1, R2] ; 将存储器地址为“R1 + R2”的半字数据读入寄存器R0，并将R0的高<span class="number">16</span>位清零</span><br></pre></td></tr></table></figure>
<h4 id="STR指令"><a href="#STR指令" class="headerlink" title="STR指令"></a>STR指令</h4><p>&emsp;&emsp;<code>STR</code>指令的格式为<code>STR{条件} 源寄存器, &lt;存储器地址&gt;</code>，<code>STR</code>指令用于从源寄存器中将一个<code>32</code>位的字数据传送到存储器中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STR R0, [R1], #<span class="number">8</span> ; 将R0中的字数据写入以R1为地址的存储器中，并将新地址“R1 + <span class="number">8</span>”写入R1</span><br><span class="line">STR R0, [R1, #<span class="number">8</span>] ; 将R0中的字数据写入以“R1 + <span class="number">8</span>”为地址的存储器中</span><br></pre></td></tr></table></figure>
<h4 id="批量加载-存储指令"><a href="#批量加载-存储指令" class="headerlink" title="批量加载/存储指令"></a>批量加载/存储指令</h4><p>&emsp;&emsp;<code>ARM</code>微处理器所支持的批量数据<code>加载/存储</code>指令可以一次在一片连续的存储器单元和多个寄存器之间传送数据，批量加载指令用于将一片连续的存储器中的数据传送到多个寄存器，批量数据存储指令则完成相反的操作。常用的加载存储指令如下：</p>
<ul>
<li><code>LDM</code>：批量数据加载指令。</li>
<li><code>STM</code>：批量数据存储指令。</li>
</ul>
<h4 id="LDM指令"><a href="#LDM指令" class="headerlink" title="LDM指令"></a>LDM指令</h4><p>&emsp;&emsp;<code>LDM</code>指令的格式为<code>LDM {条件}{类型} 基址寄存器{!}, 寄存器列表{^}</code>，<code>LDM</code>(或<code>STM</code>)指令用于从由基址寄存器所指示的一片连续存储器到寄存器列表所指示的多个寄存器之间传送数据，该指令的常见用途是将多个寄存器的内容入栈或出栈。其中，<code>{类型}</code>为以下几种情况：</p>
<ul>
<li><code>IA</code>：每次传送后地址加<code>1</code>。</li>
<li><code>IB</code>：每次传送前地址加<code>1</code>。</li>
<li><code>DA</code>：每次传送后地址减<code>1</code>。</li>
<li><code>DB</code>：每次传送前地址减<code>1</code>。</li>
<li><code>FD</code>：满递减堆栈。</li>
<li><code>ED</code>：空递减堆栈。</li>
<li><code>FA</code>：满递增堆栈。</li>
<li><code>EA</code>：空递增堆栈。</li>
</ul>
<p>&emsp;&emsp;<code>{!}</code>为可选后缀，若选用该后缀，则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。基址寄存器不允许为<code>R15</code>，寄存器列表可以为<code>R0</code>至<code>R15</code>的任意组合。<code>{^}</code>为可选后缀，当指令为<code>LDM</code>且寄存器列表中包含<code>R15</code>，选用该后缀时表示：除了正常的数据传送之外，还将<code>SPSR</code>复制到<code>CPSR</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STMFD R13!, &#123;R0, R4-R12, LR&#125; ; 将寄存器列表中的寄存器(R0、R4到R12、LR)存入堆栈</span><br><span class="line">LDMFD R13!, &#123;R0, R4-R12, PC&#125; ; 将堆栈内容恢复到寄存器(R0、R4到R12、LR)</span><br></pre></td></tr></table></figure>
<h4 id="数据交换指令"><a href="#数据交换指令" class="headerlink" title="数据交换指令"></a>数据交换指令</h4><p>&emsp;&emsp;<code>ARM</code>微处理器所支持数据交换指令能在存储器和寄存器之间交换数据。数据交换指令有如下两条：</p>
<ul>
<li><code>SWP</code>：字数据交换指令。</li>
<li><code>SWPB</code>：字节数据交换指令。</li>
</ul>
<h4 id="SWP指令"><a href="#SWP指令" class="headerlink" title="SWP指令"></a>SWP指令</h4><p>&emsp;&emsp;<code>SWP</code>指令的格式为<code>SWP{条件} 目的寄存器，源寄存器1，[源寄存器2]</code>，<code>SWP</code>指令用于将<code>源寄存器2</code>所指向的存储器中的字数据传送到目的寄存器中，同时将<code>源寄存器1</code>中的字数据传送到<code>源寄存器2</code>所指向的存储器中。显然，当<code>源寄存器1</code>和<code>目的寄存器</code>为同一个寄存器时，指令交换该寄存器和存储器的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SWP R0, R1, [R2] ; 将R2所指向的存储器中的字数据传送到R0，同时将R1中的字数据传送到R2所指向的存储单元</span><br><span class="line">SWP R0, R0, [R1] ; 该指令完成将R1所指向的存储器中的字数据与R0中的字数据交换</span><br></pre></td></tr></table></figure>
<h4 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h4><p>&emsp;&emsp;<code>ARM</code>微处理器支持数据的移位操作，移位操作在<code>ARM</code>指令集中不作为单独的指令使用，它只能作为指令格式中是一个字段，在汇编语言中表示为指令中的选项。移位操作包括如下<code>6</code>种类型，<code>ASL</code>和<code>LSL</code>是等价的，可以自由互换：</p>
<ul>
<li><code>LSL</code>：逻辑左移。</li>
<li><code>ASL</code>：算术左移。</li>
<li><code>LSR</code>：逻辑右移。</li>
<li><code>ASR</code>：算术右移。</li>
<li><code>ROR</code>：循环右移。</li>
</ul>
<h4 id="LSL操作"><a href="#LSL操作" class="headerlink" title="LSL操作"></a>LSL操作</h4><p>&emsp;&emsp;<code>LSL</code>操作的格式为<code>通用寄存器, LSL操作数</code>，<code>LSL</code>可完成对通用寄存器中的内容进行逻辑左移操作，按操作数所指定的数量向左移位，低位用<code>0</code>来填充。其中，操作数可以是通用寄存器，也可以是立即数(<code>0</code>至<code>31</code>)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV R0, R1, LSL#<span class="number">2</span> ; 将R1中的内容左移两位后传送到R0中</span><br></pre></td></tr></table></figure>
<h4 id="ROR操作"><a href="#ROR操作" class="headerlink" title="ROR操作"></a>ROR操作</h4><p>&emsp;&emsp;<code>ROR</code>操作的格式为<code>通用寄存器, ROR操作数</code>，<code>ROR</code>可完成对通用寄存器中的内容进行循环右移的操作，按操作数所指定的数量向右循环移位，左端用右端移出的位来填充。其中，操作数可以是通用寄存器，也可以是立即数(<code>0</code>至<code>31</code>)。显然，当进行<code>32</code>位的循环右移操作时，通用寄存器中的值不改变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV R0, R1, ROR#<span class="number">2</span> ; 将R1中的内容循环右移两位后传送到R0中</span><br></pre></td></tr></table></figure>
<h4 id="异常产生指令"><a href="#异常产生指令" class="headerlink" title="异常产生指令"></a>异常产生指令</h4><p>&emsp;&emsp;<code>ARM</code>微处理器所支持的异常指令有如下两条：</p>
<ul>
<li><code>SWI</code>：软件中断指令。</li>
<li><code>BKPT</code>：断点中断指令。</li>
</ul>
<h4 id="SWI指令"><a href="#SWI指令" class="headerlink" title="SWI指令"></a>SWI指令</h4><p>&emsp;&emsp;<code>SWI</code>指令的格式为<code>SWI{条件} 24位的立即数</code>，<code>SWI</code>指令用于产生软件中断，以便用户程序能调用操作系统的系统<code>API</code>。操作系统在<code>SWI</code>的异常处理程序中提供相应的系统服务，指令中<code>24</code>位的立即数指定用户程序调用的<code>API</code>类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWI <span class="number">0x02</span> ; 该指令调用操作系统编号位<span class="number">02</span>的系统例程</span><br></pre></td></tr></table></figure>
<h3 id="ARM伪指令"><a href="#ARM伪指令" class="headerlink" title="ARM伪指令"></a>ARM伪指令</h3><h4 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h4><p>&emsp;&emsp;在<code>ARM</code>汇编语言程序里，有一些特殊指令助记符，这些助记符与指令系统的助记符不同，没有相对应的操作码，通常称这些特殊指令助记符为伪指令，他们所完成的操作称为伪操作。伪指令在源程序中的作用是为完成汇编程序作各种准备工作的，这些伪指令仅在汇编过程中起作用，一旦汇编结束，伪指令的使命就完成(类似于<code>C</code>语言中的宏定义、关键字等)。在<code>ARM</code>的汇编程序中，有如下几种伪指令：符号定义伪指令、数据定义伪指令、汇编控制伪指令、宏指令以及其他伪指令。</p>
<h4 id="符号定义伪指令"><a href="#符号定义伪指令" class="headerlink" title="符号定义伪指令"></a>符号定义伪指令</h4><p>&emsp;&emsp;符号定义伪指令用于定义<code>ARM</code>汇编程序中的变量、对变量赋值以及定义寄存器的别名等操作。常见的符号定义伪指令有如下几种：</p>
<ul>
<li>定义全局变量的<code>GBLA</code>、<code>GBLL</code>和<code>GBLS</code>。</li>
<li>定义局部变量的<code>LCLA</code>、<code>LCLL</code>和<code>LCLS</code>。</li>
<li>对变量赋值的<code>SETA</code>、<code>SETL</code>和<code>SETS</code>。</li>
<li>为通用寄存器列表定义名称的<code>RLIST</code>。</li>
</ul>
<h4 id="GBLA-GBLL-GBLS"><a href="#GBLA-GBLL-GBLS" class="headerlink" title="GBLA/GBLL/GBLS"></a>GBLA/GBLL/GBLS</h4><p>&emsp;&emsp;语法格式为<code>GBLA(GBLL或GBLS) 全局变量名</code>，<code>GBLA</code>、<code>GBLL</code>和<code>GBLS</code>伪指令用于定义一个<code>ARM</code>程序中的全局变量，并将其初始化。</p>
<ul>
<li><code>GBLA</code>：定义一个全局的数字变量，并初始化为<code>0</code>。</li>
<li><code>GBLL</code>：定义一个全局的逻辑变量，并初始化为<code>F</code>(假)。</li>
<li><code>GBLS</code>：定义一个全局的字符串变量，并初始化为空。</li>
</ul>
<p>以上三条伪指令用于定义全局变量，因此在整个程序范围内变量名必须唯一。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GBLA Test1           ; 定义一个全局的数字变量，变量名为Test1</span><br><span class="line">Test1 SETA <span class="number">0xaa</span>      ; 将该变量赋值为<span class="number">0xaa</span></span><br><span class="line">GBLL Test2           ; 定义一个全局的逻辑变量，变量名为Test2</span><br><span class="line">Test2 SETL &#123;TRUE&#125;    ; 将该变量赋值为真</span><br><span class="line">GBLS Test3           ; 定义一个全局的字符串变量，变量名为Test3</span><br><span class="line">Test3 SETS <span class="string">"Testing"</span> ; 将该变量赋值为Testing</span><br></pre></td></tr></table></figure>
<h4 id="RLIST指令"><a href="#RLIST指令" class="headerlink" title="RLIST指令"></a>RLIST指令</h4><p>&emsp;&emsp;语法格式为<code>名称 RLIST {寄存器列表}</code>，<code>RLIST</code>伪指令用于对一个通用寄存器列表定义名称，使用该伪指令定义的列表名称可在<code>ARM</code>指令<code>LDM/STM</code>中使用。在<code>LDM/STM</code>指令中，列表中的寄存器访问次序为根据寄存器的编号由低到高，而与列表中的寄存器排列次序无关。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RegList RLIST &#123;R0-R5, R8, R10&#125; ; 将寄存器列表名称定义为RegList，可在ARM指令LDM/STM中通过该名称访问寄存器列表</span><br></pre></td></tr></table></figure>
<h4 id="数据定义伪指令"><a href="#数据定义伪指令" class="headerlink" title="数据定义伪指令"></a>数据定义伪指令</h4><p>&emsp;&emsp;数据定义伪指令一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化。常见的数据定义伪指令有如下几种：<code>DCB</code>、<code>DCW</code>、<code>DCD</code>、<code>DCFD</code>、<code>DCFS</code>、<code>DCQ</code>、<code>SPACE</code>、<code>MAP</code>、<code>FIELD</code>。</p>
<h4 id="DCB指令"><a href="#DCB指令" class="headerlink" title="DCB指令"></a>DCB指令</h4><p>&emsp;&emsp;语法格式<code>标号 DCB 表达式</code>，<code>DCB</code>伪指令用于分配一片连续的字节存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为<code>0</code>至<code>255</code>的数字或字符串。<code>DCB</code>也可用<code>=</code>代替。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Str DCB “This is a test！” ；分配一片连续的字节存储单元并初始化。</span><br></pre></td></tr></table></figure>
<h4 id="SPACE指令"><a href="#SPACE指令" class="headerlink" title="SPACE指令"></a>SPACE指令</h4><p>&emsp;&emsp;语法格式<code>标号 SPACE 表达式</code>，<code>SPACE</code>伪指令用于分配一片连续的存储区域并初始化为<code>0</code>。其中，表达式为要分配的字节数。<code>SPACE</code>也可用<code>%</code>代替。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataSpace SPACE <span class="number">100</span> ; 分配连续<span class="number">100</span>字节的存储单元并初始化为<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="MAP指令"><a href="#MAP指令" class="headerlink" title="MAP指令"></a>MAP指令</h4><p>&emsp;&emsp;语法格式<code>MAP 表达式{, 基址寄存器}</code>，<code>MAP</code>伪指令用于定义一个结构化的内存表的首地址。<code>MAP</code>也可用<code>^</code>代替。表达式可以为程序中的标号或数学表达式，基址寄存器为可选项，当基址寄存器选项不存在时，表达式的值即为内存表的首地址，当该选项存在时，内存表的首地址为表达式的值与基址寄存器的和。<code>MAP</code>伪指令通常与<code>FIELD</code>伪指令配合使用来定义结构化的内存表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAP <span class="number">0x100</span>, R0 ; 定义结构化内存表首地址的值为“<span class="number">0x100</span> + R0”</span><br></pre></td></tr></table></figure>
<h4 id="FILED指令"><a href="#FILED指令" class="headerlink" title="FILED指令"></a>FILED指令</h4><p>&emsp;&emsp;语法格式<code>标号 FIELD 表达式</code>，<code>FIELD</code>伪指令用于定义一个结构化内存表中的数据域。<code>FILED</code>也可用<code>#</code>代替。表达式的值为当前数据域在内存表中所占的字节数。<code>FIELD</code>伪指令常与<code>MAP</code>伪指令配合使用来定义结构化的内存表。<code>MAP</code>伪指令定义内存表的首地址，<code>FIELD</code>伪指令定义内存表中的各个数据域，并可以为每个数据域指定一个标号供其他的指令引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAP <span class="number">0x100</span>   ; 定义结构化内存表首地址的值为<span class="number">0x100</span></span><br><span class="line">A FIELD <span class="number">16</span>  ; 定义A的长度为<span class="number">16</span>字节，位置为<span class="number">0x100</span></span><br><span class="line">B FIELD <span class="number">32</span>  ; 定义B的长度为<span class="number">32</span>字节，位置为<span class="number">0x110</span></span><br><span class="line">S FIELD <span class="number">256</span> ; 定义S的长度为<span class="number">256</span>字节，位置为<span class="number">0x130</span></span><br></pre></td></tr></table></figure>
<h4 id="汇编控制伪指令"><a href="#汇编控制伪指令" class="headerlink" title="汇编控制伪指令"></a>汇编控制伪指令</h4><h4 id="IF指令"><a href="#IF指令" class="headerlink" title="IF指令"></a>IF指令</h4><p>&emsp;&emsp;语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IF 逻辑表达式</span><br><span class="line">    指令序列<span class="number">1</span></span><br><span class="line">ELSE</span><br><span class="line">    指令序列<span class="number">2</span></span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure>
<p><code>IF</code>、<code>ELSE</code>、<code>ENDIF</code>伪指令能根据条件的成立与否决定是否执行某个指令序列。当<code>IF</code>后面的逻辑表达式为真，则执行<code>指令序列1</code>，否则执行<code>指令序列2</code>。其中，<code>ELSE</code>及<code>指令序列2</code>可以没有。<code>IF</code>、<code>ELSE</code>、<code>ENDIF</code>伪指令可以嵌套使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GBLL Test ；声明一个全局的逻辑变量，变量名为Test</span><br><span class="line">...</span><br><span class="line">IF Test = TRUE</span><br><span class="line">    指令序列<span class="number">1</span></span><br><span class="line">ELSE</span><br><span class="line">    指令序列<span class="number">2</span></span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure>
<h4 id="WHILE指令"><a href="#WHILE指令" class="headerlink" title="WHILE指令"></a>WHILE指令</h4><p>&emsp;&emsp;语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE 逻辑表达式</span><br><span class="line">    指令序列</span><br><span class="line">WEND</span><br></pre></td></tr></table></figure>
<p><code>WHILE</code>、<code>WEND</code>伪指令能根据条件的成立与否决定是否循环执行某个指令序列。当<code>WHILE</code>后面的逻辑表达式为真，则执行指令序列，该指令序列执行完毕后，再判断逻辑表达式的值，若为真则继续执行，一直到逻辑表达式的值为假。<code>WHILE</code>、<code>WEND</code>伪指令可以嵌套使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GBLA Counter   ; 声明一个全局的数学变量，变量名为Counter</span><br><span class="line">Counter SETA <span class="number">3</span> ; 由变量Counter控制循环次数</span><br><span class="line">...</span><br><span class="line">WHILE Counter &lt; <span class="number">10</span></span><br><span class="line">    指令序列</span><br><span class="line">WEND</span><br></pre></td></tr></table></figure>
<h4 id="其他伪指令"><a href="#其他伪指令" class="headerlink" title="其他伪指令"></a>其他伪指令</h4><h4 id="AREA指令"><a href="#AREA指令" class="headerlink" title="AREA指令"></a>AREA指令</h4><p>&emsp;&emsp;语法格式为<code>AREA 段名 属性1, 属性2, ...</code>。<code>AREA</code>伪指令用于定义一个代码段或数据段。其中，段名若以数字开头，则该段名需用<code>|</code>括起来，如<code>|1_test|</code>。属性字段表示该代码段(或数据段)的相关属性，多个属性用逗号分隔。常用的属性如下：</p>
<ul>
<li><code>CODE</code>属性：用于定义代码段，默认为<code>READONLY</code>。</li>
<li><code>DATA</code>属性：用于定义数据段，默认为<code>READWRITE</code>。</li>
<li><code>READONLY</code>属性：指定本段为只读，代码段默认为<code>READONLY</code>。</li>
<li><code>READWRITE</code>属性：指定本段为可读可写，数据段的默认属性为<code>READWRITE</code>。</li>
</ul>
<p>&emsp;&emsp;<code>ALIGN</code>属性使用方式为<code>ALIGN 表达式</code>。在默认时，<code>ELF</code>(可执行连接文件)的代码段和数据段是按字对齐的。一个汇编语言程序至少要包含一个段，当程序太长时，也可以将程序分为多个代码段和数据段。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AREA Init, CODE, READONLY ; 该伪指令定义了一个代码段，段名为Init，属性为只读</span><br></pre></td></tr></table></figure>
<h4 id="ALIGN指令"><a href="#ALIGN指令" class="headerlink" title="ALIGN指令"></a>ALIGN指令</h4><p>&emsp;&emsp;语法格式为<code>ALIGN {表达式{, 偏移量}}</code>，<code>ALIGN</code>伪指令可通过添加填充字节的方式，使当前位置满足一定的对其方式。其中，表达式的值用于指定对齐方式，可能的取值为<code>2</code>的幂，如<code>1</code>、<code>2</code>、<code>4</code>、<code>8</code>、<code>16</code>等。若未指定表达式，则将当前位置对齐到下一个字的位置。偏移量也为一个数字表达式，若使用该字段，则当前位置的对齐方式为<code>2的表达式次幂 + 偏移量</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AREA Init, CODE, READONLY, ALIEN=<span class="number">3</span> ; 指定后面的指令为<span class="number">8</span>字节对齐。</span><br></pre></td></tr></table></figure>
<h4 id="CODE16指令"><a href="#CODE16指令" class="headerlink" title="CODE16指令"></a>CODE16指令</h4><p>&emsp;&emsp;语法格式为<code>CODE16</code>(或<code>CODE32</code>)，<code>CODE16</code>伪指令通知编译器，其后的指令序列为<code>16</code>位的<code>Thumb</code>指令。<code>CODE32</code>伪指令通知编译器，其后的指令序列为<code>32</code>位的<code>ARM</code>指令。因此，在使用<code>ARM</code>指令和<code>Thumb</code>指令混合编程的代码里，可用这两条伪指令进行切换，但注意它们只通知编译器其后指令的类型，并不能对处理器进行状态的切换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AREA Init, CODE, READONLY</span><br><span class="line">...</span><br><span class="line">CODE32          ; 通知编译器其后的指令为<span class="number">32</span>位的ARM指令</span><br><span class="line">LDR R0, =NEXT+<span class="number">1</span> ; 将跳转地址放入寄存器R0</span><br><span class="line">BX R0           ; 程序跳转到新的位置执行，并将处理器切换到Thumb工作状态</span><br><span class="line">....</span><br><span class="line">CODE16          ; 通知编译器其后的指令为<span class="number">16</span>位的Thumb指令</span><br><span class="line">NEXT LDR R3, =<span class="number">0x3FF</span></span><br><span class="line">....</span><br><span class="line">END             ; 程序结束</span><br></pre></td></tr></table></figure>
<h4 id="ENTRY指令"><a href="#ENTRY指令" class="headerlink" title="ENTRY指令"></a>ENTRY指令</h4><p>&emsp;&emsp;语法格式为<code>ENTRY</code>，<code>ENTRY</code>伪指令用于指定汇编程序的入口点。在一个完整的汇编程序中至少要有一个<code>ENTRY</code>(也可以有多个，当有多个<code>ENTRY</code>时，程序的真正入口点由链接器指定)，但在一个源文件里最多只能有一个<code>ENTRY</code>(可以没有)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AREA Init, CODE, READONLY</span><br><span class="line">ENTRY ; 指定应用程序的入口点</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="EQU指令"><a href="#EQU指令" class="headerlink" title="EQU指令"></a>EQU指令</h4><p>&emsp;&emsp;语法格式为<code>名称 EQU 表达式{, 类型}</code>，<code>EQU</code>伪指令用于为程序中的常量、标号等定义一个等效的字符名称，类似于<code>C</code>语言中的<code>#define</code>。其中<code>EQU</code>可用<code>*</code>代替。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test EQU <span class="number">50</span>           ; 定义标号Test的值为<span class="number">50</span></span><br><span class="line">Addr EQU <span class="number">0x55</span>, CODE32 ; 定义Addr的值为<span class="number">0x55</span>，且该处为<span class="number">32</span>位的ARM指令</span><br></pre></td></tr></table></figure>
<h4 id="EXPORT指令"><a href="#EXPORT指令" class="headerlink" title="EXPORT指令"></a>EXPORT指令</h4><p>&emsp;&emsp;语法格式为<code>EXPORT 标号</code>，<code>EXPORT</code>伪指令用于在程序中声明一个全局的标号，该标号可在其他的文件中引用。<code>EXPORT</code>可用<code>GLOBAL</code>代替。标号在程序中区分大小写。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AREA Init, CODE, READONLY</span><br><span class="line">EXPORT Stest ; 声明一个可全局引用的标号Stest</span><br></pre></td></tr></table></figure>
<h4 id="IMPORT指令"><a href="#IMPORT指令" class="headerlink" title="IMPORT指令"></a>IMPORT指令</h4><p>&emsp;&emsp;语法格式为<code>IMPORT 标号</code>，<code>IMPORT</code>伪指令用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用。标号在程序中区分大小写。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AREA Init, CODE, READONLY</span><br><span class="line">IMPORT Main ; 通知编译器当前文件要引用标号Main，但Main在其他源文件中定义</span><br></pre></td></tr></table></figure>
<h4 id="END指令"><a href="#END指令" class="headerlink" title="END指令"></a>END指令</h4><p>&emsp;&emsp;语法格式为<code>END</code>，<code>END</code>伪指令用于通知编译器已经到了源程序的结尾。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AREA Init, CODE, READONLY</span><br><span class="line">...</span><br><span class="line">END ; 指定应用程序的结尾</span><br></pre></td></tr></table></figure>
<h3 id="C-C-混合编程"><a href="#C-C-混合编程" class="headerlink" title="C/C++混合编程"></a>C/C++混合编程</h3><p>&emsp;&emsp;在应用系统的程序设计中，若所有的编程任务均用汇编语言来完成，其工作量是可想而知的，同时不利于系统升级或应用软件移植。事实上，<code>ARM</code>体系结构支持<code>C/C++</code>以及与汇编语言的混合编程，在一个完整的程序设计的中，除了初始化部分用汇编语言完成以外，其主要的编程任务一般都用<code>C/C++</code>完成。汇编语言与<code>C/C++</code>的混合编程通常有以下几种方式：</p>
<ul>
<li>在<code>C/C++</code>代码中嵌入汇编指令。</li>
<li>在汇编程序和<code>C/C++</code>的程序之间进行变量的互访。</li>
<li>汇编程序、<code>C/C++</code>程序间的相互调用。</li>
</ul>
<p>&emsp;&emsp;在实际的编程中，使用较多的方式是：程序的初始化部分用汇编语言完成，然后用<code>C/C++</code>完成主要的编程任务，程序在执行时首先完成初始化过程，然后跳转到<code>C/C++</code>程序代码中，汇编程序和<code>C/C++</code>程序之间一般没有参数的传递，也没有频繁的相互调用，因此整个程序的结构显得相对简单，容易理解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">IMPORT Main             ; 通知编译器该标号为一个外部标号</span><br><span class="line">AREA Init,CODE,READONLY ; 定义一个代码段</span><br><span class="line">ENTRY                   ; 定义程序的入口点</span><br><span class="line">LDR R0,=<span class="number">0x3FF0000</span>       ; 初始化系统配置寄存器</span><br><span class="line">LDR R1,=<span class="number">0xE7FFFF80</span></span><br><span class="line">STR R1,[R0]</span><br><span class="line">LDR SP, =<span class="number">0x3FE1000</span>      ; 初始化用户堆栈</span><br><span class="line">BL Main                 ; 跳转到Main函数处的“C/C++”代码执行</span><br><span class="line">END                     ; 标识汇编程序的结束</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    * ( ( <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> * ) <span class="number">0x3ff5000</span> ) = <span class="number">0x0000000f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        * ( ( <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> * ) <span class="number">0x3ff5008</span> ) = <span class="number">0x00000001</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x7fFFF</span>; i++ );</span><br><span class="line">        * ( ( <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> * ) <span class="number">0x3ff5008</span> ) = <span class="number">0x00000002</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x7FFFF</span>; i++ );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/19/Linux系统编程/Linux系统编程基础/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/19/Linux系统编程/Linux系统编程基础/" itemprop="url">Linux系统编程基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T13:43:45+08:00">
                2019-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="系统调用之文件访问"><a href="#系统调用之文件访问" class="headerlink" title="系统调用之文件访问"></a>系统调用之文件访问</h3><h4 id="文件编程"><a href="#文件编程" class="headerlink" title="文件编程"></a>文件编程</h4><p>&emsp;&emsp;<code>Linux</code>文件编程可以使用两种方法：<code>Linux</code>系统调用和<code>C</code>语言库函数，前者依赖于<code>Linux</code>系统，后者与操作系统是独立的，在任何操作系统下，使用<code>C</code>语言库函数操作文件的方法都是相同的。</p>
<h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">mode_t</span> mode )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>filename</code>是要创建的文件名(包含路径，缺省为当前路径)，<code>mode</code>为创建模式。常见创建模式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_IRUSR</code></td>
<td>可读</td>
</tr>
<tr>
<td><code>S_IWUSR</code></td>
<td>可写</td>
</tr>
<tr>
<td><code>S_IXUSR</code></td>
<td>可执行</td>
</tr>
<tr>
<td><code>S_IRWXU</code></td>
<td>可读、写、执行</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;除了可以使用上述宏以外，还可以直接使用数字来表示文件的访问权限：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数字</th>
<th>权限</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1</code></td>
<td>可执行</td>
</tr>
<tr>
<td><code>2</code></td>
<td>可写</td>
</tr>
<tr>
<td><code>4</code></td>
<td>可读</td>
</tr>
<tr>
<td><code>6</code></td>
<td>可写可读(即<code>4 + 2</code>)</td>
</tr>
<tr>
<td><code>0</code></td>
<td>无任何权限</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;使用<code>creat</code>函数创建文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_file</span> <span class="params">( <span class="keyword">char</span> *filename )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( creat ( filename, <span class="number">0755</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"create file %s failure!\n"</span>, filename );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"create file %s success!\n"</span>, filename );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> ( argc &lt; <span class="number">2</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"you haven't input the filename, please try again!\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; argc; i++ ) &#123;</span><br><span class="line">        create_file ( argv[i] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span> ( EXIT_SUCCESS );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文件描述"><a href="#文件描述" class="headerlink" title="文件描述"></a>文件描述</h4><p>&emsp;&emsp;在<code>Linux</code>系统中，所有打开的文件都对应一个文件描述符。文件描述符的本质是一个非负整数。当打开一个文件时，该整数由系统来分配。文件描述符的范围是<code>0</code>至<code>OPEN_MAX</code>。早期<code>UNIX</code>的<code>OPEN_MAX</code>为<code>19</code>，即允许每个进程同时打开<code>20</code>个文件，现在很多系统则将其增加至<code>1024</code>。</p>
<h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>pathname</code>是要打开的文件名(包含路径，缺省为当前路径)，<code>flags</code>是打开标志。常见的打开标志：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_RDONLY</code></td>
<td>只读方式打开</td>
</tr>
<tr>
<td><code>O_WRONLY</code></td>
<td>只写方式打开</td>
</tr>
<tr>
<td><code>O_RDWR</code></td>
<td>读写方式打开</td>
</tr>
<tr>
<td><code>O_APPEND</code></td>
<td>追加方式打开</td>
</tr>
<tr>
<td><code>O_CREAT</code></td>
<td>创建一个文件</td>
</tr>
<tr>
<td><code>O_NOBLOCK</code></td>
<td>非阻塞方式打开</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;如果使用了<code>O_CREATE</code>标志，则使用的函数是<code>int open(const char *pathname, int flags, mode_t mode);</code>，这时需要指定<code>mode</code>来表示文件的访问权限。</p>
<h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p>&emsp;&emsp;当我们操作完文件以后，需要关闭文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span> <span class="params">( <span class="keyword">int</span> fd )</span></span>; <span class="comment">/* fd是文件描述符 */</span></span><br></pre></td></tr></table></figure>
<p>对文件进行打开或关闭操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc , <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ( argc &lt; <span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="built_in">puts</span> ( <span class="string">"please input the open file pathname!\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果flag参数里有O_CREAT，表示该文件如果不存在，系统则会创建该文件，</span></span><br><span class="line"><span class="comment">       该文件的权限由第三个参数决定，此处为0755。如果flah参数里没有O_CREAT参数，</span></span><br><span class="line"><span class="comment">       则第三个参数不起作用。此时，如果要打开的文件不存在，则会报错。</span></span><br><span class="line"><span class="comment">       所以“fd = open(argv[1], O_RDWR)”仅仅只是打开指定文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( fd = open ( argv[<span class="number">1</span>], O_CREAT | O_RDWR, <span class="number">0755</span> ) ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"open file failure!\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"open file %d  success!\n"</span>, fd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close ( fd );</span><br><span class="line">    <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span> <span class="params">( <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> length )</span></span>;</span><br></pre></td></tr></table></figure>
<p>从文件描述符<code>fd</code>所指定的文件中读取<code>length</code>个字节到<code>buf</code>所指向的缓冲区中，返回值为实际读取的字节数。</p>
<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span> <span class="params">( <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> length )</span></span>;</span><br></pre></td></tr></table></figure>
<p>把<code>length</code>个字节从<code>buf</code>指向的缓冲区中写到文件描述符<code>fd</code>所指向的文件中，返回值为实际写入的字节数。</p>
<h4 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lseek</span> <span class="params">( <span class="keyword">int</span> fd, <span class="keyword">offset_t</span> offset, <span class="keyword">int</span> whence )</span></span>;</span><br></pre></td></tr></table></figure>
<p>将文件读写指针相对<code>whence</code>移动<code>offset</code>个字节。操作成功时，返回文件指针相对于文件头的位置。<code>whence</code>可使用下述值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>whence</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SEEK_SET</code></td>
<td>相对文件开头</td>
</tr>
<tr>
<td><code>SEEK_CUR</code></td>
<td>相对文件读写指针的当前位置</td>
</tr>
<tr>
<td><code>SEEK_END</code></td>
<td>相对文件末尾</td>
</tr>
</tbody>
</table>
</div>
<p><code>offset</code>可取负值，表示向前移动。例如下述调用可将文件指针相对当前位置向前移动<code>5</code>个字节：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek ( fd, <span class="number">-5</span>, SEEK_CUR );</span><br></pre></td></tr></table></figure>
<p>由于<code>lseek</code>函数的返回值为文件指针相对于文件头的位置，因此下面调用的返回值就是文件的长度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek ( fd, <span class="number">0</span>, SEEK_END );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对文件进行读写操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fcntl.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO_DUP 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> NO_DUP</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="string">"123456789"</span>;</span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">10</span>];</span><br><span class="line">    fd = open ( <span class="string">"./test.txt"</span>, O_RDWR | O_CREAT, <span class="number">0755</span> ); <span class="comment">/* 打开文件 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"open file fail\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write ( fd, buf, <span class="number">7</span> ); <span class="comment">/* 写入文件 */</span></span><br><span class="line">    lseek ( fd, <span class="number">0</span>, SEEK_SET ); <span class="comment">/* 重定位文件指针 */</span></span><br><span class="line">    read ( fd, buf1, <span class="number">5</span> ); <span class="comment">/* 读文件 */</span></span><br><span class="line">    buf1[<span class="number">5</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"buf1 is %s\n"</span>, buf1 );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> fd1;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="string">"123456789"</span>;</span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">10</span>];</span><br><span class="line">    fd = open ( <span class="string">"./test.txt"</span>, O_RDWR | O_CREAT, <span class="number">0755</span> ); <span class="comment">/* 打开文件 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"open file fail\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd1 = dup ( fd );</span><br><span class="line">    write ( fd1, buf, <span class="number">7</span> ); <span class="comment">/* 写入文件 */</span></span><br><span class="line">    lseek ( fd1, <span class="number">0</span>, SEEK_SET ); <span class="comment">/* 重定位文件指针 */</span></span><br><span class="line">    read ( fd1, buf1, <span class="number">5</span> ); <span class="comment">/* 读文件 */</span></span><br><span class="line">    buf1[<span class="number">5</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"buf1 is %s\n"</span>, buf1 );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="文件访问判断"><a href="#文件访问判断" class="headerlink" title="文件访问判断"></a>文件访问判断</h4><p>&emsp;&emsp;有时需要判断文件是否可以进行某种操作(读、写等)，这时可以使用<code>access</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>pathname</code>是文件名称；<code>mode</code>是要判断的访问权限，可以取以下值或者是它们的组合：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>mode</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>R_OK</code></td>
<td>文件可读</td>
</tr>
<tr>
<td><code>W_OK</code></td>
<td>文件可写</td>
</tr>
<tr>
<td><code>X_OK</code></td>
<td>文件可执行</td>
</tr>
<tr>
<td><code>F_OK</code></td>
<td>文件存在</td>
</tr>
</tbody>
</table>
</div>
<p>当我们测试成功时，函数返回<code>0</code>，否则如果一个条件不符时，返回<code>-1</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( access ( <span class="string">"/etc/passwd"</span>, R_OK ) == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"/etc/passwd can be read!\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;使用系统调用实现对文件的复制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> from_fd, to_fd;</span><br><span class="line">    <span class="keyword">int</span> bytes_read, bytes_write;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">3</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Usage:%s fromfile tofile/n/a"</span>, argv[<span class="number">0</span>] );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ( from_fd = open ( argv[<span class="number">1</span>], O_RDONLY ) ) == <span class="number">-1</span> ) &#123; <span class="comment">/* 打开源文件 */</span></span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Open %s Error:%s/n"</span>, argv[<span class="number">1</span>], strerror ( errno ) );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建目的文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( to_fd = open ( argv[<span class="number">2</span>], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR ) ) == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Open %s Error:%s/n"</span>, argv[<span class="number">2</span>], strerror ( errno ) );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以下代码是一个经典的拷贝文件的代码 */</span></span><br><span class="line">    <span class="keyword">while</span> ( bytes_read = read ( from_fd, buffer, BUFFER_SIZE ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( ( bytes_read == <span class="number">-1</span> ) &amp;&amp; ( errno != EINTR ) ) &#123; <span class="comment">/* 一个致命的错误发生了 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( bytes_read &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            ptr = buffer;</span><br><span class="line">            <span class="keyword">while</span> ( bytes_write = write ( to_fd, ptr, bytes_read ) ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( ( bytes_write == <span class="number">-1</span> ) &amp;&amp; ( errno != EINTR ) ) &#123; <span class="comment">/* 一个致命错误发生了 */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( bytes_write == bytes_read ) &#123; <span class="comment">/* 写完了所有读的字节 */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( bytes_write &gt; <span class="number">0</span> ) &#123; <span class="comment">/* 只写了一部分，继续写 */</span></span><br><span class="line">                    ptr += bytes_write;</span><br><span class="line">                    bytes_read -= bytes_write;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( bytes_write == <span class="number">-1</span> ) &#123; <span class="comment">/* 写的时候发生的致命错误 */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close ( from_fd );</span><br><span class="line">    close ( to_fd );</span><br><span class="line">    <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="库函数之文件访问"><a href="#库函数之文件访问" class="headerlink" title="库函数之文件访问"></a>库函数之文件访问</h3><h4 id="文件创建和打开"><a href="#文件创建和打开" class="headerlink" title="文件创建和打开"></a>文件创建和打开</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>filename</code>为打开的文件名(包含路径，缺省为当前路径)；<code>mode</code>是打开模式，常见打开模式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>r</code>、<code>rb</code></td>
<td>只读方式打开</td>
</tr>
<tr>
<td><code>w</code>、<code>wb</code></td>
<td>只写方式打开，如果文件不存在，则创建该文件</td>
</tr>
<tr>
<td><code>a</code>、<code>ab</code></td>
<td>追加方式打开，如果文件不存在，则创建该文件</td>
</tr>
<tr>
<td><code>r+</code>、<code>r+b</code>、<code>rb+</code></td>
<td>读写方式打开</td>
</tr>
<tr>
<td><code>w+</code>、<code>w+b</code>、<code>wb+</code></td>
<td>读写方式打开，如果文件不存在，则创建该文件</td>
</tr>
<tr>
<td><code>a+</code>、<code>a+b</code>、<code>ab+</code></td>
<td>读和追加方式打开，如果文件不存在，则创建该文件</td>
</tr>
</tbody>
</table>
</div>
<p><code>b</code>用于区分二进制文件和文本文件，这一点在<code>DOS</code>、<code>Windows</code>系统中是有区分的，但<code>Linux</code>不区分二进制文件和文本文件。</p>
<h4 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fread ( <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> n, FILE *stream );</span><br></pre></td></tr></table></figure>
<p>从<code>stream</code>指向的文件中读取<code>n</code>个字段，每个字段为<code>size</code>字节，并将读取的数据放入<code>ptr</code>所指的字符数组中，返回实际已读取的字节数。</p>
<h4 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fwrite ( <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> n, FILE *stream );</span><br></pre></td></tr></table></figure>
<p>从缓冲区<code>ptr</code>所指的数组中把<code>n</code>个字段写到<code>stream</code>指向的文件中，每个字段长为<code>size</code>个字节，返回实际写入的字段数。</p>
<h4 id="读字符"><a href="#读字符" class="headerlink" title="读字符"></a>读字符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span> <span class="params">( FILE *stream )</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能是从指定的文件中读一个字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ( fp = fopen ( <span class="string">"1.txt"</span>, <span class="string">"r+"</span> ) ) == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Cannot open file strike any key exit!\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ch = fgetc ( fp );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( ch != EOF ) &#123;</span><br><span class="line">        <span class="built_in">putchar</span> ( ch );</span><br><span class="line">        ch = fgetc ( fp );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose ( fp );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="写字符"><a href="#写字符" class="headerlink" title="写字符"></a>写字符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span> <span class="params">( <span class="keyword">int</span> c, FILE *stream )</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能是向指定的文件中写入一个字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ( fp = fopen ( <span class="string">"1.txt"</span>, <span class="string">"w+"</span> ) ) == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Cannot open file￡?strike any key exit!"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"input a string:\n"</span> );</span><br><span class="line">    ch = getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( ch != <span class="string">'\n'</span> ) &#123;</span><br><span class="line">        fputc ( ch, fp );</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"\n"</span> );</span><br><span class="line">    fclose ( fp );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从输入直接复制到输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        fputc ( fgetc ( <span class="built_in">stdin</span> ), <span class="built_in">stdout</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式化读"><a href="#格式化读" class="headerlink" title="格式化读"></a>格式化读</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fscanf</span> ( FILE *stream, <span class="keyword">char</span> *format[, argument...] );</span><br></pre></td></tr></table></figure>
<p>功能是从一个流中进行格式化输入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Input an integer: "</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">fscanf</span> ( <span class="built_in">stdin</span>, <span class="string">"%d"</span>, &amp;i ) ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"The integer read was: %i\n"</span>, i );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式化写"><a href="#格式化写" class="headerlink" title="格式化写"></a>格式化写</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span> <span class="params">( FILE *stream, <span class="keyword">char</span> *format[, argument, ...] )</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能是格式化输出到一个流中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *stream;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> fp = <span class="number">1.5</span>;</span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"this is a string"</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'\n'</span>;</span><br><span class="line">    stream = fopen ( <span class="string">"1.txt"</span>, <span class="string">"w"</span> );</span><br><span class="line">    <span class="built_in">fprintf</span> ( stream, <span class="string">"%s%c"</span>, s, c );</span><br><span class="line">    <span class="built_in">fprintf</span> ( stream, <span class="string">"%d\n"</span>, i );</span><br><span class="line">    <span class="built_in">fprintf</span> ( stream, <span class="string">"%f\n"</span>, fp );</span><br><span class="line">    fclose ( stream );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文件定位-1"><a href="#文件定位-1" class="headerlink" title="文件定位"></a>文件定位</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span> <span class="params">( FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence )</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>whence</code>有如下选项：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>whence</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SEEK_SET</code></td>
<td>从文件的开始处开始搜索</td>
</tr>
<tr>
<td><code>SEEK_CUR</code></td>
<td>从当前位置开始搜索</td>
</tr>
<tr>
<td><code>SEEK_END</code></td>
<td>从文件的结束处开始搜索</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSEEK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FSEEK</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> *c_buf = <span class="string">"987654321"</span>;</span><br><span class="line">    fp = fopen ( <span class="string">"./test.bin"</span>, <span class="string">"r+"</span> );</span><br><span class="line">    <span class="comment">/* 如果使用“W+”，则test.bin会被抹掉 */</span></span><br><span class="line">    fseek ( fp, <span class="number">0</span>, SEEK_SET );</span><br><span class="line">    fwrite ( c_buf, <span class="number">5</span>, <span class="number">1</span>, fp );</span><br><span class="line">    fclose ( fp );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> c_buf[<span class="number">15</span>];</span><br><span class="line">    fp = fopen ( <span class="string">"./test.bin"</span>, <span class="string">"r+"</span> );</span><br><span class="line">    <span class="comment">/* 如果使用“W+”，则test.bin会被抹掉 */</span></span><br><span class="line">    fread ( c_buf, <span class="number">1</span>, <span class="number">10</span>, fp );</span><br><span class="line">    c_buf[<span class="number">10</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"now we read %s\n"</span>, c_buf );</span><br><span class="line">    fclose ( fp );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>使用库函数实现对文件的复制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    FILE *from_fd;</span><br><span class="line">    FILE *to_fd;</span><br><span class="line">    <span class="keyword">long</span> file_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">3</span> ) &#123; <span class="comment">/* 判断输入参数 */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Usage:%s fromfile tofile\n"</span>, argv[<span class="number">0</span>] );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打开源文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( from_fd = fopen ( argv[<span class="number">1</span>], <span class="string">"rb"</span> ) ) == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Open %s Error\n"</span>, argv[<span class="number">1</span>] );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 创建目的文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( to_fd = fopen ( argv[<span class="number">2</span>], <span class="string">"wb"</span> ) ) == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Open %s Error\n"</span>, argv[<span class="number">2</span>] );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 测得文件大小 */</span></span><br><span class="line">    fseek ( from_fd, <span class="number">0L</span>, SEEK_END );</span><br><span class="line">    file_len = ftell ( from_fd );</span><br><span class="line">    fseek ( from_fd, <span class="number">0L</span>, SEEK_SET );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"from file size is=%d\n"</span>, file_len );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( !feof ( from_fd ) ) &#123; <span class="comment">/* 进行文件拷贝 */</span></span><br><span class="line">        fread ( buffer, BUFFER_SIZE, <span class="number">1</span>, from_fd );</span><br><span class="line">        <span class="keyword">if</span> ( BUFFER_SIZE &gt;= file_len ) &#123;</span><br><span class="line">            fwrite ( buffer, file_len, <span class="number">1</span>, to_fd );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fwrite ( buffer, BUFFER_SIZE, <span class="number">1</span>, to_fd );</span><br><span class="line">            file_len = file_len - BUFFER_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        bzero ( buffer, BUFFER_SIZE );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose ( from_fd );</span><br><span class="line">    fclose ( to_fd );</span><br><span class="line">    <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程控制理论基础"><a href="#进程控制理论基础" class="headerlink" title="进程控制理论基础"></a>进程控制理论基础</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>&emsp;&emsp;进程是一个具有一定独立功能的程序的一次运行活动。其特点有：动态性、并发性、独立性和异步性。进程的状态变换如下：</p>
<p><img src="/2019/03/19/Linux系统编程/Linux系统编程基础/1.png" height="244" width="306"></p>
<h4 id="进程ID"><a href="#进程ID" class="headerlink" title="进程ID"></a>进程ID</h4><p>&emsp;&emsp;进程<code>ID</code>(<code>PID</code>)是标识进程的唯一数字；<code>PPID</code>是父进程的<code>ID</code>，<code>UID</code>是启动进程的用户<code>ID</code>。</p>
<h4 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h4><p>&emsp;&emsp;进程互斥是指当有若干进程都要使用某一共享资源时，任何时刻最多允许一个进程使用，其他要使用该资源的进程必须等待，直到占用该资源者释放了该资源为止。</p>
<h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h4><p>&emsp;&emsp;操作系统中将一次只允许一个进程访问的资源称为<code>临界资源</code>。进程中访问临界资源的那段程序代码称为<code>临界区</code>。为实现对临界资源的互斥访问，应保证诸进程互斥地进入各自的临界区。</p>
<h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p>&emsp;&emsp;一组并发进程按一定的顺序执行的过程称为进程间的同步。具有同步关系的一组并发进程称为合作进程，合作进程间互相发送的信号称为消息或事件。</p>
<h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>&emsp;&emsp;概念：按一定算法，从一组待运行的进程中选出一个来占有<code>CPU</code>运行。调度方式主要有<code>抢占式</code>和<code>非抢占式</code>。调度算法主要有<code>先来先服务调度算法</code>、<code>短进程优先调度算法</code>、<code>高优先级优先调度算法</code>和<code>时间片轮转法</code>。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>&emsp;&emsp;多个进程因竞争资源而形成一种僵局，若无外力作用，这些进程都将永远不能再向前推进。</p>
<h4 id="进程控制编程"><a href="#进程控制编程" class="headerlink" title="进程控制编程"></a>进程控制编程</h4><p>&emsp;&emsp;获取<code>ID</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getpid ( <span class="keyword">void</span> ); <span class="comment">/* 获取本进程ID */</span></span><br><span class="line"><span class="keyword">pid_t</span> getppid ( <span class="keyword">void</span> ); <span class="comment">/* 获取父进程ID */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;使用例程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"PID = %d\n"</span>, getpid() );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"PPID = %d\n"</span>, getppid() );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程间通讯概述"><a href="#进程间通讯概述" class="headerlink" title="进程间通讯概述"></a>进程间通讯概述</h3><p>&emsp;&emsp;为什么进程间需要通信？</p>
<ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程。</li>
<li>资源共享：多个进程之间共享同样的资源。</li>
<li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它们发生了某种事件。</li>
<li>进程控制：有些进程希望完全控制另一个进程的执行(如<code>Debug</code>进程)，此时控制进程希望能够拦截另一个进程的所有操作，并能够及时知道它的状态改变。</li>
</ul>
<h4 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h4><p>&emsp;&emsp;<code>Linux</code>进程间通信(<code>IPC</code>)由以下几部分发展而来：</p>
<ul>
<li><code>UNIX</code>进程间通信。</li>
<li>基于<code>System V</code>进程间通信。</li>
<li><code>POSIX</code>进程间通信。</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>&emsp;&emsp;现在<code>Linux</code>使用的进程间通信方式包括：管道(<code>pipe</code>)和有名管道(<code>FIFO</code>)、信号(<code>signal</code>)、消息队列、共享内存、信号量、套接字(<code>socket</code>)。</p>
<h3 id="线程理论基础"><a href="#线程理论基础" class="headerlink" title="线程理论基础"></a>线程理论基础</h3><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>&emsp;&emsp;线程(<code>thread</code>)技术早在<code>60</code>年代就被提出，但真正应用多线程到操作系统中去，是在<code>80</code>年代中期，<code>solaris</code>是这方面的佼佼者。传统的<code>Unix</code>也支持线程的概念，但是在一个进程(<code>process</code>)中只允许有一个线程，这样多线程就意味着多进程。现在，多线程技术已经被许多操作系统所支持，包括<code>Windows NT</code>、<code>Linux</code>。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>&emsp;&emsp;使用多线程的理由之一：和进程相比，它是一种非常<code>节俭</code>的多任务操作方式。在<code>Linux</code>系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种<code>昂贵</code>的多任务工作方式。运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的<code>30</code>倍左右。<br>&emsp;&emsp;使用多线程的理由之二：线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。线程之间共享数据段，全局变量是数据段，局部变量是在栈里。多线程共享也有优先级，先用数据段(全局变量)，再用局部变量(栈)，进程的共享与之相反。<br>&emsp;&emsp;除了以上所说的优点外，多线程程序作为一种多任务、并发的工作方式，有如下优点：</p>
<ul>
<li>使多<code>CPU</code>系统更加有效：操作系统会保证当线程数不大于<code>CPU</code>数目时，不同的线程运行于不同的<code>CPU</code>上。</li>
<li>改善程序结构：一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。</li>
</ul>
<p>&emsp;&emsp;<code>Linux</code>系统下的多线程遵循<code>POSIX</code>线程接口，称为<code>pthread</code>。编写<code>Linux</code>下的多线程程序，需要使用头文件<code>pthread.h</code>，连接时需要使用库<code>libpthread.a</code>。默认情况下，<code>GCC</code>在编译的时候使用的是<code>C</code>库。</p>
<h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">pthread_t</span> *tidp, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> * ( *start_rtn ) ( <span class="keyword">void</span> ), <span class="keyword">void</span> *arg )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>tidp</code>是线程<code>id</code>，<code>attr</code>是线程属性(通常为空)，<code>start_rtn</code>是线程要执行的函数，<code>arg</code>是<code>start_rtn</code>的参数。<br>&emsp;&emsp;<code>pthread_create</code>创建线程并使线程进入就绪态，而不是执行态。在进程执行到<code>sleep</code>函数时，它交出<code>cpu</code>控制权，于是线程得以执行。执行完线程后，这个线程也消失了。<br>&emsp;&emsp;线程的使用(无参数)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* getpid() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">create</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"New thread .... \n"</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"This thread's id is %u\n"</span>, ( <span class="keyword">unsigned</span> <span class="keyword">int</span> ) pthread_self() );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"The process pid is %d\n"</span>, getpid() );</span><br><span class="line">    <span class="keyword">return</span> ( <span class="keyword">void</span> * ) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Main thread is starting ... \n"</span> );</span><br><span class="line">    error = pthread_create ( &amp;tid, <span class="literal">NULL</span>, create, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( error ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"thread is not created ... \n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"The main process's pid is %d  \n"</span>, getpid() );</span><br><span class="line">    sleep ( <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;线程的使用(使用参数)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">create</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">    num = ( <span class="keyword">int</span> * ) arg;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"create parameter is %d \n"</span>, *num );</span><br><span class="line">    <span class="keyword">return</span> ( <span class="keyword">void</span> * ) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc , <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tidp;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">int</span> test = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> *attr = &amp;test;</span><br><span class="line">    error = pthread_create ( &amp;tidp, <span class="literal">NULL</span>, create, ( <span class="keyword">void</span> * ) attr );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( error ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"pthread_create is created is not created ... \n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep ( <span class="number">1</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"pthread_create is created ...\n"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;线程的使用(使用复杂参数)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">menber</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">create</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123; <span class="comment">/* 线程执行函数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">menber</span> *<span class="title">temp</span>;</span></span><br><span class="line">    temp = ( struct menber * ) arg;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"menber-&gt;a = %d  \n"</span>, temp-&gt;a );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"menber-&gt;s = %s  \n"</span>, temp-&gt;s );</span><br><span class="line">    <span class="keyword">return</span> ( <span class="keyword">void</span> * ) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tidp;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">menber</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="comment">/* 为结构体指针b分配内存并赋值 */</span></span><br><span class="line">    b = ( struct menber * ) <span class="built_in">malloc</span> ( <span class="keyword">sizeof</span> ( struct menber ) );</span><br><span class="line">    b-&gt;a = <span class="number">4</span>;</span><br><span class="line">    b-&gt;s = <span class="string">"zieckey"</span>;</span><br><span class="line">    <span class="comment">/* 创建线程并运行线程执行函数 */</span></span><br><span class="line">    error = pthread_create ( &amp;tidp, <span class="literal">NULL</span>, create, ( <span class="keyword">void</span> * ) b );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( error ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"phread is not created...\n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep ( <span class="number">1</span> ); <span class="comment">/* 进程睡眠一秒使线程执行完后进程才会结束 */</span></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"pthread is created...\n"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译多线程代码"><a href="#编译多线程代码" class="headerlink" title="编译多线程代码"></a>编译多线程代码</h4><p>&emsp;&emsp;因为<code>pthread</code>的库不是<code>linux</code>系统的库，所以在进行编译的时候要加上<code>-lpthread</code>，如<code>gcc filename -lpthread</code>。</p>
<h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><p>&emsp;&emsp;如果进程中任何一个线程中调用<code>exit</code>或<code>_exit</code>，那么整个进程都会终止。线程的正常退出方式有：</p>
<ul>
<li>线程从启动例程中返回。</li>
<li>线程可以被另一个进程终止。</li>
<li>线程自己调用<code>pthread_exit</code>函数。</li>
</ul>
<h4 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span> <span class="params">( <span class="keyword">void</span> *rval_ptr )</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能为终止调用线程。参数<code>rval_ptr</code>是线程退出返回值的指针。<br>&emsp;&emsp;线程的设置与退出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> message[<span class="number">32</span>] = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_function</span> <span class="params">( <span class="keyword">void</span> *arg )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> a_thread;</span><br><span class="line">    <span class="keyword">void</span> *thread_result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( pthread_create ( &amp;a_thread, <span class="literal">NULL</span>, thread_function, ( <span class="keyword">void</span> * ) message ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fail to pthread_create"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"waiting for thread to finish\n"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( pthread_join ( a_thread, &amp;thread_result ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fail to pthread_join"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"MESSAGE is now %s\n"</span>, message );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_function</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"thread_function is running, argument is %s\n"</span>, ( <span class="keyword">char</span> * ) arg );</span><br><span class="line">    <span class="built_in">strcpy</span> ( message, <span class="string">"marked by thread"</span> );</span><br><span class="line">    pthread_exit ( <span class="string">"Thank you for the cpu time"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span> <span class="params">( <span class="keyword">pthread_t</span> tid, <span class="keyword">void</span> **rval_ptr )</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能是阻塞调用线程，直到指定的线程终止。参数<code>tid</code>是等待退出的线程<code>id</code>，<code>rval_ptr</code>是线程退出的返回值的指针。<br>&emsp;&emsp;<code>pthread_join</code>的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span> <span class="params">( <span class="keyword">void</span> *str )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i ) &#123;</span><br><span class="line">        sleep ( <span class="number">1</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"This in the thread : %d\n"</span> , i );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pth;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create ( &amp;pth, <span class="literal">NULL</span>, thread, ( <span class="keyword">void</span> * ) ( <span class="number">0</span> ) );</span><br><span class="line">    pthread_join ( pth, <span class="literal">NULL</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"\n"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i ) &#123;</span><br><span class="line">        sleep ( <span class="number">1</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"This in the main : %d\n"</span> , i );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;带有参数的<code>pthread_join</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">create</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"new thread is created ... \n"</span> );</span><br><span class="line">    <span class="keyword">return</span> ( <span class="keyword">void</span> * ) <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">void</span> *temp;</span><br><span class="line">    error = pthread_create ( &amp;tid, <span class="literal">NULL</span>, create, <span class="literal">NULL</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"main thread!\n"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( error ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"thread is not created ... \n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error = pthread_join ( tid, &amp;temp );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( error ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"thread is not exit ... \n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"thread is exit code %d \n"</span>, ( <span class="keyword">int</span> ) temp );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self ( <span class="keyword">void</span> );</span><br></pre></td></tr></table></figure>
<p>功能是获取调用线程的<code>thread identifier</code>，返回线程的<code>ID</code>。</p>
<h4 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h4><p>&emsp;&emsp;线程终止有两种情况：正常终止和非正常终止。线程主动调用<code>pthread_exit</code>或者从线程函数中<code>return</code>都将使线程正常退出，这是可预见的退出方式；非正常终止是线程在其他线程的干预下，或者由于自身运行出错(比如访问非法地址)而退出，这种退出方式是不可预见的(非正常的例子有访问空指针)。<br>&emsp;&emsp;不论是可预见的线程终止还是异常终止，都会存在资源释放的问题，如何保证线程终止时能顺利的释放掉自己所占用的资源，是一个必须考虑解决的问题。<br>&emsp;&emsp;从<code>pthread_cleanup_push</code>的调用点到<code>pthread_cleanup_pop</code>之间的程序段中的终止动作(包括调用<code>pthread_exit</code>和异常终止，不包括<code>return</code>)都将执行<code>pthread_cleanup_push</code>所指定的清理函数。当某段代码有不可预知的非正常终止行为，就用<code>push</code>和<code>pop</code>保护起来。保护了之后，如果这段代码有不可预知的终止，我们就可以固定地在它终止之前去执行某一个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span> <span class="params">( <span class="keyword">void</span> ( *rtn ) ( <span class="keyword">void</span> * ), <span class="keyword">void</span> *arg )</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能是将清除函数压入清除栈。参数<code>Rtn</code>是清除函数，<code>Arg</code>是清除函数的参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span> <span class="params">( <span class="keyword">int</span> execute )</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能是将清除函数弹出清除栈。参数<code>execute</code>决定执行到<code>pthread_cleanup_pop</code>时是否在弹出清理函数的同时执行该函数，非<code>0</code>为执行，<code>0</code>为不执行。<br>&emsp;&emsp;线程的清除：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">clean</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"cleanup :%s  \n"</span>, ( <span class="keyword">char</span> * ) arg );</span><br><span class="line">    <span class="keyword">return</span> ( <span class="keyword">void</span> * ) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn1</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"thread 1 start  \n"</span> );</span><br><span class="line">    pthread_cleanup_push ( ( <span class="keyword">void</span> * ) clean, <span class="string">"thread 1 first handler"</span> );</span><br><span class="line">    pthread_cleanup_push ( ( <span class="keyword">void</span> * ) clean, <span class="string">"thread 1 second hadler"</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"thread 1 push complete  \n"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( arg ) &#123;</span><br><span class="line">        <span class="keyword">return</span> ( ( <span class="keyword">void</span> * ) <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop ( <span class="number">0</span> );</span><br><span class="line">    pthread_cleanup_pop ( <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">return</span> ( <span class="keyword">void</span> * ) <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn2</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"thread 2 start  \n"</span> );</span><br><span class="line">    pthread_cleanup_push ( ( <span class="keyword">void</span> * ) clean, <span class="string">"thread 2 first handler"</span> );</span><br><span class="line">    pthread_cleanup_push ( ( <span class="keyword">void</span> * ) clean, <span class="string">"thread 2 second handler"</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"thread 2 push complete  \n"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( arg ) &#123;</span><br><span class="line">        pthread_exit ( ( <span class="keyword">void</span> * ) <span class="number">2</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop ( <span class="number">0</span> );</span><br><span class="line">    pthread_cleanup_pop ( <span class="number">0</span> );</span><br><span class="line">    pthread_exit ( ( <span class="keyword">void</span> * ) <span class="number">2</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="keyword">void</span> *tret;</span><br><span class="line">    err = pthread_create ( &amp;tid1, <span class="literal">NULL</span>, thr_fn1, ( <span class="keyword">void</span> * ) <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( err != <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"error .... \n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = pthread_create ( &amp;tid2, <span class="literal">NULL</span>, thr_fn2, ( <span class="keyword">void</span> * ) <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( err != <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"error .... \n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = pthread_join ( tid1, &amp;tret );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( err != <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"error .... \n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"thread 1 exit code %d  \n"</span>, ( <span class="keyword">int</span> ) tret );</span><br><span class="line">    err = pthread_join ( tid2, &amp;tret );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( err != <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"error .... "</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"thread 2 exit code %d  \n"</span>, ( <span class="keyword">int</span> ) tret );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;具体解释如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push ( A );</span><br><span class="line">可能出现异常终止的代码;</span><br><span class="line">pop ( <span class="number">0</span>或非<span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p>假如<code>push</code>函数指明了<code>A</code>函数，在异常终止时，函数得到调用，可以在函数里释放资源，由<code>A</code>函数执行清除工作。如果没有出现异常，当执行到<code>pop</code>函数时，<code>pop</code>函数会决定<code>A</code>函数是否还要执行。</p>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>&emsp;&emsp;进行多线程编程，因为无法知道哪个线程会在哪个时候对共享资源进行操作，因此让如何保护共享资源变得复杂，通过下面这些技术的使用，可以解决线程之间对资源的竞争：</p>
<ul>
<li>互斥量<code>Mutex</code>。</li>
<li>信号灯<code>Semaphore</code>。</li>
<li>条件变量<code>Conditions</code>。</li>
</ul>
<p>&emsp;&emsp;线程的同步：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"semaphore.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">60</span>];</span><br><span class="line"><span class="keyword">sem_t</span> sem;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">function</span> <span class="params">( <span class="keyword">void</span> *arg )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> a_thread;</span><br><span class="line">    <span class="keyword">void</span> *thread_result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( sem_init ( &amp;sem, <span class="number">0</span>, <span class="number">0</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fail to sem_init"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( pthread_create ( &amp;a_thread, <span class="literal">NULL</span>, function, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fail to pthread_creat"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"input 'quit' to exit\n"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        fgets ( buf, <span class="number">60</span>, <span class="built_in">stdin</span> );</span><br><span class="line">        sem_post ( &amp;sem );</span><br><span class="line">    &#125; <span class="keyword">while</span> ( <span class="built_in">strncmp</span> ( buf, <span class="string">"quit"</span>, <span class="number">4</span> ) != <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">function</span> <span class="params">( <span class="keyword">void</span> *argc )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        sem_wait ( &amp;sem );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"You enter %d character\n"</span>, <span class="built_in">strlen</span> ( buf ) - <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h4><p>&emsp;&emsp;为什么需要互斥量？代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Item *p = queue_list;</span><br><span class="line">Queue_list = queue_list-&gt;next;</span><br><span class="line">process_job ( p );</span><br><span class="line"><span class="built_in">free</span> ( p );</span><br></pre></td></tr></table></figure>
<p>当线程<code>1</code>处理完<code>Item *p = queue_list</code>后，系统停止线程1的运行，改而运行线程<code>2</code>。线程<code>2</code>照样取出头节点，然后进行处理，最后释放了该节点。过了一段时间，线程<code>1</code>重新得到运行。而这个时候，<code>p</code>所指向的节点已经被线程<code>2</code>释放掉，而线程<code>1</code>对此毫无知晓，它会接着运行<code>process_job(p)</code>，而这将导致无法预料的后果！<br>&emsp;&emsp;对于这种情况，系统给我们提供了互斥量。线程在取出头节点前必须要等待互斥量，如果此时有其他线程已经获得该互斥量，那么该线程将会阻塞在这里。只有等到其他线程释放掉该互斥量后，该线程才有可能得到该互斥量。互斥量从本质上说就是一把锁，提供对共享资源的保护访问。</p>
<h4 id="创建互斥量"><a href="#创建互斥量" class="headerlink" title="创建互斥量"></a>创建互斥量</h4><p>&emsp;&emsp;在<code>Linux</code>中，互斥量使用类型<code>pthread_mutex_t</code>表示。在使用前，要对它进行初始化：</p>
<ul>
<li>对于静态分配的互斥量，可以把它设置为默认的<code>mutex</code>对象<code>PTHREAD_MUTEX_INITIALIZER</code>。</li>
<li>对于动态分配的互斥，在申请内存(<code>malloc</code>)之后，通过<code>pthread_mutex_init</code>进行初始化，并且在释放内存(<code>free</code>)前需要调用<code>pthread_mutex_destroy</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span> <span class="params">( <span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span> <span class="params">( <span class="keyword">pthread_mutex_t</span> *mutex )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>&emsp;&emsp;对共享资源的访问，要使用互斥量进行加锁，如果互斥量已经上了锁，调用线程会阻塞，直到互斥量被解锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span> <span class="params">( <span class="keyword">pthread_mutex_t</span> *mutex )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span> <span class="params">( <span class="keyword">pthread_mutex_t</span> *mutex )</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数执行成功则返回<code>0</code>，出错则返回错误编号。<br>&emsp;&emsp;<code>trylock</code>是非阻塞调用模式，如果互斥量没被锁住，<code>trylock</code>函数将对互斥量加锁，并获得对共享资源的访问权限；如果互斥量被锁住了，<code>trylock</code>函数将不会阻塞等待而直接返回<code>EBUSY</code>，表示共享资源处于忙状态。</p>
<h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>&emsp;&emsp;在操作完成后，必须给互斥量解锁，也就是前面所说的释放。这样，其他等待该锁的线程才有机会获得该锁，否则其他线程将会永远阻塞。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span> <span class="params">( <span class="keyword">pthread_mutex_t</span> *mutex )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="互斥量-vs-信号量"><a href="#互斥量-vs-信号量" class="headerlink" title="互斥量 vs 信号量"></a>互斥量 vs 信号量</h4><p>&emsp;&emsp;<code>Mutex</code>是一把钥匙，一个人拿了就可进入一个房间，出来的时候把钥匙交给队列的第一个。<code>Semaphore</code>是一件可以容纳<code>N</code>人的房间，如果人不满就可以进去；如果人满了，就要等待有人出来。对于<code>N = 1</code>的情况，称为<code>binary semaphore</code>。<code>Binary semaphore</code>与<code>Mutex</code>的差异：<code>mutex</code>要由获得锁的线程来释放(谁获得，谁释放)，<code>semaphore</code>可以由其它线程释放；初始状态可能不一样，<code>mutex</code>的初始值是<code>1</code>，而<code>semaphore</code>的初始值可能是<code>0</code>(或者为<code>1</code>)。<br>&emsp;&emsp;线程的互斥：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LOCK_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value1 = <span class="number">1</span>, value2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">function</span> <span class="params">( <span class="keyword">void</span> *arg )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> a_thread;</span><br><span class="line">    <span class="keyword">void</span> *thread_result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( pthread_mutex_init ( &amp;mutex, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fail to mutex_init"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( pthread_create ( &amp;a_thread, <span class="literal">NULL</span>, function, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fail to pthread_create"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        sleep ( <span class="number">1</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LOCK_</span></span><br><span class="line">        pthread_mutex_lock ( &amp;mutex );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        value1 = count;</span><br><span class="line">        value2 = count;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"count = %d, value1 = %d, value2 = %d\n"</span>, count, value1, value2 );</span><br><span class="line">        value1 = ++count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LOCK_</span></span><br><span class="line">        pthread_mutex_unlock ( &amp;mutex );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">function</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        sleep ( <span class="number">1</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LOCK_</span></span><br><span class="line">        pthread_mutex_lock ( &amp;mutex );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> ( value1 != value2 ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"count = %d, value1 = %d, value2 = %d\n"</span>, count, value1, value2 );</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LOCK_</span></span><br><span class="line">        pthread_mutex_unlock ( &amp;mutex );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Linux网络编程"><a href="#Linux网络编程" class="headerlink" title="Linux网络编程"></a>Linux网络编程</h3><h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h4><p><img src="/2019/03/19/Linux系统编程/Linux系统编程基础/2.png" height="262" width="926"></p>
<h4 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h4><p>&emsp;&emsp;<code>TCP/IP</code>实际上一个协同工作的通信家族，为网络数据通信提供通路。为讨论方便可<code>TCP/IP</code>协议组大体上分为三部分：</p>
<ul>
<li><code>Internet</code>协议(<code>IP</code>)。</li>
<li>传输控制协议(<code>TCP</code>)和用户数据报协议(<code>UDP</code>)。</li>
<li>处于<code>TCP</code>和<code>UDP</code>之上的一组应用协议，它们包括<code>TELNET</code>、文件传送协议(<code>FTP</code>)、域名服务(<code>DNS</code>)和简单邮件传送程序(<code>SMTP</code>)等。</li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>&emsp;&emsp;第一部分称为网络层。主要包括<code>Internet</code>协议(<code>IP</code>)、网际控制报文协议(<code>ICMP</code>)和地址解析协议(<code>ARP</code>)。</p>
<ul>
<li><code>Internet</code>协议(<code>IP</code>)：该协议被设计成互联分组交换通信网，以形成一个网际通信环境。它负责在源主机和目的地主机之间传输来自其较高层软件的称为数据报文的数据块，它在源和目的地之间提供非连接型传递服务。</li>
<li>网际控制报文协议(<code>ICMP</code>)：它实际上不是<code>IP</code>层部分，但直接同<code>IP</code>层一起工作，报告网络上的某些出错情况。允许网际路由器传输差错信息或测试报文。</li>
<li>地址解析协议(<code>ARP</code>)：<code>ARP</code>实际上不是网络层部分，它处于<code>IP</code>和数据链路层之间，它是在<code>32</code>位<code>IP</code>地址和<code>48</code>位物理地址之间执行翻译的协议。</li>
</ul>
<h4 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h4><p>&emsp;&emsp;第二部分是传输层协议，包括传输控制协议和用户数据报文协议。</p>
<ul>
<li>传输控制协议(<code>TCP</code>)：该协议对建立网络上用户进程之间的对话负责，它确保进程之间的可靠通信，所提供的功能如下：监听输入对话建立请求、请求另一网络站点对话、可靠的发送和接收数据和适度的关闭对话。</li>
<li>用户数据报文协议(<code>UDP</code>)：<code>UDP</code>提供不可靠的非连接型传输层服务，它允许在源和目的地之间传送数据，而不必在传送数据之前建立对话。它主要用于那些非连接型的应用程序，如视频点播。</li>
</ul>
<h4 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h4><p>&emsp;&emsp;这部分主要包括<code>Telnet</code>、文件传送协议(<code>FTP</code>和<code>TFTP</code>)，简单文件传送协议(<code>SMTP</code>)和域名服务(<code>DNS</code>)等协议。</p>
<h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>&emsp;&emsp;<code>IP</code>主要有以下四个主要功能：数据传送、寻址、路由选择和数据报文的分段。<br>&emsp;&emsp;<code>IP</code>的主要目的是为数据<code>输入/输出</code>网络提供基本算法，为高层协议提供无连接的传送服务。这意味着在<code>IP</code>将数据递交给接收站点以前不在传输站点和接收站点之间建立对话。它只是封装和传递数据，但不向发送者或接收者报告包的状态，不处理所遇到的故障。</p>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>&emsp;&emsp;<code>TCP</code>是重要的传输层协议，目的是允许数据同网络上的其他节点进行可靠的交换。它能提供端口编号的译码，以识别主机的应用程序，而且完成数据的可靠传输。<code>TCP</code>协议具有严格的内装差错检验算法确保数据的完整性。<code>TCP</code>是面向字节的顺序协议，这意味着包内的每个字节被分配一个顺序编号，并分配给每包一个顺序编号。</p>
<h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>&emsp;&emsp;<code>UDP</code>也是传输层协议，它是无连接的，不可靠的传输服务。当接收数据时它不向发送方提供确认信息，它不提供输入包的顺序，如果出现丢失包或重份包的情况，也不会向发送方发出差错报文。由于它执行功能时具有较低的开销，因而执行速度比<code>TCP</code>快。</p>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>&emsp;&emsp;<code>Linux</code>中的网络编程通过<code>Socket</code>接口实现，<code>Socket</code>是一种文件描述符。套接字<code>socket</code>有三种类型：</p>
<ul>
<li>流式套接字(<code>SOCK_STREAM</code>)：流式的套接字可以提供可靠的、面向连接的通讯流。它使用了<code>TCP</code>协议。<code>TCP</code>保证了数据传输的正确性和顺序性。</li>
<li>数据报套接字(<code>SOCK_DGRAM</code>)：数据报套接字定义了一种无连接的服务，数据通过相互独立的报文进行传输，是无序的，并且不保证可靠，无差错，它使用数据报协议<code>UDP</code>。</li>
<li>原始套接字：原始套接字允许对低层协议如<code>IP</code>或<code>ICMP</code>直接访问，主要用于新的网络协议的测试等。</li>
</ul>
<h4 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    u_short sa_family; <span class="comment">/* 地址族，采用“AF_xxx”的形式，如AF_INET */</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">/* 14字节的特定协议地址 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s_addr; <span class="comment">/* 32位的地址 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sin_family; <span class="comment">/* Internet地址族 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port; <span class="comment">/* 端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* IP地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/* 填0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编程中一般并不直接针对<code>sockaddr</code>数据结构操作，而是使用与<code>sockaddr</code>等价的<code>sockaddr_in</code>数据结构。</p>
<h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p>&emsp;&emsp;<code>IP</code>地址通常由数字加点(<code>192.168.0.1</code>)的形式表示，而在<code>struct in_addr</code>中使用的是<code>IP</code>地址是由<code>32</code>位的整数表示的。为了进行转换，我们可以使用下面两个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span> <span class="params">( struct in_addr in )</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数里面的<code>a</code>代表<code>ascii</code>，<code>n</code>代表<code>network</code>。第一个函数表示将<code>a.b.c.d</code>形式的<code>IP</code>转换为<code>32</code>位的<code>IP</code>，存储在<code>inp</code>指针里面。第二个是将<code>32</code>位<code>IP</code>转换为<code>a.b.c.d</code>的格式。</p>
<h4 id="字节序转换"><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h4><p>&emsp;&emsp;不同类型的<code>CPU</code>对变量的字节存储顺序可能不同：有的系统是高位在前，低位在后，而有的系统是低位在前，高位在后，而网络传输的数据顺序是一定要统一的。所以当内部字节存储顺序和网络字节顺序不同时，就一定要进行转换。<br>&emsp;&emsp;网络字节顺序是<code>TCP/IP</code>中规定好的一种数据表示格式，它与具体的<code>CPU</code>类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用<code>big endian</code>排序方式。</p>
<ul>
<li><code>htons</code>：把<code>unsigned short</code>类型从主机序转换到网络序。</li>
<li><code>htonl</code>：把<code>unsigned long</code>类型从主机序转换到网络序。</li>
<li><code>ntohs</code>：把<code>unsigned short</code>类型从网络序转换到主机序。</li>
<li><code>ntohl</code>：把<code>unsigned long</code>类型从网络序转换到主机序。</li>
</ul>
<h4 id="IP与主机名"><a href="#IP与主机名" class="headerlink" title="IP与主机名"></a>IP与主机名</h4><p>&emsp;&emsp;在网络上标识一台机器可以用<code>IP</code>，也可以使用主机名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *h_name;       <span class="comment">/* 主机的正式名称 */</span></span><br><span class="line">    <span class="keyword">char</span> *h_aliases;    <span class="comment">/* 主机的别名 */</span></span><br><span class="line">    <span class="keyword">int</span> h_addrtype;     <span class="comment">/* 主机的地址类型 */</span></span><br><span class="line">    <span class="keyword">int</span> h_length;       <span class="comment">/* 主机的地址长度 */</span></span><br><span class="line">    <span class="keyword">char</span> **h_addr_list; <span class="comment">/* 主机的IP地址列表 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> h_addr h_addr_list[0] <span class="comment">/* 主机的第一个IP地址 */</span></span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *hostname )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h4><p>&emsp;&emsp;进行<code>Socket</code>编程的常用函数有：</p>
<ul>
<li><code>socket</code>：创建一个<code>socket</code>。</li>
<li><code>bind</code>：用于绑定<code>IP</code>地址和端口号到<code>socket</code>。</li>
<li><code>connect</code>：该函数用于绑定之后的<code>client</code>端，与服务器建立连接。</li>
<li><code>listen</code>：设置能处理的最大连接要求，<code>Listen</code>并未开始接收连线，只是设置<code>socket</code>为<code>listen</code>模式。</li>
<li><code>accept</code>：用来接受<code>socket</code>连接。</li>
<li><code>send</code>：发送数据。</li>
<li><code>recv</code>：接收数据。</li>
</ul>
<h4 id="基于TCP的服务器"><a href="#基于TCP的服务器" class="headerlink" title="基于TCP的服务器"></a>基于TCP的服务器</h4><ol>
<li>创建一个<code>socket</code>，用函数<code>socket</code>。</li>
<li>绑定<code>IP</code>地址、端口等信息到<code>socket</code>上，用函数<code>bind</code>。</li>
<li>设置允许的最大连接数，用函数<code>listen</code>。</li>
<li>接收客户端上来的连接，用函数<code>accept</code>。</li>
<li>收发数据，用函数<code>send</code>和<code>recv</code>，或者<code>read</code>和<code>write</code>。</li>
<li>关闭网络连接。</li>
</ol>
<h4 id="基于TCP的客户端"><a href="#基于TCP的客户端" class="headerlink" title="基于TCP的客户端"></a>基于TCP的客户端</h4><ol>
<li>创建一个<code>socket</code>，用函数<code>socket</code>。</li>
<li>设置要连接的对方的<code>IP</code>地址和端口等属性。</li>
<li>连接服务器，用函数<code>connect</code>。</li>
<li>收发数据，用函数<code>send</code>和<code>recv</code>，或者<code>read</code>和<code>write</code>。</li>
<li>关闭网络连接。</li>
</ol>
<p><img src="/2019/03/19/Linux系统编程/Linux系统编程基础/3.png" height="244" width="277"></p>
<h4 id="基于UDP的服务器"><a href="#基于UDP的服务器" class="headerlink" title="基于UDP的服务器"></a>基于UDP的服务器</h4><ol>
<li>创建一个<code>socket</code>，用函数<code>socket</code>。</li>
<li>绑定<code>IP</code>地址、端口等信息到<code>socket</code>上，用函数<code>bind</code>。</li>
<li>设置对方的<code>IP</code>地址和端口等属性。</li>
<li>发送数据，用函数<code>sendto</code>。</li>
<li>关闭网络连接。</li>
</ol>
<p><img src="/2019/03/19/Linux系统编程/Linux系统编程基础/4.png" height="296" width="374"></p>
<h4 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h4><p>&emsp;&emsp;在网络程序里面，一般来说都是许多客户对应一个服务器，为了处理客户的请求，对服务端的程序就提出了特殊的要求。目前最常用的服务器模型有：</p>
<ul>
<li>循环服务器：服务器在同一个时刻只可以响应一个客户端的请求。</li>
<li>并发服务器：服务器在同一个时刻可以响应多个客户端的请求。</li>
</ul>
<h4 id="UDP循环服务器"><a href="#UDP循环服务器" class="headerlink" title="UDP循环服务器"></a>UDP循环服务器</h4><p>&emsp;&emsp;<code>UDP</code>循环服务器的实现方法：<code>UDP</code>服务器每次从套接字上读取一个客户端的请求，然后进行处理，最后将结果返回给客户机。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">socket ( ... );</span><br><span class="line">bind ( ... );</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">    recvfrom ( ... );</span><br><span class="line">    process ( ... );</span><br><span class="line">    sendto ( ... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>UDP</code>是非面向连接的，没有一个客户端可以老是占住服务端，服务器对于每一个客户机的请求总是能够满足。</p>
<h4 id="TCP循环服务器"><a href="#TCP循环服务器" class="headerlink" title="TCP循环服务器"></a>TCP循环服务器</h4><p>&emsp;&emsp;<code>TCP</code>服务器接受一个客户端的连接，然后处理，完成了这个客户的所有请求后，断开连接。算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">socket ( ... );</span><br><span class="line">bind ( ... );</span><br><span class="line">listen ( ... );</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">    accept ( ... );</span><br><span class="line">    process ( ... );</span><br><span class="line">    close ( ... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TCP</code>循环服务器一次只能处理一个客户端的请求。只有在这个客户的所有请求都满足后，服务器才可以继续后面的请求。这样如果有一个客户端占住服务器不放时，其它的客户机都不能工作了，因此<code>TCP</code>服务器一般很少用循环服务器模型的。</p>
<h4 id="TCP并发服务器"><a href="#TCP并发服务器" class="headerlink" title="TCP并发服务器"></a>TCP并发服务器</h4><p>&emsp;&emsp;并发服务器的思想是每一个客户机的请求并不由服务器直接处理，而是由服务器创建一个子进程来处理。算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">socket ( ... );</span><br><span class="line">bind ( ... );</span><br><span class="line">listen ( ... );</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">    accept ( ... );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( fork ( .. ) == <span class="number">0</span> ) &#123;</span><br><span class="line">        process ( ... );</span><br><span class="line">        close ( ... );</span><br><span class="line">        <span class="built_in">exit</span> ( ... );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close ( ... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TCP</code>并发服务器可以解决<code>TCP</code>循环服务器客户机独占服务器的情况。但同时也带来了问题：为了响应客户的请求，服务器要创建子进程来处理，而创建子进程是一种非常消耗资源的操作。</p>
<h4 id="多路复用I-O"><a href="#多路复用I-O" class="headerlink" title="多路复用I/O"></a>多路复用I/O</h4><p>&emsp;&emsp;阻塞函数在完成其指定的任务以前不允许程序继续向下执行。例如，当服务器运行到<code>accept</code>语句时，而没有客户请求连接，服务器就会停止在<code>accept</code>语句上等待连接请求的到来，这种情况称为阻塞(<code>blocking</code>)。而非阻塞操作则可以立即完成，例如，如果你希望服务器仅仅检查是否有客户在等待连接，有就接受连接，否则就继续做其他事情，则可以通过使用<code>select</code>系统调用来实现。除此之外，<code>select</code>还可以同时监视多个套接字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> maxfd, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">    fe_set *exceptfds, <span class="keyword">const</span> struct timeval *timeout )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>Maxfd</code>是文件描述符的范围，比待检的最大文件描述符大<code>1</code>；<code>Readfds</code>是被读监控的文件描述符集；<code>Writefds</code>是被写监控的文件描述符集；<code>Exceptfds</code>是被异常监控的文件描述符集；<code>Timeout</code>是定时器，取不同的值，该调用有不同的表现：</p>
<ul>
<li><code>Timeout</code>值为<code>0</code>，不管是否有文件满足要求，都立刻返回，无文件满足要求返回<code>0</code>，有文件满足要求返回一个正值。</li>
<li><code>Timeout</code>为<code>NULL</code>，<code>select</code>将阻塞进程，直到某个文件满足要求。</li>
<li><code>Timeout</code>值为正整数，就是等待的最长时间，即<code>select</code>在<code>timeout</code>时间内阻塞进程。</li>
</ul>
<p>&emsp;&emsp;<code>Select</code>调用返回时，返回值有如下情况：</p>
<ul>
<li>正常情况下返回满足要求的文件描述符个数。</li>
<li>经过了<code>timeout</code>等待后仍无文件满足要求，返回值为<code>0</code>。</li>
<li>如果<code>select</code>被某个信号中断，它将返回<code>-1</code>，并设置<code>errno</code>为<code>EINTR</code>。</li>
<li>如果出错，返回<code>-1</code>并设置相应的<code>errno</code>。</li>
</ul>
<p>&emsp;&emsp;多路复用的步骤为：</p>
<ol>
<li>设置要监控的文件。</li>
<li>调用<code>Select</code>开始监控。</li>
<li>判断文件是否发生变化。</li>
</ol>
<p>&emsp;&emsp;系统提供了<code>4</code>个宏对描述符集进行操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span> <span class="params">( <span class="keyword">int</span> fd, fd_set *fdset )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span> <span class="params">( <span class="keyword">int</span> fd, fd_set *fdset )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span> <span class="params">( fd_set *fdset )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ISSET</span> <span class="params">( <span class="keyword">int</span> fd, fd_set *fdset )</span></span>;</span><br></pre></td></tr></table></figure>
<p>宏<code>FD_SET</code>将文件描述符<code>fd</code>添加到文件描述符集<code>fdset</code>中；宏<code>FD_CLR</code>从文件描述符集<code>fdset</code>中清除文件描述符<code>fd</code>；宏<code>FD_ZERO</code>清空文件描述符集<code>fdset</code>；在调用<code>select</code>后使用<code>FD_ISSET</code>来检测文件描述符集<code>fdset</code>中的文件<code>fd</code>发生了变化。<br>&emsp;&emsp;编程模型为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">FD_ZERO ( &amp;fds ); <span class="comment">/* 清空集合 */</span></span><br><span class="line">sock1 = socket ( ... );</span><br><span class="line">sock2 = socket ( ... );</span><br><span class="line">bind ( sock1, ... );</span><br><span class="line">bind ( sock2, ... );</span><br><span class="line">listen ( sock1, ... );</span><br><span class="line">listen ( sock1, ... );</span><br><span class="line">FD_SET ( sock1, &amp;fds ); <span class="comment">/* 设置描述符 */</span></span><br><span class="line">FD_SET ( sock2, &amp;fds ); <span class="comment">/* 设置描述符 */</span></span><br><span class="line"></span><br><span class="line">maxfdp = ( sock1 &gt; sock2 ? sock1 : sock2 ) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ( select ( maxfdp, &amp;fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout ) ) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">/* select发送错误，退出程序 */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> ( FD_ISSET ( sock1, &amp;fds ) ) &#123; <span class="comment">/* 测试sock1是否可读 */</span></span><br><span class="line">            accpet ( sock1, ... );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/19/嵌入式笔记/对ARM堆栈的理解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/19/嵌入式笔记/对ARM堆栈的理解/" itemprop="url">对ARM堆栈的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T13:36:10+08:00">
                2019-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;堆栈严格来说应该叫做栈，栈(<code>Stack</code>)是限定仅在一端进行插入或删除操作的线性表。从栈顶的定义来看，栈顶的位置是可变的。空栈时，栈顶和栈底重合；满栈时，栈顶离栈底最远。<br>&emsp;&emsp;<code>ARM</code>为堆栈提供了硬件支持，它使用一个专门的寄存器(堆栈指针)指向堆栈的栈顶，而且<code>7</code>种模式都有各自独立的堆栈指针，也就是有各自独立的堆栈空间。但这里的堆栈和<code>uCOS</code>操作系统的任务堆栈又有区别，<code>uCOS</code>的每个任务都有自己的堆栈，要是把<code>uCOS</code>移植到<code>ARM</code>上，可以借助<code>ARM</code>的堆栈指针来实现。<br>&emsp;&emsp;存储器堆栈可分为两种：</p>
<ul>
<li>向上生长：向高地址方向生长，称为<code>递增堆栈</code>。</li>
<li>向下生长：向低地址方向生长，称为<code>递减堆栈</code>。</li>
</ul>
<p>&emsp;&emsp;堆栈指针指向最后压入的堆栈的有效数据项，称为<code>满堆栈</code>；堆栈指针指向下一个要放入的空位置，称为<code>空堆栈</code>。这样就有<code>4</code>种类型的堆栈表示递增和递减的满堆栈和空堆栈的各种组合。</p>
<ul>
<li>满递增：堆栈通过增大存储器的地址向上增长，堆栈指针指向内含有效数据项的最高地址，指令如<code>LDMFA</code>、<code>STMFA</code>等。</li>
<li>空递增：堆栈通过增大存储器的地址向上增长，堆栈指针指向堆栈上的第一个空位置，指令如<code>LDMEA</code>、<code>STMEA</code>等。</li>
<li>满递减：堆栈通过减小存储器的地址向下增长，堆栈指针指向内含有效数据项的最低地址，指令如<code>LDMFD</code>、<code>STMFD</code>等。</li>
<li>空递减：堆栈通过减小存储器的地址向下增长，堆栈指针指向堆栈下的第一个空位置，指令如<code>LDMED</code>、<code>STMED</code>等。</li>
</ul>
<p>&emsp;&emsp;为什么说<code>向上生长</code>和<code>向下生长</code>呢？那是因为一般画堆栈示意图都是把低地址画在下面，高地址画在上面：</p>
<p><img src="/2019/03/19/嵌入式笔记/对ARM堆栈的理解/1.png" height="366" width="265"></p>
<p>&emsp;&emsp;有一点需要注意的是，虽然<code>ARM</code>处理器对于两种生长方式的堆栈均支持，但<code>ADS</code>的<code>C</code>语言编译器仅支持一种方式，即从上往下长，并且必须是满递减堆栈，所以<code>STMFD</code>等指令用的最多。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/19/软件与硬件问题/Mosquitto安装和使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/19/软件与硬件问题/Mosquitto安装和使用/" itemprop="url">Mosquitto安装和使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T13:15:26+08:00">
                2019-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;<code>MQTT</code>是<code>IBM</code>开发的一个即时通讯协议。<code>MQTT</code>是面向<code>M2M</code>和物联网的连接协议，采用轻量级发布和订阅消息传输机制。<code>Mosquitto</code>是一款实现了<code>MQTT v3.1</code>协议的开源消息代理软件，提供轻量级的、支持<code>发布/订阅</code>的消息推送模式，使设备对设备之间的短消息通信简单易用。若初次接触<code>MQTT</code>协议，可先理解以下概念：</p>
<ul>
<li><code>MQTT</code>协议特点：相比于<code>RESTful</code>架构的物联网系统，<code>MQTT</code>协议借助消息推送功能，可以更好地实现远程控制。</li>
<li><code>MQTT</code>协议角色：在<code>RESTful</code>架构的物联网系统，包含两个角色客户端和服务器端，而在<code>MQTT</code>协议中包括发布者、代理器(服务器)和订阅者。</li>
<li><code>MQTT</code>协议消息：<code>MQTT</code>中的消息可理解为发布者和订阅者交换的内容(负载)，这些消息包含具体的内容，可以被订阅者使用。</li>
<li><code>MQTT</code>协议主题：<code>MQTT</code>中的主题可理解为相同类型或相似类型的消息集合。</li>
</ul>
<h3 id="安装和使用注意点"><a href="#安装和使用注意点" class="headerlink" title="安装和使用注意点"></a>安装和使用注意点</h3><p>&emsp;&emsp;安装步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://mosquitto.org/files/<span class="built_in">source</span>/mosquitto-1.4.5.tar.gz</span><br><span class="line">tar zxfv mosquitto-1.4.5.tar.gz</span><br><span class="line"><span class="built_in">cd</span> mosquitto-1.4.5</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>安装时，需要注意如下几点：</p>
<ul>
<li>编译找不到<code>openssl/ssl.h</code>，解决方法为<code>sudo apt-get install libssl-dev</code>。</li>
<li>编译过程找不到<code>ares.h</code>，解决方法为<code>sudo apt-get install libc-ares-dev</code>。</li>
<li>编译过程找不到<code>uuid/uuid.h</code>，解决方法为<code>sudo apt-get install uuid-dev</code>。</li>
<li>使用过程中找不到<code>libmosquitto.so.1</code>，解决方法为：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/lib/libmosquitto.so.1 /usr/lib/libmosquitto.so.1</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>
<h3 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h3><p>&emsp;&emsp;一个完整的<code>MQTT</code>示例包括一个代理器，一个发布者和一个订阅者。测试分为以下几个步骤：</p>
<ol>
<li>启动服务<code>mosquitto</code>。</li>
<li>订阅者通过<code>mosquitto_sub</code>订阅指定主题的消息。</li>
<li>发布者通过<code>mosquitto_pub</code>发布指定主题的消息。</li>
<li>代理服务器把该主题的消息推送到订阅者。</li>
</ol>
<p>&emsp;&emsp;在本例中，发布者、代理和订阅者均为<code>localhsot</code>，但是在实际的情况下三种并不是同一个设备。在<code>mosquitto</code>中可通过<code>-h</code>(或<code>--host</code>)设置主机名称(<code>hostname</code>)。为了实现这个简单的测试案例，需要在<code>linux</code>中打开三个控制台，分别代表代理服务器、发布者和订阅者：</p>
<p><img src="/2019/03/19/软件与硬件问题/Mosquitto安装和使用/1.png"></p>
<ul>
<li>启动代理服务，命令为<code>mosquitto -v</code>，<code>-v</code>是为了打印更多的调试信息。</li>
<li>订阅主题，命令为<code>mosquitto_sub -v -t sensor</code>，<code>-t</code>指定主题，此处为<code>sensor</code>。</li>
<li>发布内容，命令为<code>mosquitto_pub -t sensor -m 12</code>，<code>-t</code>指定主题，<code>-m</code>指定消息内容。</li>
</ul>
<p>&emsp;&emsp;当发布者推送消息之后，订阅者获得内容<code>sensor 12</code>。而代理服务器控制台中会出现一一连接、消息发布和心跳等调试信息。通过代理服务器的调试输出，可以对<code>MQTT</code>协议的相关过程有所了解：</p>
<p><img src="/2019/03/19/软件与硬件问题/Mosquitto安装和使用/2.png" height="275" width="436"></p>
<p>&emsp;&emsp;<strong>补充说明</strong>：在启动<code>MQTT</code>服务器后，应该先进行消息订阅，再进行消息发布，否则订阅者收不到发布者发布的消息。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/19/单片机/STM32的ADC以及内部温度传感器/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/19/单片机/STM32的ADC以及内部温度传感器/" itemprop="url">STM32的ADC以及内部温度传感器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T09:58:57+08:00">
                2019-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>STM32</code>自带<code>1</code>至<code>3</code>个<code>ADC</code>模块，采样精度达到了<code>12</code>位。在<code>STM32F103RBT6</code>中，<code>ADC1</code>和<code>ADC2</code>共用一组管脚。总体编程思路如下：</p>
<ol>
<li>初始化<code>RCC</code>相关，使能系统时钟，使能功能模块如<code>ADC</code>、<code>DMA</code>的时钟。</li>
<li><code>GPIO</code>相关初始化，比如常用的指示灯，<code>ADC</code>的引脚要设置为输入。</li>
<li><code>NVIC</code>向量中断的配置，因为这里使用了<code>DMA</code>中断和中断服务程序编写(下例中暂不使用)。</li>
<li><code>DMA</code>配置(下例中暂不使用)。</li>
<li><code>ADC</code>初始化。</li>
</ol>
<p>&emsp;&emsp;相关的通道如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>通道</th>
<th>ADC1</th>
<th>ADC2</th>
<th>ADC3</th>
</tr>
</thead>
<tbody>
<tr>
<td>通道<code>0</code></td>
<td><code>PA0</code></td>
<td><code>PA0</code></td>
<td><code>PA0</code></td>
</tr>
<tr>
<td>通道<code>1</code></td>
<td><code>PA1</code></td>
<td><code>PA1</code></td>
<td><code>PA1</code></td>
</tr>
<tr>
<td>通道<code>2</code></td>
<td><code>PA2</code></td>
<td><code>PA2</code></td>
<td><code>PA2</code></td>
</tr>
<tr>
<td>通道<code>3</code></td>
<td><code>PA3</code></td>
<td><code>PA3</code></td>
<td><code>PA3</code></td>
</tr>
<tr>
<td>通道<code>4</code></td>
<td><code>PA4</code></td>
<td><code>PA4</code></td>
<td><code>PF6</code></td>
</tr>
<tr>
<td>通道<code>5</code></td>
<td><code>PA5</code></td>
<td><code>PA5</code></td>
<td><code>PF7</code></td>
</tr>
<tr>
<td>通道<code>6</code></td>
<td><code>PA6</code></td>
<td><code>PA6</code></td>
<td><code>PF8</code></td>
</tr>
<tr>
<td>通道<code>7</code></td>
<td><code>PA7</code></td>
<td><code>PA7</code></td>
<td><code>PF9</code></td>
</tr>
<tr>
<td>通道<code>8</code></td>
<td><code>PB0</code></td>
<td><code>PB0</code></td>
<td><code>PF10</code></td>
</tr>
<tr>
<td>通道<code>9</code></td>
<td><code>PB1</code></td>
<td><code>PB1</code></td>
<td></td>
</tr>
<tr>
<td>通道<code>10</code></td>
<td><code>PC0</code></td>
<td><code>PC0</code></td>
<td><code>PC0</code></td>
</tr>
<tr>
<td>通道<code>11</code></td>
<td><code>PC1</code></td>
<td><code>PC1</code></td>
<td><code>PC1</code></td>
</tr>
<tr>
<td>通道<code>12</code></td>
<td><code>PC2</code></td>
<td><code>PC2</code></td>
<td><code>PC2</code></td>
</tr>
<tr>
<td>通道<code>13</code></td>
<td><code>PC3</code></td>
<td><code>PC3</code></td>
<td><code>PC3</code></td>
</tr>
<tr>
<td>通道<code>14</code></td>
<td><code>PC4</code></td>
<td><code>PC4</code></td>
<td></td>
</tr>
<tr>
<td>通道<code>15</code></td>
<td><code>PC5</code></td>
<td><code>PC5</code></td>
<td></td>
</tr>
<tr>
<td>通道<code>16</code></td>
<td>温度传感器</td>
<td></td>
<td></td>
</tr>
<tr>
<td>通道<code>17</code></td>
<td>内部参考电压</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;以下是参考代码，使用<code>ADC1</code>的<code>IN0</code>脚：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_GPIO_Init</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    RCC_APB2PeriphClockCmd ( RCC_APB2Periph_GPIOA | RCC_APB2Periph_ADC1, ENABLE );</span><br><span class="line">    GPIO_DeInit ( GPIOA );</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; <span class="comment">/* 设为模拟输入 */</span></span><br><span class="line">    GPIO_Init ( GPIOA, &amp;GPIO_InitStructure );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_configuration</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; <span class="comment">/* 独立模式 */</span></span><br><span class="line">    ADC_InitStructure.ADC_ScanConvMode = DISABLE; <span class="comment">/* 连续多通道模式 */</span></span><br><span class="line">    ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; <span class="comment">/* 单次转换 */</span></span><br><span class="line">    <span class="comment">/* 转换由软件而不是外部触发启动 */</span></span><br><span class="line">    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; <span class="comment">/* 右对齐 */</span></span><br><span class="line">    ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>; <span class="comment">/* 扫描通道数 */</span></span><br><span class="line">    ADC_Init ( ADC1, &amp;ADC_InitStructure );</span><br><span class="line">    <span class="comment">// ADC_RegularChannelConfig( ADC1, ADC_Channel_0, 1, ADC_SampleTime_7Cycles5 );</span></span><br><span class="line">    ADC_Cmd ( ADC1, ENABLE ); <span class="comment">/* 使能或者失能指定的ADC */</span></span><br><span class="line">    ADC_ResetCalibration ( ADC1 ); <span class="comment">/* 重置指定的ADC的校准寄存器 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( ADC_GetResetCalibrationStatus ( ADC1 ) ); <span class="comment">/* 等待校准寄存器初始化 */</span></span><br><span class="line">​</span><br><span class="line">    ADC_StartCalibration ( ADC1 ); <span class="comment">/* 开始校准 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( ADC_GetCalibrationStatus ( ADC1 ) ); <span class="comment">/* 等待校准完成 */</span></span><br><span class="line">​</span><br><span class="line">    ADC_SoftwareStartConvCmd ( ADC1, ENABLE ); <span class="comment">/* 使能指定的ADC的软件转换启动功能 */</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function">u16 <span class="title">GetADCValue</span> <span class="params">( u8 ADC_Channel )</span> </span>&#123; <span class="comment">/* ADC_Channel_x 0~17 */</span></span><br><span class="line">    u16 adc_value;</span><br><span class="line">    ADC_RegularChannelConfig ( ADC1, ADC_Channel, <span class="number">1</span>, ADC_SampleTime_7Cycles5 );</span><br><span class="line">    ADC_SoftwareStartConvCmd ( ADC1, ENABLE ); <span class="comment">/* 使能指定的ADC的软件转换启动功能 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 检查制定ADC标志位是否置为1，ADC_FLAG_EOC是转换结束标志位 */</span></span><br><span class="line">    <span class="keyword">while</span> ( ADC_GetFlagStatus ( ADC1, ADC_FLAG_EOC ) == RESET );</span><br><span class="line">​</span><br><span class="line">    adc_value = ADC_GetConversionValue ( ADC1 );</span><br><span class="line">    <span class="keyword">return</span> adc_value; <span class="comment">/* 返回最近一次ADCx规则组的转换结果 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当使用内部温度传感器时，需要使能温度传感器通道：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC_TempSensorVrefintCmd ( ENABLE );</span><br></pre></td></tr></table></figure>
<p>温度传感器通道号是<code>ADC_Channel_16</code>，此通道的采样时间调到最大，来保证精度。温度的计算公式如下：</p>
<script type="math/tex; mode=display">温度(^{\circ}C) = \{(V_{25}-V_{SENSE})/Avg\_Slope\} + 25</script><p>其中$V_{25}$是$V_{SENSE}$在$25^{\circ}C$时的数值；$Avg\_Slope$是温度与$V_{SENSE}$曲线的平均斜率(单位是$mV/^{\circ}C$或$\mu V/^{\circ}C$)。$V_{25}$、$V_{SENSE}$的典型值分别为$1.43$、$4.3mV/^{\circ}C$，则<code>TEMP = (1.43 - Vsense)/0.0043 + 25</code>。</p>
<p>&emsp;&emsp;<strong>补充说明</strong>：</p>
<ol>
<li><code>STM32</code>的<code>ADC</code>可以分为注入组(<code>Injected Channel</code>)和规则组(<code>Regular Channel</code>)，规则组放的是常规情况下的检查所需要的数据，注入组放的是特殊情况下的检查所需要的数据(或者是特殊数据)，也可以说规则组是主程序，而注入组是中断程序。</li>
<li>如果你的<code>ADC_CLK</code>越小，即你的<code>AD</code>转换速度越慢，那么<code>AD</code>转换的精度就越高。</li>
<li>注意<code>STM32</code>的<code>ADC</code>功能的触发模块(可允许外部触发，也可以允许内部定时器触发)。</li>
<li><code>STM32</code>的<code>ADC</code>转换模式：单次(对单个端口只转换一次)、连续(对端口连续转换多次)、扫描(对多个端口进行扫描)和中断。</li>
<li>自动注入(<code>IAUTO</code>)将规则组与注入组规为一组。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/19/ucos和ucgui/STM32的ucgui移植/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/19/ucos和ucgui/STM32的ucgui移植/" itemprop="url">STM32的ucgui移植</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T09:18:14+08:00">
                2019-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;这里移植的是<code>UCGUI3.90a</code>版本，虽然已经有更新的版本，例如<code>UCGUI3.98</code>、甚至<code>4.04</code>版本，但目前只有这个版本的代码是最全的，包括<code>JPEG</code>、<code>MULTILAYER</code>、<code>MEMDEV</code>、<code>AntiAlias</code>等模块。<br>&emsp;&emsp;<code>UCGUI</code>的文件数量很大，主要用到<code>UCGUI390a/Start/Config</code>和<code>UCGUI390a/Start/GUI</code>两个文件夹下文件，相关文件介绍如下。将<code>Config</code>和<code>GUI</code>下的所有文件加入工程，这是<code>UCGUI</code>官方推荐的结构：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>目录</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Config</code></td>
<td>配置文件</td>
</tr>
<tr>
<td><code>GUI/AntiAlias</code></td>
<td>抗锯齿支持</td>
</tr>
<tr>
<td><code>GUI/ConvertMono</code></td>
<td>用于<code>B/W</code>(黑白两色)以及灰度显示的色彩转换程序</td>
</tr>
<tr>
<td><code>GUI/ConvertColor</code></td>
<td>用于彩色显示的色彩转换程序</td>
</tr>
<tr>
<td><code>GUI/Core</code></td>
<td>UCGUI内核文件</td>
</tr>
<tr>
<td><code>GUI/Font</code></td>
<td>字体文件</td>
</tr>
<tr>
<td><code>GUI/LCDDriver</code></td>
<td>LCD驱动</td>
</tr>
<tr>
<td><code>GUI/Mendev</code></td>
<td>存储器件支持</td>
</tr>
<tr>
<td><code>GUI/Touch</code></td>
<td>触摸屏支持</td>
</tr>
<tr>
<td><code>GUI/Widget</code></td>
<td>视窗控件库</td>
</tr>
<tr>
<td><code>GUI/WM</code></td>
<td>视窗管理器</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;<code>JPEG</code>、<code>MemDev</code>、<code>MultiLayer</code>、<code>Widget</code>和<code>Wm</code>这<code>5</code>个文件夹的内容可以暂时不加入<code>MDK</code>工程，因为这些文件起到的是扩展功能。<code>ConverMono</code>、<code>ConverColor</code>、<code>Core</code>、<code>Font</code>这四个目录下的文件是不用修改的，要修改的文件在<code>LCDDriver</code>、<code>Config</code>这两个目录下的内容。<code>LCDDriver</code>是<code>LCD</code>的驱动接口函数文件，需要将自己的<code>LCD</code>驱动函数提供给<code>UCGUI</code>调用。需要提供<code>3</code>个<code>LCD</code>底层驱动函数：</p>
<ul>
<li><code>void LCD_L0_SetPixelIndex ( int x, int y, int PixelIndex )</code>：<code>LCD</code>画点函数，用指定颜色填充一个像素。</li>
<li><code>unsigned int LCD_L0_GetPixelIndex ( int x, int y )</code>：<code>LCD</code>读取定点颜色函数，读取一个像素点的<code>16</code>位<code>RGB</code>颜色值。</li>
<li><code>void LCD_L0_FillRect ( int x0, int y0, int x1, int y1 )</code>：矩形填充函数，用指定颜色填充一个矩形。这个函数也可以不改，使用<code>UCGUI</code>的函数，用一个一个的像素点填充成一个矩形。也可以在底层驱动根据像素个数直接往<code>GRAM</code>中写数据，封装成函数，供这个函数调用，速度会快很多。</li>
</ul>
<p>&emsp;&emsp;<code>LCDDriver</code>下有三个文件，即<code>LCDDummy.c</code>、<code>LCDNull.c</code>和<code>LCDWin.c</code>，它们都是<code>UCGUI</code>的<code>LCD</code>接口模板文件。以<code>LCDDummy.c</code>为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LCD_Private.h"</span> <span class="comment">/* private modul definitions &amp; config */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GUI_Private.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GUIDebug.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/* #if (LCD_CONTROLLER == -1) \</span></span><br><span class="line"><span class="comment">    &amp;&amp; (!defined(WIN32) | defined(LCD_SIMCONTROLLER)) */</span> <span class="comment">/* 必须注释，否则不会编译 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ili93xx.h"</span> <span class="comment">/* 包含你的LCD驱动函数声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (LCD_CONTROLLER == -1) <span class="comment">/* 这句对应“Config/LCDConf.h” */</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCD_L0_SetPixelIndex</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> PixelIndex )</span> </span>&#123;</span><br><span class="line">    POINT_COLOR = PixelIndex; <span class="comment">/* 我的画点函数使用了一个全局变量设定颜色 */</span></span><br><span class="line">    LCD_DrawPoint ( x, y ); <span class="comment">/* 画点函数 */</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">LCD_L0_GetPixelIndex</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LCD_ReadPoint ( x, y ); <span class="comment">/* 我的读取像素颜色函数 */</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCD_L0_FillRect</span> <span class="params">( <span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1 )</span> </span>&#123;</span><br><span class="line">    LCD_Fill ( x0, y0, x1, y1, LCD_COLORINDEX ); <span class="comment">/* 填充矩形函数 */</span></span><br><span class="line">    <span class="comment">/*------------------------</span></span><br><span class="line"><span class="comment">    for ( ; y0 &lt;= y1; y0++ ) &#123;</span></span><br><span class="line"><span class="comment">        LCD_L0_DrawHLine ( x0, y0, x1 );</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    ------------------------*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UCGUI</code>提供了一些<code>LCD</code>控制器的驱动函数，但是这种配置方法可以适用于任何控制<code>IC</code>。<br>&emsp;&emsp;接下来修改<code>Config</code>文件夹下文件，即<code>GUIConf.h</code>、<code>LCDConf.h</code>和<code>GUITouchConf.h</code>。还需要加入一个<code>GUI_X.c</code>文件，否则编译时会有错误，直接复制<code>UCGUI390a\Sample\GUI_X\GUI_X.c</code>即可。如果打开了触摸功能，还需要加入<code>UCGUI390a\Sample\GUI_X\GUI_X_Touch.c</code>。这三个文件是<code>UCGUI</code>的上层配置文件，也就是<code>GUI</code>一些功能的开关。<br>&emsp;&emsp;<code>GUIConf.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUICONF_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUICONF_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUI_OS              (0) <span class="comment">/* 操作系统的支持，当用到ucos时需要打开 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUI_SUPPORT_TOUCH   (0) <span class="comment">/* 触摸屏的支持 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUI_SUPPORT_UNICODE (0) <span class="comment">/* 用汉字库时再打开 */</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUI_DEFAULT_FONT   &amp;GUI_Font6x8 <span class="comment">/* 定义字体大小 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUI_ALLOC_SIZE     12500 <span class="comment">/* 分配的动态内存空间 */</span></span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*         Configuration of available packages</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUI_WINSUPPORT     0 <span class="comment">/* 窗口功能支持  要使用指针图标时必须打开 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUI_SUPPORT_MEMDEV 0 <span class="comment">/* 内存管理 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUI_SUPPORT_AA     0 <span class="comment">/* 抗锯齿功能，打开后可以提高显示效果 */</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* Avoid multiple inclusion */</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>LCDConf.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LCDCONF_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCDCONF_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_XSIZE  (320) <span class="comment">/* lcd的水平分辨率 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_YSIZE  (480) <span class="comment">/* lcd的垂直分辨率 */</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_BITSPERPIXEL (16) <span class="comment">/* 16位颜色RGB值(颜色深度) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_SWAP_RB      (1)  <span class="comment">/* 红蓝反色交换 */</span></span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/* lcd控制器的具体型号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 设置为“-1”时，会编译LCDDriver下的LCDDummy.c</span></span><br><span class="line"><span class="comment"> * 设置为“-2”时，会编译LCDDriver下的LCDNull.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 还需要修改LCDDriver下文件的宏定义才可以被编译</span></span><br><span class="line"><span class="comment"> * eg. LCDDummy.c：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * #if (LCD_CONTROLLER == -1) &amp;&amp; (!defined(WIN32) |defined(LCD_SIMCONTROLLER))</span></span><br><span class="line"><span class="comment"> * 改为#if (LCD_CONTROLLER == -1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_CONTROLLER  -1 <span class="comment">/* 设置为“-1”或“-2”，因为UCGUI没有相应LCD控制IC驱动 */</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_INIT_CONTROLLER() LCD_Config(); <span class="comment">/* 绑定相关LCD底层驱动的初始化函数 */</span></span></span><br></pre></td></tr></table></figure>
<p>配置完这两个文件，如果不启用触摸屏的话，UCGUI已经可以正常运行。<br>&emsp;&emsp;先修改主函数，添加<code>#include &quot;GUI.h&quot;</code>，在<code>main</code>里添加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GUI_Init();</span><br><span class="line">GUI_SetBkColor ( GUI_BLUE );</span><br><span class="line">GUI_SetColor ( GUI_RED );</span><br><span class="line">GUI_Clear();</span><br><span class="line">GUI_DrawCircle ( <span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span> ); <span class="comment">/* 画圆 */</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> );</span><br></pre></td></tr></table></figure>
<p>要实现横屏效果，首先让显示屏基本驱动实现横屏，然后将<code>LCDConf.h</code>中的<code>LCD_XSIZE</code>和<code>LCD_YSIZE</code>进行互换。<br>&emsp;&emsp;下面讲解<code>UCGUI</code>触摸屏的配置。在<code>ucgui</code>的<code>Config</code>目录中添加<code>GUI_X_Touch.c</code>，然后将<code>GUIConf.h</code>文件中的<code>GUI_WINSUPPORT</code>和<code>GUI_SUPPORT_TOUCH</code>设置为<code>1</code>。配置<code>GUIToucConf.h</code>文件(下面的配置是针对<code>320 * 240</code>的<code>2.8</code>寸<code>TFT LCD</code>，上面的是针对<code>480 * 320</code>的<code>TFT LCD</code>)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUITOUCH_CONF_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUITOUCH_CONF_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUI_TOUCH_AD_LEFT     0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUI_TOUCH_AD_RIGHT    240</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUI_TOUCH_AD_TOP      0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUI_TOUCH_AD_BOTTOM   320</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUI_TOUCH_SWAP_XY    0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUI_TOUCH_MIRROR_X   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUI_TOUCH_MIRROR_Y   0</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>UCGUI</code>触摸屏驱动接口函数文件<code>GUI_X_Touch.c</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GUI.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GUI_X.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"touch.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GUI_TOUCH_X_ActivateX</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GUI_TOUCH_X_ActivateY</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">GUI_TOUCH_X_MeasureX</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    Convert_Pos();</span><br><span class="line">    <span class="keyword">return</span> Pen_Point.X0;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">GUI_TOUCH_X_MeasureY</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    Convert_Pos();</span><br><span class="line">    <span class="keyword">return</span> Pen_Point.Y0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对<code>main</code>函数进行如下修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"usart.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GUI.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"touch.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    SystemInit();</span><br><span class="line">    delay_init ( <span class="number">72</span> );</span><br><span class="line">    NVIC_Configuration();</span><br><span class="line">    uart_init ( <span class="number">9600</span> );</span><br><span class="line">    LED_Init();</span><br><span class="line">    GUI_Init();</span><br><span class="line">    Touch_Init();</span><br><span class="line">    GUI_SetBkColor ( GUI_RED ); <span class="comment">/* 设置背景颜色 */</span></span><br><span class="line">    GUI_SetColor ( GUI_WHITE ); <span class="comment">/* 设置前景颜色，即字体和绘图的颜色 */</span></span><br><span class="line">    GUI_Clear(); <span class="comment">/* 按指定颜色清屏 */</span></span><br><span class="line">    GUI_DispStringAt ( <span class="string">"Hello World .."</span>, <span class="number">10</span>, <span class="number">10</span> ); <span class="comment">/* 显示字符 */</span></span><br><span class="line">    GUI_CURSOR_Show(); <span class="comment">/* 显示鼠标来测试触摸屏，必须打开窗口功能GUI_WINSUPPORT */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        GUI_TOUCH_Exec(); <span class="comment">/* 调用UCGUI的TOUCH相关函数 */</span></span><br><span class="line">        GUI_Exec(); <span class="comment">/* GUI事件更新 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;触摸屏横屏的方法如下：<br>&emsp;&emsp;1. 修改<code>LCD</code>的默认显示方向：<code>LCD</code>的驱动文件里有个<code>LCD_MyInit</code>函数，用于初始化<code>LCD</code>。该函数中有个<code>LCD_Display_Dir</code>函数，用于切换<code>LCD</code>的显示方向，根据需要选择：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LCD_Display_Dir ( <span class="number">1</span> ); <span class="comment">/* 0为竖屏，1为横屏 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 修改<code>ucgui</code>中对应于触摸的坐标检测函数：<code>GUI_X_Touch.c</code>有两个检测触摸的函数，即<code>GUI_TOUCH_X_MeasureX</code>与<code>GUI_TOUCH_X_MeasureY</code>。如果是竖屏显示，<code>GUI_TOUCH_X_MeasureX</code>返回<code>X</code>坐标，<code>GUI_TOUCH_X_MeasureY</code>返回<code>Y</code>坐标，横屏显示的话反过来就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GUI_TOUCH_X_MeasureX</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    tp_dev.scan ( <span class="number">0</span> );</span><br><span class="line">    <span class="comment">// return tp_dev.x; /* 竖屏显示 */</span></span><br><span class="line">    <span class="keyword">return</span> tp_dev.y; <span class="comment">/* 横屏显示 */</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GUI_TOUCH_X_MeasureY</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    tp_dev.scan ( <span class="number">0</span> );</span><br><span class="line">    <span class="comment">// return tp_dev.y; /* 竖屏显示 */</span></span><br><span class="line">    <span class="keyword">return</span> tp_dev.x; <span class="comment">/* 横屏显示 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3. 修改<code>ucgui</code>中触摸屏的相关设置：在<code>LCDConf.h</code>中修改<code>LCD_XSIZE</code>与<code>LCD_YSIZE</code>，在<code>GUITouchConf.h</code>中修改<code>GUI_TOUCH_AD_RIGHT</code>与<code>GUI_TOUCH_AD_BOTTOM</code>。如果<code>X</code>轴触摸是反的，需要修改一下<code>GUI_TOUCH_MIRROR</code>。</p>
<p>&emsp;&emsp;如果需要将<code>UCOS</code>系统移植到<code>ucgui</code>上，可以参考以下步骤：<br>&emsp;&emsp;1. 首先将<code>ucos</code>系统移植到<code>STM32</code>上，并通过信号量、消息邮箱等机制的测试。<br>&emsp;&emsp;2. 将<code>GUIConf.h</code>文件中的<code>GUI_OS</code>设置为<code>1</code>，同时在<code>Config</code>文件夹下添加<code>GUI_X_uCOS.c</code>文件，并加入到工程中。<br>&emsp;&emsp;3. 将<code>GUI_X_uCOS.c</code>文件中的<code>GUI_X_ExecIdle</code>函数改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GUI_X_ExecIdle</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="comment">//OS_X_Delay ( 1 );</span></span><br><span class="line">    OSTimeDly ( <span class="number">50</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时在该文件中增加宏定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE  0</span></span><br></pre></td></tr></table></figure>
<p>将<code>GUI_X.c</code>文件中的如下<code>4</code>个函数注释掉：</p>
<ul>
<li><code>GUI_X_GetTime(void);</code></li>
<li><code>GUI_X_Delay(int ms);</code></li>
<li><code>GUI_X_Init(void);</code></li>
<li><code>GUI_X_ExecIdle(void);</code></li>
</ul>
<p>最后将<code>TFT</code>显示屏中的延时函数用<code>ucos</code>的延时函数替代，延时毫秒的(如<code>delay_ms</code>)用<code>OSTimeDly</code>替代，延时微秒的(如<code>delay_us</code>)用<code>OSTimeDly(1);</code>替代。至此所有移植工作结束！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/19/ucos和ucgui/ucos在STM32上的移植/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/19/ucos和ucgui/ucos在STM32上的移植/" itemprop="url">ucos在STM32上的移植</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T08:49:39+08:00">
                2019-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>UCOS-II</code>由<code>Micrium</code>公司提供，是一个可移植、可固化的、可裁剪的、占先式多任务实时内核，它适用于多种微处理器、微控制器和数字处理芯片。同时，该系统源代码开放、注释详尽，适合系统开发。<code>UCOS-II</code>已经通过联邦航空局(<code>FAA</code>)商用航行器认证，符合航空无线电技术委员会(<code>RTCA</code>)的<code>DO-178B</code>标准。<br>&emsp;&emsp;<code>UCOS-II</code>的架构如下：</p>
<p><img src="/2019/03/19/ucos和ucgui/ucos在STM32上的移植/1.png" height="295" width="344"></p>
<p>&emsp;&emsp;<strong>Step one</strong>：下面这几个文件可以完全不用修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------</span><br><span class="line">|core: os_core.c</span><br><span class="line">|  os: os_flag.c  os_mbox.c</span><br><span class="line">|      os_mem.c   os_mutex.c</span><br><span class="line">|      os_q.c     os_sem.c</span><br><span class="line">|      os_task.c  os_time.c</span><br><span class="line">|      os_tmr.c</span><br><span class="line">|head: ucos_ii.h</span><br><span class="line">+----------------------------</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>Step two</strong>：<code>os_ports</code>在<code>uCOS-II\Ports\ARM-Cortex-M3\Generic\IAR</code>目录下。对于<code>os_cpu_c.c</code>文件，<code>stm32</code>的启动代码里有部分函数和该文件重复了，所以要把重复的代码删除，并在<code>os_cpu.h</code>中注释掉它们的外部声明。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_CPU_CM3_NVIC_ST_CTRL    (*((volatile INT32U *)0xE000E010uL)) <span class="comment">/* SysTick Ctrl &amp; Status Reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_CPU_CM3_NVIC_ST_RELOAD  (*((volatile INT32U *)0xE000E014uL)) <span class="comment">/* SysTick Reload  Value Reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_CPU_CM3_NVIC_ST_CURRENT (*((volatile INT32U *)0xE000E018uL)) <span class="comment">/* SysTick Current Value Reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_CPU_CM3_NVIC_ST_CAL     (*((volatile INT32U *)0xE000E01CuL)) <span class="comment">/* SysTick Cal     Value Reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_CPU_CM3_NVIC_PRIO_ST    (*((volatile INT8U  *)0xE000ED23uL)) <span class="comment">/* SysTick Handler Prio  Reg. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_CPU_CM3_NVIC_ST_CTRL_COUNT                    0x00010000uL   <span class="comment">/* Count flag.                */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_CPU_CM3_NVIC_ST_CTRL_CLK_SRC                  0x00000004uL   <span class="comment">/* Clock Source.              */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_CPU_CM3_NVIC_ST_CTRL_INTEN                    0x00000002uL   <span class="comment">/* Interrupt enable.          */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_CPU_CM3_NVIC_ST_CTRL_ENABLE                   0x00000001uL   <span class="comment">/* Counter mode.              */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_CPU_CM3_NVIC_PRIO_MIN                               0xFFu    <span class="comment">/* Min handler prio.          */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OS_CPU_SysTickHandler</span> <span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OS_CPU_SysTickInit</span> <span class="params">( INT32U  cnts )</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在<code>os_cpu.h</code>文件中，同样把下面几个外部声明的函数注释掉：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">/* See OS_CPU_C.C */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OS_CPU_SysTickHandler</span> <span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OS_CPU_SysTickInit</span> <span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line"><span class="comment">/* See BSP.C */</span></span><br><span class="line"><span class="function">INT32U <span class="title">OS_CPU_SysTickClkFreq</span> <span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>os_cpu_a.asm</code>是汇编代码。由于它里面有部分指令集不适合stm32，所以要进行如下修改：</p>
<ul>
<li>将所有的<code>PUBLIC</code>改为<code>EXPORT</code>。</li>
<li>把对齐部分也改一下，也是因为指令集不匹配：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;       RSEG CODE:CODE:NOROOT(<span class="number">2</span>)</span><br><span class="line">    PRESERVE8</span><br><span class="line">    AREA |.text|, CODE, READONLY, ALIGN=<span class="number">2</span></span><br><span class="line">    THUMB</span><br><span class="line">    REQUIRE8</span><br></pre></td></tr></table></figure>
<p>注意，<code>AREA</code>不能顶头写，这是规定，不然会编译出错。<br>&emsp;&emsp;在<code>os_dbg.c</code>文件中，把<code>#define OS_COMPILER_OPT __root</code>改为<code>#define OS_COMPILER_OPT //__root</code>。<br>&emsp;&emsp;<strong>Step three</strong>：将<code>ST</code>的官方库导进去即可。<br>&emsp;&emsp;<strong>Step four</strong>：在<code>startup_stm32f10x_hd.s</code>文件中，将<code>PendSV_Handler</code>替换成<code>OS_CPU_PendSVHandler</code>。在<code>stm32f10x_it.c</code>文件中加头文件<code>ucos_ii.h</code>，并添加如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_Handler</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    OSIntEnter(); <span class="comment">/* 进入中断 */</span></span><br><span class="line">    OSTimeTick(); <span class="comment">/* 调用ucos的时钟服务程序 */</span></span><br><span class="line">    OSIntExit(); <span class="comment">/* 触发任务切换软中断 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>os_cfg.h</code>中对部分功能进行剪裁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_FLAG_EN        0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_MBOX_EN        0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_MEM_EN         0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_MUTEX_EN       0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_Q_EN           0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_SEM_EN         0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_TMR_EN         0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_DEBUG_EN       0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_APP_HOOKS_EN   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_EVENT_MULTI_EN 0</span></span><br></pre></td></tr></table></figure>
<p>至此系统移植完成了。下面就是写自己的<code>app</code>，<code>main.c</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"usart.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x_conf.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ucos_ii.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STARTUP_TASK_PRIO     8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STARTUP_TASK_STK_SIZE 80</span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_init</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    SysTick_Config ( SystemCoreClock / OS_TICKS_PER_SEC );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestLed1</span> <span class="params">( <span class="keyword">void</span> *p_arg )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        LED0 = !LED0;</span><br><span class="line">        OSTimeDlyHMSM ( <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestLed2</span> <span class="params">( <span class="keyword">void</span> *p_arg )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"hello\r\n"</span> );</span><br><span class="line">        OSTimeDlyHMSM ( <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">static</span> OS_STK task_testled1[STARTUP_TASK_STK_SIZE];</span><br><span class="line"><span class="keyword">static</span> OS_STK task_testled2[STARTUP_TASK_STK_SIZE];</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    SysTick_init();</span><br><span class="line">    LED_Init();</span><br><span class="line">    uart_init ( <span class="number">9600</span> );</span><br><span class="line">    OSInit();</span><br><span class="line">    OSTaskCreate ( TestLed1, ( <span class="keyword">void</span> * ) <span class="number">0</span>, &amp;task_testled1[STARTUP_TASK_STK_SIZE - <span class="number">1</span>], STARTUP_TASK_PRIO - <span class="number">1</span> );</span><br><span class="line">    OSTaskCreate ( TestLed2, ( <span class="keyword">void</span> * ) <span class="number">0</span>, &amp;task_testled2[STARTUP_TASK_STK_SIZE - <span class="number">1</span>], STARTUP_TASK_PRIO );</span><br><span class="line">    OSStart();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/19/ucos和ucgui/ucgui添加自定义汉字库/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/19/ucos和ucgui/ucgui添加自定义汉字库/" itemprop="url">ucgui添加自定义汉字库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T08:08:59+08:00">
                2019-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;首先打开<code>ucgui_font.exe</code>，然后点击<code>选择字体</code>，选择你需要的字体，并设置字形及大小。<br>&emsp;&emsp;接着输入生成的文件的名字(不要含中文)，这里输入的文件名是<code>ailson_jack_font</code>。点击<code>指定范围导出GBK码</code>按钮，然后在弹出的窗口里面输入你自己要定义的汉字库。</p>
<p><img src="/2019/03/19/ucos和ucgui/ucgui添加自定义汉字库/1.png" height="255" width="640"></p>
<p>&emsp;&emsp;输入完后点击<code>确定</code>按钮，即可在<code>ucgui_font.exe</code>所在文件夹里生成一个<code>.c</code>文件，然后将这个<code>.c</code>文件添加到你的工程里。在<code>main</code>函数所在的文件中添加如下内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUI_FLASH</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GUI_FLASH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">extern</span> GUI_FLASH <span class="keyword">const</span> GUI_FONT GUI_FontHZ_ailson_jack_font;</span><br></pre></td></tr></table></figure>
<p>在<code>main</code>函数里面输入如下代码，即可调用刚才生成的<code>.c</code>文件字库：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GUI_Init(); <span class="comment">/* GUI初始化 */</span></span><br><span class="line">GUI_SetBkColor ( GUI_GYAN ); <span class="comment">/* 设置背景颜色 */</span></span><br><span class="line">GUI_SetColor ( GUI_RED ); <span class="comment">/* 设置前景颜色 */</span></span><br><span class="line">GUI_Clear(); <span class="comment">/* 按指定颜色清屏 */</span></span><br><span class="line">GUI_SetFont ( &amp;GUI_FontHZ_ailson_jack_font );</span><br><span class="line">GUI_DispStringAt ( <span class="string">"自定义汉字库"</span>, <span class="number">12</span>, <span class="number">70</span> );</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/94/">94</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">939</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
