<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="暴徒">
<meta property="og:url" content="http://fukangwei.gitee.io/page/65/index.html">
<meta property="og:site_name" content="暴徒">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="暴徒">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/65/">





  <title>暴徒</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">暴徒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/opencv和图像处理/cvSeq的用法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/opencv和图像处理/cvSeq的用法/" itemprop="url">cvSeq的用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T18:13:46+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/opencv和图像处理/" itemprop="url" rel="index">
                    <span itemprop="name">opencv和图像处理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="cvCreateSeq"><a href="#cvCreateSeq" class="headerlink" title="cvCreateSeq"></a>cvCreateSeq</h3><p>&emsp;&emsp;该函数的功能是创建一个序列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CvSeq *<span class="title">cvCreateSeq</span> <span class="params">(<span class="keyword">int</span> seq_flags, <span class="keyword">int</span> header_size, <span class="keyword">int</span> elem_size, CvMemStorage *storage)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>seq_flags</code>：它是序列的符号标志。如果序列不会被传递给任何使用特定序列的函数，那么将它设为<code>0</code>，否则从预定义的序列类型中选择一合适的类型。</li>
<li><code>header_size</code>：它是序列头部的大小，其值必须大于或等于<code>sizeof(CvSeq)</code>。如果制定了类型或它的扩展名，则此类型必须适合基类的头部大小。</li>
<li><code>elem_size</code>：它是元素的大小，以字节计算。这个大小必须与序列类型(由<code>seq_flags</code>指定)相一致。例如对于一个点的序列，元素类型<code>CV_SEQ_ELTYPE_POINT</code>应当被指定，参数<code>elem_size</code>必须等同于<code>sizeof(CvPoint)</code>。</li>
<li><code>storage</code>：它指向前面定义的内存存储器。</li>
</ul>
<h3 id="cvCloneSeq"><a href="#cvCloneSeq" class="headerlink" title="cvCloneSeq"></a>cvCloneSeq</h3><p>&emsp;&emsp;该函数的作用是创建序列的一份拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CvSeq *<span class="title">cvCloneSeq</span> <span class="params">( <span class="keyword">const</span> CvSeq *seq, CvMemStorage *storage = <span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqInvert"><a href="#cvSeqInvert" class="headerlink" title="cvSeqInvert"></a>cvSeqInvert</h3><p>&emsp;&emsp;该函数的作用是将序列中的元素进行逆序操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSeqInvert</span> <span class="params">( CvSeq *seq )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqSort"><a href="#cvSeqSort" class="headerlink" title="cvSeqSort"></a>cvSeqSort</h3><p>&emsp;&emsp;该函数的功能是使用特定的比较函数对序列中的元素进行排序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSeqSort</span> <span class="params">( CvSeq *seq, CvCmpFunc func, <span class="keyword">void</span> *userdata = <span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqSearch"><a href="#cvSeqSearch" class="headerlink" title="cvSeqSearch"></a>cvSeqSearch</h3><p>&emsp;&emsp;该函数的功能是查询序列中的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">cvSeqSearch</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    CvSeq *seq, <span class="keyword">const</span> <span class="keyword">void</span> *elem, CvCmpFunc func,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> is_sorted, <span class="keyword">int</span> *elem_idx, <span class="keyword">void</span> *userdata = <span class="literal">NULL</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvClearSeq"><a href="#cvClearSeq" class="headerlink" title="cvClearSeq"></a>cvClearSeq</h3><p>&emsp;&emsp;其函数的功能是清空序列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvClearSeq</span> <span class="params">( CvSeq *seq )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqPush"><a href="#cvSeqPush" class="headerlink" title="cvSeqPush"></a>cvSeqPush</h3><p>&emsp;&emsp;该函数的功能是添加元素到序列的尾部：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">cvSeqPush</span> <span class="params">( CvSeq *seq, <span class="keyword">void</span> *element = <span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqPop"><a href="#cvSeqPop" class="headerlink" title="cvSeqPop"></a>cvSeqPop</h3><p>&emsp;&emsp;该函数的作用是删除序列尾部元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSeqPop</span> <span class="params">( CvSeq *seq, <span class="keyword">void</span> *element = <span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqPushFront"><a href="#cvSeqPushFront" class="headerlink" title="cvSeqPushFront"></a>cvSeqPushFront</h3><p>&emsp;&emsp;该函数的作用是在序列头部添加元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">cvSeqPushFront</span> <span class="params">( CvSeq *seq, <span class="keyword">void</span> *element = <span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqPopFront"><a href="#cvSeqPopFront" class="headerlink" title="cvSeqPopFront"></a>cvSeqPopFront</h3><p>&emsp;&emsp;其函数的作用是删除在序列的头部的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSeqPopFront</span> <span class="params">( CvSeq *seq, <span class="keyword">void</span> *element = <span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqPushMulti"><a href="#cvSeqPushMulti" class="headerlink" title="cvSeqPushMulti"></a>cvSeqPushMulti</h3><p>&emsp;&emsp;其函数的作用是添加多个元素到序列尾部或头部：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSeqPushMulti</span> <span class="params">( CvSeq *seq, <span class="keyword">void</span> *elements, <span class="keyword">int</span> count, <span class="keyword">int</span> in_front = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqPopMulti"><a href="#cvSeqPopMulti" class="headerlink" title="cvSeqPopMulti"></a>cvSeqPopMulti</h3><p>&emsp;&emsp;其函数作用是删除多个序列头部或尾部元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSeqPopMulti</span> <span class="params">( CvSeq *seq, <span class="keyword">void</span> *elements, <span class="keyword">int</span> count, <span class="keyword">int</span> in_front = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqInsert"><a href="#cvSeqInsert" class="headerlink" title="cvSeqInsert"></a>cvSeqInsert</h3><p>&emsp;&emsp;该函数的作用是在序列中的指定位置添加元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">cvSeqInsert</span> <span class="params">( CvSeq *seq, <span class="keyword">int</span> before_index, <span class="keyword">void</span> *element = <span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqRemove"><a href="#cvSeqRemove" class="headerlink" title="cvSeqRemove"></a>cvSeqRemove</h3><p>&emsp;&emsp;其函数的作用是删除序列中的指定位置的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSeqRemove</span> <span class="params">( CvSeq *seq, <span class="keyword">int</span> index )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvGetSeqElem"><a href="#cvGetSeqElem" class="headerlink" title="cvGetSeqElem"></a>cvGetSeqElem</h3><p>&emsp;&emsp;其函数的作用是返回索引所指定的元素指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">cvGetSeqElem</span> <span class="params">( <span class="keyword">const</span> CvSeq *seq, <span class="keyword">int</span> index )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqElemIdx"><a href="#cvSeqElemIdx" class="headerlink" title="cvSeqElemIdx"></a>cvSeqElemIdx</h3><p>&emsp;&emsp;其函数的作用是返回序列中元素的索引：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cvSeqElemIdx</span> <span class="params">( <span class="keyword">const</span> CvSeq *seq, <span class="keyword">const</span> <span class="keyword">void</span> *element, CvSeqBlock **block = <span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvStartAppendToSeq"><a href="#cvStartAppendToSeq" class="headerlink" title="cvStartAppendToSeq"></a>cvStartAppendToSeq</h3><p>&emsp;&emsp;其函数的作用是将数据写入序列中，并初始化该过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvStartAppendToSeq</span> <span class="params">( CvSeq *seq, CvSeqWriter *writer )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvStartWriteSeq"><a href="#cvStartWriteSeq" class="headerlink" title="cvStartWriteSeq"></a>cvStartWriteSeq</h3><p>&emsp;&emsp;其函数的作用是创建新序列，并初始化写入部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvStartWriteSeq</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> seq_flags, <span class="keyword">int</span> header_size, <span class="keyword">int</span> elem_size,</span></span></span><br><span class="line"><span class="function"><span class="params">    CvMemStorage *storage, CvSeqWriter *writer)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvEndWriteSeq"><a href="#cvEndWriteSeq" class="headerlink" title="cvEndWriteSeq"></a>cvEndWriteSeq</h3><p>&emsp;&emsp;其函数的作用是完成写入操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CvSeq *<span class="title">cvEndWriteSeq</span> <span class="params">( CvSeqWriter *writer )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvStartReadSeq"><a href="#cvStartReadSeq" class="headerlink" title="cvStartReadSeq"></a>cvStartReadSeq</h3><p>&emsp;&emsp;其函数的作用是初始化序列中的读取过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvStartReadSeq</span> <span class="params">( <span class="keyword">const</span> CvSeq *seq, CvSeqReader *reader, <span class="keyword">int</span> reverse = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>&emsp;&emsp;一直困惑于<code>CvSeq</code>到底是个什么样的东西，因为曾经拿到别人写的一个函数库，其返回值是一个<code>CvSeq</code>指针。我的任务是遍历所有的<code>Sequence</code>，然后删除其中不符合要求的<code>Sequence</code>。由于没有文档，我当时并不知道需要遍历的是<code>Sequence</code>还是<code>Sequence</code>中的<code>Element</code>，于是写下了类似如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CvSeq *pCurSeq = pInputSeq;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( pCurSeq = pCurSeq-&gt;h_next ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( process ( pCurSeq ) ) &#123;</span><br><span class="line">        pCurSeq = pCurSeq-&gt;h_prev; <span class="comment">/* 这里为了简单，不考虑是否为列表头 */</span></span><br><span class="line">        cvSeqRemove ( pInputSeq, index );</span><br><span class="line">        --index;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    ++index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实证明这段代码是错误的，而且返回的错误信息是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; OpenCV ERROR: One of arguments<span class="string">' values is out of range (Invalid index)</span></span><br><span class="line"><span class="string">&gt; in function cvSeqRemove, cxdatastructs.cpp(1587)</span></span><br></pre></td></tr></table></figure>
<p>为什么会有这样的错误呢？看一下<code>CvSeq</code>的源代码就清楚了。下面是<code>OpenCV 1.0</code>版本有关<code>CvSeq</code>的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CV_TREE_NODE_FIELDS(node_type)                       \</span></span><br><span class="line">    <span class="keyword">int</span>    flags;             <span class="comment">/* micsellaneous flags */</span>      \</span><br><span class="line">    <span class="keyword">int</span>    header_size;       <span class="comment">/* size of sequence header */</span>  \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_type</span>* <span class="title">h_prev</span>;</span> <span class="comment">/* previous sequence */</span>        \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_type</span>* <span class="title">h_next</span>;</span> <span class="comment">/* next sequence */</span>            \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_type</span>* <span class="title">v_prev</span>;</span> <span class="comment">/* 2nd previous sequence */</span>    \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_type</span>* <span class="title">v_next</span>  /* 2<span class="title">nd</span> <span class="title">next</span> <span class="title">sequence</span> */</span></span><br><span class="line"><span class="class">​</span></span><br><span class="line"><span class="class">/*</span></span><br><span class="line"><span class="class">   <span class="title">Read</span>/<span class="title">Write</span> <span class="title">sequence</span>.</span></span><br><span class="line"><span class="class">   <span class="title">Elements</span> <span class="title">can</span> <span class="title">be</span> <span class="title">dynamically</span> <span class="title">inserted</span> <span class="title">to</span> <span class="title">or</span> <span class="title">deleted</span> <span class="title">from</span> <span class="title">the</span> <span class="title">sequence</span>.</span></span><br><span class="line"><span class="class">*/</span></span><br><span class="line"><span class="class">#<span class="title">define</span> <span class="title">CV_SEQUENCE_FIELDS</span>()                                   \</span></span><br><span class="line"><span class="class">    <span class="title">CV_TREE_NODE_FIELDS</span>(<span class="title">CvSeq</span>);</span>                                \</span><br><span class="line">    <span class="keyword">int</span>   total;       <span class="comment">/* total number of elements */</span>          \</span><br><span class="line">    <span class="keyword">int</span>   elem_size;   <span class="comment">/* size of sequence element in bytes */</span> \</span><br><span class="line">    <span class="keyword">char</span>* block_max;   <span class="comment">/* maximal bound of the last block */</span>   \</span><br><span class="line">    <span class="keyword">char</span>* ptr;         <span class="comment">/* current write pointer */</span>             \</span><br><span class="line">    <span class="keyword">int</span>   delta_elems; <span class="comment">/* how many elements allocated when the seq grows */</span>  \</span><br><span class="line">    CvMemStorage* storage;   <span class="comment">/* where the seq is stored */</span>                   \</span><br><span class="line">    CvSeqBlock* free_blocks; <span class="comment">/* free blocks list */</span>                          \</span><br><span class="line">    CvSeqBlock* first; <span class="comment">/* pointer to the first sequence block */</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CvSeq</span> &#123;</span></span><br><span class="line">    CV_SEQUENCE_FIELDS()</span><br><span class="line">&#125; CvSeq;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;原来<code>CvSeq</code>本身就是一个可增长的序列，<code>CvSeq::total</code>是指序列内部有效元素的个数；而<code>h_next</code>和<code>h_prev</code>并不是指向<code>CvSeq</code>内部元素的指针，它们是指向其它<code>CvSeq</code>的。再回到最初的代码，可以看到该代码具有逻辑上的错误，首先<code>while</code>语句遍历的是所有的<code>CvSeq</code>，使用<code>process</code>处理每一个<code>CvSeq</code>，而遇到需要删除的<code>CvSeq</code>时，又使用<code>cvSeqRemove</code>删除当前<code>CvSeq</code>中的第<code>index</code>个元素。实际上此时<code>index</code>很可能超出了当前<code>CvSeq</code>中总元素的个数，所以出现了超出边界的错误。正确的做法是直接删除该<code>CvSeq</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CvSeq *pCurSeq = pInputSeq;</span><br><span class="line">CvSeq *pOldSeq = <span class="literal">NULL</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( pCurSeq ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( process ( pCurSeq ) ) &#123;</span><br><span class="line">        pOldSeq = pCurSeq;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( pOldSeq-&gt;h_prev ) &#123;</span><br><span class="line">            pCurSeq = pOldSeq-&gt;h_prev;</span><br><span class="line">            pCurSeq-&gt;h_next = pOldSeq-&gt;h_next;</span><br><span class="line">            pOldSeq-&gt;h_next-&gt;h_prev = pCurSeq;</span><br><span class="line">            pCurSeq = pCurSeq-&gt;h_next;</span><br><span class="line">            cvClearSeq ( pOldSeq );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pCurSeq = pOldSeq-&gt;h_next;</span><br><span class="line">            pCurSeq-&gt;h_prev = <span class="literal">NULL</span>;</span><br><span class="line">            cvClearSeq ( pOldSeq );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pCurSeq = pCurSeq-&gt;h_next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;后来在<code>Google Book</code>里查了一下，发现<code>《Learning OpenCV: Computer Vision with the OpenCV Library》</code>中有这么一段话：The sequence structure itself has some important elements that you should be aware of. The first, and one you will use often, is total. This is the total number of points or objects in the sequence. The next four important elements are pointers to other sequence: <code>h_prev</code>, <code>h_next</code>, <code>v_prev</code> and <code>v_next</code>. These four pointers are part of what are called <code>CV_TREE_NODE_FIELDS</code>; they are used not to indicate elements inside of the sequence but rather to connect different sequences to one another. Other objects in the OpenCV universe also contain these tree node fields。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/opencv和图像处理/动态内存存储/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/opencv和图像处理/动态内存存储/" itemprop="url">动态内存存储</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T17:54:03+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/opencv和图像处理/" itemprop="url" rel="index">
                    <span itemprop="name">opencv和图像处理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="CvMemStorage"><a href="#CvMemStorage" class="headerlink" title="CvMemStorage"></a>CvMemStorage</h3><p>&emsp;&emsp;其原型如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CvMemStorage</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CvMemBlock</span> *<span class="title">bottom</span>;</span><span class="comment">/* first allocated block */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CvMemBlock</span> *<span class="title">top</span>;</span> <span class="comment">/* the current memory block - top of the stack */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CvMemStorage</span> *<span class="title">parent</span>;</span> <span class="comment">/* borrows new blocks from */</span></span><br><span class="line">    <span class="keyword">int</span> block_size; <span class="comment">/* block size */</span></span><br><span class="line">    <span class="keyword">int</span> free_space; <span class="comment">/* free space in the top block (in bytes) */</span></span><br><span class="line">&#125; CvMemStorage;</span><br></pre></td></tr></table></figure>
<p>内存存储器是一个可用来存储诸如序列、轮廓、图形、子划分等动态增长数据结构的底层结构。它是由一系列以同等大小的内存块构成，呈列表型：<code>bottom</code>域指的是列首，<code>top</code>域指的是当前指向的块但未必是列尾。在<code>bottom</code>和<code>top</code>之间所有的块(包括<code>bottom</code>，不包括<code>top</code>)被完全占据了空间；在<code>top</code>和列尾之间所有的块(包括块尾，不包括<code>top</code>)则是空的；而<code>top</code>块本身则被占据了部分空间，<code>free_space</code>指的是<code>top</code>块剩余的空字节数。新分配的内存缓冲区(或显式地通过<code>cvMemStorageAlloc</code>函数分配，或隐式地通过<code>cvSeqPush</code>、<code>cvGraphAddEdge</code>等高级函数分配)总是起始于当前块(即<code>top</code>块)的剩余那部分。如果剩余那部分能满足要求(足够分配的大小)，分配后，<code>free_space</code>就减少了新分配的那部分内存大小，外加一些用来保存适当列型的附加大小。当<code>top</code>块的剩余空间无法满足被分配的块(缓冲区)大小时，<code>top</code>块的下一个存储块被置为当前块(新的<code>top</code>块)，<code>free_space</code>被置为先前分配的整个块的大小。如果已经不存在空的存储块(即<code>top</code>块已是列尾)，则必须再分配一个新的块(或从<code>parent</code>那继承，见<code>cvCreateChildMemStorage</code>)并将该块加到列尾上去。于是存储器(<code>memory storage</code>)就如同栈(<code>Stack</code>)那样，<code>bottom</code>指向栈底，<code>(top, free_space)</code>对指向栈顶。栈顶可通过<code>cvSaveMemStoragePos</code>保存，通过<code>cvRestoreMemStoragePos</code>恢复指向，通过<code>cvClearStorage</code>重置。</p>
<h3 id="CvMemBlock"><a href="#CvMemBlock" class="headerlink" title="CvMemBlock"></a>CvMemBlock</h3><p>&emsp;&emsp;其原型如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CvMemBlock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CvMemBlock</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CvMemBlock</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; CvMemBlock;</span><br></pre></td></tr></table></figure>
<p><code>CvMemBlock</code>代表一个单独的内存存储块结构。内存存储块中的实际数据存储在<code>header</code>块之后(即存在一个头指针head指向的块<code>header</code>，该块不存储数据)，于是内存块的第<code>i</code>个字节可以通过表达式<code>((char *)(mem_block_ptr + 1))[i]</code>获得。然而，通常没必要直接去获得存储结构的域。</p>
<h3 id="CvMemStoragePos"><a href="#CvMemStoragePos" class="headerlink" title="CvMemStoragePos"></a>CvMemStoragePos</h3><p>&emsp;&emsp;其原型如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CvMemStoragePos</span> &#123;</span></span><br><span class="line">    CvMemBlock *top;</span><br><span class="line">    <span class="keyword">int</span> free_space;</span><br><span class="line">&#125; CvMemStoragePos;</span><br></pre></td></tr></table></figure>
<p>该结构保存栈顶的地址。栈顶可以通过<code>cvSaveMemStoragePos</code>保存，也可以通过<code>cvRestoreMemStoragePos</code>恢复。</p>
<h3 id="cvCreateMemStorage"><a href="#cvCreateMemStorage" class="headerlink" title="cvCreateMemStorage"></a>cvCreateMemStorage</h3><p>&emsp;&emsp;其作用是创建内存块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CvMemStorage *<span class="title">cvCreateMemStorage</span> <span class="params">( <span class="keyword">int</span> block_size = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>block_size</code>是存储块的大小，它以字节表示。如果大小是<code>0 byte</code>，则将该块设置成默认值，当前默认大小为<code>64k</code>。函数<code>cvCreateMemStorage</code>创建一内存块，并返回指向块首的指针。起初存储块是空的，除了<code>block_size</code>外，头部(即<code>header</code>)的所有域值都为<code>0</code>。</p>
<h3 id="cvReleaseMemStorage"><a href="#cvReleaseMemStorage" class="headerlink" title="cvReleaseMemStorage"></a>cvReleaseMemStorage</h3><p>&emsp;&emsp;其作用是释放内存块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvReleaseMemStorage</span> <span class="params">( CvMemStorage **storage )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>storage</code>指向被释放了的存储块的指针。函数<code>cvReleaseMemStorage</code>释放所有的存储(内存)块或者将它们返回给各自的<code>parent</code>(如果需要的话)。接下来再释放<code>header</code>块(即释放头指针<code>head</code>指向的块<code>free(head)</code>)，并清除指向该块的指针(即<code>head = NULL</code>)。在释放作为<code>parent</code>的块之前，先清除各自的<code>child</code>块。</p>
<h3 id="cvClearMemStorage"><a href="#cvClearMemStorage" class="headerlink" title="cvClearMemStorage"></a>cvClearMemStorage</h3><p>&emsp;&emsp;其作用是清空内存存储块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvClearMemStorage</span> <span class="params">( CvMemStorage *storage )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>storage</code>是存储存储块。函数<code>cvClearMemStorage</code>将存储块的<code>top</code>置到存储块的头部(清空存储块中的存储内容)。该函数并不释放内存，仅清空内存。假使该内存块有一个父内存块(即存在一内存块与其有父子关系)，则函数就将所有的块返回给其<code>parent</code>。</p>
<h3 id="cvMemStorageAlloc"><a href="#cvMemStorageAlloc" class="headerlink" title="cvMemStorageAlloc"></a>cvMemStorageAlloc</h3><p>&emsp;&emsp;其作用是在存储块中分配以内存缓冲区：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">cvMemStorageAlloc</span> <span class="params">( CvMemStorage *storage, <span class="keyword">size_t</span> size )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>storage</code>是内存块，<code>size</code>是缓冲区的大小。函数<code>cvMemStorageAlloc</code>在存储块中分配一内存缓冲区。该缓冲区的大小不能超过内存块的大小，否则就会导致运行时错误。缓冲区的地址被调整为<code>CV_STRUCT_ALIGN</code>字节(当前为<code>sizeof(double)</code>)。</p>
<h3 id="cvMemStorageAllocString"><a href="#cvMemStorageAllocString" class="headerlink" title="cvMemStorageAllocString"></a>cvMemStorageAllocString</h3><p>&emsp;&emsp;其作用是在存储块中分配一文本字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CvString</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">&#125; CvString;</span><br><span class="line">​</span><br><span class="line"><span class="function">CvString <span class="title">cvMemStorageAllocString</span> <span class="params">( CvMemStorage *storage, <span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">int</span> len = <span class="number">-1</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>storage</code>：存储块。</li>
<li><code>ptr</code>：字符串。</li>
<li><code>len</code>：字符串的长度(不计算<code>\0</code>)。如果参数为负数，函数就计算该字符串的长度。</li>
</ul>
<p>函数<code>cvMemStorageAlloString</code>在存储块中创建了一字符串的拷贝。它返回一个结构，该结构包含字符串的长度(该长度或通过用户传递，或通过计算得到)和指向被拷贝了的字符串的指针。</p>
<h3 id="cvSaveMemStoragePos"><a href="#cvSaveMemStoragePos" class="headerlink" title="cvSaveMemStoragePos"></a>cvSaveMemStoragePos</h3><p>&emsp;&emsp;其作用是保存内存块的位置(地址)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSaveMemStoragePos</span> <span class="params">( <span class="keyword">const</span> CvMemStorage *storage, CvMemStoragePos *pos )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>storage</code>是内存块，<code>pos</code>是内存块顶部位置。函数<code>cvSaveMemStoragePos</code>将存储块的当前位置保存到参数<code>pos</code>中。函数<code>cvRestoreMemStoragePos</code>可进一步获取该位置(地址)。</p>
<h3 id="cvRestoreMemStoragePos"><a href="#cvRestoreMemStoragePos" class="headerlink" title="cvRestoreMemStoragePos"></a>cvRestoreMemStoragePos</h3><p>&emsp;&emsp;其作用是恢复内存存储块的位置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvRestoreMemStoragePos</span> <span class="params">( CvMemStorage *storage, CvMemStoragePos *pos )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>storage</code>是内存块，<code>pos</code>是新的存储块的位置。函数<code>cvRestoreMemStoragePos</code>通过参数<code>pos</code>恢复内存块的位置。该函数和函数<code>cvClearMemStorage</code>是释放被占用内存块的唯一方法。注意，没有什么方法可以去释放存储块中被占用的部分内存。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/数学和物理/不可解问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/数学和物理/不可解问题/" itemprop="url">不可解问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T17:41:27+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;不可解问题(<code>Undecidable Decision Problem</code>)指的是这样一种问题：它无论如何也不可能有一个正确的算法来解决。虽然不可思议，但这种问题被证明确实是存在的。图灵在<code>1936</code>年提出了第一个不可解问题的实例：<code>The Halting Problem</code>。<br>&emsp;&emsp;<code>The Halting Problem</code>是指，输入一段程序代码和一个针对此程序的输入，能否编程判断运行这个程序后程序是否会终止。这个问题的答案是否定的，也就是说不可能有一种算法可以正确判断一个指定的程序运行后，给予指定的输入，程序最后出不出得来。换句话说，<code>The Halting Problem</code>是一个不可解问题。<br>&emsp;&emsp;假设我们某一天真做出了这么一个极度聪明的万能算法(就叫<code>God_algo</code>吧)，你只要给它一段程序(二进制描述)，再给它这段程序的输入，它就能告诉你这段程序在这个输入上会不会结束(停机)。我们来编写一下这个算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">God_algo</span> <span class="params">( <span class="keyword">char</span> *program, <span class="keyword">char</span> *input )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( &lt;program&gt; halts on &lt;input&gt; ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里假设<code>if</code>的判断语句里面是天才思考的结晶，它能够像上帝一样洞察一切程序的宿命。现在从这个<code>God_algo</code>出发，导出一个新的算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Satan_algo</span> <span class="params">( <span class="keyword">char</span> *program )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( God_algo ( program, program ) ) &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> ); <span class="comment">/* loop forever! */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* can never get here! */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如它的名字所暗示的那样，这个算法便是一切邪恶的根源了。当我们把这个算法运用到它自身身上时，会发生什么呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Satan_algo ( Satan_algo );</span><br></pre></td></tr></table></figure>
<p>我们来分析一下这行简单的调用：显然<code>Satan_algo(Satan_algo)</code>要么能够运行结束返回(停机)，要么不能返回(<code>loop forever</code>)。如果它能够结束，那么<code>Santa_algo</code>算法里面的那个<code>if</code>判断就会成立(因为<code>God_algo(Santa_algo, Santa_algo</code>)将会返回<code>true</code>)，从而程序便进入那个包含一个无穷循环<code>while(1);</code>的<code>if</code>分支，于是这个<code>Satan_algo(Satan_algo)</code>调用便永远不会返回(结束)了。如果不能结束(停机)，则<code>if</code>判断就会失败，从而选择另一个<code>if</code>分支并返回<code>false</code>，即<code>Satan_algo(Satan_algo)</code>又能够返回(停机)。可以得到如下结论：</p>
<ul>
<li><code>Satan_algo</code>能够停机 =&gt; <code>Satan_algo(Satan_algo)</code>不能停机。</li>
<li><code>Satan_algo</code>不能停机 =&gt; <code>Satan_algo(Satan_algo)</code>能够停机。</li>
</ul>
<p>于是得到矛盾的结果。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/数学和物理/完全平方数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/数学和物理/完全平方数/" itemprop="url">完全平方数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T16:46:33+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;一个正整数如果是另一个整数的完全平方，那么我们就称这个数为<code>完全平方数</code>，也叫做<code>平方数</code>。例如，<code>0</code>、<code>1</code>、<code>4</code>、<code>9</code>、<code>16</code>、<code>25</code>、<code>36</code>、<code>49</code>、<code>64</code>、<code>81</code>、<code>100</code>等。通过对这些完全平方数的观察和分析，我们可以获得一些规律性的认识。下面是完全平方数的一些常用性质：</p>
<ul>
<li>性质<code>1</code>：完全平方数的末位数只能是<code>0</code>、<code>1</code>、<code>4</code>、<code>5</code>、<code>6</code>、<code>9</code>。</li>
<li>性质<code>2</code>：奇数的平方的个位数字为奇数，十位数字为偶数。</li>
<li>性质<code>3</code>：如果完全平方数的十位数字是奇数，则它的个位数字一定是<code>6</code>；反之，如果完全平方数的个位数字是<code>6</code>，则它的十位数字一定是奇数。</li>
<li>性质<code>4</code>：凡个位数字是<code>5</code>，但末两位数字不是<code>25</code>的自然数不是完全平方数；末尾只有奇数个<code>0</code>的自然数(不包括<code>0</code>本身)不是完全平方数；个位数字为<code>1</code>、<code>4</code>、<code>9</code>，而十位数字为奇数的自然数不是完全平方数。</li>
<li>性质<code>5</code>：偶数的平方是<code>4</code>的倍数；奇数的平方是<code>4</code>的倍数加<code>1</code>。</li>
<li>性质<code>6</code>：奇数的平方是<code>8n + 1</code>型；偶数的平方为<code>8k</code>或<code>8k + 4</code>型。</li>
<li>性质<code>7</code>：平方数的形式必为<code>3k</code>或<code>3k + 1</code>之一。</li>
<li>性质<code>8</code>：不能被<code>5</code>整除的数的平方为<code>5k ± 1</code>型，能被<code>5</code>整除的数的平方为<code>5k</code>型。</li>
<li>性质<code>9</code>：平方数的形式具有下列形式之一：<code>16k</code>、<code>16k + 1</code>、<code>16k + 4</code>、<code>16k + 9</code>。</li>
<li>性质<code>10</code>：完全平方数的各位数字之和只能是<code>0</code>、<code>1</code>、<code>4</code>、<code>7</code>、<code>9</code>。</li>
<li>性质<code>11</code>：<code>a^2b</code>为完全平方数的充要条件是<code>b</code>为完全平方数。</li>
<li>性质<code>12</code>：如果质数<code>p</code>能整除<code>a</code>，但<code>p^2</code>不能整除<code>a</code>，则<code>a</code>不是完全平方数。</li>
<li>性质<code>13</code>：在两个相邻的整数的平方数之间的所有整数都不是完全平方数，即若<code>n^2 &lt; k &lt; (n+1)^2</code>，则<code>k</code>一定不是完全平方数。</li>
<li>性质<code>14</code>：一个正整数<code>n</code>是完全平方数的充分必要条件是<code>n</code>有奇数个因子(包括<code>1</code>和<code>n</code>本身)。</li>
<li>性质<code>15</code>：完全平方数的约数个数是奇数个。约数的个数为奇数个的自然数是完全平方数。</li>
<li>性质<code>16</code>：如果质数<code>p</code>能整除<code>a</code>，但<code>p</code>的平方不能整除<code>a</code>，则<code>a</code>不是完全平方数。</li>
</ul>
<p>&emsp;&emsp;与上述性质相对应的几个结论：</p>
<ul>
<li>个位数是<code>2</code>、<code>3</code>、<code>7</code>或<code>8</code>的整数一定不是完全平方数。</li>
<li>个位数和十位数都是奇数的整数一定不是完全平方数。</li>
<li>个位数是<code>6</code>，十位数是偶数的整数一定不是完全平方数。</li>
<li>形如<code>3k + 2</code>型的整数一定不是完全平方数。</li>
<li>形如<code>4k + 2</code>和<code>4k + 3</code>型的整数一定不是完全平方数。</li>
<li>形如<code>5k ± 2</code>型的整数一定不是完全平方数。</li>
<li>形如<code>8k + 2</code>、<code>8k + 3</code>、<code>8k + 5</code>、<code>8k + 6</code>、<code>8k + 7</code>型的整数一定不是完全平方数。</li>
<li>数字和是<code>2</code>、<code>3</code>、<code>5</code>、<code>6</code>、<code>8</code>的整数一定不是完全平方数。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/数学和物理/鲁棒性/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/数学和物理/鲁棒性/" itemprop="url">鲁棒性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T16:32:57+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;鲁棒性/抗变换性(<code>robustness</code>)原是统计学中的一个专门术语，<code>20</code>世纪<code>70</code>年代初开始在控制理论的研究中流行起来，用以表征控制系统对特性或参数扰动的不敏感性。鉴于中文<code>鲁棒性</code>的词义不易被理解，<code>robustness</code>又被翻译成了语义更加易懂的<code>抗变换性</code>。<code>抗变换性</code>和<code>鲁棒性</code>在译文中经常互相通用。<br>&emsp;&emsp;在实际问题中，系统特性或参数的摄动常常是不可避免的。产生摄动的原因主要有两个方面，一个是由于量测的不精确使特性或参数的实际值会偏离它的设计值(<code>标称值</code>)，另一个是系统运行过程中受环境因素的影响而引起特性或参数的缓慢漂移。因此，鲁棒性已成为控制理论中的一个重要的研究课题，也是一切类型的控制系统的设计中所必须考虑的一个基本问题。对鲁棒性的研究主要限于线性定常控制系统，所涉及的领域包括<code>稳定性</code>、<code>无静差性</code>、<code>适应控制</code>等。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&emsp;&emsp;鲁棒性问题与控制系统的<code>相对稳定性</code>(频率域内表征控制系统稳定性裕量的一种性能指标)和<code>不变性原理</code>(自动控制理论中研究扼制和消除扰动对控制系统影响的理论)有着密切的联系，<code>内模原理</code>(把外部作用信号的动力学模型植入控制器来构成高精度反馈控制系统的一种设计原理)的建立则对鲁棒性问题的研究起了重要的推动作用。当系统中存在模型摄动或随机干扰等不确定性因素时能保持其满意功能品质的控制理论和方法称为<code>鲁棒控制</code>。早期的鲁棒控制主要研究单回路系统频率特性的某些特征，或基于小摄动分析上的灵敏度问题。现代鲁棒控制则着重研究控制系统中非微有界摄动下的分析与设计的理论和方法。<br>&emsp;&emsp;控制系统的一个鲁棒性是指控制系统在某种类型的扰动作用下，包括自身模型的扰动下，系统某个性能指标保持不变的能力，即抗干扰能力较强。对于实际工程系统，人们最关心的问题是一个控制系统当其模型参数发生大幅度变化或其结构发生变化时能否仍保持渐近稳定，这叫<code>稳定鲁棒性</code>。进而还要求在模型扰动下系统的品质指标仍然保持在某个许可范围内，这称为<code>品质鲁棒性</code>。鲁棒性理论致力于研究多变量系统具有稳定鲁棒性和品质鲁棒性的各种条件。它的进一步发展和应用，将是控制系统最终能否成功应用于实践的关键。</p>
<h3 id="鲁棒控制"><a href="#鲁棒控制" class="headerlink" title="鲁棒控制"></a>鲁棒控制</h3><p>&emsp;&emsp;鲁棒控制是一个着重控制算法可靠性研究的控制器设计方法。鲁棒性一般定义为在实际环境中为保证安全要求控制系统最小必须满足的要求。一旦设计好这个控制器，它的参数不能改变而且控制性能保证。<br>&emsp;&emsp;鲁棒控制方法适用于<code>稳定性</code>和<code>可靠性</code>作为首要目标的应用，同时过程的动态特性已知且不确定因素的变化范围可以预估。飞机和空间飞行器的控制是这类系统的例子。过程控制应用中，某些控制系统也可以用鲁棒控制方法设计，特别是对那些比较关键且：</p>
<ol>
<li>不确定因素变化范围大。</li>
<li>稳定裕度小的对象。</li>
</ol>
<p>但是，鲁棒控制系统的设计要由高级专家完成。一旦设计成功，就不需太多的人工干预。另一方面，如果要升级或作重大调整，系统就要重新设计。<br>&emsp;&emsp;通常，系统的分析方法和控制器的设计大多是基于数学模型而建立的，而且各类方法已经趋于成熟和完善。然而，系统总是存在这样或那样的不确定性。在系统建模时，有时只考虑了工作点附近的情况，造成了数学模型的人为简化；另一方面，执行部件与控制元件存在制造容差，系统运行过程也存在老化、磨损以及环境和运行条件恶化等现象，使得大多数系统存在结构或者参数的不确定性。这样，用精确数学模型对系统的分析结果或设计出来的控制器常常不满足工程要求。近些年来，人们展开了对不确定系统鲁棒控制问题的研究，并取得了一系列研究成果。<code>Hoo</code>鲁棒控制理论和<code>μ</code>分析理论则是当前控制工程中最活跃的研究领域之一，多年来一直备受控制研究工作者的青睐。</p>
<h3 id="渐近稳定"><a href="#渐近稳定" class="headerlink" title="渐近稳定"></a>渐近稳定</h3><p>&emsp;&emsp;以渐近稳定为性能指标的一类鲁棒性。如果控制系统在其特性或参数的标称值处是渐近稳定的，并且对标称值的一个邻域内的每一种情况它也是渐近稳定的，则称此系统是<code>结构渐近稳定的</code>。结构渐近稳定的控制系统除了要满足一般控制系统设计的要求外，还必须满足另外一些附加的条件。这些条件称为<code>结构渐近稳定性条件</code>，可用代数的或几何的语言来表述，但都具有比较复杂的形式。结构渐近稳定性的一个常用的度量是<code>稳定裕量</code>，包括<code>增益裕量</code>和<code>相角裕量</code>，它们分别代表控制系统为渐近稳定的前提下其频率响应在增益和相角上所留有的储备。一个控制系统的稳定裕量越大，其特性或参数的允许摄动范围一般也越大，因此它的鲁棒性也越好。已经证明，线性二次型(<code>LQ</code>)最优控制系统具有十分良好的鲁棒性，其相角裕量至少为<code>60</code>度，并确保<code>0.5</code>到<code>∞</code>的增益裕量，已经成为软件性能指标之一。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/数学和物理/帕累托分布/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/数学和物理/帕累托分布/" itemprop="url">帕累托分布</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T16:27:24+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;帕累托分布(<code>Pareto distribution</code>)是以意大利经济学家<code>维弗雷多·帕雷托</code>命名的，是从大量真实世界的现象中发现的幂次定律分布。这个分布在经济学以外，也被称为<code>布拉德福分布</code>。帕累托因对意大利<code>20%</code>的人口拥有<code>80%</code>的财产的观察而著名，后来被<code>约瑟夫·朱兰</code>和其他人概括为<code>帕累托法则</code>(<code>80/20</code>法则)，后来进一步概括为<code>帕累托分布</code>的概念。<br>&emsp;&emsp;<code>19</code>世纪末期，意大利经济学家维弗雷多·帕累托认为，贫与富的存在，既是经济问题，也有政治原因。帕累托在研究英国人的收入分配问题时发现，绝大部分社会财富最终总会流向少数人群；他还发现，某一部分人口占总人口的比例，与这一部分人所拥有的财富的份额具有比较确定的计量经济关系；进一步的研究证实，这种不平衡模式可以重复出现，甚至可以预测。经济学把这一社会财富的分布状态，称为<code>帕累托分布</code>。<br>&emsp;&emsp;帕累托分布可以归纳为一个非常简洁的表述：通过市场交易，<code>20%</code>的人将占有<code>80%</code>的社会财富，如果交易可以不断进行下去，那么，<code>在因和果、努力和收获之间，普遍存在着不平衡关系，典型的情况是：80%的收获来自20%的努力；其他80%的力气只带来20%的结果</code>。<code>丹尼尔·贝尔</code>在<code>《帕累托分布与收入最大化》</code>中进一步叙述到：<code>如果待分配的财富总量是100万元，人数为100人，那么我们会有这样一组对应的分配比例：排在前面的20个人，分得80万元；同理，这20人中的4个人，分得64万元；4个人中的1个人，分得50万元</code>。<br>&emsp;&emsp;如果我们把这些数据用数学公式简单处理一下，就会显示一条收缩中的<code>财富曲线</code>以及一条发散中的<code>贫困曲线</code>。它的最终走向是必然会<code>清零</code>的，也只有如此，<code>财富</code>中所包含的生产力因子才能重新释放出来。<br>&emsp;&emsp;帕累托分布从经济学角度论证出，社会分配的<code>绝对的失衡</code>必然导致<code>绝对的贫困</code>，甚至导致<code>宗教末日审判</code>的来临。除非我们可以通过政治手段，人为地阻止财富向高端不断聚集，否则，贫富双方的利益冲突是不可避免的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/数学和物理/数学归纳法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/数学和物理/数学归纳法/" itemprop="url">数学归纳法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T16:19:38+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;数学归纳法(<code>Mathematical Induction, MI</code>)是一种数学证明方法，通常被用于证明某个给定命题在整个(或者局部)自然数范围内成立。除了自然数以外，广义上的数学归纳法也可以用于证明一般良基结构，例如集合论中的树。这种广义的数学归纳法应用于数学逻辑和计算机科学领域，称作<code>结构归纳法</code>。<br>&emsp;&emsp;在数论中，数学归纳法是以一种不同的方式来证明任意一个给定的情形都是正确的(第一个、第二个、第三个，一直下去概不例外)的数学定理。虽然数学归纳法名字中有<code>归纳</code>，但是数学归纳法并非不严谨的归纳推理法，它属于完全严谨的演绎推理法。事实上，所有数学证明都是演绎法。<br>&emsp;&emsp;最简单和常见的数学归纳法是证明当<code>n</code>等于任意一个自然数时某命题成立。证明分下面两步：</p>
<ul>
<li>证明当<code>n = 1</code>时命题成立。</li>
<li>假设<code>n = m</code>时命题成立，那么可以推导出在<code>n = m + 1</code>时命题也成立(<code>m</code>代表任意自然数)。</li>
</ul>
<p>这种方法的原理在于：首先证明在某个起点值时命题成立，然后证明从一个值到下一个值的过程有效。当这两点都已经证明，那么任意值都可以通过反复使用这个方法推导出来。把这个方法想成多米诺效应也许更容易理解一些，例如你有一列很长的直立着的多米诺骨牌，如果你可以：</p>
<ul>
<li>证明第一张骨牌会倒。</li>
<li>证明只要任意一张骨牌倒了，那么与其相邻的下一张骨牌也会倒。</li>
</ul>
<p>那么便可以下结论：所有的骨牌都会倒下。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/数学和物理/中心极限定理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/数学和物理/中心极限定理/" itemprop="url">中心极限定理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T16:15:33+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;我们已经知道：</p>
<ul>
<li>如果将一些服从正态分布的数据加起来，得到的和也服从正态分布。</li>
<li>如果将一些不服从正态分布的数据加起来，那么得到的结果一般情况下不会服从前面讲过的连续分布。</li>
<li>我们可以证明：如果将大量服从某种分布的值加起来，所得到的和会收敛到正态分布。</li>
</ul>
<p>&emsp;&emsp;假设随机变量<code>X</code>的均值和标准差为<code>μ</code>和<code>σ</code>，那么<code>n</code>个随机变量<code>X</code>的和渐进地服从<code>N(nμ, nσ^2)</code>。上述理论称为中心极限定理(<code>Central Limit Theorem</code>)，它是统计分析中非常重要的工具。但是这个定理的成立要求满足一些条件：</p>
<ul>
<li>用于求和的数据必须满足独立性。</li>
<li>数据必须服从同一个分布(这个要求可以被适当地放松)。</li>
<li>产生这些数据分布的均值和方差必须是有限的(所以<code>帕累托分布</code>就不能满足这个条件了)。</li>
<li>收敛的速度取决于原来分布的偏度。如果数据服从指数分布，那么这些数据的和将会很快收敛；但如果数据服从对数正态分布，那么收敛速度就没那么快了。</li>
</ul>
<p>&emsp;&emsp;中心极限定理部分解释了为什么正态分布在自然界中广泛存在。绝大多数动物(或者其他生命形式)的特征(例如体重)，都会受到大量遗传和环境因素的影响，而且这些影响是具有可加性的。我们观测到的这些特征是大量微效因素的加和，所以它们都近似地服从正态分布。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/数学和物理/反证法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/数学和物理/反证法/" itemprop="url">反证法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T16:13:07+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;反证法(又称<code>背理法</code>)是一种论证方式。首先假设某命题不成立(即在原命题的题设下，结论不成立)，然后推理出明显矛盾的结果，从而下结论说假设不成立，原命题得证。反证法与归谬法相似，但归谬法不仅包括推理出矛盾结果，也包括推理出不符事实的结果或显然荒谬不可信的结果。<br>&emsp;&emsp;反证法常称作<code>Reductio ad absurdum</code>，在拉丁语中的意思是<code>转化为不可能</code>，阿基米德经常使用它。<br>&emsp;&emsp;法国数学家阿达玛对反证法的实质作过概括：<code>若肯定定理的假设而否定其结论，就会导致矛盾</code>。具体地讲，反证法就是从反论题入手，把命题结论的否定当作条件，使之得到与条件相矛盾，肯定了命题的结论，从而使命题获得了证明。<br>&emsp;&emsp;在应用反证法证题时，一定要用到<code>反设</code>，否则就不是反证法。用反证法证题时，如果欲证明的命题的方面情况只有一种，那么只要将这种情况驳倒了就可以，这种反证法又叫<code>归谬法</code>；如果结论的方面情况有多种，那么必须将所有的反面情况一一驳倒，才能推断原结论成立，这种证法又叫<code>穷举法</code>。反证法在数学中经常运用，当论题从正面不容易或不能得到证明时，就需要运用反证法，此即所谓<code>正难则反</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/C语言应用代码/获取文件大小/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/C语言应用代码/获取文件大小/" itemprop="url">获取文件大小</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T16:02:56+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>C</code>语言是一种比较底层的语言，有时在其他语言中很容易操作的事情，在<code>C</code>语言中就比较麻烦。例如获取一个文件的大小，<code>Java</code>中<code>File</code>类有个<code>length</code>函数，<code>Python</code>中<code>os.path</code>包中有个<code>getsize</code>函数，<code>C</code>语言中却没有直接对应的函数获取文件大小。目前网上有一种流传很广的方法，读取文件到内存，然后跳转到文件末尾，查看跳转的长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_size</span> <span class="params">( <span class="keyword">char</span> *filename )</span> </span>&#123;</span><br><span class="line">    FILE *fp = fopen ( filename, <span class="string">"r"</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !fp ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    fseek ( fp, <span class="number">0L</span>, SEEK_END );</span><br><span class="line">    <span class="keyword">int</span> size = ftell ( fp );</span><br><span class="line">    fclose ( fp );</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法利用<code>fseek</code>移动一个文件的存取位置到文件的末尾，然后利用<code>ftell</code>获得目前的文件访问位置。这种方法可以认为是一种间接的获取方式。虽说可以获得文件大小，但是有两个缺点。首先，<code>ftell</code>的返回值为<code>long</code>，在不同环境下占用的字节数也不同，这就可能存在<code>long</code>是四个字节的情况。此时，获取的文件大小就不能超过<code>2G</code>，否则就会出错。<br>&emsp;&emsp;上述缺点在大多数情况下都没问题，超大文件还可以通过<code>fsetpos</code>和<code>fgetpos</code>获取文件大小。最致命的缺陷就是它需要加载文件到内存，然后跳转到文件末尾，这个操作非常耗时。<br>&emsp;&emsp;如果可能的话，尽量避免采用上述间接的方式获取文件大小。在<code>linux</code>下，还有一种更简单的方式，通过读取文件信息获得文件大小，速度也快很多：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_size</span> <span class="params">( <span class="keyword">char</span>* filename )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line">    stat ( filename, &amp;statbuf );</span><br><span class="line">    <span class="keyword">int</span> size = statbuf.st_size;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>补充说明</strong>：在使用文件指针取得文件的大小后，一定不要忘记将其转移到最初的位置。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/64/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/64/">64</a><span class="page-number current">65</span><a class="page-number" href="/page/66/">66</a><span class="space">&hellip;</span><a class="page-number" href="/page/94/">94</a><a class="extend next" rel="next" href="/page/66/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">939</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
