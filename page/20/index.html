<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="泥腿子出身">
<meta property="og:url" content="http://fukangwei.gitee.io/page/20/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="泥腿子出身">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/20/">





  <title>泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/22/Qt语法详解/Qt之QTextTableFormat/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/22/Qt语法详解/Qt之QTextTableFormat/" itemprop="url">Qt之QTextTableFormat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T10:35:23+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTextTableFormat</code> class provides formatting information for tables in a <code>QTextDocument</code>.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextTableFormat</code></td>
<td><code>QTextFrameFormat</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextTableFormat()</code></td>
</tr>
<tr>
<td><code>Qt::Alignment</code></td>
<td><code>alignment() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>cellPadding() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>cellSpacing() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clearColumnWidthConstraints()</code></td>
</tr>
<tr>
<td><code>QVector&lt;QTextLength&gt;</code></td>
<td><code>columnWidthConstraints() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>columns() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>headerRowCount() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isValid() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setAlignment(Qt::Alignment alignment)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCellPadding(qreal padding)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCellSpacing(qreal spacing)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setColumnWidthConstraints(const QVector&lt;QTextLength&gt; &amp; constraints)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHeaderRowCount(int count)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextTableFormat</code> class provides formatting information for tables in a <code>QTextDocument</code>.<br>&emsp;&emsp;A table is a group of cells ordered into rows and columns. Each table contains at least one row and one column. Each cell contains a block. Tables in rich text documents are formatted using the properties defined in this class.<br>&emsp;&emsp;Tables are horizontally justified within their parent frame according to the table’s alignment. This can be read with the <code>alignment()</code> function and set with <code>setAlignment()</code>.<br>&emsp;&emsp;Cells within the table are separated by cell spacing. The number of pixels between cells is set with <code>setCellSpacing()</code> and read with <code>cellSpacing()</code>. The contents of each cell is surrounded by cell padding. The number of pixels between each cell edge and its contents is set with <code>setCellPadding()</code> and read with <code>cellPadding()</code>.</p>
<p><img src="/2019/02/22/Qt语法详解/Qt之QTextTableFormat/1.png" height="154" width="219"></p>
<p>&emsp;&emsp;The table’s background color can be read with the <code>background()</code> function, and can be specified with <code>setBackground()</code>. The background color of each cell can be set independently, and will control the color of the cell within the padded area.<br>&emsp;&emsp;The table format also provides a way to constrain the widths of the columns in the table. Columns can be assigned a fixed width, a variable width, or a percentage of the available width. The <code>columns()</code> function returns the number of columns with constraints, and the <code>columnWidthConstraints()</code> function returns the constraints defined for the table. These quantities can also be set by calling <code>setColumnWidthConstraints()</code> with a vector containing new constraints. If no constraints are required, <code>clearColumnWidthConstraints()</code> can be used to remove them.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextTableFormat::QTextTableFormat()</code>: Constructs a new table format object.</li>
<li><code>Qt::Alignment QTextTableFormat::alignment() const</code>: Returns the table’s alignment.</li>
<li><code>qreal QTextTableFormat::cellPadding() const</code>: Returns the table’s cell padding. This describes the distance between the border of a cell and its contents.</li>
<li><code>qreal QTextTableFormat::cellSpacing() const</code>: Returns the table’s cell spacing. This describes the distance between adjacent cells.</li>
<li><code>void QTextTableFormat::clearColumnWidthConstraints()</code>: Clears the column width constraints for the table.</li>
<li><code>QVector&lt;QTextLength&gt; QTextTableFormat::columnWidthConstraints() const</code>: Returns a list of constraints used by this table format to control the appearance of columns in a table.</li>
<li><code>int QTextTableFormat::columns() const</code>: Returns the number of columns specified by the table format.</li>
<li><code>int QTextTableFormat::headerRowCount() const</code>: Returns the number of rows in the table that define the header.</li>
<li><code>bool QTextTableFormat::isValid() const</code>: Returns true if this table format is valid; otherwise returns false.</li>
<li><code>void QTextTableFormat::setAlignment(Qt::Alignment alignment)</code>: Sets the table’s <code>alignment</code>.</li>
<li><code>void QTextTableFormat::setCellPadding(qreal padding)</code>: Sets the cell <code>padding</code> for the table. This determines the distance between the border of a cell and its contents.</li>
<li><code>void QTextTableFormat::setCellSpacing(qreal spacing)</code>: Sets the cell <code>spacing</code> for the table. This determines the distance between adjacent cells.</li>
<li><code>void QTextTableFormat::setColumnWidthConstraints(const QVector&lt;QTextLength&gt; &amp; constraints)</code>: Sets the column width <code>constraints</code> for the table.</li>
<li><code>void QTextTableFormat::setHeaderRowCount(int count)</code>: Declares the first <code>count</code> rows of the table as table header. The table header rows get repeated when a table is broken across a page boundary.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/21/Qt语法详解/Qt之QComboBox/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/21/Qt语法详解/Qt之QComboBox/" itemprop="url">Qt之QComboBox</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-21T16:23:06+08:00">
                2019-02-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>QComboBox</code>提供了下拉列表框的控件，下面简单地介绍几个的方法和属性。<br>&emsp;&emsp;<code>addItems</code>在列表的最后一项添加一个文本内容为<code>text</code>选项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addItem</span> <span class="params">( <span class="keyword">const</span> QString &amp;text, <span class="keyword">const</span> QVariant &amp;userData = QVariant() )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addItem</span> <span class="params">( <span class="keyword">const</span> QIcon &amp;icon, <span class="keyword">const</span> QString &amp;text, <span class="keyword">const</span> QVariant &amp;userData = QVariant() )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>currentText</code>返回下拉列表框中当前选中的文本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">currentText</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>count</code>返回当前列表框中选项数量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>currentIndex</code>返回当前列表框中选中文本的序号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">currentIndex</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QComboBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line">​</span><br><span class="line">Widget::Widget ( QWidget *parent ) : QWidget ( parent ) &#123;</span><br><span class="line">    QComboBox *combobox = <span class="keyword">new</span> QComboBox ( <span class="keyword">this</span> );</span><br><span class="line">    combobox-&gt;addItem ( tr ( <span class="string">"Circle"</span> ) );</span><br><span class="line">    combobox-&gt;addItem ( tr ( <span class="string">"Pology"</span> ) );</span><br><span class="line">    QGridLayout *mainLayout = <span class="keyword">new</span> QGridLayout ( <span class="keyword">this</span> );</span><br><span class="line">    mainLayout-&gt;addWidget ( combobox, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"Now there are "</span> &lt;&lt; combobox-&gt;count() &lt;&lt; <span class="string">"Items"</span>;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"The current item is"</span> &lt;&lt; combobox-&gt;currentText();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">Widget::~Widget() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/21/Qt语法详解/Qt之QComboBox/1.png"></p>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Now there are <span class="number">2</span> Items</span><br><span class="line">The current item is <span class="string">"Circle"</span></span><br></pre></td></tr></table></figure>
<hr>
<p>&emsp;&emsp;The <code>QComboBox</code> widget is a combined button and popup list.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QComboBox</code></td>
<td><code>QWidget</code></td>
<td><code>QFontComboBox</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QComboBox(QWidget * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QComboBox()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addItem(const QString &amp; text, const QVariant &amp; userData = QVariant())</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addItem(const QIcon &amp; icon, const QString &amp; text, const QVariant &amp; userData = QVariant())</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addItems(const QStringList &amp; texts)</code></td>
</tr>
<tr>
<td><code>QCompleter *</code></td>
<td><code>completer() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>currentIndex() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>currentText() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>duplicatesEnabled() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>findData(const QVariant &amp; data, int role = Qt::UserRole, Qt::MatchFlags flags = static_cast<qt::matchflags> ( Qt::MatchExactly &#124; Qt::MatchCaseSensitive )) const<code \=""></code></qt::matchflags></code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>findText(const QString &amp; text, Qt::MatchFlags flags = static_cast<qt::matchflags> ( Qt::MatchExactly &#124; Qt::MatchCaseSensitive )) const<code \=""></code></qt::matchflags></code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasFrame() const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>hidePopup()</code></td>
</tr>
<tr>
<td><code>QSize</code></td>
<td><code>iconSize() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertItem(int index, const QString &amp; text, const QVariant &amp; userData = QVariant())</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertItem(int index, const QIcon &amp; icon, const QString &amp; text, const QVariant &amp; userData = QVariant())</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertItems(int index, const QStringList &amp; list)</code></td>
</tr>
<tr>
<td><code>InsertPolicy</code></td>
<td><code>insertPolicy() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertSeparator(int index)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEditable() const</code></td>
</tr>
<tr>
<td><code>QVariant</code></td>
<td><code>itemData(int index, int role = Qt::UserRole) const</code></td>
</tr>
<tr>
<td><code>QAbstractItemDelegate *</code></td>
<td><code>itemDelegate() const</code></td>
</tr>
<tr>
<td><code>QIcon</code></td>
<td><code>itemIcon(int index) const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>itemText(int index) const</code></td>
</tr>
<tr>
<td><code>QLineEdit *</code></td>
<td><code>lineEdit() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>maxCount() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>maxVisibleItems() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>minimumContentsLength() const</code></td>
</tr>
<tr>
<td><code>QAbstractItemModel *</code></td>
<td><code>model() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>modelColumn() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeItem(int index)</code></td>
</tr>
<tr>
<td><code>QModelIndex</code></td>
<td><code>rootModelIndex() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCompleter(QCompleter * completer)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDuplicatesEnabled(bool enable)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setEditable(bool editable)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFrame(bool)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setIconSize(const QSize &amp; size)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setInsertPolicy(InsertPolicy policy)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setItemData(int index, const QVariant &amp; value, int role = Qt::UserRole)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setItemDelegate(QAbstractItemDelegate * delegate)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setItemIcon(int index, const QIcon &amp; icon)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setItemText(int index, const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setLineEdit(QLineEdit * edit)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMaxCount(int max)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMaxVisibleItems(int maxItems)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMinimumContentsLength(int characters)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setModel(QAbstractItemModel * model)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setModelColumn(int visibleColumn)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setRootModelIndex(const QModelIndex &amp; index)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSizeAdjustPolicy(SizeAdjustPolicy policy)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setValidator(const QValidator * validator)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setView(QAbstractItemView * itemView)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>showPopup()</code></td>
</tr>
<tr>
<td><code>SizeAdjustPolicy</code></td>
<td><code>sizeAdjustPolicy() const</code></td>
</tr>
<tr>
<td><code>const QValidator *</code></td>
<td><code>validator() const</code></td>
</tr>
<tr>
<td><code>QAbstractItemView *</code></td>
<td><code>view() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Public-Functions"><a href="#Reimplemented-Public-Functions" class="headerlink" title="Reimplemented Public Functions"></a>Reimplemented Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual bool</code></td>
<td><code>event(QEvent * event)</code></td>
</tr>
<tr>
<td><code>virtual QSize</code></td>
<td><code>minimumSizeHint() const</code></td>
</tr>
<tr>
<td><code>virtual QSize</code></td>
<td><code>sizeHint() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Slots"><a href="#Public-Slots" class="headerlink" title="Public Slots"></a>Public Slots</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clearEditText()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentIndex(int index)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setEditText(const QString &amp; text)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>activated(int index)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>activated(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>currentIndexChanged(int index)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>currentIndexChanged(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>editTextChanged(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>highlighted(int index)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>highlighted(const QString &amp; text)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><ul>
<li><code>void initStyleOption(QStyleOptionComboBox * option) const</code></li>
</ul>
<h3 id="Reimplemented-Protected-Functions"><a href="#Reimplemented-Protected-Functions" class="headerlink" title="Reimplemented Protected Functions"></a>Reimplemented Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual void</code></td>
<td><code>changeEvent(QEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>contextMenuEvent(QContextMenuEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>focusInEvent(QFocusEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>focusOutEvent(QFocusEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>hideEvent(QHideEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>inputMethodEvent(QInputMethodEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual QVariant</code></td>
<td><code>inputMethodQuery(Qt::InputMethodQuery query) const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>keyPressEvent(QKeyEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>keyReleaseEvent(QKeyEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>mousePressEvent(QMouseEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>mouseReleaseEvent(QMouseEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>paintEvent(QPaintEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>resizeEvent(QResizeEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>showEvent(QShowEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>wheelEvent(QWheelEvent * e)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QComboBox</code> widget is a combined button and popup list.<br>&emsp;&emsp;A <code>QComboBox</code> provides a means of presenting a list of options to the user in a way that takes up the minimum amount of screen space.<br>&emsp;&emsp;A combobox is a selection widget that displays the current item, and can pop up a list of selectable items. A combobox may be editable, allowing the user to modify each item in the list.<br>&emsp;&emsp;Comboboxes can contain pixmaps as well as strings; the <code>insertItem()</code> and <code>setItemText()</code> functions are suitably overloaded. For editable comboboxes, the function <code>clearEditText()</code> is provided, to clear the displayed string without changing the combobox’s contents.<br>&emsp;&emsp;There are two signals emitted if the current item of a combobox changes, <code>currentIndexChanged()</code> and <code>activated()</code>. <code>currentIndexChanged()</code> is always emitted regardless if the change was done programmatically or by user interaction, while <code>activated()</code> is only emitted when the change is caused by user interaction. The <code>highlighted()</code> signal is emitted when the user highlights an item in the combobox popup list. All three signals exist in two versions, one with a <code>QString</code> argument and one with an int argument. If the user selects or highlights a pixmap, only the int signals are emitted. Whenever the text of an editable combobox is changed the <code>editTextChanged()</code> signal is emitted.<br>&emsp;&emsp;When the user enters a new string in an editable combobox, the widget may or may not insert it, and it can insert it in several locations. The default policy is is <code>AtBottom</code> but you can change this using <code>setInsertPolicy()</code>.<br>&emsp;&emsp;It is possible to constrain the input to an editable combobox using <code>QValidator</code>; see <code>setValidator()</code>. By default, any input is accepted.<br>&emsp;&emsp;A combobox can be populated using the insert functions, <code>insertItem()</code> and <code>insertItems()</code> for example. Items can be changed with <code>setItemText()</code>. An item can be removed with <code>removeItem()</code> and all items can be removed with <code>clear()</code>. The text of the current item is returned by <code>currentText()</code>, and the text of a numbered item is returned with <code>text()</code>. The current item can be set with <code>setCurrentIndex()</code>. The number of items in the combobox is returned by <code>count()</code>; the maximum number of items can be set with <code>setMaxCount()</code>. You can allow editing using <code>setEditable()</code>. For editable comboboxes you can set <code>auto-completion</code> using <code>setCompleter()</code> and whether or not the user can add duplicates is set with <code>setDuplicatesEnabled()</code>.<br>&emsp;&emsp;<code>QComboBox</code> uses the <code>model/view</code> framework for its popup list and to store its items. By default a <code>QStandardItemModel</code> stores the items and a <code>QListView</code> subclass displays the popuplist. You can access the model and view directly (with <code>model()</code> and <code>view()</code>), but <code>QComboBox</code> also provides functions to set and get item data (e.g., <code>setItemData()</code> and <code>itemText()</code>). You can also set a new model and view (with <code>setModel()</code> and <code>setView()</code>). For the text and icon in the combobox label, the data in the model that has the <code>Qt::DisplayRole</code> and <code>Qt::DecorationRole</code> is used. Note that you cannot alter the <code>SelectionMode</code> of the <code>view()</code>, e.g., by using <code>setSelectionMode()</code>.</p>
<p><img src="/2019/02/21/Qt语法详解/Qt之QComboBox/2.png"></p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QComboBox::InsertPolicy</code>: This enum specifies what the <code>QComboBox</code> should do when a new string is entered by the user.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QComboBox::NoInsert</code></td>
<td><code>0</code></td>
<td>The string will not be inserted into the combobox.</td>
</tr>
<tr>
<td><code>QComboBox::InsertAtTop</code></td>
<td><code>1</code></td>
<td>The string will be inserted as the first item in the combobox.</td>
</tr>
<tr>
<td><code>QComboBox::InsertAtCurrent</code></td>
<td><code>2</code></td>
<td>The current item will be replaced by the string.</td>
</tr>
<tr>
<td><code>QComboBox::InsertAtBottom</code></td>
<td><code>3</code></td>
<td>The string will be inserted after the last item in the combobox.</td>
</tr>
<tr>
<td><code>QComboBox::InsertAfterCurrent</code></td>
<td><code>4</code></td>
<td>The string is inserted after the current item in the combobox.</td>
</tr>
<tr>
<td><code>QComboBox::InsertBeforeCurrent</code></td>
<td><code>5</code></td>
<td>The string is inserted before the current item in the combobox.</td>
</tr>
<tr>
<td><code>QComboBox::InsertAlphabetically</code></td>
<td><code>6</code></td>
<td>The string is inserted in the alphabetic order in the combobox.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QComboBox::SizeAdjustPolicy</code>: This enum specifies how the size hint of the <code>QComboBox</code> should adjust when new content is added or content changes.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QComboBox::AdjustToContents</code></td>
<td><code>0</code></td>
<td>The combobox will always adjust to the contents</td>
</tr>
<tr>
<td><code>QComboBox::AdjustToContentsOnFirstShow</code></td>
<td><code>1</code></td>
<td>The combobox will adjust to its contents the first time it is shown.</td>
</tr>
<tr>
<td><code>QComboBox::AdjustToMinimumContentsLength</code></td>
<td><code>2</code></td>
<td>Use <code>AdjustToContents</code> or <code>AdjustToContentsOnFirstShow</code> instead.</td>
</tr>
<tr>
<td><code>QComboBox::AdjustToMinimumContentsLengthWithIcon</code></td>
<td><code>3</code></td>
<td>The combobox will adjust to <code>minimumContentsLength</code> plus space for an icon. For performance reasons use this policy on large models.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Property-Documentation"><a href="#Property-Documentation" class="headerlink" title="Property Documentation"></a>Property Documentation</h3><ul>
<li><code>count : const int</code>: This property holds the number of items in the combobox. By default, for an empty combo box, this property has a value of <code>0</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>currentIndex : int</code>: This property holds the index of the current item in the combobox. The current index can change when inserting or removing items. By default, for an empty combo box or a combo box in which no current item is set, this property has a value of <code>-1</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">currentIndex</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCurrentIndex</span> <span class="params">( <span class="keyword">int</span> index )</span></span></span><br></pre></td></tr></table></figure>
<p>Notifier signal:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">currentIndexChanged</span> <span class="params">( <span class="keyword">int</span> index )</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">currentIndexChanged</span> <span class="params">( <span class="keyword">const</span> QString &amp;text )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>currentText : const QString</code>: This property holds the current text. If the combo box is editable, the current text is the value displayed by the line edit. Otherwise, it is the value of the current item or an empty string if the combo box is empty or no current item is set. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">currentText</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>duplicatesEnabled : bool</code>: This property holds whether the user can enter duplicate items into the combobox. Note that it is always possible to programmatically insert duplicate items into the combobox. By default, this property is false (duplicates are not allowed). Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicatesEnabled</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDuplicatesEnabled</span> <span class="params">( <span class="keyword">bool</span> enable )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>editable : bool</code>: This property holds whether the combo box can be edited by the user. By default, this property is false. The effect of editing depends on the insert policy. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEditable</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEditable</span> <span class="params">( <span class="keyword">bool</span> editable )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>frame : bool</code>: This property holds whether the combo box draws itself with a frame. If enabled (the default) the combo box draws itself inside a frame, otherwise the combo box draws itself without any frame. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasFrame</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFrame</span> <span class="params">( <span class="keyword">bool</span> )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>iconSize : QSize</code>: This property holds the size of the icons shown in the combobox. Unless explicitly set this returns the default value of the current style. This size is the maximum size that icons can have; icons of smaller size are not scaled up. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QSize <span class="title">iconSize</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIconSize</span> <span class="params">( <span class="keyword">const</span> QSize &amp;size )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>insertPolicy : InsertPolicy</code>: This property holds the policy used to determine where <code>user-inserted</code> items should appear in the combobox. The default value is <code>AtBottom</code>, indicating that new items will appear at the bottom of the list of items. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InsertPolicy <span class="title">insertPolicy</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInsertPolicy</span> <span class="params">( InsertPolicy policy )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>maxCount : int</code>: This property holds the maximum number of items allowed in the combobox. <strong>Note</strong>: If you set the maximum number to be less then the current amount of items in the combobox, the extra items will be truncated. This also applies if you have set an external model on the combobox. By default, this property’s value is derived from the highest signed integer available (typically <code>2147483647</code>). Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMaxCount</span> <span class="params">( <span class="keyword">int</span> max )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>maxVisibleItems : int</code>: This property holds the maximum allowed size on screen of the combo box, measured in items. By default, this property has a value of <code>10</code>. <strong>Note</strong>: This property is ignored for <code>non-editable</code> comboboxes in styles that returns true for <code>QStyle::SH_ComboBox_Popup</code> such as the <code>Mac</code> style or the <code>Gtk+</code> Style. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxVisibleItems</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMaxVisibleItems</span> <span class="params">( <span class="keyword">int</span> maxItems )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>minimumContentsLength : int</code>: This property holds the minimum number of characters that should fit into the combobox. The default value is <code>0</code>. If this property is set to a positive value, the <code>minimumSizeHint()</code> and <code>sizeHint()</code> take it into account. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumContentsLength</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMinimumContentsLength</span> <span class="params">( <span class="keyword">int</span> characters )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>modelColumn : int</code>: This property holds the column in the model that is visible. If set prior to populating the combo box, the <code>pop-up</code> view will not be affected and will show the first column (using this property’s default value). By default, this property has a value of <code>0</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modelColumn</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setModelColumn</span> <span class="params">( <span class="keyword">int</span> visibleColumn )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>sizeAdjustPolicy : SizeAdjustPolicy</code>: This property holds the policy describing how the size of the combobox changes when the content changes. The default value is <code>AdjustToContentsOnFirstShow</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SizeAdjustPolicy <span class="title">sizeAdjustPolicy</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSizeAdjustPolicy</span> <span class="params">( SizeAdjustPolicy policy )</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QComboBox::QComboBox(QWidget * parent = 0)</code>: Constructs a combobox with the given <code>parent</code>, using the default model <code>QStandardItemModel</code>.</li>
<li><code>QComboBox::~QComboBox()</code>: Destroys the combobox.</li>
<li><code>void QComboBox::activated(int index) [signal]</code>: This signal is sent when the user chooses an item in the combobox. The item’s <code>index</code> is passed. Note that this signal is sent even when the choice is not changed. If you need to know when the choice actually changes, use signal <code>currentIndexChanged()</code>.</li>
<li><code>void QComboBox::activated(const QString &amp; text) [signal]</code>: This signal is sent when the user chooses an item in the combobox. The item’s <code>text</code> is passed. Note that this signal is sent even when the choice is not changed. If you need to know when the choice actually changes, use signal <code>currentIndexChanged()</code>.</li>
<li><code>void QComboBox::addItem(const QString &amp; text, const QVariant &amp; userData = QVariant())</code>: Adds an item to the combobox with the given <code>text</code>, and containing the specified <code>userData</code> (stored in the <code>Qt::UserRole</code>). The item is appended to the list of existing items.</li>
<li><code>void QComboBox::addItem(const QIcon &amp; icon, const QString &amp; text, const QVariant &amp; userData = QVariant())</code>: Adds an item to the combobox with the given <code>icon</code> and <code>text</code>, and containing the specified <code>userData</code> (stored in the <code>Qt::UserRole</code>). The item is appended to the list of existing items.</li>
<li><code>void QComboBox::addItems(const QStringList &amp; texts)</code>: Adds each of the strings in the given <code>texts</code> to the combobox. Each item is appended to the list of existing items in turn.  </li>
<li><code>void QComboBox::changeEvent(QEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::changeEvent()</code>.</li>
<li><code>void QComboBox::clear() [slot]</code>: Clears the combobox, removing all items. <strong>Note</strong>: If you have set an external model on the combobox this model will still be cleared when calling this function.</li>
<li><code>void QComboBox::clearEditText() [slot]</code>: Clears the contents of the line edit used for editing in the combobox.</li>
<li><code>QCompleter * QComboBox::completer() const</code>: Returns the completer that is used to auto complete text input for the combobox.</li>
<li><code>void QComboBox::contextMenuEvent(QContextMenuEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::contextMenuEvent()</code>.</li>
<li><code>void QComboBox::editTextChanged(const QString &amp; text) [signal]</code>: This signal is emitted when the <code>text</code> in the combobox’s line edit widget is changed. The new text is specified by <code>text</code>.</li>
<li><code>bool QComboBox::event(QEvent * event) [virtual]</code>: Reimplemented from <code>QObject::event()</code>.</li>
<li><code>int QComboBox::findData(const QVariant &amp; data, int role = Qt::UserRole, Qt::MatchFlags flags = static_cast&lt;Qt::MatchFlags&gt; ( Qt::MatchExactly | Qt::MatchCaseSensitive )) const</code>: Returns the index of the item containing the given <code>data</code> for the given <code>role</code>; otherwise returns <code>-1</code>. The <code>flags</code> specify how the items in the combobox are searched.</li>
<li><code>int QComboBox::findText(const QString &amp; text, Qt::MatchFlags flags = static_cast&lt;Qt::MatchFlags&gt; ( Qt::MatchExactly | Qt::MatchCaseSensitive )) const</code>: Returns the index of the item containing the given <code>text</code>; otherwise returns <code>-1</code>. The <code>flags</code> specify how the items in the combobox are searched.</li>
<li><code>void QComboBox::focusInEvent(QFocusEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::focusInEvent()</code>.</li>
<li><code>void QComboBox::focusOutEvent(QFocusEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::focusOutEvent()</code>.</li>
<li><code>void QComboBox::hideEvent(QHideEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::hideEvent()</code>.</li>
<li><code>void QComboBox::hidePopup() [virtual]</code>: Hides the list of items in the combobox if it is currently visible and resets the internal state, so that if the custom <code>pop-up</code> was shown inside the reimplemented <code>showPopup()</code>, then you also need to reimplement the <code>hidePopup()</code> function to hide your custom <code>pop-up</code> and call the base class implementation to reset the internal state whenever your custom <code>pop-up</code> widget is hidden.</li>
<li><code>void QComboBox::highlighted(int index) [signal]</code>: This signal is sent when an item in the combobox popup list is highlighted by the user. The item’s <code>index</code> is passed.</li>
<li><code>void QComboBox::highlighted(const QString &amp; text) [signal]</code>: This signal is sent when an item in the combobox popup list is highlighted by the user. The item’s <code>text</code> is passed.</li>
<li><code>void QComboBox::initStyleOption(QStyleOptionComboBox * option) const [protected]</code>:  Initialize <code>option</code> with the values from this <code>QComboBox</code>. This method is useful for subclasses when they need a <code>QStyleOptionComboBox</code>, but don’t want to fill in all the information themselves.</li>
<li><code>void QComboBox::inputMethodEvent(QInputMethodEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::inputMethodEvent()</code>.</li>
<li><code>QVariant QComboBox::inputMethodQuery(Qt::InputMethodQuery query) const [virtual protected]</code>: Reimplemented from <code>QWidget::inputMethodQuery()</code>.</li>
<li><code>void QComboBox::insertItem(int index, const QString &amp; text, const QVariant &amp; userData = QVariant())</code>: Inserts the <code>text</code> and <code>userData</code> (stored in the <code>Qt::UserRole</code>) into the combobox at the given <code>index</code>. If the <code>index</code> is equal to or higher than the total number of items, the new item is appended to the list of existing items. If the <code>index</code> is <code>0</code> or negative, the new item is prepended to the list of existing items.</li>
<li><code>void QComboBox::insertItem(int index, const QIcon &amp; icon, const QString &amp; text, const QVariant &amp; userData = QVariant())</code>: Inserts the <code>icon</code>, <code>text</code> and <code>userData</code> (stored in the <code>Qt::UserRole</code>) into the combobox at the given <code>index</code>. If the <code>index</code> is equal to or higher than the total number of items, the new item is appended to the list of existing items. If the <code>index</code> is <code>0</code> or negative, the new item is prepended to the list of existing items.</li>
<li><p><code>void QComboBox::insertItems(int index, const QStringList &amp; list)</code>: Inserts the strings from the <code>list</code> into the combobox as separate items, starting at the <code>index</code> specified. If the <code>index</code> is equal to or higher than the total number of items, the new items are appended to the list of existing items. If the <code>index</code> is <code>0</code> or negative, the new items are prepended to the list of existing items.</p>
</li>
<li><p><code>void QComboBox::insertSeparator(int index)</code>: Inserts a separator item into the combobox at the given index. If the index is equal to or higher than the total number of items, the new item is appended to the list of existing items. If the index is zero or negative, the new item is prepended to the list of existing items.</p>
</li>
<li><code>QVariant QComboBox::itemData(int index, int role = Qt::UserRole) const</code>: Returns the data for the given role in the given index in the combobox, or QVariant::Invalid if there is no data for this role.</li>
<li><code>QAbstractItemDelegate * QComboBox::itemDelegate() const</code>: Returns the item delegate used by the popup list view.</li>
<li><code>QIcon QComboBox::itemIcon(int index) const</code>: Returns the icon for the given index in the combobox.</li>
<li><code>QString QComboBox::itemText(int index) const</code>: Returns the text for the given index in the combobox.</li>
<li><code>void QComboBox::keyPressEvent(QKeyEvent * e) [virtual protected]</code>: Reimplemented from QWidget::keyPressEvent().</li>
<li><code>void QComboBox::keyReleaseEvent(QKeyEvent * e) [virtual protected]</code>: Reimplemented from QWidget::keyReleaseEvent().</li>
<li><code>QLineEdit * QComboBox::lineEdit() const</code>: Returns the line edit used to edit items in the combobox, or 0 if there is no line edit. Only editable combo boxes have a line edit.</li>
<li><code>QSize QComboBox::minimumSizeHint() const [virtual]</code>: Reimplemented from QWidget::minimumSizeHint().</li>
<li><code>QAbstractItemModel * QComboBox::model() const</code>: Returns the model used by the combobox.</li>
<li><code>void QComboBox::mousePressEvent(QMouseEvent * e) [virtual protected]</code>: Reimplemented from QWidget::mousePressEvent().</li>
<li><code>void QComboBox::mouseReleaseEvent(QMouseEvent * e) [virtual protected]</code>: Reimplemented from QWidget::mouseReleaseEvent().</li>
<li><code>void QComboBox::paintEvent(QPaintEvent * e) [virtual protected]</code>: Reimplemented from QWidget::paintEvent().</li>
<li><code>void QComboBox::removeItem(int index)</code>: Removes the item at the given index from the combobox. This will update the current index if the index is removed. This function does nothing if index is out of range.</li>
<li><code>void QComboBox::resizeEvent(QResizeEvent * e) [virtual protected]</code>: Reimplemented from QWidget::resizeEvent().</li>
<li><code>QModelIndex QComboBox::rootModelIndex() const</code>: Returns the root model item index for the items in the combobox.</li>
<li><code>void QComboBox::setCompleter(QCompleter * completer)</code>: Sets the completer to use instead of the current completer. If completer is 0, auto completion is disabled. By default, for an editable combo box, a QCompleter that performs case insensitive inline completion is automatically created.</li>
<li><code>void QComboBox::setEditText(const QString &amp; text) [slot]</code>: Sets the text in the combobox’s text edit.</li>
<li><code>void QComboBox::setItemData(int index, const QVariant &amp; value, int role = Qt::UserRole)</code>: Sets the data role for the item on the given index in the combobox to the specified value.</li>
<li><code>void QComboBox::setItemDelegate(QAbstractItemDelegate * delegate)</code>: Sets the item delegate for the popup list view. The combobox takes ownership of the delegate. Warning: You should not share the same instance of a delegate between comboboxes, widget mappers or views. Doing so can cause incorrect or unintuitive editing behavior since each view connected to a given delegate may receive the closeEditor() signal, and attempt to access, modify or close an editor that has already been closed.</li>
<li><code>void QComboBox::setItemIcon(int index, const QIcon &amp; icon)</code>: Sets the icon for the item on the given index in the combobox.</li>
<li><code>void QComboBox::setItemText(int index, const QString &amp; text)</code>: Sets the text for the item on the given index in the combobox.</li>
<li><code>void QComboBox::setLineEdit(QLineEdit * edit)</code>: Sets the line edit to use instead of the current line edit widget. The combo box takes ownership of the line edit.</li>
<li><code>void QComboBox::setModel(QAbstractItemModel * model)</code>: Sets the model to be model. model must not be 0. If you want to clear the contents of a model, call clear().</li>
<li><code>void QComboBox::setRootModelIndex(const QModelIndex &amp; index)</code>: Sets the root model item index for the items in the combobox.</li>
<li><code>void QComboBox::setValidator(const QValidator * validator)</code>: Sets the validator to use instead of the current validator.</li>
<li><code>void QComboBox::setView(QAbstractItemView * itemView)</code>: Sets the view to be used in the combobox popup to the given itemView. The combobox takes ownership of the view. Note: If you want to use the convenience views (like QListWidget, QTableWidget or QTreeWidget), make sure to call setModel() on the combobox with the convenience widgets model before calling this function.</li>
<li><code>void QComboBox::showEvent(QShowEvent * e) [virtual protected]</code>: Reimplemented from QWidget::showEvent().</li>
<li><code>void QComboBox::showPopup() [virtual]</code>: Displays the list of items in the combobox. If the list is empty then the no items will be shown. If you reimplement this function to show a custom pop-up, make sure you call hidePopup() to reset the internal state.</li>
<li><code>QSize QComboBox::sizeHint() const [virtual]</code>: Reimplemented from QWidget::sizeHint(). This implementation caches the size hint to avoid resizing when the contents change dynamically. To invalidate the cached value change the sizeAdjustPolicy.</li>
<li><code>const QValidator * QComboBox::validator() const</code>: Returns the validator that is used to constrain text input for the combobox.</li>
<li><code>QAbstractItemView * QComboBox::view() const</code>: Returns the list view used for the combobox popup.</li>
<li><code>void QComboBox::wheelEvent(QWheelEvent * e) [virtual protected]</code>: Reimplemented from QWidget::wheelEvent().</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/20/Qt语法详解/Qt之QPixmap/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/20/Qt语法详解/Qt之QPixmap/" itemprop="url">Qt之QPixmap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-20T14:05:57+08:00">
                2019-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QPixmap</code> class is an <code>off-screen</code> image representation that can be used as a paint device.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPixmap</code></td>
<td><code>QPaintDevice</code></td>
<td><code>Q3CanvasPixmap</code> and <code>QBitmap</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Retrun</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QPixmap()</code></td>
</tr>
<tr>
<td></td>
<td><code>QPixmap(int width, int height)</code></td>
</tr>
<tr>
<td></td>
<td><code>QPixmap(const QString &amp; fileName, const char * format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor)</code></td>
</tr>
<tr>
<td></td>
<td><code>QPixmap(const char * const[] xpm)</code></td>
</tr>
<tr>
<td></td>
<td><code>QPixmap(const QPixmap &amp; pixmap)</code></td>
</tr>
<tr>
<td></td>
<td><code>QPixmap(const QSize &amp; size)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QPixmap()</code></td>
</tr>
<tr>
<td><code>qint64</code></td>
<td><code>cacheKey() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>convertFromImage(const QImage &amp; image, Qt::ImageConversionFlags flags = Qt::AutoColor)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>copy(const QRect &amp; rectangle = QRect()) const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>copy(int x, int y, int width, int height) const</code></td>
</tr>
<tr>
<td><code>QBitmap</code></td>
<td><code>createHeuristicMask(bool clipTight = true) const</code></td>
</tr>
<tr>
<td><code>QBitmap</code></td>
<td><code>createMaskFromColor(const QColor &amp; maskColor, Qt::MaskMode mode) const</code></td>
</tr>
<tr>
<td><code>QBitmap</code></td>
<td><code>createMaskFromColor(const QColor &amp; maskColor) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>depth() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>detach()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>fill(const QColor &amp; color = Qt::white)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>fill(const QWidget * widget, const QPoint &amp; offset)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>fill(const QWidget * widget, int x, int y)</code></td>
</tr>
<tr>
<td><code>Qt::HANDLE</code></td>
<td><code>handle() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasAlpha() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasAlphaChannel() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>height() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isNull() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isQBitmap() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>load(const QString &amp; fileName, const char * format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>loadFromData(const uchar * data, uint len, const char * format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>loadFromData(const QByteArray &amp; data, const char * format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor)</code></td>
</tr>
<tr>
<td><code>QBitmap</code></td>
<td><code>mask() const</code></td>
</tr>
<tr>
<td><code>QRect</code></td>
<td><code>rect() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>save(const QString &amp; fileName, const char * format = 0, int quality = -1) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>save(QIODevice * device, const char * format = 0, int quality = -1) const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>scaled(const QSize &amp; size, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation) const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>scaled(int width, int height, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation) const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>scaledToHeight(int height, Qt::TransformationMode mode = Qt::FastTransformation) const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>scaledToWidth(int width, Qt::TransformationMode mode = Qt::FastTransformation) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>scroll(int dx, int dy, int x, int y, int width, int height, QRegion * exposed = 0)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>scroll(int dx, int dy, const QRect &amp; rect, QRegion * exposed = 0)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMask(const QBitmap &amp; mask)</code></td>
</tr>
<tr>
<td><code>QSize</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(QPixmap &amp; other)</code></td>
</tr>
<tr>
<td><code>QImage</code></td>
<td><code>toImage() const</code></td>
</tr>
<tr>
<td><code>CGImageRef</code></td>
<td><code>toMacCGImageRef() const</code></td>
</tr>
<tr>
<td><code>HBITMAP</code></td>
<td><code>toWinHBITMAP(HBitmapFormat format = NoAlpha) const</code></td>
</tr>
<tr>
<td><code>HICON</code></td>
<td><code>toWinHICON() const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>transformed(const QTransform &amp; transform, Qt::TransformationMode mode = Qt::FastTransformation) const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>transformed(const QMatrix &amp; matrix, Qt::TransformationMode mode = Qt::FastTransformation) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>width() const</code></td>
</tr>
<tr>
<td><code>const QX11Info &amp;</code></td>
<td><code>x11Info() const</code></td>
</tr>
<tr>
<td><code>Qt::HANDLE</code></td>
<td><code>x11PictureHandle() const</code></td>
</tr>
<tr>
<td></td>
<td><code>operator QVariant() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!() const</code></td>
</tr>
<tr>
<td><code>QPixmap &amp;</code></td>
<td><code>operator=(const QPixmap &amp; pixmap)</code></td>
</tr>
<tr>
<td><code>QPixmap &amp;</code></td>
<td><code>operator=(QPixmap &amp;&amp; other)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Static-Public-Members"><a href="#Static-Public-Members" class="headerlink" title="Static Public Members"></a>Static Public Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td><code>defaultDepth()</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>fromImage(const QImage &amp; image, Qt::ImageConversionFlags flags = Qt::AutoColor)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>fromImageReader(QImageReader * imageReader, Qt::ImageConversionFlags flags = Qt::AutoColor)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>fromMacCGImageRef(CGImageRef image)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>fromWinHBITMAP(HBITMAP bitmap, HBitmapFormat format = NoAlpha)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>fromWinHICON(HICON icon)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>fromX11Pixmap(Qt::HANDLE pixmap, ShareMode mode = ImplicitlyShared)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>grabWidget(QWidget * widget, const QRect &amp; rectangle)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>grabWidget(QWidget * widget, int x = 0, int y = 0, int width = -1, int height = -1)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>grabWindow(WId window, int x = 0, int y = 0, int width = -1, int height = -1)</code></td>
</tr>
<tr>
<td><code>QTransform</code></td>
<td><code>trueMatrix(const QTransform &amp; matrix, int width, int height)</code></td>
</tr>
<tr>
<td><code>QMatrix</code></td>
<td><code>trueMatrix(const QMatrix &amp; m, int w, int h)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&lt;&lt;(QDataStream &amp; stream, const QPixmap &amp; pixmap)</code></td>
</tr>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&gt;&gt;(QDataStream &amp; stream, QPixmap &amp; pixmap)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QPixmap</code> class is an <code>off-screen</code> image representation that can be used as a paint device.<br>&emsp;&emsp;<code>Qt</code> provides four classes for handling image data: <code>QImage</code>, <code>QPixmap</code>, <code>QBitmap</code> and <code>QPicture</code>. <code>QImage</code> is designed and optimized for <code>I/O</code>, and for direct pixel access and manipulation, while <code>QPixmap</code> is designed and optimized for showing images on screen. <code>QBitmap</code> is only a convenience class that inherits <code>QPixmap</code>, ensuring a depth of <code>1</code>. The <code>isQBitmap()</code> function returns <code>true</code> if a <code>QPixmap</code> object is really a bitmap, otherwise returns <code>false</code>. Finally, the <code>QPicture</code> class is a paint device that records and replays <code>QPainter</code> commands.<br>&emsp;&emsp;A <code>QPixmap</code> can easily be displayed on the screen using <code>QLabel</code> or one of <code>QAbstractButton&#39;s</code> subclasses (such as <code>QPushButton</code> and <code>QToolButton</code>). <code>QLabel</code> has a pixmap property, whereas <code>QAbstractButton</code> has an icon property.<br>&emsp;&emsp;In addition to the ordinary constructors, a <code>QPixmap</code> can be constructed using the static <code>grabWidget()</code> and <code>grabWindow()</code> functions which creates a <code>QPixmap</code> and paints the given widget, or window, into it.<br>&emsp;&emsp;<code>QPixmap</code> objects can be passed around by value since the <code>QPixmap</code> class uses implicit data sharing. <code>QPixmap</code> objects can also be streamed.<br>&emsp;&emsp;Note that the pixel data in a pixmap is internal and is managed by the underlying window system. Because <code>QPixmap</code> is a <code>QPaintDevice</code> subclass, <code>QPainter</code> can be used to draw directly onto pixmaps. Pixels can only be accessed through <code>QPainter</code> functions or by converting the <code>QPixmap</code> to a <code>QImage</code>. However, the <code>fill()</code> function is available for initializing the entire pixmap with a given color.<br>&emsp;&emsp;There are functions to convert between <code>QImage</code> and <code>QPixmap</code>. Typically, the <code>QImage</code> class is used to load an image file, optionally manipulating the image data, before the <code>QImage</code> object is converted into a <code>QPixmap</code> to be shown on screen. Alternatively, if no manipulation is desired, the image file can be loaded directly into a <code>QPixmap</code>. On <code>Windows</code>, the <code>QPixmap</code> class also supports conversion between <code>HBITMAP</code> and <code>QPixmap</code>. On <code>Symbian</code>, the <code>QPixmap</code> class also supports conversion between <code>CFbsBitmap</code> and <code>QPixmap</code>.<br>&emsp;&emsp;<code>QPixmap</code> provides a collection of functions that can be used to obtain a variety of information about the pixmap. In addition, there are several functions that enables transformation of the pixmap.</p>
<h3 id="Reading-and-Writing-Image-Files"><a href="#Reading-and-Writing-Image-Files" class="headerlink" title="Reading and Writing Image Files"></a>Reading and Writing Image Files</h3><p>&emsp;&emsp;<code>QPixmap</code> provides several ways of reading an image file: The file can be loaded when constructing the <code>QPixmap</code> object, or by using the <code>load()</code> or <code>loadFromData()</code> functions later on. When loading an image, the file name can either refer to an actual file on disk or to one of the application’s embedded resources.<br>&emsp;&emsp;Simply call the <code>save()</code> function to save a <code>QPixmap</code> object.<br>&emsp;&emsp;The complete list of supported file formats are available through the <code>QImageReader::supportedImageFormats()</code> and <code>QImageWriter::supportedImageFormats()</code> functions. New file formats can be added as plugins. By default, <code>Qt</code> supports the following formats:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Format</th>
<th>Description</th>
<th>Qt’s support</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BMP</code></td>
<td><code>Windows Bitmap</code></td>
<td><code>Read/write</code></td>
</tr>
<tr>
<td><code>GIF</code></td>
<td><code>Graphic Interchange Format</code></td>
<td><code>Read</code></td>
</tr>
<tr>
<td><code>JPG</code></td>
<td><code>Joint Photographic Experts Group</code></td>
<td><code>Read/write</code></td>
</tr>
<tr>
<td><code>JPEG</code></td>
<td><code>Joint Photographic Experts Group</code></td>
<td><code>Read/write</code></td>
</tr>
<tr>
<td><code>PNG</code></td>
<td><code>Portable Network Graphics</code></td>
<td><code>Read/write</code></td>
</tr>
<tr>
<td><code>PBM</code></td>
<td><code>Portable Bitmap</code></td>
<td><code>Read</code></td>
</tr>
<tr>
<td><code>PGM</code></td>
<td><code>Portable Graymap</code></td>
<td><code>Read</code></td>
</tr>
<tr>
<td><code>PPM</code></td>
<td><code>Portable Pixmap</code></td>
<td><code>Read/write</code></td>
</tr>
<tr>
<td><code>XBM</code></td>
<td><code>X11 Bitmap</code></td>
<td><code>Read/write</code></td>
</tr>
<tr>
<td><code>XPM</code></td>
<td><code>X11 Pixmap</code></td>
<td><code>Read/write</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Pixmap-Information"><a href="#Pixmap-Information" class="headerlink" title="Pixmap Information"></a>Pixmap Information</h3><p>&emsp;&emsp;<code>QPixmap</code> provides a collection of functions that can be used to obtain a variety of information about the pixmap:</p>
<p>&emsp;&emsp;1. <code>Geometry</code>: The <code>size()</code>, <code>width()</code> and <code>height()</code> functions provide information about the pixmap’s size. The <code>rect()</code> function returns the image’s enclosing rectangle.<br>&emsp;&emsp;2. <code>Alpha component</code>: The <code>hasAlphaChannel()</code> returns <code>true</code> if the pixmap has a format that respects the alpha channel, otherwise returns <code>false</code>. The <code>hasAlpha()</code>, <code>setMask()</code> and <code>mask()</code> functions are legacy and should not be used. They are potentially very slow.<br>&emsp;&emsp;The <code>createHeuristicMask()</code> function creates and returns a <code>1-bpp</code> heuristic mask (i.e. a <code>QBitmap</code>) for this pixmap. It works by selecting a color from one of the corners and then chipping away pixels of that color, starting at all the edges. The <code>createMaskFromColor()</code> function creates and returns a mask (i.e. a <code>QBitmap</code>) for the pixmap based on a given color.<br>&emsp;&emsp;3. <code>Low-level information</code>: The <code>depth()</code> function returns the depth of the pixmap. The <code>defaultDepth()</code> function returns the default depth, i.e. the depth used by the application on the given screen.<br>&emsp;&emsp;The <code>cacheKey()</code> function returns a number that uniquely identifies the contents of the <code>QPixmap</code> object.<br>&emsp;&emsp;The <code>x11Info()</code> function returns information about the configuration of the <code>X</code> display used by the screen to which the pixmap currently belongs. The <code>x11PictureHandle()</code> function returns the <code>X11</code> Picture handle of the pixmap for <code>XRender</code> support. Note that the two latter functions are only available on <code>x11</code>.</p>
<h3 id="Pixmap-Conversion"><a href="#Pixmap-Conversion" class="headerlink" title="Pixmap Conversion"></a>Pixmap Conversion</h3><p>&emsp;&emsp;A <code>QPixmap</code> object can be converted into a <code>QImage</code> using the <code>toImage()</code> function. Likewise, a <code>QImage</code> can be converted into a <code>QPixmap</code> using the <code>fromImage()</code>. If this is too expensive an operation, you can use <code>QBitmap::fromImage()</code> instead.<br>&emsp;&emsp;In addition, on <code>Windows</code>, the <code>QPixmap</code> class supports conversion to and from <code>HBITMAP</code>: the <code>toWinHBITMAP()</code> function creates a <code>HBITMAP</code> equivalent to the <code>QPixmap</code>, based on the given <code>HBitmapFormat</code>, and returns the <code>HBITMAP</code> handle. The <code>fromWinHBITMAP()</code> function returns a <code>QPixmap</code> that is equivalent to the given bitmap which has the specified format. The <code>QPixmap</code> class also supports conversion to and from <code>HICON</code>: the <code>toWinHICON()</code> function creates a <code>HICON</code> equivalent to the <code>QPixmap</code>, and returns the <code>HICON</code> handle. The <code>fromWinHICON()</code> function returns a <code>QPixmap</code> that is equivalent to the given icon.</p>
<h3 id="Pixmap-Transformations"><a href="#Pixmap-Transformations" class="headerlink" title="Pixmap Transformations"></a>Pixmap Transformations</h3><p>&emsp;&emsp;<code>QPixmap</code> supports a number of functions for creating a new pixmap that is a transformed version of the original:<br>&emsp;&emsp;The <code>scaled()</code>, <code>scaledToWidth()</code> and <code>scaledToHeight()</code> functions return scaled copies of the pixmap, while the <code>copy()</code> function creates a <code>QPixmap</code> that is a plain copy of the original one.<br>&emsp;&emsp;The <code>transformed()</code> function returns a copy of the pixmap that is transformed with the given transformation matrix and transformation mode: Internally, the transformation matrix is adjusted to compensate for unwanted translation, i.e. <code>transformed()</code> returns the smallest pixmap containing all transformed points of the original pixmap. The static <code>trueMatrix()</code> function returns the actual matrix used for transforming the pixmap.<br>&emsp;&emsp;<strong>Note</strong>: When using the native <code>X11</code> graphics system, the pixmap becomes invalid when the <code>QApplication</code> instance is destroyed.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QPixmap::HBitmapFormat</code>: <code>Win32</code> only: This enum defines how the conversion between <code>HBITMAP</code> and <code>QPixmap</code> is performed. <strong>Warning</strong>: This enum is only available on <code>Windows</code>.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPixmap::NoAlpha</code></td>
<td><code>0</code></td>
<td>The alpha channel is ignored and always treated as being set to fully opaque. This is preferred if the <code>HBITMAP</code> is used with standard <code>GDI</code> calls, such as <code>BitBlt()</code>.</td>
</tr>
<tr>
<td><code>QPixmap::PremultipliedAlpha</code></td>
<td><code>1</code></td>
<td>The <code>HBITMAP</code> is treated as having an alpha channel and premultiplied colors. This is preferred if the <code>HBITMAP</code> is accessed through the <code>AlphaBlend()</code> <code>GDI</code> function.</td>
</tr>
<tr>
<td><code>QPixmap::Alpha</code></td>
<td><code>2</code></td>
<td>The <code>HBITMAP</code> is treated as having a plain alpha channel. This is the preferred format if the <code>HBITMAP</code> is going to be used as an application icon or systray icon.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QPixmap::ShareMode</code>: This enum type defines the share modes that are available when creating a <code>QPixmap</code> object from a raw <code>X11</code> <code>Pixmap</code> handle.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPixmap::ImplicitlyShared</code></td>
<td><code>0</code></td>
<td>This mode will cause the <code>QPixmap</code> object to create a copy of the internal data before it is modified, thus keeping the original <code>X11</code> pixmap intact.</td>
</tr>
<tr>
<td><code>QPixmap::ExplicitlyShared</code></td>
<td><code>1</code></td>
<td>In this mode, the pixmap data will not be copied before it is modified, which in effect will change the original <code>X11</code> pixmap.</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Warning</strong>: This enum is only used for <code>X11</code> specific functions; using it is <code>non-portable</code>.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QPixmap::QPixmap()</code>: Constructs a null pixmap.</li>
<li><code>QPixmap::QPixmap(int width, int height)</code>: Constructs a pixmap with the given <code>width</code> and <code>height</code>. If either <code>width</code> or <code>height</code> is zero, a null pixmap is constructed. Warning: This will create a <code>QPixmap</code> with uninitialized data. Call <code>fill()</code> to fill the pixmap with an appropriate color before drawing onto it with <code>QPainter</code>.</li>
<li><code>QPixmap::QPixmap(const QString &amp; fileName, const char * format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor)</code>: Constructs a pixmap from the file with the given <code>fileName</code>. If the file does not exist or is of an unknown format, the pixmap becomes a null pixmap. The loader attempts to read the pixmap using the specified <code>format</code>. If the <code>format</code> is not specified (which is the default), the loader probes the file for a header to guess the file format. The file name can either refer to an actual file on disk or to one of the application’s embedded resources. If the image needs to be modified to fit in a <code>lower-resolution</code> result (e.g. converting from <code>32-bit</code> to <code>8-bit</code>), use the <code>flags</code> to control the conversion. The <code>fileName</code>, <code>format</code> and <code>flags</code> parameters are passed on to <code>load()</code>. This means that the data in <code>fileName</code> is not compiled into the binary. If <code>fileName</code> contains a relative path (e.g. the filename only) the relevant file must be found relative to the runtime working directory.</li>
<li><code>QPixmap::QPixmap(const char * const[] xpm)</code>: Constructs a pixmap from the given <code>xpm</code> data, which must be a valid <code>XPM</code> image. Errors are silently ignored. Note that it’s possible to squeeze the <code>XPM</code> variable a little bit by using an unusual declaration:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> start_xpm[]=&#123;</span><br><span class="line">    <span class="string">"16 15 8 1"</span>,</span><br><span class="line">    <span class="string">"a c #cec6bd"</span>,</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>The extra const makes the entire definition <code>read-only</code>, which is slightly more efficient (for example, when the code is in a shared library) and <code>ROMable</code> when the application is to be stored in <code>ROM</code>.</p>
<ul>
<li><code>QPixmap::QPixmap(const QPixmap &amp; pixmap)</code>: Constructs a pixmap that is a copy of the given <code>pixmap</code>.</li>
<li><code>QPixmap::QPixmap(const QSize &amp; size)</code>: This is an overloaded function. Constructs a pixmap of the given <code>size</code>. <strong>Warning</strong>: This will create a <code>QPixmap</code> with uninitialized data. Call <code>fill()</code> to fill the pixmap with an appropriate color before drawing onto it with <code>QPainter</code>.</li>
<li><code>QPixmap::~QPixmap()</code>: Destroys the pixmap.</li>
<li><code>qint64 QPixmap::cacheKey() const</code>: Returns a number that identifies this <code>QPixmap</code>. Distinct <code>QPixmap</code> objects can only have the same cache key if they refer to the same contents. The <code>cacheKey()</code> will change when the pixmap is altered.</li>
<li><code>bool QPixmap::convertFromImage(const QImage &amp; image, Qt::ImageConversionFlags flags = Qt::AutoColor)</code>: Replaces this pixmap’s data with the given <code>image</code> using the specified <code>flags</code> to control the conversion. The <code>flags</code> argument is a <code>bitwise-OR</code> of the <code>Qt::ImageConversionFlags</code>. Passing <code>0</code> for <code>flags</code> sets all the default options. Returns <code>true</code> if the result is that this pixmap is not null. <strong>Note</strong>: this function was part of <code>Qt 3</code> support in <code>Qt 4.6</code> and earlier. It has been promoted to official <code>API</code> status in <code>4.7</code> to support updating the pixmap’s image without creating a new <code>QPixmap</code> as <code>fromImage()</code> would.</li>
<li><code>QPixmap QPixmap::copy(const QRect &amp; rectangle = QRect()) const</code>: Returns a deep copy of the subset of the pixmap that is specified by the given <code>rectangle</code>. If the given <code>rectangle</code> is empty, the whole image is copied.</li>
<li><code>QPixmap QPixmap::copy(int x, int y, int width, int height) const</code>: This is an overloaded function. Returns a deep copy of the subset of the pixmap that is specified by the rectangle <code>QRect(x, y, width, height)</code>.</li>
<li><code>QBitmap QPixmap::createHeuristicMask(bool clipTight = true) const</code>: Creates and returns a heuristic mask for this pixmap. The function works by selecting a color from one of the corners and then chipping away pixels of that color, starting at all the edges. If <code>clipTight</code> is <code>true</code> (the default), the mask is just large enough to cover the pixels; otherwise, the mask is larger than the data pixels. The mask may not be perfect but it should be reasonable, so you can do things such as the following:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPixmap myPixmap;</span><br><span class="line">myPixmap-&gt;setMask ( myPixmap-&gt;createHeuristicMask() );</span><br></pre></td></tr></table></figure>
<p>This function is slow because it involves converting <code>to/from</code> a <code>QImage</code>, and <code>non-trivial</code> computations.</p>
<ul>
<li><code>QBitmap QPixmap::createMaskFromColor(const QColor &amp; maskColor, Qt::MaskMode mode) const</code>: Creates and returns a mask for this pixmap based on the given <code>maskColor</code>. If the <code>mode</code> is <code>Qt::MaskInColor</code>, all pixels matching the <code>maskColor</code> will be transparent. If <code>mode</code> is <code>Qt::MaskOutColor</code>, all pixels matching the <code>maskColor</code> will be opaque. This function is slow because it involves converting <code>to/from</code> a <code>QImage</code>.</li>
<li><code>QBitmap QPixmap::createMaskFromColor(const QColor &amp; maskColor) const</code>: This is an overloaded function. Creates and returns a mask for this pixmap based on the given <code>maskColor</code>. Same as calling <code>createMaskFromColor(maskColor, Qt::MaskInColor)</code>.</li>
<li><code>int QPixmap::defaultDepth() [static]</code>: Returns the default pixmap depth used by the application. On <code>Windows</code> and <code>Mac</code>, the default depth is always <code>32</code>. On <code>X11</code> and embedded, the depth of the screen will be returned by this function.</li>
<li><code>int QPixmap::depth() const</code>: Returns the depth of the pixmap. The pixmap depth is also called <code>bits per pixel</code> (<code>bpp</code>) or bit planes of a pixmap. A null pixmap has depth <code>0</code>.</li>
<li><code>void QPixmap::detach()</code>: Detaches the pixmap from shared pixmap data. A pixmap is automatically detached by <code>Qt</code> whenever its contents are about to change. This is done in almost all <code>QPixmap</code> member functions that modify the pixmap (<code>fill()</code>, <code>fromImage()</code>, <code>load()</code>, etc.), and in <code>QPainter::begin()</code> on a pixmap. There are two exceptions in which <code>detach()</code> must be called explicitly, that is when calling the <code>handle()</code> or the <code>x11PictureHandle()</code> function (only available on <code>X11</code>). Otherwise, any modifications done using system calls, will be performed on the shared data. The <code>detach()</code> function returns immediately if there is just a single reference or if the pixmap has not been initialized yet.</li>
<li><code>void QPixmap::fill(const QColor &amp; color = Qt::white)</code>: Fills the pixmap with the given <code>color</code>. The effect of this function is undefined when the pixmap is being painted on.</li>
<li><code>void QPixmap::fill(const QWidget * widget, const QPoint &amp; offset)</code>: Fills the pixmap with the <code>widget&#39;s</code> background color or pixmap according to the given <code>offset</code>. The <code>QPoint</code> <code>offset</code> defines a point in <code>widget</code> coordinates to which the pixmap’s <code>top-left</code> pixel will be mapped to. This is only significant if the <code>widget</code> has a background pixmap; otherwise the pixmap will simply be filled with the background color of the <code>widget</code>.</li>
<li><code>void QPixmap::fill(const QWidget * widget, int x, int y)</code>: This is an overloaded function. Fills the pixmap with the <code>widget&#39;s</code> background color or pixmap. The given point, <code>(x, y)</code>, defines an offset in <code>widget</code> coordinates to which the pixmap’s <code>top-left</code> pixel will be mapped to.</li>
<li><code>QPixmap QPixmap::fromImage(const QImage &amp; image, Qt::ImageConversionFlags flags = Qt::AutoColor) [static]</code>: Converts the given <code>image</code> to a pixmap using the specified <code>flags</code> to control the conversion. The <code>flags</code> argument is a <code>bitwise-OR</code> of the <code>Qt::ImageConversionFlags</code>. Passing <code>0</code> for <code>flags</code> sets all the default options. In case of monochrome and <code>8-bit</code> images, the <code>image</code> is first converted to a <code>32-bit</code> pixmap and then filled with the colors in the color table. If this is too expensive an operation, you can use <code>QBitmap::fromImage()</code> instead.</li>
<li><code>QPixmap QPixmap::fromImageReader(QImageReader * imageReader, Qt::ImageConversionFlags flags = Qt::AutoColor) [static]</code>: Create a <code>QPixmap</code> from an image read directly from an <code>imageReader</code>. The <code>flags</code> argument is a <code>bitwise-OR</code> of the <code>Qt::ImageConversionFlags</code>. Passing <code>0</code> for <code>flags</code> sets all the default options. On some systems, reading an image directly to <code>QPixmap</code> can use less memory than reading a <code>QImage</code> to convert it to <code>QPixmap</code>.</li>
<li><p><code>QPixmap QPixmap::fromMacCGImageRef(CGImageRef image) [static]</code>: Returns a <code>QPixmap</code> that is equivalent to the given <code>image</code>. <strong>Warning</strong>: This function is only available on <code>Mac OS X</code>.</p>
</li>
<li><p><code>QPixmap QPixmap::fromWinHBITMAP(HBITMAP bitmap, HBitmapFormat format = NoAlpha) [static]</code>: <code>Win32</code> only: Returns a <code>QPixmap</code> that is equivalent to the given <code>bitmap</code>. The conversion is based on the specified <code>format</code>. <strong>Warning</strong>: This function is only available on Windows.</p>
</li>
<li><code>QPixmap QPixmap::fromWinHICON(HICON icon) [static]</code>: <code>Win32</code> only: Returns a <code>QPixmap</code> that is equivalent to the given <code>icon</code>. <strong>Warning</strong>: This function is only available on <code>Windows</code>.</li>
<li><code>QPixmap QPixmap::fromX11Pixmap(Qt::HANDLE pixmap, ShareMode mode = ImplicitlyShared) [static]</code>: Creates a <code>QPixmap</code> from the native <code>X11</code> <code>Pixmap</code> handle <code>pixmap</code>, using mode as the share <code>mode</code>. The default share mode is <code>QPixmap::ImplicitlyShared</code>, which means that a copy of the pixmap is made if someone tries to modify it by e.g. drawing onto it. <code>QPixmap</code> does not take ownership of the pixmap handle, and have to be deleted by the user. <strong>Warning</strong>: This function is <code>X11</code> specific; using it is <code>non-portable</code>.</li>
<li><code>QPixmap QPixmap::grabWidget(QWidget * widget, const QRect &amp; rectangle) [static]</code>: Creates a pixmap and paints the given <code>widget</code>, restricted by the given <code>rectangle</code>, in it. If the <code>widget</code> has any children, then they are also painted in the appropriate positions. If no <code>rectangle</code> is specified (the default) the entire widget is painted. If <code>widget</code> is <code>0</code>, the specified <code>rectangle</code> doesn’t overlap the widget’s rectangle, or an error occurs, the function will return a null <code>QPixmap</code>. If the <code>rectangle</code> is a superset of the given <code>widget</code>, the areas outside the <code>widget</code> are covered with the widget’s background. This function actually asks <code>widget</code> to paint itself (and its children to paint themselves) by calling <code>paintEvent()</code> with painter redirection turned on. But <code>QPixmap</code> also provides the <code>grabWindow()</code> function which is a bit faster by grabbing pixels directly off the screen. In addition, if there are overlaying windows, <code>grabWindow()</code>, unlike <code>grabWidget()</code>, will see them. <strong>Warning</strong>: Do not grab a widget from its <code>QWidget::paintEvent()</code>. However, it is safe to grab a widget from another widget’s <code>paintEvent()</code>.</li>
<li><code>QPixmap QPixmap::grabWidget(QWidget * widget, int x = 0, int y = 0, int width = -1, int height = -1) [static]</code>: This is an overloaded function. Creates a pixmap and paints the given <code>widget</code>, restricted by <code>QRect(x, y, width, height)</code>, in it. <strong>Warning</strong>: Do not grab a widget from its <code>QWidget::paintEvent()</code>. However, it is safe to grab a widget from another widget’s <code>paintEvent()</code>.</li>
<li><code>QPixmap QPixmap::grabWindow(WId window, int x = 0, int y = 0, int width = -1, int height = -1) [static]</code>: Creates and returns a pixmap constructed by grabbing the contents of the given <code>window</code> restricted by <code>QRect(x, y, width, height)</code>. The arguments <code>(x, y)</code> specify the offset in the window, whereas <code>(width, height)</code> specify the area to be copied. If <code>width</code> is negative, the function copies everything to the right border of the window. If <code>height</code> is negative, the function copies everything to the bottom of the window. The <code>window system identifier</code> (<code>WId</code>) can be retrieved using the <code>QWidget::winId()</code> function. The rationale for using a window identifier and not a <code>QWidget</code>, is to enable grabbing of windows that are not part of the application, window system frames, and so on. The <code>grabWindow()</code> function grabs pixels from the screen, not from the window, i.e. if there is another window partially or entirely over the one you grab, you get pixels from the overlying window, too. The mouse cursor is generally not grabbed. Note on <code>X11</code> that if the given <code>window</code> doesn’t have the same depth as the root window, and another window partially or entirely obscures the one you grab, you will not get pixels from the overlying window. The contents of the obscured areas in the pixmap will be undefined and uninitialized. On <code>Windows Vista</code> and above grabbing a layered window, which is created by setting the <code>Qt::WA_TranslucentBackground</code> attribute, will not work. Instead grabbing the desktop widget should work. <strong>Warning</strong>: In general, grabbing an area outside the screen is not safe. This depends on the underlying window system.</li>
<li><code>Qt::HANDLE QPixmap::handle() const</code>: Returns the pixmap’s handle to the device context. Note that, since <code>QPixmap</code> make use of implicit data sharing, the <code>detach()</code> function must be called explicitly to ensure that only this pixmap’s data is modified if the pixmap data is shared. <strong>Warning</strong>: This function is <code>X11</code> specific; using it is <code>non-portable</code>. <strong>Warning</strong>: Since <code>4.8</code>, pixmaps do not have an <code>X11</code> handle unless created with <code>fromX11Pixmap()</code>, or if the native graphics system is explicitly enabled.</li>
<li><code>bool QPixmap::hasAlpha() const</code>: Returns <code>true</code> if this pixmap has an alpha channel, or has a mask, otherwise returns <code>false</code>.</li>
<li><code>bool QPixmap::hasAlphaChannel() const</code>: Returns <code>true</code> if the pixmap has a format that respects the alpha channel, otherwise returns <code>false</code>.</li>
<li><code>int QPixmap::height() const</code>: Returns the height of the pixmap.</li>
<li><code>bool QPixmap::isNull() const</code>: Returns <code>true</code> if this is a null pixmap; otherwise returns <code>false</code>. A null pixmap has zero width, zero height and no contents. You cannot draw in a null pixmap.</li>
<li><code>bool QPixmap::isQBitmap() const</code>: Returns <code>true</code> if this is a <code>QBitmap</code>; otherwise returns <code>false</code>.</li>
<li><p><code>bool QPixmap::load(const QString &amp; fileName, const char * format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor)</code>: Loads a pixmap from the file with the given <code>fileName</code>. Returns <code>true</code> if the pixmap was successfully loaded; otherwise returns <code>false</code>. The loader attempts to read the pixmap using the specified <code>format</code>. If the <code>format</code> is not specified (which is the default), the loader probes the file for a header to guess the file format. The file name can either refer to an actual file on disk or to one of the application’s embedded resources. If the data needs to be modified to fit in a <code>lower-resolution</code> result (e.g. converting from <code>32-bit</code> to <code>8-bit</code>), use the <code>flags</code> to control the conversion. Note that <code>QPixmaps</code> are automatically added to the <code>QPixmapCache</code> when loaded from a file; the key used is internal and can not be acquired.</p>
</li>
<li><p><code>bool QPixmap::loadFromData(const uchar * data, uint len, const char * format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor)</code>: Loads a pixmap from the <code>len</code> first bytes of the given binary <code>data</code>. Returns <code>true</code> if the pixmap was loaded successfully; otherwise returns <code>false</code>. The loader attempts to read the pixmap using the specified <code>format</code>. If the <code>format</code> is not specified (which is the default), the loader probes the file for a header to guess the file format. If the <code>data</code> needs to be modified to fit in a <code>lower-resolution</code> result (e.g. converting from <code>32-bit</code> to <code>8-bit</code>), use the <code>flags</code> to control the conversion.</p>
</li>
<li><code>bool QPixmap::loadFromData(const QByteArray &amp; data, const char * format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor)</code>: This is an overloaded function. Loads a pixmap from the binary <code>data</code> using the specified <code>format</code> and conversion <code>flags</code>.</li>
<li><code>QBitmap QPixmap::mask() const</code>: Extracts a bitmap mask from the pixmap’s alpha channel. <strong>Warning</strong>: This is potentially an expensive operation. The mask of the pixmap is extracted dynamically from the pixeldata.</li>
<li><code>QRect QPixmap::rect() const</code>: Returns the pixmap’s enclosing rectangle.</li>
<li><code>bool QPixmap::save(const QString &amp; fileName, const char * format = 0, int quality = -1) const</code>: Saves the pixmap to the file with the given <code>fileName</code> using the specified image file <code>format</code> and <code>quality</code> factor. Returns <code>true</code> if successful; otherwise returns <code>false</code>. The <code>quality</code> factor must be in the range <code>[0, 100]</code> or <code>-1</code>. Specify <code>0</code> to obtain small compressed files, <code>100</code> for large uncompressed files, and <code>-1</code> to use the default settings. If <code>format</code> is <code>0</code>, an image format will be chosen from <code>fileName&#39;s</code> suffix.</li>
<li><code>bool QPixmap::save(QIODevice * device, const char * format = 0, int quality = -1) const</code>: This is an overloaded function. This function writes a <code>QPixmap</code> to the given <code>device</code> using the specified image file <code>format</code> and <code>quality</code> factor. This can be used, for example, to save a pixmap directly into a <code>QByteArray</code>:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QPixmap pixmap;</span><br><span class="line">QByteArray bytes;</span><br><span class="line"><span class="function">QBuffer <span class="title">buffer</span> <span class="params">( &amp;bytes )</span></span>;</span><br><span class="line">buffer.open ( QIODevice::WriteOnly );</span><br><span class="line"><span class="comment">/* writes pixmap into bytes in PNG format */</span></span><br><span class="line">pixmap.save ( &amp;buffer, <span class="string">"PNG"</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QPixmap QPixmap::scaled(const QSize &amp; size, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation) const</code>: Scales the pixmap to the given <code>size</code>, using the aspect ratio and transformation modes specified by <code>aspectRatioMode</code> and <code>transformMode</code>.</li>
</ul>
<p><img src="/2019/02/20/Qt语法详解/Qt之QPixmap/1.png"></p>
<ol>
<li>If <code>aspectRatioMode</code> is <code>Qt::IgnoreAspectRatio</code>, the pixmap is scaled to <code>size</code>.</li>
<li>If <code>aspectRatioMode</code> is <code>Qt::KeepAspectRatio</code>, the pixmap is scaled to a rectangle as large as possible inside <code>size</code>, preserving the aspect ratio.</li>
<li>If <code>aspectRatioMode</code> is <code>Qt::KeepAspectRatioByExpanding</code>, the pixmap is scaled to a rectangle as small as possible outside <code>size</code>, preserving the aspect ratio.</li>
</ol>
<p>If the given <code>size</code> is empty, this function returns a null pixmap. In some cases it can be more beneficial to draw the pixmap to a painter with a scale set rather than scaling the pixmap. This is the case when the painter is for instance based on <code>OpenGL</code> or when the scale factor changes rapidly.</p>
<ul>
<li><code>QPixmap QPixmap::scaled(int width, int height, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation) const</code>: This is an overloaded function. Returns a copy of the pixmap scaled to a rectangle with the given <code>width</code> and <code>height</code> according to the given <code>aspectRatioMode</code> and <code>transformMode</code>. If either the <code>width</code> or the <code>height</code> is zero or negative, this function returns a null pixmap.</li>
<li><code>QPixmap QPixmap::scaledToHeight(int height, Qt::TransformationMode mode = Qt::FastTransformation) const</code>: Returns a scaled copy of the image. The returned image is scaled to the given <code>height</code> using the specified transformation <code>mode</code>. The width of the pixmap is automatically calculated so that the aspect ratio of the pixmap is preserved. If <code>height</code> is <code>0</code> or negative, a null pixmap is returned.</li>
<li><code>QPixmap QPixmap::scaledToWidth(int width, Qt::TransformationMode mode = Qt::FastTransformation) const</code>: Returns a scaled copy of the image. The returned image is scaled to the given <code>width</code> using the specified transformation <code>mode</code>. The height of the pixmap is automatically calculated so that the aspect ratio of the pixmap is preserved. If <code>width</code> is <code>0</code> or <code>negative</code>, a null pixmap is returned.</li>
<li><code>void QPixmap::scroll(int dx, int dy, int x, int y, int width, int height, QRegion * exposed = 0)</code>: This convenience function is equivalent to calling <code>QPixmap::scroll(dx, dy, QRect(x, y, width, height), exposed)</code>.</li>
<li><code>void QPixmap::scroll(int dx, int dy, const QRect &amp; rect, QRegion * exposed = 0)</code>: Scrolls the area <code>rect</code> of this pixmap by <code>(dx, dy)</code>. The <code>exposed</code> region is left unchanged. You can optionally pass a pointer to an empty <code>QRegion</code> to get the region that is <code>exposed</code> by the scroll operation.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">pixmap</span> <span class="params">( <span class="string">"background.png"</span> )</span></span>;</span><br><span class="line">QRegion exposed;</span><br><span class="line">pixmap.scroll ( <span class="number">10</span>, <span class="number">10</span>, pixmap.rect(), &amp;exposed );</span><br></pre></td></tr></table></figure>
<p>You cannot scroll while there is an active painter on the pixmap.</p>
<ul>
<li><code>void QPixmap::setMask(const QBitmap &amp; mask)</code>: Sets a <code>mask</code> bitmap. This function merges the <code>mask</code> with the pixmap’s alpha channel. A pixel value of <code>1</code> on the <code>mask</code> means the pixmap’s pixel is unchanged; a value of <code>0</code> means the pixel is transparent. The <code>mask</code> must have the same size as this pixmap. Setting a null mask resets the <code>mask</code>, leaving the previously transparent pixels black. The effect of this function is undefined when the pixmap is being painted on. <strong>Warning</strong>: This is potentially an expensive operation.</li>
<li><code>QSize QPixmap::size() const</code>: Returns the size of the pixmap.</li>
<li><code>void QPixmap::swap(QPixmap &amp; other)</code>: Swaps pixmap <code>other</code> with this pixmap. This operation is very fast and never fails.</li>
<li><code>QImage QPixmap::toImage() const</code>: Converts the pixmap to a <code>QImage</code>. Returns a null image if the conversion fails. If the pixmap has <code>1-bit</code> depth, the returned image will also be <code>1</code> bit deep. Images with more bits will be returned in a format closely represents the underlying system. Usually this will be <code>QImage::Format_ARGB32_Premultiplied</code> for pixmaps with an alpha and <code>QImage::Format_RGB32</code> or <code>QImage::Format_RGB16</code> for pixmaps without alpha. Note that for the moment, alpha masks on monochrome images are ignored.</li>
<li><code>CGImageRef QPixmap::toMacCGImageRef() const</code>: Creates a <code>CGImageRef</code> equivalent to the <code>QPixmap</code>. Returns the <code>CGImageRef</code> handle. It is the caller’s responsibility to release the <code>CGImageRef</code> data after use. <strong>Warning</strong>: This function is only available on <code>Mac OS X</code>.</li>
<li><code>HBITMAP QPixmap::toWinHBITMAP(HBitmapFormat format = NoAlpha) const</code>:  <code>Win32</code> only: Creates a <code>HBITMAP</code> equivalent to the <code>QPixmap</code>, based on the given <code>format</code>. Returns the <code>HBITMAP</code> handle. It is the caller’s responsibility to free the <code>HBITMAP</code> data after use. <strong>Warning</strong>: This function is only available on <code>Windows</code>.</li>
<li><code>HICON QPixmap::toWinHICON() const</code>: <code>Win32</code> only: Creates a <code>HICON</code> equivalent to the <code>QPixmap</code>. Returns the <code>HICON</code> handle. It is the caller’s responsibility to free the <code>HICON</code> data after use. <strong>Warning</strong>: This function is only available on <code>Windows</code>.</li>
<li><code>QPixmap QPixmap::transformed(const QTransform &amp; transform, Qt::TransformationMode mode = Qt::FastTransformation) const</code>: Returns a copy of the pixmap that is transformed using the given transformation <code>transform</code> and transformation <code>mode</code>. The original pixmap is not changed. The transformation <code>transform</code> is internally adjusted to compensate for unwanted translation; i.e. the pixmap produced is the smallest pixmap that contains all the transformed points of the original pixmap. Use the <code>trueMatrix()</code> function to retrieve the actual matrix used for transforming the pixmap. This function is slow because it involves transformation to a <code>QImage</code>, <code>non-trivial</code> computations and a transformation back to a <code>QPixmap</code>.</li>
<li><code>QPixmap QPixmap::transformed(const QMatrix &amp; matrix, Qt::TransformationMode mode = Qt::FastTransformation) const</code>: This is an overloaded function. This convenience function loads the <code>matrix</code> into a <code>QTransform</code> and calls the overloaded function.</li>
<li><code>QTransform QPixmap::trueMatrix(const QTransform &amp; matrix, int width, int height) [static]</code>: Returns the actual <code>matrix</code> used for transforming a pixmap with the given <code>width</code>, <code>height</code> and <code>matrix</code>. When transforming a pixmap using the <code>transformed()</code> function, the transformation <code>matrix</code> is internally adjusted to compensate for unwanted translation, i.e. <code>transformed()</code> returns the smallest pixmap containing all transformed points of the original pixmap. This function returns the modified <code>matrix</code>, which maps points correctly from the original pixmap into the new pixmap.</li>
<li><code>QMatrix QPixmap::trueMatrix(const QMatrix &amp; m, int w, int h) [static]</code>: This is an overloaded function. This convenience function loads the matrix <code>m</code> into a <code>QTransform</code> and calls the overloaded function with the <code>QTransform</code> and the width <code>w</code> and the height <code>h</code>.</li>
<li><code>int QPixmap::width() const</code>: Returns the width of the pixmap.</li>
<li><code>const QX11Info &amp; QPixmap::x11Info() const</code>: <code>X11</code> only: Returns information about the configuration of the <code>X</code> display used by the screen to which the pixmap currently belongs. <strong>Warning</strong>: This function is only available on <code>X11</code>.</li>
<li><code>Qt::HANDLE QPixmap::x11PictureHandle() const</code>: <code>X11</code> only: Returns the <code>X11</code> <code>Picture</code> handle of the pixmap for <code>XRender</code> support. This function will return <code>0</code> if <code>XRender</code> support is not compiled into <code>Qt</code>, if the <code>XRender</code> extension is not supported on the <code>X11</code> display, or if the handle could not be created. Use of this function is not portable. <strong>Warning</strong>: This function is only available on <code>X11</code>.</li>
<li><code>QPixmap::operator QVariant() const</code>: Returns the pixmap as a <code>QVariant</code>.</li>
<li><code>bool QPixmap::operator!() const</code>: Returns <code>true</code> if this is a null pixmap; otherwise returns <code>false</code>.</li>
<li><code>QPixmap &amp; QPixmap::operator=(const QPixmap &amp; pixmap)</code>: Assigns the given <code>pixmap</code> to this pixmap and returns a reference to this pixmap.</li>
</ul>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; stream, const QPixmap &amp; pixmap)</code>: Writes the given <code>pixmap</code> to the given <code>stream</code> as a <code>PNG</code> image. Note that writing the stream to a file will not produce a valid image file.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; stream, QPixmap &amp; pixmap)</code>: Reads an image from the given <code>stream</code> into the given <code>pixmap</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/20/Qt语法详解/Qt之QTextFrameFormat/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/20/Qt语法详解/Qt之QTextFrameFormat/" itemprop="url">Qt之QTextFrameFormat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-20T13:00:40+08:00">
                2019-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTextFrameFormat</code> class provides formatting information for frames in a <code>QTextDocument</code>.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextFrameFormat</code></td>
<td><code>QTextFormat</code></td>
<td><code>QTextTableFormat</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextFrameFormat()</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>border() const</code></td>
</tr>
<tr>
<td><code>QBrush</code></td>
<td><code>borderBrush() const</code></td>
</tr>
<tr>
<td><code>BorderStyle</code></td>
<td><code>borderStyle() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>bottomMargin() const</code></td>
</tr>
<tr>
<td><code>QTextLength</code></td>
<td><code>height() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isValid() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>leftMargin() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>margin() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>padding() const</code></td>
</tr>
<tr>
<td><code>PageBreakFlags</code></td>
<td><code>pageBreakPolicy() const</code></td>
</tr>
<tr>
<td><code>Position</code></td>
<td><code>position() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>rightMargin() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBorder(qreal width)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBorderBrush(const QBrush &amp; brush)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBorderStyle(BorderStyle style)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBottomMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHeight(const QTextLength &amp; height)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHeight(qreal height)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setLeftMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPadding(qreal width)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPageBreakPolicy(PageBreakFlags policy)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPosition(Position policy)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setRightMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTopMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setWidth(const QTextLength &amp; width)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setWidth(qreal width)</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>topMargin() const</code></td>
</tr>
<tr>
<td><code>QTextLength</code></td>
<td><code>width() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextFrameFormat</code> class provides formatting information for frames in a <code>QTextDocument</code>.<br>&emsp;&emsp;A text frame groups together one or more blocks of text, providing a layer of structure larger than the paragraph. The format of a frame specifies how it is rendered and positioned on the screen. It does not directly specify the behavior of the text formatting within, but provides constraints on the layout of its children.<br>&emsp;&emsp;The frame format defines the <code>width()</code> and <code>height()</code> of the frame on the screen. Each frame can have a <code>border()</code> that surrounds its contents with a rectangular box. The border is surrounded by a <code>margin()</code> around the frame, and the contents of the frame are kept separate from the border by the frame’s <code>padding()</code>. This scheme is similar to the box model used by <code>Cascading Style Sheets</code> for <code>HTML</code> pages.</p>
<p><img src="/2019/02/20/Qt语法详解/Qt之QTextFrameFormat/1.png" height="159" width="246"></p>
<p>&emsp;&emsp;The <code>position()</code> of a frame is set using <code>setPosition()</code> and determines how it is located relative to the surrounding text.<br>&emsp;&emsp;The validity of a <code>QTextFrameFormat</code> object can be determined with the <code>isValid()</code> function.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li><code>enum QTextFrameFormat::BorderStyle</code>: This enum describes different border styles for the text frame.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextFrameFormat::BorderStyle_None</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_Dotted</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_Dashed</code></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_Solid</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_Double</code></td>
<td><code>4</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_DotDash</code></td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_DotDotDash</code></td>
<td><code>6</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_Groove</code></td>
<td><code>7</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_Ridge</code></td>
<td><code>8</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_Inset</code></td>
<td><code>9</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_Outset</code></td>
<td><code>10</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>enum QTextFrameFormat::Position</code>: This enum describes how a frame is located relative to the surrounding text.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextFrameFormat::InFlow</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::FloatLeft</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::FloatRight</code></td>
<td><code>2</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextFrameFormat::QTextFrameFormat()</code>: Constructs a text frame format object with the default properties.</li>
<li><code>qreal QTextFrameFormat::border() const</code>: Returns the width of the border in pixels.</li>
<li><code>QBrush QTextFrameFormat::borderBrush() const</code>: Returns the brush used for the frame’s border.</li>
<li><code>BorderStyle QTextFrameFormat::borderStyle() const</code>: Returns the style of the frame’s border.</li>
<li><code>qreal QTextFrameFormat::bottomMargin() const</code>: Returns the width of the frame’s bottom margin in pixels.</li>
<li><code>QTextLength QTextFrameFormat::height() const</code>: Returns the height of the frame’s border rectangle.</li>
<li><code>bool QTextFrameFormat::isValid() const</code>: Returns <code>true</code> if the format description is valid; otherwise returns <code>false</code>.</li>
<li><code>qreal QTextFrameFormat::leftMargin() const</code>: Returns the width of the frame’s left margin in pixels.</li>
<li><code>qreal QTextFrameFormat::margin() const</code>: Returns the width of the frame’s external margin in pixels.</li>
<li><code>qreal QTextFrameFormat::padding() const</code>: Returns the width of the frame’s internal padding in pixels.</li>
<li><code>PageBreakFlags QTextFrameFormat::pageBreakPolicy() const</code>: Returns the currently set page break policy for the <code>frame/table</code>. The default is <code>QTextFormat::PageBreak_Auto</code>.</li>
<li><code>Position QTextFrameFormat::position() const</code>: Returns the positioning policy for frames with this frame format.</li>
<li><code>qreal QTextFrameFormat::rightMargin() const</code>: Returns the width of the frame’s right margin in pixels.</li>
<li><code>void QTextFrameFormat::setBorder(qreal width)</code>: Sets the <code>width</code> (in pixels) of the frame’s border.</li>
<li><code>void QTextFrameFormat::setBorderBrush(const QBrush &amp; brush)</code>: Sets the <code>brush</code> used for the frame’s border.</li>
<li><code>void QTextFrameFormat::setBorderStyle(BorderStyle style)</code>: Sets the <code>style</code> of the frame’s border.</li>
<li><code>void QTextFrameFormat::setBottomMargin(qreal margin)</code>: Sets the frame’s bottom <code>margin</code> in pixels.</li>
<li><code>void QTextFrameFormat::setHeight(const QTextLength &amp; height)</code>: Sets the frame’s <code>height</code>.</li>
<li><code>void QTextFrameFormat::setHeight(qreal height)</code>: This is an overloaded function. Sets the frame’s <code>height</code>.</li>
<li><code>void QTextFrameFormat::setLeftMargin(qreal margin)</code>: Sets the frame’s left <code>margin</code> in pixels.</li>
<li><code>void QTextFrameFormat::setMargin(qreal margin)</code>: Sets the frame’s <code>margin</code> in pixels. This method also sets the left, right, top and bottom margins of the frame to the same value. The individual margins override the general margin.</li>
<li><code>void QTextFrameFormat::setPadding(qreal width)</code>: Sets the <code>width</code> of the frame’s internal padding in pixels.</li>
<li><code>void QTextFrameFormat::setPageBreakPolicy(PageBreakFlags policy)</code>: Sets the page break policy for the <code>frame/table</code> to <code>policy</code>.</li>
<li><code>void QTextFrameFormat::setPosition(Position policy)</code>: Sets the <code>policy</code> for positioning frames with this frame format.</li>
<li><code>void QTextFrameFormat::setRightMargin(qreal margin)</code>: Sets the frame’s right <code>margin</code> in pixels.</li>
<li><code>void QTextFrameFormat::setTopMargin(qreal margin)</code>: Sets the frame’s top <code>margin</code> in pixels.</li>
<li><code>void QTextFrameFormat::setWidth(const QTextLength &amp; width)</code>: Sets the frame’s border rectangle’s <code>width</code>.</li>
<li><code>void QTextFrameFormat::setWidth(qreal width)</code>: This is an overloaded function. Convenience method that sets the <code>width</code> of the frame’s border rectangle’s width to the specified fixed width.</li>
<li><code>qreal QTextFrameFormat::topMargin() const</code>: Returns the width of the frame’s top margin in pixels.</li>
<li><code>QTextLength QTextFrameFormat::width() const</code>: Returns the width of the frame’s border rectangle.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/19/Qt语法详解/Qt之QTextBlock/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/Qt语法详解/Qt之QTextBlock/" itemprop="url">Qt之QTextBlock</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T21:02:01+08:00">
                2019-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTextBlock</code> class provides a container for text fragments in a <code>QTextDocument</code>. The header file is <code>QTextBlock</code>. <strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextBlock(const QTextBlock &amp; other)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>QTextBlockFormat</code></td>
<td><code>blockFormat() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>blockFormatIndex() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>blockNumber() const</code></td>
</tr>
<tr>
<td><code>QTextCharFormat</code></td>
<td><code>charFormat() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>charFormatIndex() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clearLayout()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>contains(int position) const</code></td>
</tr>
<tr>
<td><code>const QTextDocument *</code></td>
<td><code>document() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>firstLineNumber() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isValid() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isVisible() const</code></td>
</tr>
<tr>
<td><code>QTextLayout *</code></td>
<td><code>layout() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>length() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lineCount() const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>next() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>position() const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>previous() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>revision() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setLineCount(int count)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setRevision(int rev)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUserData(QTextBlockUserData * data)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUserState(int state)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setVisible(bool visible)</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>text() const</code></td>
</tr>
<tr>
<td><code>Qt::LayoutDirection</code></td>
<td><code>textDirection() const</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>textList() const</code></td>
</tr>
<tr>
<td><code>QTextBlockUserData *</code></td>
<td><code>userData() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>userState() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QTextBlock &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&lt;(const QTextBlock &amp; other) const</code></td>
</tr>
<tr>
<td><code>QTextBlock &amp;</code></td>
<td><code>operator=(const QTextBlock &amp; other)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QTextBlock &amp; other) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextBlock</code> class provides a container for text fragments in a <code>QTextDocument</code>.<br>&emsp;&emsp;A text block encapsulates a block or paragraph of text in a <code>QTextDocument</code>. <code>QTextBlock</code> provides <code>read-only</code> access to the <code>block/paragraph</code> structure of <code>QTextDocuments</code>. It is mainly of use if you want to implement your own layouts for the visual representation of a <code>QTextDocument</code>, or if you want to iterate over a document and write out the contents in your own custom format.<br>&emsp;&emsp;Text blocks are created by their parent documents. If you need to create a new text block, or modify the contents of a document while examining its contents, use the <code>cursor-based</code> interface provided by <code>QTextCursor</code> instead.<br>&emsp;&emsp;Each text block is located at a specific <code>position()</code> in a <code>document()</code>. The contents of the block can be obtained by using the <code>text()</code> function. The <code>length()</code> function determines the block’s size within the document (including formatting characters). The visual properties of the block are determined by its text <code>layout()</code>, its <code>charFormat()</code>, and its <code>blockFormat()</code>.<br>&emsp;&emsp;The <code>next()</code> and <code>previous()</code> functions enable iteration over consecutive valid blocks in a document under the condition that the document is not modified by other means during the iteration process. Note that, although blocks are returned in sequence, adjacent blocks may come from different places in the document structure. The validity of a block can be determined by calling <code>isValid()</code>.<br>&emsp;&emsp;<code>QTextBlock</code> provides comparison operators to make it easier to work with blocks: <code>operator==()</code> compares two block for equality, <code>operator!=()</code> compares two blocks for inequality, and <code>operator&lt;()</code> determines whether a block precedes another in the same document.</p>
<p><img src="/2019/02/19/Qt语法详解/Qt之QTextBlock/1.png" height="156" width="164"></p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li><code>typedef QTextBlock::Iterator</code>: <code>Qt-style</code> synonym for <code>QTextBlock::iterator</code>.</li>
</ul>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextBlock::QTextBlock(const QTextBlock &amp; other)</code>: Copies the <code>other</code> text block’s attributes to this text block.</li>
<li><code>iterator QTextBlock::begin() const</code>: Returns a text block iterator pointing to the beginning of the text block.</li>
<li><code>QTextBlockFormat QTextBlock::blockFormat() const</code>: Returns the QTextBlockFormat that describes <code>block-specific</code> properties.</li>
<li><code>int QTextBlock::blockFormatIndex() const</code>: Returns an index into the document’s internal list of block formats for the text block’s format.</li>
<li><code>int QTextBlock::blockNumber() const</code>: Returns the number of this block, or <code>-1</code> if the block is invalid.</li>
<li><code>QTextCharFormat QTextBlock::charFormat() const</code>: Returns the <code>QTextCharFormat</code> that describes the block’s character format. The block’s character format is used when inserting text into an empty block.</li>
<li><code>int QTextBlock::charFormatIndex() const</code>: Returns an index into the document’s internal list of character formats for the text block’s character format.</li>
<li><code>void QTextBlock::clearLayout()</code>: Clears the <code>QTextLayout</code> that is used to lay out and display the block’s contents.</li>
<li><code>bool QTextBlock::contains(int position) const</code>: Returns <code>true</code> if the given <code>position</code> is located within the text block; otherwise returns <code>false</code>.</li>
<li><code>const QTextDocument * QTextBlock::document() const</code>: Returns the text document this text block belongs to, or <code>0</code> if the text block does not belong to any document.</li>
<li><code>iterator QTextBlock::end() const</code>: Returns a text block iterator pointing to the end of the text block.</li>
<li><code>int QTextBlock::firstLineNumber() const</code>: Returns the first line number of this block, or <code>-1</code> if the block is invalid. Unless the layout supports it, the line number is identical to the block number.</li>
<li><code>bool QTextBlock::isValid() const</code>: Returns <code>true</code> if this text block is valid; otherwise returns <code>false</code>.</li>
<li><code>bool QTextBlock::isVisible() const</code>: Returns <code>true</code> if the block is visible; otherwise returns <code>false</code>.</li>
<li><code>QTextLayout * QTextBlock::layout() const</code>: Returns the <code>QTextLayout</code> that is used to lay out and display the block’s contents. Note that the returned <code>QTextLayout</code> object can only be modified from the <code>documentChanged</code> implementation of a <code>QAbstractTextDocumentLayout</code> subclass. Any changes applied from the outside cause undefined behavior.</li>
<li><code>int QTextBlock::length() const</code>: Returns the length of the block in characters. <strong>Note</strong>: The length returned includes all formatting characters, for example, newline.</li>
<li><code>int QTextBlock::lineCount() const</code>: Returns the line count. Not all document layouts support this feature.</li>
<li><code>QTextBlock QTextBlock::next() const</code>: Returns the text block in the document after this block, or an empty text block if this is the last one. Note that the next block may be in a different frame or table to this block.</li>
<li><code>int QTextBlock::position() const</code>: Returns the index of the block’s first character within the document.</li>
<li><code>QTextBlock QTextBlock::previous() const</code>: Returns the text block in the document before this block, or an empty text block if this is the first one. Note that the next block may be in a different frame or table to this block.</li>
<li><code>int QTextBlock::revision() const</code>: Returns the blocks revision.</li>
<li><code>void QTextBlock::setLineCount(int count)</code>: Sets the line count to <code>count</code>.</li>
<li><code>void QTextBlock::setRevision(int rev)</code>: Sets a blocks revision to <code>rev</code>.</li>
<li><code>void QTextBlock::setUserData(QTextBlockUserData * data)</code>: Attaches the given <code>data</code> object to the text block. <code>QTextBlockUserData</code> can be used to store custom settings. The ownership is passed to the underlying text document, i.e. the provided <code>QTextBlockUserData</code> object will be deleted if the corresponding text block gets deleted. The user data object is not stored in the undo history, so it will not be available after undoing the deletion of a text block. For example, if you write a programming editor in an <code>IDE</code>, you may want to let your user set breakpoints visually in your code for an integrated debugger. In a programming editor a line of text usually corresponds to one <code>QTextBlock</code>. The <code>QTextBlockUserData</code> interface allows the developer to store data for each <code>QTextBlock</code>, like for example in which lines of the source code the user has a breakpoint set. Of course this could also be stored externally, but by storing it inside the <code>QTextDocument</code>, it will for example be automatically deleted when the user deletes the associated line. It’s really just a way to store custom information in the <code>QTextDocument</code> without using custom properties in <code>QTextFormat</code> which would affect the <code>undo/redo</code> stack.</li>
<li><code>void QTextBlock::setUserState(int state)</code>: Stores the specified <code>state</code> integer value in the text block. This may be useful for example in a syntax highlighter to store a text parsing <code>state</code>.</li>
<li><code>void QTextBlock::setVisible(bool visible)</code>: Sets the block’s visibility to <code>visible</code>.</li>
<li><code>QString QTextBlock::text() const</code>: Returns the block’s contents as plain text.</li>
<li><code>Qt::LayoutDirection QTextBlock::textDirection() const</code>: Returns the resolved text direction. If the block has no explicit direction set, it will resolve the direction from the blocks content. Returns either <code>Qt::LeftToRight</code> or <code>Qt::RightToLeft</code>.</li>
<li><code>QTextList * QTextBlock::textList() const</code>: If the block represents a list item, returns the list that the item belongs to; otherwise returns <code>0</code>.</li>
<li><code>QTextBlockUserData * QTextBlock::userData() const</code>: Returns a pointer to a <code>QTextBlockUserData</code> object if previously set with <code>setUserData()</code> or a null pointer.</li>
<li><code>int QTextBlock::userState() const</code>: Returns the integer value previously set with <code>setUserState()</code> or <code>-1</code>.</li>
<li><code>bool QTextBlock::operator!=(const QTextBlock &amp; other) const</code>: Returns <code>true</code> if this text block is different from the <code>other</code> text block.</li>
<li><code>bool QTextBlock::operator&lt;(const QTextBlock &amp; other) const</code>: Returns <code>true</code> if this text block occurs before the <code>other</code> text block in the document.</li>
<li><code>QTextBlock &amp; QTextBlock::operator=(const QTextBlock &amp; other)</code>: Assigns the <code>other</code> text block to this text block.</li>
<li><code>bool QTextBlock::operator==(const QTextBlock &amp; other) const</code>: Returns true if this text block is the same as the <code>other</code> text block.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/19/Qt语法详解/Qt之QGridLayout/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/Qt语法详解/Qt之QGridLayout/" itemprop="url">Qt之QGridLayout</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T17:52:20+08:00">
                2019-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>&emsp;&emsp;<code>QGridLayout</code>是格栅布局，也被称作网格布局(多行多列)。栅格布局将位于其中的窗口部件放入一个网状的栅格之中。<code>QGridLayout</code>需要将提供给它的空间划分成的行和列，并把每个窗口部件插入并管理到正确的单元格。<br>&emsp;&emsp;栅格布局是这样工作的：它计算了位于其中的空间，然后将它们合理的划分成若干个行(<code>row</code>)和列(<code>column</code>)，并把每个由它管理的窗口部件放置在合适的单元之中，这里所指的单元(<code>cell</code>)即是指由行和列交叉所划分出来的空间。在栅格布局中，行和列本质上是相同的，只是叫法不同而已。下面将重点讨论列，这些内容当然也适用于行。<br>&emsp;&emsp;在栅格布局中，每个列(以及行)都有一个最小宽度(使用<code>setColumnMinimumWidth</code>设置)以及一个伸缩因子(使用<code>setColumnStretch</code>设置)。最小宽度指的是位于该列中的窗口部件的最小的宽度，而伸缩因子决定了该列内的窗口部件能够获得多少空间。</p>
<h3 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h3><p>&emsp;&emsp;一般情况下我们都是把某个窗口部件放进栅格布局的一个单元中，但窗口部件有时也可能会需要占用多个单元。这时就需要用到<code>addWidget</code>方法的一个重载版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addWidget</span> <span class="params">( QWidget *, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">int</span> rowSpan, <span class="keyword">int</span> columnSpan, Qt::Alignment = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个单元将从<code>row</code>和<code>column</code>开始，扩展到<code>rowSpan</code>和<code>columnSpan</code>指定的倍数的行和列。如果<code>rowSpan</code>或<code>columnSpan</code>的值为<code>-1</code>，则窗口部件将扩展到布局的底部或者右边边缘处。<br>&emsp;&emsp;在创建栅格布局完成后，就可以使用<code>addWidget</code>、<code>addItem</code>或者<code>addLayout</code>方法向其中加入窗口部件，以及其它的布局。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>&emsp;&emsp;下面以登录界面为例，来讲解如何使用<code>QGridLayout</code>：</p>
<p><img src="/2019/02/19/Qt语法详解/Qt之QGridLayout/1.png" height="152" width="255"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构建控件，即头像、用户名、密码输入框等 */</span></span><br><span class="line">QLabel *pImageLabel = <span class="keyword">new</span> QLabel ( <span class="keyword">this</span> );</span><br><span class="line">QLineEdit *pUserLineEdit = <span class="keyword">new</span> QLineEdit ( <span class="keyword">this</span> );</span><br><span class="line">QLineEdit *pPasswordLineEdit = <span class="keyword">new</span> QLineEdit ( <span class="keyword">this</span> );</span><br><span class="line">QCheckBox *pRememberCheckBox = <span class="keyword">new</span> QCheckBox ( <span class="keyword">this</span> );</span><br><span class="line">QCheckBox *pAutoLoginCheckBox = <span class="keyword">new</span> QCheckBox ( <span class="keyword">this</span> );</span><br><span class="line">QPushButton *pLoginButton = <span class="keyword">new</span> QPushButton ( <span class="keyword">this</span> );</span><br><span class="line">QPushButton *pRegisterButton = <span class="keyword">new</span> QPushButton ( <span class="keyword">this</span> );</span><br><span class="line">QPushButton *pForgotButton = <span class="keyword">new</span> QPushButton ( <span class="keyword">this</span> );</span><br><span class="line">​</span><br><span class="line">pLoginButton-&gt;setFixedHeight ( <span class="number">30</span> );</span><br><span class="line">pUserLineEdit-&gt;setFixedWidth ( <span class="number">200</span> );</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 设置头像 */</span></span><br><span class="line"><span class="function">QPixmap <span class="title">pixmap</span> <span class="params">( <span class="string">":/Images/logo"</span> )</span></span>;</span><br><span class="line">pImageLabel-&gt;setFixedSize ( <span class="number">90</span>, <span class="number">90</span> );</span><br><span class="line">pImageLabel-&gt;setPixmap ( pixmap );</span><br><span class="line">pImageLabel-&gt;setScaledContents ( <span class="literal">true</span> );</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 设置文本 */</span></span><br><span class="line">pUserLineEdit-&gt;setPlaceholderText ( QStringLiteral ( <span class="string">"QQ号码/手机/邮箱"</span> ) );</span><br><span class="line">pPasswordLineEdit-&gt;setPlaceholderText ( QStringLiteral ( <span class="string">"密码"</span> ) );</span><br><span class="line">pPasswordLineEdit-&gt;setEchoMode ( QLineEdit::Password );</span><br><span class="line">pRememberCheckBox-&gt;setText ( QStringLiteral ( <span class="string">"记住密码"</span> ) );</span><br><span class="line">pAutoLoginCheckBox-&gt;setText ( QStringLiteral ( <span class="string">"自动登录"</span> ) );</span><br><span class="line">pLoginButton-&gt;setText ( QStringLiteral ( <span class="string">"登录"</span> ) );</span><br><span class="line">pRegisterButton-&gt;setText ( QStringLiteral ( <span class="string">"注册账号"</span> ) );</span><br><span class="line">pForgotButton-&gt;setText ( QStringLiteral ( <span class="string">"找回密码"</span> ) );</span><br><span class="line">​</span><br><span class="line">QGridLayout *pLayout = <span class="keyword">new</span> QGridLayout();</span><br><span class="line"><span class="comment">/* 头像从第0行第0列开始，占3行1列 */</span></span><br><span class="line">pLayout-&gt;addWidget ( pImageLabel, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span> );</span><br><span class="line"><span class="comment">/* 用户名输入框从第0行，第1列开始，占1行2列 */</span></span><br><span class="line">pLayout-&gt;addWidget ( pUserLineEdit, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span> );</span><br><span class="line">pLayout-&gt;addWidget ( pRegisterButton, <span class="number">0</span>, <span class="number">4</span> );</span><br><span class="line"><span class="comment">/* 密码输入框从第1行，第1列开始，占1行2列 */</span></span><br><span class="line">pLayout-&gt;addWidget ( pPasswordLineEdit, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span> );</span><br><span class="line">pLayout-&gt;addWidget ( pForgotButton, <span class="number">1</span>, <span class="number">4</span> );</span><br><span class="line"><span class="comment">/* 记住密码从第2行第1列开始，占1行1列，水平居左，垂直居中 */</span></span><br><span class="line">pLayout-&gt;addWidget ( pRememberCheckBox, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, Qt::AlignLeft | Qt::AlignVCenter );</span><br><span class="line"><span class="comment">/* 自动登录从第2行第2列开始，占1行1列，水平居右，垂直居中 */</span></span><br><span class="line">pLayout-&gt;addWidget ( pAutoLoginCheckBox, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, Qt::AlignRight | Qt::AlignVCenter );</span><br><span class="line">pLayout-&gt;addWidget ( pLoginButton, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span> ); <span class="comment">/* 登录按钮从第3行第1列开始，占1行2列 */</span></span><br><span class="line">pLayout-&gt;setHorizontalSpacing ( <span class="number">10</span> ); <span class="comment">/* 设置水平间距 */</span></span><br><span class="line">pLayout-&gt;setVerticalSpacing ( <span class="number">10</span> ); <span class="comment">/* 设置垂直间距 */</span></span><br><span class="line">pLayout-&gt;setContentsMargins ( <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span> ); <span class="comment">/* 设置外间距 */</span></span><br><span class="line">setLayout ( pLayout );</span><br></pre></td></tr></table></figure>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><ul>
<li><code>addWidget ( QWidget *, int row, int column, Qt::Alignment = 0 );</code></li>
<li><code>addWidget ( QWidget *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0 );</code></li>
</ul>
<p>添加窗口部件至布局。这个单元将从<code>row</code>和<code>column</code>开始，扩展到<code>rowSpan</code>和<code>columnSpan</code>指定的倍数的行和列。如果<code>rowSpan</code>或<code>columnSpan</code>的值为<code>-1</code>，则窗口部件将扩展到布局的底部或者右边边缘处，<code>Qt::Alignment</code>为对齐方式。</p>
<ul>
<li><code>addLayout ( QLayout *, int row, int column, Qt::Alignment = 0 );</code></li>
<li><code>addLayout ( QLayout *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0 );</code></li>
</ul>
<p>和<code>addWidget</code>类似，这个是添加布局。</p>
<ul>
<li><code>setRowStretch ( int row, int stretch );</code></li>
<li><code>setColumnStretch ( int column, int stretch );</code></li>
</ul>
<p>设置<code>行/列</code>的伸缩空间，和<code>QBoxLayout</code>的<code>addStretch</code>功能类似。</p>
<ul>
<li><code>setSpacing ( int spacing );</code></li>
<li><code>setHorizontalSpacing ( int spacing );</code></li>
<li><code>setVerticalSpacing ( int spacing );</code></li>
</ul>
<p>设置间距。<code>setSpacing</code>可以同时设置水平、垂直间距，设置之后，水平、垂直间距相同。<code>setHorizontalSpacing</code>、<code>setVerticalSpacing</code>可以分别设置水平间距、垂直间距。</p>
<ul>
<li><code>setRowMinimumHeight(int row, int minSize);</code>：设置行最小高度。</li>
<li><code>setColumnMinimumWidth(int column, int minSize);</code>：设置列最小宽度。</li>
<li><code>columnCount();</code>：获取列数。</li>
<li><code>rowCount();</code>：获取行数。</li>
<li><code>setOriginCorner(Qt::Corner);</code>：设置原始方向，和<code>QBoxLayout</code>的<code>setDirection</code>功能类似。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/19/Qt语法详解/Qt之QDialog/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/Qt语法详解/Qt之QDialog/" itemprop="url">Qt之QDialog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T17:12:19+08:00">
                2019-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="QDialog基础"><a href="#QDialog基础" class="headerlink" title="QDialog基础"></a>QDialog基础</h3><p>&emsp;&emsp;代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextCodec&gt; /* 提供文本编码转换功能 */</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span> <span class="params">( argc, argv )</span></span>; <span class="comment">/* QApplication对象用于管理应用程序的资源 */</span></span><br><span class="line">    <span class="comment">// /* 设置QObject::tr函数所用的字符集，这里使用系统指定的字符集 */</span></span><br><span class="line">    <span class="comment">// QTextCodec::setCodecForTr ( QTextCodec::codecForLocale() );</span></span><br><span class="line">    QTextCodec::setCodecForTr ( QTextCodec::codecForName ( <span class="string">"UTF-8"</span> ) ); <span class="comment">/* 指定字符集为UTF-8 */</span></span><br><span class="line">    QDialog w; <span class="comment">/* QDialog对象用于实现一个对话框 */</span></span><br><span class="line">    w.resize ( <span class="number">400</span>, <span class="number">300</span> ); <span class="comment">/* 设置QDialog对话框的大小 */</span></span><br><span class="line">    <span class="function">QLabel <span class="title">label</span> <span class="params">( &amp;w )</span></span>;  <span class="comment">/* 说明对话框是label的父对象 */</span></span><br><span class="line">    label.move ( <span class="number">120</span>, <span class="number">120</span> ); <span class="comment">/* 移动label的位置 */</span></span><br><span class="line">    label.setText ( QObject::tr ( <span class="string">"Hello World!你好Qt！"</span> ) ); <span class="comment">/* 设置label的文本 */</span></span><br><span class="line">    w.show();</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Qt语法详解/Qt之QDialog/1.png" height="228" width="280"></p>
<hr>
<h3 id="多窗口切换"><a href="#多窗口切换" class="headerlink" title="多窗口切换"></a>多窗口切换</h3><p>&emsp;&emsp;<code>mywidget.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYWIDGET_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> :</span> <span class="keyword">public</span> QWidget &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWidget</span> <span class="params">( QWidget *parent = <span class="number">0</span> )</span></span>;</span><br><span class="line">    ~MyWidget();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MyWidget *ui;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showChildDialog</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYWIDGET_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mywidget.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mywidget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_mywidget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDialog&gt;</span></span></span><br><span class="line">​</span><br><span class="line">MyWidget::MyWidget ( QWidget *parent ) : QWidget ( parent ), ui ( <span class="keyword">new</span> Ui::MyWidget ) &#123;</span><br><span class="line">    ui-&gt;setupUi ( <span class="keyword">this</span> );</span><br><span class="line">    <span class="comment">/* 发送信号的对象、发送的信号、接收信号的对象、要执行的槽 */</span></span><br><span class="line">    connect ( ui-&gt;showChildButton, SIGNAL ( clicked() ), <span class="keyword">this</span>, SLOT ( showChildDialog() ) );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">MyWidget::~MyWidget() &#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MyWidget::showChildDialog() &#123;</span><br><span class="line">    QDialog *dialog = <span class="keyword">new</span> QDialog ( <span class="keyword">this</span> );</span><br><span class="line">    dialog-&gt;show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Qt语法详解/Qt之QDialog/2.png" height="228" width="646"></p>
<hr>
<h3 id="QDialog对话框的show和exec"><a href="#QDialog对话框的show和exec" class="headerlink" title="QDialog对话框的show和exec"></a>QDialog对话框的show和exec</h3><p>&emsp;&emsp;<code>QDialog</code>继承自<code>QWitget</code>，自然从基类继承了显示函数<code>show</code>。然而<code>QDialog</code>还有一个特殊的显示函数<code>exec</code>，二者的区别如下：</p>
<ul>
<li><code>show</code>：显示一个非<code>modal</code>的对话框，控制权立刻返回给调用函数，弹出窗口是否为<code>model</code>对话框，可由<code>modal</code>值决定。</li>
<li><code>exec</code>：显示一个<code>modal</code>的对话框，并且锁住程序，直到用户关闭对话框为止，函数返回一个<code>DialogCode</code>结果。在对话框弹出期间，用户不可切换至其他窗口。</li>
</ul>
<p>&emsp;&emsp;<code>mydialog.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYDIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYDIALOG_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDialog&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyDialog</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDialog</span> :</span> <span class="keyword">public</span> QDialog &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyDialog</span> <span class="params">( QWidget *parent = <span class="number">0</span> )</span></span>;</span><br><span class="line">    ~MyDialog();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_pushButton_clicked</span><span class="params">()</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MyDialog *ui;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYDIALOG_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mywidget.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYWIDGET_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> :</span> <span class="keyword">public</span> QWidget &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWidget</span> <span class="params">( QWidget *parent = <span class="number">0</span> )</span></span>;</span><br><span class="line">    ~MyWidget();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MyWidget *ui;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_showChildButton_clicked</span><span class="params">()</span></span>;</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_pushButton_clicked</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYWIDGET_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mydialog.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mydialog.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_mydialog.h"</span></span></span><br><span class="line">​</span><br><span class="line">MyDialog::MyDialog ( QWidget *parent ) : QDialog ( parent ), ui ( <span class="keyword">new</span> Ui::MyDialog ) &#123;</span><br><span class="line">    ui-&gt;setupUi ( <span class="keyword">this</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">MyDialog::~MyDialog() &#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MyDialog::on_pushButton_clicked() &#123;</span><br><span class="line">    accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mywidget.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mywidget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_mywidget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mydialog.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line">​</span><br><span class="line">MyWidget::MyWidget ( QWidget *parent ) : QWidget ( parent ), ui ( <span class="keyword">new</span> Ui::MyWidget ) &#123;</span><br><span class="line">    ui-&gt;setupUi ( <span class="keyword">this</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">MyWidget::~MyWidget() &#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MyWidget::on_showChildButton_clicked() &#123; <span class="comment">/* 显示子窗口按钮 */</span></span><br><span class="line">    QDialog *dialog = <span class="keyword">new</span> QDialog ( <span class="keyword">this</span> );</span><br><span class="line">    dialog-&gt;show();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MyWidget::on_pushButton_clicked() &#123; <span class="comment">/* 重新登录按钮 */</span></span><br><span class="line">    close(); <span class="comment">/* 先关闭主界面，其实是隐藏起来了，并没有真正退出 */</span></span><br><span class="line">    MyDialog dlg; <span class="comment">/* 新建MyDialog对象 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 如果按下了“进入主窗口”按钮，则再次显示主界面。</span></span><br><span class="line"><span class="comment">       否则，因为现在已经没有显示的界面了，所以程序将退出 */</span></span><br><span class="line">    <span class="keyword">if</span> ( dlg.exec() == QDialog::Accepted ) &#123;</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>main.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtGui/QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mywidget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mydialog.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    MyWidget w;</span><br><span class="line">    MyDialog dialog; <span class="comment">/* 新建MyDialog类对象 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( dialog.exec() == QDialog::Accepted ) &#123; <span class="comment">/* 判断dialog执行结果 */</span></span><br><span class="line">        w.show(); <span class="comment">/* 如果是按下了“进入主界面”按钮，则显示主界面 */</span></span><br><span class="line">        <span class="keyword">return</span> a.exec(); <span class="comment">/* 程序正常运行 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 否则，退出程序 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Qt语法详解/Qt之QDialog/3.png" height="227" width="559"></p>
<p>&emsp;&emsp;对于<code>QDialog</code>的<code>accept</code>函数和<code>reject</code>函数，这两个函数都能够隐藏<code>QDialog</code>。但是返回的值不同，一个是<code>Accepted</code>，一个是<code>Rejected</code>。通过返回值可以区分用户按下的是<code>OK</code>按钮，还是<code>Cancel</code>按钮。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/19/Qt语法详解/Qt之QInputDialog/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/Qt语法详解/Qt之QInputDialog/" itemprop="url">Qt之QInputDialog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T14:24:05+08:00">
                2019-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>QInputDialog</code>类提供了从用户那里得到一个单一值的简单方便的对话框，输入值可以是字符串、数字或者列表中的一项，必须设置标签来告诉用户应该输入什么。其头文件为<code>qinputdialog.h</code>，它继承了<code>QDialog</code>。</p>
<h3 id="getDouble"><a href="#getDouble" class="headerlink" title="getDouble"></a>getDouble</h3><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> QInputDialog::getDouble (</span><br><span class="line">    <span class="keyword">const</span> QString &amp;caption, <span class="keyword">const</span> QString &amp;label, <span class="keyword">double</span> num = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">double</span> from = <span class="number">-2147483647</span>, <span class="keyword">double</span> to = <span class="number">2147483647</span>, <span class="keyword">int</span> decimals = <span class="number">1</span>,</span><br><span class="line">    <span class="keyword">bool</span> *ok = <span class="number">0</span>, QWidget *parent = <span class="number">0</span>, <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p>这是从用户那里得到浮点数的函数。</p>
<ul>
<li><code>caption</code>：这个对话框在标题栏显示的文本。</li>
<li><code>label</code>：显示给用户的文本(它应该告诉用户应该输入什么)。</li>
<li><code>num</code>：这个行编辑中所要设置的默认的浮点数值。</li>
<li><code>from</code>和<code>to</code>：最小值和最大值，用户应该在这个范围内进行选择。</li>
<li><code>decimals</code>：小数点后面小数的最大位数；</li>
<li><code>parent</code>和<code>name</code>：对话框的父对象为<code>parent</code>，名称为<code>name</code>。</li>
<li><code>ok</code>：如果<code>ok</code>参数为非零，则用户点击<code>OK</code>，<code>*ok</code>被设置为<code>True</code>，并且如果用户点击<code>Cancel</code>，就被设置为<code>False</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok = FALSE;</span><br><span class="line"><span class="keyword">double</span> res = QInputDialog::getDouble (</span><br><span class="line">                tr ( <span class="string">"Application name"</span> ),</span><br><span class="line">                tr ( <span class="string">"Please enter a decimal number"</span> ),</span><br><span class="line">                <span class="number">33.7</span>, <span class="number">0</span>, <span class="number">1000</span>, <span class="number">2</span>, &amp;ok, <span class="keyword">this</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ok ) &#123;</span><br><span class="line">    <span class="comment">/* 用户输入一些东西并且按下OK */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 用户按下Cancel */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getInteger"><a href="#getInteger" class="headerlink" title="getInteger"></a>getInteger</h3><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QInputDialog::getInteger (</span><br><span class="line">    <span class="keyword">const</span> QString &amp;caption, <span class="keyword">const</span> QString &amp;label, <span class="keyword">int</span> num = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">int</span> from = <span class="number">-2147483647</span>, <span class="keyword">int</span> to = <span class="number">2147483647</span>, <span class="keyword">int</span> step = <span class="number">1</span>,</span><br><span class="line">    <span class="keyword">bool</span> *ok = <span class="number">0</span>, QWidget *parent = <span class="number">0</span>, <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p>从用户那里得到整数的函数。</p>
<ul>
<li><code>caption</code>：这个对话框在标题栏显示的文本；</li>
<li><code>label</code>：显示给用户的文本(它应该告诉用户应该输入什么)。</li>
<li><code>num</code>：微调框中所要设置的默认整数。</li>
<li><code>from</code>和<code>to</code>：最小值和最大值，用户应该在这个范围内进行选择。</li>
<li><code>step</code>：用户通过点击上下箭头增加或者减少的数值。</li>
<li><code>parent</code>和<code>name</code>：对话框的父对象为<code>parent</code>，名称为<code>name</code>。</li>
<li><code>ok</code>：如果<code>ok</code>参数为非零，则用户点击<code>OK</code>，<code>*ok</code>被设置为<code>True</code>，并且如果用户点击<code>Cancel</code>，就被设置为<code>False</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok = FALSE;</span><br><span class="line"><span class="keyword">int</span> res = QInputDialog::getInteger (</span><br><span class="line">            tr ( <span class="string">"Application name"</span> ),</span><br><span class="line">            tr ( <span class="string">"Please enter a number"</span> ),</span><br><span class="line">            <span class="number">22</span>, <span class="number">0</span>, <span class="number">1000</span>, <span class="number">2</span>, &amp;ok, <span class="keyword">this</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ok ) &#123;</span><br><span class="line">    <span class="comment">/* 用户输入一些东西并且按下OK  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 用户按下Cancel */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getItem"><a href="#getItem" class="headerlink" title="getItem"></a>getItem</h3><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString QInputDialog::getItem (</span><br><span class="line">    <span class="keyword">const</span> QString &amp;caption, <span class="keyword">const</span> QString &amp;label, <span class="keyword">const</span> QStringList &amp;<span class="built_in">list</span>, <span class="keyword">int</span> current = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">bool</span> editable = TRUE, <span class="keyword">bool</span> *ok = <span class="number">0</span>, QWidget *parent = <span class="number">0</span>, <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p>让用户从一个字符串列表中选择一项的函数。</p>
<ul>
<li><code>caption</code>：这个对话框在标题栏显示的文本。</li>
<li><code>label</code>：显示给用户的文本(它应该告诉用户应该输入什么)。</li>
<li><code>list</code>：插入到组合框中的字符串列表。</li>
<li><code>current</code>：哪一项为当前项。</li>
<li><code>editable</code>：如果<code>editable</code>为<code>True</code>，则用户可以输入自己的文本；如果<code>editable</code>为<code>False</code>，则用户只能选择已有的项中的一项。</li>
<li><code>parent</code>和<code>name</code>：对话框的父对象为<code>parent</code>，名称为<code>name</code>。</li>
<li><code>ok</code>：如果<code>ok</code>参数为非零，则用户点击<code>OK</code>，<code>*ok</code>被设置为<code>True</code>，并且如果用户点击<code>Cancel</code>，就被设置为<code>False</code>。</li>
</ul>
<p>这个函数返回当前项的文本，或者如果<code>editable</code>为真，就是组合框的当前文本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">QStringList lst;</span><br><span class="line">lst &lt;&lt; <span class="string">"First"</span> &lt;&lt; <span class="string">"Second"</span> &lt;&lt; <span class="string">"Third"</span> &lt;&lt; <span class="string">"Fourth"</span> &lt;&lt; <span class="string">"Fifth"</span>;</span><br><span class="line"><span class="keyword">bool</span> ok = FALSE;</span><br><span class="line">QString res = QInputDialog::getItem (</span><br><span class="line">                tr ( <span class="string">"Application name"</span> ),</span><br><span class="line">                tr ( <span class="string">"Please select an item"</span> ),</span><br><span class="line">                lst, <span class="number">1</span>, TRUE, &amp;ok, <span class="keyword">this</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ok ) &#123;</span><br><span class="line">    <span class="comment">/* 用户选择一项并且按下OK */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 用户按下Cancel */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getText"><a href="#getText" class="headerlink" title="getText"></a>getText</h3><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString QInputDialog::getText (</span><br><span class="line">    <span class="keyword">const</span> QString &amp;caption, <span class="keyword">const</span> QString &amp;label, QLineEdit::EchoMode mode = QLineEdit::Normal,</span><br><span class="line">    <span class="keyword">const</span> QString &amp;text = QString::null, <span class="keyword">bool</span> *ok = <span class="number">0</span>, QWidget *parent = <span class="number">0</span>, <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p>从用户那里得到一个字符串的函数。</p>
<ul>
<li><code>caption</code>：这个对话框在标题栏显示的文本。</li>
<li><code>label</code>：显示给用户的文本(它应该告诉用户应该输入什么)。</li>
<li><code>text</code>：放置在行编辑中的默认文本。</li>
<li><code>mode</code>：行编辑的回显模式。</li>
<li><code>parent</code>和<code>name</code>：对话框的父对象为<code>parent</code>，名称为<code>name</code>。</li>
<li><code>ok</code>：如果<code>ok</code>参数为非零，则用户点击<code>OK</code>，<code>*ok</code>被设置为<code>True</code>，并且如果用户点击<code>Cancel</code>，就被设置为<code>False</code>。</li>
</ul>
<p>这个函数返回用户在行编辑中输入的文本，如果没有输入，就返回空字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok = FALSE;</span><br><span class="line">QString text = QInputDialog::getText (</span><br><span class="line">                   tr ( <span class="string">"Application name"</span> ),</span><br><span class="line">                   tr ( <span class="string">"Please enter your name"</span> ),</span><br><span class="line">                   QLineEdit::Normal, QString::null, &amp;ok, <span class="keyword">this</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ok &amp;&amp; !text.isEmpty() ) &#123;</span><br><span class="line">    <span class="comment">/* 用户输入一些东西并且按下OK */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 用户不输入任何东西或者按下Cancel */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Qt语法详解/Qt之QInputDialog/1.png" height="188" width="547"></p>
<p>&emsp;&emsp;实际用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok;</span><br><span class="line"><span class="comment">/* 获取字符串(参数：指定父窗口、标题栏、设置对话框中的标签的显示文本、设置输入的</span></span><br><span class="line"><span class="comment">   字符串的显示模式、设置输入框中的默认字符串、设置获取按下按钮信息的bool变量) */</span></span><br><span class="line">QString <span class="built_in">string</span> = QInputDialog::getText (</span><br><span class="line">    <span class="keyword">this</span>, tr ( <span class="string">"输入字符串对话框"</span> ), tr ( <span class="string">"请输入用户名："</span> ),</span><br><span class="line">    QLineEdit::Normal, tr ( <span class="string">"admin"</span> ), &amp;ok );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ok ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"string:"</span> &lt;&lt; <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 获取整数 */</span></span><br><span class="line"><span class="keyword">int</span> value1 = QInputDialog::getInt (</span><br><span class="line">    <span class="keyword">this</span>, tr ( <span class="string">"输入整数对话框"</span> ), tr ( <span class="string">"请输入-1000到1000之间的数值"</span> ),</span><br><span class="line">    <span class="number">100</span>, <span class="number">-1000</span>, <span class="number">1000</span>, <span class="number">10</span>, &amp;ok ); <span class="comment">/* 默认值100，最小值“-1000”，最大值1000，数值每次变化10 */</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ok ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"value1:"</span> &lt;&lt; value1;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 获取浮点数 */</span></span><br><span class="line"><span class="keyword">double</span> value2 = QInputDialog::getDouble (</span><br><span class="line">    <span class="keyword">this</span>, tr ( <span class="string">"输入浮点数对话框"</span> ), tr ( <span class="string">"请输入-1000到1000之间的数值"</span> ),</span><br><span class="line">    <span class="number">0.00</span>, <span class="number">-1000</span>, <span class="number">1000</span>, <span class="number">2</span>, &amp;ok ); <span class="comment">/* 2表示小数的位数为2 */</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ok ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"value2:"</span> &lt;&lt; value2;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 获取条目 */</span></span><br><span class="line">QStringList items;</span><br><span class="line">items &lt;&lt; tr ( <span class="string">"条目1"</span> ) &lt;&lt; tr ( <span class="string">"条目2"</span> );</span><br><span class="line">QString item = QInputDialog::getItem (</span><br><span class="line">    <span class="keyword">this</span>, tr ( <span class="string">"输入条目对话框"</span> ), tr ( <span class="string">"请选择一个条目"</span> ),</span><br><span class="line">    items, <span class="number">0</span>, <span class="literal">true</span>, &amp;ok ); <span class="comment">/* 0表示默认显示列表中的第0个条目，true表示条目可以被更改 */</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ok ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"item:"</span> &lt;&lt; item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/19/Python语法/skimage模块/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/Python语法/skimage模块/" itemprop="url">skimage模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T11:51:39+08:00">
                2019-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Python语法/" itemprop="url" rel="index">
                    <span itemprop="name">Python语法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>scikit-image</code>是基于<code>scipy</code>的一款图像处理包，它将图片作为<code>numpy</code>数组进行处理。可以使用<code>pip</code>进行安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scikit-image</span><br></pre></td></tr></table></figure>
<h3 id="skimage库子模块"><a href="#skimage库子模块" class="headerlink" title="skimage库子模块"></a>skimage库子模块</h3><p>&emsp;&emsp;<code>skimage</code>包含了很多子模块，各个子模块具有不同的功能：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>子模块名称</th>
<th>实现功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>io</code></td>
<td>读取、保存以及显示图片和视频</td>
</tr>
<tr>
<td><code>color</code></td>
<td>颜色空间变换</td>
</tr>
<tr>
<td><code>data</code></td>
<td>提供一些测试图片和样本数据</td>
</tr>
<tr>
<td><code>filters</code></td>
<td>图像增强的模块，例如边缘检测、自动阈值</td>
</tr>
<tr>
<td><code>draw</code></td>
<td>操作于<code>numpy</code>数组上的基本图形绘制，包括线条、矩阵、圆和文本等</td>
</tr>
<tr>
<td><code>transform</code></td>
<td>几何变换和其他变换，例如旋转、拉伸和<code>Radon</code>变换</td>
</tr>
<tr>
<td><code>exposure</code></td>
<td>图像强度调整，例如直方图均衡化</td>
</tr>
<tr>
<td><code>feature</code></td>
<td>特征检测和提取，例如纹理分析</td>
</tr>
<tr>
<td><code>graph</code></td>
<td>图论操作，例如最短路径</td>
</tr>
<tr>
<td><code>measure</code></td>
<td>图像属性测量，例如相似度和轮廓</td>
</tr>
<tr>
<td><code>morphology</code></td>
<td>形态学操作，例如开闭运算、骨架提取</td>
</tr>
<tr>
<td><code>novice</code></td>
<td>简化的用于教学目的的接口</td>
</tr>
<tr>
<td><code>restoration</code></td>
<td>修复算法，例如去卷积算法、去噪</td>
</tr>
<tr>
<td><code>segmentation</code></td>
<td>图像分割为多个区域</td>
</tr>
<tr>
<td><code>util</code></td>
<td>通用工具</td>
</tr>
<tr>
<td><code>viewer</code></td>
<td>简单图形用户界面，用于可视化结果</td>
</tr>
</tbody>
</table>
</div>
<h3 id="skimage操作"><a href="#skimage操作" class="headerlink" title="skimage操作"></a>skimage操作</h3><h4 id="图像读取与显示"><a href="#图像读取与显示" class="headerlink" title="图像读取与显示"></a>图像读取与显示</h4><p>&emsp;&emsp;<code>skimage</code>的<code>io</code>模块提供了图像读取、保存与显示等功能，<code>data</code>模块包含了一些示例图片。从外部读取图片并显示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">skimage.io.imread(fname)  <span class="comment"># 读取fname指定的图片</span></span><br><span class="line">skimage.io.imshow(arr)  <span class="comment"># 显示arr数组表示的图片</span></span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">img = io.imread(<span class="string">'cat.png'</span>)</span><br><span class="line">io.imshow(img)</span><br><span class="line">io.show()  <span class="comment"># 不要忘记这一句</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/1.png" height="182" width="267"></p>
<p>以灰度图的形式读取时，使用函数<code>skimage.io.imread(fname, as_grey=True)</code>，参数<code>fname</code>表示要显示的图片路径：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">img = io.imread(<span class="string">'./cat.png'</span>, as_grey=<span class="keyword">True</span>)</span><br><span class="line">io.imshow(img)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/2.png" height="180" width="268"></p>
<h4 id="skimage自带图片"><a href="#skimage自带图片" class="headerlink" title="skimage自带图片"></a>skimage自带图片</h4><p>&emsp;&emsp;自带图片如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>图片名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>astronaut</code></td>
<td>宇航员</td>
</tr>
<tr>
<td><code>binary_blobs</code></td>
<td>二元斑点</td>
</tr>
<tr>
<td><code>camera</code></td>
<td>相机</td>
</tr>
<tr>
<td><code>checkerboard</code></td>
<td>棋盘</td>
</tr>
<tr>
<td><code>chelsea</code></td>
<td>猫</td>
</tr>
<tr>
<td><code>clock</code></td>
<td>时钟</td>
</tr>
<tr>
<td><code>coffee</code></td>
<td>一杯咖啡</td>
</tr>
<tr>
<td><code>coins</code></td>
<td>硬币</td>
</tr>
<tr>
<td><code>horse</code></td>
<td>马</td>
</tr>
<tr>
<td><code>hubble_deep_field</code></td>
<td>星空</td>
</tr>
<tr>
<td><code>immunohistochemistry</code></td>
<td>结肠图片</td>
</tr>
<tr>
<td><code>logo</code></td>
<td>商标</td>
</tr>
<tr>
<td><code>moon</code></td>
<td>月球表面</td>
</tr>
<tr>
<td><code>page</code></td>
<td>书页内容</td>
</tr>
<tr>
<td><code>rocket</code></td>
<td>火箭</td>
</tr>
<tr>
<td><code>text</code></td>
<td>文字图片</td>
</tr>
</tbody>
</table>
</div>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line">img = data.hubble_deep_field()</span><br><span class="line">io.imshow(img)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/3.jpg" height="226" width="272"></p>
<p>图片名就是对应的函数名，如<code>camera</code>图片对应的函数名为<code>data.camera()</code>。这些图片存储在<code>skimage</code>的安装目录下，可以通过<code>data_dir</code>把路径打印出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data_dir</span><br><span class="line">print(data_dir)</span><br></pre></td></tr></table></figure>
<h4 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h4><p>&emsp;&emsp;使用<code>io.imsave(fname, arr)</code>函数对图片进行保存，参数<code>fname</code>表示保存的路径和名称，参数<code>arr</code>表示需要保存的数组变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line"></span><br><span class="line">img = data.checkerboard()</span><br><span class="line">io.imshow(img)</span><br><span class="line">io.imsave(<span class="string">'checkerboard_copy.jpg'</span>, img)</span><br></pre></td></tr></table></figure>
<p>这样就在当前的工作目录下增加了一个<code>checkerboard_copy.jpg</code>文件。保存图片同时也起到了转换格式的作用，若读取的是<code>png</code>格式图片，当保存为<code>jpg</code>时，则图片从<code>png</code>格式转换为<code>jpg</code>格式。</p>
<h4 id="获取图片信息"><a href="#获取图片信息" class="headerlink" title="获取图片信息"></a>获取图片信息</h4><p>&emsp;&emsp;代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line"></span><br><span class="line">img = data.chelsea()</span><br><span class="line">io.imshow(img)</span><br><span class="line">io.show()</span><br><span class="line">print(type(img))  <span class="comment"># 类型</span></span><br><span class="line">print(img.shape)  <span class="comment"># 形状</span></span><br><span class="line">print(img.shape[<span class="number">0</span>])  <span class="comment"># 图片宽度</span></span><br><span class="line">print(img.shape[<span class="number">1</span>])  <span class="comment"># 图片高度</span></span><br><span class="line">print(img.shape[<span class="number">2</span>])  <span class="comment"># 图片通道数</span></span><br><span class="line">print(img.size)  <span class="comment"># 显示总像素个数</span></span><br><span class="line">print(img.max())  <span class="comment"># 最大像素值</span></span><br><span class="line">print(img.min())  <span class="comment"># 最小像素值</span></span><br><span class="line">print(img.mean())  <span class="comment"># 像素平均值</span></span><br></pre></td></tr></table></figure>
<h4 id="图像像素访问与裁剪"><a href="#图像像素访问与裁剪" class="headerlink" title="图像像素访问与裁剪"></a>图像像素访问与裁剪</h4><p>&emsp;&emsp;图片读入程序后，以<code>numpy</code>数组方式存储，因此对<code>numpy</code>数组的操作，都可以用于图片数组。对数组元素的访问，实际上就是对图片像素点的访问。对彩色图片的像素点访问方式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img[i, j, c]</span><br></pre></td></tr></table></figure>
<p><code>i</code>表示图片的行数，<code>j</code>表示图片的列数，<code>c</code>表示图片的通道数(<code>RGB</code>三通道分别对应<code>0</code>、<code>1</code>和<code>2</code>)，坐标从左上角开始。<br>&emsp;&emsp;对灰度图片的像素点访问方式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gray[i, j]</span><br></pre></td></tr></table></figure>
<p>例如输出<code>data</code>中宇航员图片第<code>20</code>行第<code>10</code>列的<code>B</code>通道数值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data</span><br><span class="line"></span><br><span class="line">img = data.astronaut()</span><br><span class="line">pixel = img[<span class="number">20</span>, <span class="number">10</span>, <span class="number">2</span>]</span><br><span class="line">print(pixel)  <span class="comment"># 输出“69”</span></span><br></pre></td></tr></table></figure>
<p>显示图片的红色单通道如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line"></span><br><span class="line">img = data.astronaut()</span><br><span class="line">R = img[:, :, <span class="number">0</span>]</span><br><span class="line">io.imshow(R)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/4.jpg" height="226" width="233"></p>
<h4 id="像素修改"><a href="#像素修改" class="headerlink" title="像素修改"></a>像素修改</h4><p>&emsp;&emsp;例如对宇航员图片随机添加椒盐噪声：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = data.astronaut()</span><br><span class="line">rows, cols, dims = img.shape</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5000</span>):  <span class="comment"># 随机生成5000个椒盐点</span></span><br><span class="line">    x = np.random.randint(<span class="number">0</span>, rows)</span><br><span class="line">    y = np.random.randint(<span class="number">0</span>, cols)</span><br><span class="line">    img[x, y, :] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">io.imshow(img)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/5.jpg" height="225" width="235"></p>
<h4 id="图片裁剪"><a href="#图片裁剪" class="headerlink" title="图片裁剪"></a>图片裁剪</h4><p>&emsp;&emsp;由于图片是以<code>numpy</code>数组进行存储，因此对于数组的裁剪，就是对图片的裁剪。例如对宇航员图片进行裁剪：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line"></span><br><span class="line">img = data.astronaut()</span><br><span class="line">partial_img = img[<span class="number">50</span>:<span class="number">150</span>, <span class="number">170</span>:<span class="number">270</span>, :]</span><br><span class="line">io.imshow(partial_img)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/6.png" height="227" width="228"></p>
<p>对多个像素点进行操作时，使用数组切片方式进行访问：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img[i, :] = im[j, :]  <span class="comment"># 将第j行的数值赋值给第i行</span></span><br><span class="line">img[:, i] = <span class="number">100</span>  <span class="comment"># 将第i列的所有数值设为100</span></span><br><span class="line">img[:<span class="number">100</span>, :<span class="number">50</span>].sum()  <span class="comment"># 计算前100行、前50列所有数值的和</span></span><br><span class="line">img[<span class="number">50</span>:<span class="number">100</span>, <span class="number">50</span>:<span class="number">100</span>]  <span class="comment"># 第50至100行，第50至100列(不包括第100行和第100列)</span></span><br><span class="line">img[i].mean()  <span class="comment"># 第i行所有数值的平均值</span></span><br><span class="line">img[:, <span class="number">-1</span>]  <span class="comment"># 最后一列</span></span><br><span class="line">img[<span class="number">-2</span>, :] (<span class="keyword">or</span> im[<span class="number">-2</span>])  <span class="comment"># 倒数第二行</span></span><br></pre></td></tr></table></figure>
<p>将宇航员图片进行二值化，像素值大于<code>128</code>的变为<code>1</code>，否则变为<code>0</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data, color</span><br><span class="line"></span><br><span class="line">img = data.astronaut()</span><br><span class="line">img_gray = color.rgb2gray(img)</span><br><span class="line">rows, cols = img_gray.shape</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">        <span class="keyword">if</span> (img_gray[i, j] &lt;= <span class="number">0.5</span>):</span><br><span class="line">            img_gray[i, j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            img_gray[i, j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">io.imshow(img_gray)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/7.png" height="226" width="234"></p>
<p>使用<code>color</code>模块的<code>rgb2gray</code>函数，将彩色三通道图片转换为灰度图片，转换结果为<code>float64</code>类型的数组，范围在<code>[0, 1]</code>之间。<br>&emsp;&emsp;对<code>R</code>通道的数值进行修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line"></span><br><span class="line">img = data.astronaut()</span><br><span class="line">img_idx_modified = img[:, :, <span class="number">0</span>] &gt; <span class="number">170</span></span><br><span class="line">print(img_idx_modified)</span><br><span class="line">img[img_idx_modified] = [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>]</span><br><span class="line">io.imshow(img)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/8.jpg" height="226" width="233"></p>
<p>这个例子先对<code>R</code>通道的所有像素值进行判断，如果大于<code>170</code>，则将这个地方的像素值变为<code>[0, 255, 0]</code>，即<code>G</code>通道值为<code>255</code>，<code>R</code>和<code>B</code>通道值为<code>0</code>。</p>
<h3 id="图像数据类型以及颜色空间转换"><a href="#图像数据类型以及颜色空间转换" class="headerlink" title="图像数据类型以及颜色空间转换"></a>图像数据类型以及颜色空间转换</h3><h4 id="图像数据类型"><a href="#图像数据类型" class="headerlink" title="图像数据类型"></a>图像数据类型</h4><p>&emsp;&emsp;在<code>skimage</code>中，一张图片以<code>numpy</code>数组形式存储，数组的数据类型有很多中，相互之间可以转换。数据类型以及取值范围如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>uint8</code></td>
<td><code>0</code> to <code>255</code></td>
</tr>
<tr>
<td><code>uint16</code></td>
<td><code>0</code> to <code>65535</code></td>
</tr>
<tr>
<td><code>uint32</code></td>
<td><code>0</code> to <code>2^32 - 1</code></td>
</tr>
<tr>
<td><code>float16</code></td>
<td>半精度浮点数：<code>16</code>位，正负号<code>1</code>位，指数<code>5</code>位，精度<code>10</code>位</td>
</tr>
<tr>
<td><code>float32</code></td>
<td>单精度浮点数：<code>32</code>位，正负号<code>1</code>位，指数<code>8</code>位，精度<code>23</code>位</td>
</tr>
<tr>
<td><code>float64</code></td>
<td>双精度浮点数：<code>64</code>位，正负号<code>1</code>位，指数<code>11</code>位，精度<code>52</code>位</td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>-1</code> to <code>1</code> or <code>0</code> to <code>1</code></td>
</tr>
<tr>
<td><code>int8</code></td>
<td><code>-128</code> to <code>127</code></td>
</tr>
<tr>
<td><code>int16</code></td>
<td><code>-32768</code> to <code>32767</code></td>
</tr>
<tr>
<td><code>int32</code></td>
<td><code>-2^31</code> to <code>2^32 - 1</code></td>
</tr>
</tbody>
</table>
</div>
<p>一张图片的像素值范围是<code>[0, 255]</code>，因此默认类型是<code>unit8</code>，可用如下代码查看数据类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line"></span><br><span class="line">img = data.astronaut()</span><br><span class="line">print(img.dtype.name)  <span class="comment"># 输出“uint8”</span></span><br></pre></td></tr></table></figure>
<p>在上面的表中，特别注意的是<code>float</code>类型，它的范围是<code>[-1, 1]</code>或<code>[0, 1]</code>之间。一张彩色图片转换为灰度图后，它的类型就由<code>unit8</code>变成了<code>float</code>。<br>&emsp;&emsp;<code>uint8</code>转为<code>float</code>如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data, img_as_float</span><br><span class="line"></span><br><span class="line">img = data.astronaut()</span><br><span class="line">print(img.dtype.name)  <span class="comment"># 输出“uint8”</span></span><br><span class="line">dst = img_as_float(img)</span><br><span class="line">print(dst.dtype.name)  <span class="comment"># 输出“float64”</span></span><br></pre></td></tr></table></figure>
<p><code>float</code>转为<code>uint8</code>如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> img_as_ubyte</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = np.array([<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>], dtype=float)</span><br><span class="line">print(img.dtype.name)  <span class="comment"># 输出“float64”</span></span><br><span class="line">dst = img_as_ubyte(img)</span><br><span class="line">print(dst.dtype.name)  <span class="comment"># 输出“uint8”</span></span><br></pre></td></tr></table></figure>
<p><code>float</code>转为<code>uint8</code>可能会造成数据损失，因此会有警告。除了如上两种转换以外，还有其他的一些类型转换：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>img_as_float</code></td>
<td>Convert to <code>64-bit</code> floating point</td>
</tr>
<tr>
<td><code>img_as_ubyte</code></td>
<td>Convert to <code>8-bit</code> uint</td>
</tr>
<tr>
<td><code>img_as_uint</code></td>
<td>Convert to <code>16-bit</code> uint</td>
</tr>
<tr>
<td><code>img_as_int</code></td>
<td>Convert to <code>16-bit</code> int</td>
</tr>
</tbody>
</table>
</div>
<h4 id="颜色空间及转换"><a href="#颜色空间及转换" class="headerlink" title="颜色空间及转换"></a>颜色空间及转换</h4><p>&emsp;&emsp;除了直接转换可以改变数据类型外，还可以通过图像的颜色空间转换来改变数据类型。常用的颜色空间有灰度空间、<code>rgb</code>空间、<code>hsv</code>空间和<code>cmyk</code>空间。颜色空间转换以后，图片类型都变成了<code>float</code>型。<br>&emsp;&emsp;所有的颜色空间转换函数都放在<code>skimage</code>的<code>color</code>模块内。例如<code>RGB</code>转为灰度图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data, color</span><br><span class="line"></span><br><span class="line">img = data.camera()</span><br><span class="line">gray = color.rgb2gray(img)</span><br><span class="line">io.imshow(gray)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/9.jpg" height="226" width="233"></p>
<p>其它转换的用法都是一样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">skimage.color.rgb2grey(rgb)</span><br><span class="line">skimage.color.rgb2hsv(rgb)</span><br><span class="line">skimage.color.rgb2lab(rgb)</span><br><span class="line">skimage.color.gray2rgb(image)</span><br><span class="line">skimage.color.hsv2rgb(hsv)</span><br><span class="line">skimage.color.lab2rgb(lab)</span><br></pre></td></tr></table></figure>
<p>实际上，上面的所有转换函数都可以用一个函数来代替：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.color.convert_colorspace(arr, fromspace, tospace)</span><br></pre></td></tr></table></figure>
<p>表示将<code>arr</code>从<code>fromspace</code>颜色空间转换到<code>tospace</code>颜色空间。<br>&emsp;&emsp;<code>RGB</code>转为<code>HSV</code>如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data, color</span><br><span class="line"></span><br><span class="line">img = data.coffee()</span><br><span class="line">hsv = color.convert_colorspace(img, <span class="string">'RGB'</span>, <span class="string">'HSV'</span>)</span><br><span class="line">io.imshow(hsv)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/10.jpg" height="269" width="410"></p>
<p>在<code>color</code>模块的颜色空间转换函数中，还有一个比较有用的函数是<code>skimage.color.label2rgb(arr)</code>，可以根据标签值对图片进行着色。以后的图片分类后着色就可以用这个函数。例如将<code>coffee</code>图片分成三类，然后用默认颜色对三类进行着色：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data, color</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = data.coffee()</span><br><span class="line">gray = color.rgb2gray(img)</span><br><span class="line">rows, cols = gray.shape</span><br><span class="line">labels = np.zeros([rows, cols])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">        <span class="keyword">if</span> (gray[i, j] &lt; <span class="number">0.4</span>):</span><br><span class="line">            labels[i, j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> (gray[i, j] &lt; <span class="number">0.75</span>):</span><br><span class="line">            labels[i, j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            labels[i, j] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">dst = color.label2rgb(labels)</span><br><span class="line">io.imshow(dst)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/11.png" height="274" width="410"></p>
<h3 id="图像的批量处理"><a href="#图像的批量处理" class="headerlink" title="图像的批量处理"></a>图像的批量处理</h3><p>&emsp;&emsp;有时我们不仅要对一张图片进行处理，可能还会对一批图片处理。这时我们可以通过循环来执行处理，也可以调用程序自带的图片集合来处理。图片集合函数为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.io.ImageCollection(load_pattern, load_func=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<p>该函数的第一个参数<code>load_pattern</code>表示图片组的路径，可以是一个<code>str</code>字符串；第二个参数<code>load_func</code>是一个回调函数，我们对图片进行批量处理就可以通过这个回调函数实现。回调函数默认为<code>imread</code>，即默认这个函数是批量读取图片。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> skimage.io <span class="keyword">as</span> io</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data_dir</span><br><span class="line"></span><br><span class="line">str = data_dir + <span class="string">'/*.png'</span></span><br><span class="line">coll = io.ImageCollection(str)</span><br><span class="line">print(len(coll))</span><br></pre></td></tr></table></figure>
<p>显示结果为<code>28</code>，说明系统自带了<code>25</code>张<code>png</code>的示例图片。这些图片都读取了出来，放在图片集合<code>coll</code>里。如果我们想显示其中一张图片，则可以在后面加上代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io.imshow(coll[<span class="number">10</span>])</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/12.jpg" height="269" width="410"></p>
<p>&emsp;&emsp;如果一个文件夹里，我们既存放了一些<code>jpg</code>格式的图片，又存放了一些<code>png</code>格式的图片。现在想把它们全部读取出来，可以采用如下方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> skimage.io <span class="keyword">as</span> io</span><br><span class="line"></span><br><span class="line">str = <span class="string">'d:/pic/*.jpg:d:/pic/*.png'</span></span><br><span class="line">coll = io.ImageCollection(str)</span><br><span class="line">print(len(coll))</span><br></pre></td></tr></table></figure>
<p>注意字符串<code>d:/pic/*.jpg:d:/pic/*.png</code>，它是两个字符串合在一起，第一个是<code>d:/pic/*.jpg</code>，第二个是<code>d:/pic/*.png</code>，合在一起后，中间用冒号来隔开，这样就可以把<code>d:/pic/</code>文件夹下的<code>jpg</code>和<code>png</code>格式的图片都读取出来。如果还想读取存放在其它地方的图片，也可以一并加进去，只是中间同样用冒号来隔开。<br>&emsp;&emsp;<code>io.ImageCollection</code>默认的第二个参数就是批量读取。如果我们不是想批量读取，而是其它批量操作(如批量转换为灰度图)，又该怎么做呢？那就需要先定义一个函数，然后将这个函数作为第二个参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data_dir, io, color</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_gray</span><span class="params">(f)</span>:</span></span><br><span class="line">    rgb = io.imread(f)</span><br><span class="line">    <span class="keyword">return</span> color.rgb2gray(rgb)</span><br><span class="line"></span><br><span class="line">str = data_dir + <span class="string">'/*.png'</span></span><br><span class="line">coll = io.ImageCollection(str, load_func=convert_gray)</span><br><span class="line">io.imshow(coll[<span class="number">10</span>])</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/13.jpg" height="270" width="409"></p>
<p>得到图片集合以后，我们还可以将这些图片连接起来，构成一个维度更高的数组。连接图片的函数为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.io.concatenate_images(ic)</span><br></pre></td></tr></table></figure>
<p>该函数的参数就是以上的图片集合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">coll = io.ImageCollection(<span class="string">'d:/pic/*.jpg'</span>)</span><br><span class="line">mat = io.concatenate_images(coll)</span><br></pre></td></tr></table></figure>
<p>使用<code>concatenate_images(ic)</code>函数的前提是读取的这些图片尺寸必须一致，否则会出错。我们看看图片连接前后的维度变化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">coll = io.ImageCollection(<span class="string">'d:/pic/*.jpg'</span>)</span><br><span class="line">print(len(coll))  <span class="comment"># 连接的图片数量</span></span><br><span class="line">print(coll[<span class="number">0</span>].shape)  <span class="comment"># 连接前的图片尺寸，所有的都一样</span></span><br><span class="line">mat = io.concatenate_images(coll)</span><br><span class="line">print(mat.shape)  <span class="comment"># 连接后的数组尺寸</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">(<span class="number">870</span>, <span class="number">580</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">870</span>, <span class="number">580</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，将<code>2</code>个<code>3</code>维数组连接成了一个<code>4</code>维数组。如果我们对图片进行批量操作后，想把操作后的结果保存起来，也是可以办到的。<br>&emsp;&emsp;把系统自带的所有<code>png</code>示例图片全部转换成<code>256 * 256</code>的<code>jpg</code>格式灰度图，保存在<code>d:/data/</code>文件夹下。改变图片的大小可以使用<code>tranform</code>模块的<code>resize</code>函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data_dir, io, transform, color</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_gray</span><span class="params">(f)</span>:</span></span><br><span class="line">    rgb = io.imread(f)  <span class="comment"># 依次读取rgb图片</span></span><br><span class="line">    gray = color.rgb2gray(rgb)  <span class="comment"># 将rgb图片转换成灰度图</span></span><br><span class="line">    dst = transform.resize(gray, (<span class="number">256</span>, <span class="number">256</span>))  <span class="comment"># 将灰度图片大小转换为“256*256”</span></span><br><span class="line">    <span class="keyword">return</span> dst</span><br><span class="line"></span><br><span class="line">image_list = data_dir + <span class="string">'/*.png'</span></span><br><span class="line">coll = io.ImageCollection(image_list, load_func=convert_gray)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(coll)):</span><br><span class="line">    io.imsave(<span class="string">'d:/data/'</span> + str(i) + <span class="string">'.jpg'</span>, coll[i])  <span class="comment"># 循环保存图片</span></span><br></pre></td></tr></table></figure>
<h3 id="图像的形变与缩放"><a href="#图像的形变与缩放" class="headerlink" title="图像的形变与缩放"></a>图像的形变与缩放</h3><p>&emsp;&emsp;图像的形变与缩放使用的是<code>skimage</code>的<code>transform</code>模块。</p>
<h4 id="改变图片尺寸resize"><a href="#改变图片尺寸resize" class="headerlink" title="改变图片尺寸resize"></a>改变图片尺寸resize</h4><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.transform.resize(image, output_shape)</span><br></pre></td></tr></table></figure>
<p>参数<code>image</code>是需要改变尺寸的图片，<code>output_shape</code>是新的图片尺寸。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> transform, data</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = data.camera()</span><br><span class="line">dst = transform.resize(img, (<span class="number">80</span>, <span class="number">60</span>))</span><br><span class="line">plt.figure(<span class="string">'resize'</span>)</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.title(<span class="string">'before resize'</span>)</span><br><span class="line">plt.imshow(img, plt.cm.gray)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.title(<span class="string">'before resize'</span>)</span><br><span class="line">plt.imshow(dst, plt.cm.gray)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>将<code>camera</code>图片由原来的<code>512 * 512</code>变成了<code>80 * 60</code>大小，从下图中的坐标尺就能够看出来：</p>
<p><img src="/2019/02/19/Python语法/skimage模块/14.jpg" height="230" width="360"></p>
<h4 id="按比例缩放rescale"><a href="#按比例缩放rescale" class="headerlink" title="按比例缩放rescale"></a>按比例缩放rescale</h4><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.transform.rescale(image, scale[, ...])</span><br></pre></td></tr></table></figure>
<p>参数<code>scale</code>可以是单个<code>float</code>数，表示长和宽缩放的倍数；也可以是一个<code>float</code>型的<code>tuple</code>(例如<code>[0.2, 0.5]</code>)，将行列分别进行缩放：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> transform, data</span><br><span class="line"></span><br><span class="line">img = data.camera()</span><br><span class="line">print(img.shape)  <span class="comment"># 图片原始大小</span></span><br><span class="line">print(transform.rescale(img, <span class="number">0.1</span>).shape)  <span class="comment"># 长和宽缩小为原来图片大小的0.1</span></span><br><span class="line">print(transform.rescale(img, [<span class="number">0.5</span>, <span class="number">0.25</span>]).shape)  <span class="comment"># 行缩小为原来图片的一半，列为四分之一</span></span><br><span class="line">print(transform.rescale(img, <span class="number">2</span>).shape)  <span class="comment"># 长和宽放大为原来图片大小的2倍</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">51</span>, <span class="number">51</span>)</span><br><span class="line">(<span class="number">256</span>, <span class="number">128</span>)</span><br><span class="line">(<span class="number">1024</span>, <span class="number">1024</span>)</span><br></pre></td></tr></table></figure>
<h4 id="旋转rotate"><a href="#旋转rotate" class="headerlink" title="旋转rotate"></a>旋转rotate</h4><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.transform.rotate(image, angle[, ...], resize = <span class="keyword">False</span>)</span><br></pre></td></tr></table></figure>
<p>参数<code>angle</code>是一个<code>float</code>类型数，表示旋转的度数；参数<code>resize</code>用于控制在旋转时是否改变大小。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> transform, data</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = data.camera()</span><br><span class="line">print(img.shape)  <span class="comment"># 图片原始大小</span></span><br><span class="line">img1 = transform.rotate(img, <span class="number">60</span>)  <span class="comment"># 旋转90度，不改变大小</span></span><br><span class="line">print(img1.shape)</span><br><span class="line">img2 = transform.rotate(img, <span class="number">30</span>, resize=<span class="keyword">True</span>)  <span class="comment"># 旋转30度，同时改变大小</span></span><br><span class="line">print(img2.shape)</span><br><span class="line">plt.figure(<span class="string">'resize'</span>)</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.title(<span class="string">'rotate 60'</span>)</span><br><span class="line">plt.imshow(img1, plt.cm.gray)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.title(<span class="string">'rotate 30'</span>)</span><br><span class="line">plt.imshow(img2, plt.cm.gray)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">700</span>, <span class="number">700</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/15.jpg" height="230" width="360"></p>
<h3 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h3><p>&emsp;&emsp;以多分辨率来解释图像的一种有效但概念简单的结构就是图像金字塔。图像金字塔最初用于机器视觉和图像压缩，一幅图像的金字塔是一系列以金字塔形状排列的分辨率逐步降低的图像集合。金字塔的底部是待处理图像的高分辨率表示，而顶部是低分辨率的近似。当向金字塔的上层移动时，尺寸和分辨率就降低。<br>&emsp;&emsp;在此我们举一个高斯金字塔的应用实例，函数原型为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.transform.pyramid_gaussian(image, downscale=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><code>downscale</code>控制着金字塔的缩放比例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data, transform</span><br><span class="line"></span><br><span class="line">image = data.astronaut()  <span class="comment"># 载入宇航员图片</span></span><br><span class="line">rows, cols, dim = image.shape  <span class="comment"># 获取图片的行数、列数和通道数</span></span><br><span class="line"><span class="comment"># 产生高斯金字塔图像，共生成了“log(512) = 9”幅金字塔图像，加上原始图像共10幅</span></span><br><span class="line">pyramid = tuple(transform.pyramid_gaussian(image, downscale=<span class="number">2</span>))</span><br><span class="line">composite_image = np.ones((rows, cols + cols // <span class="number">2</span>, <span class="number">3</span>), dtype=np.float)  <span class="comment"># 生成背景</span></span><br><span class="line">composite_image[:rows, :cols, :] = pyramid[<span class="number">0</span>]  <span class="comment"># 融合原始图像</span></span><br><span class="line">i_row = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> pyramid[<span class="number">1</span>:]:</span><br><span class="line">    n_rows, n_cols = p.shape[:<span class="number">2</span>]</span><br><span class="line">    composite_image[i_row:i_row + n_rows, cols:cols + n_cols] = p  <span class="comment"># 循环融合9幅金字塔图像</span></span><br><span class="line">    i_row += n_rows</span><br><span class="line"></span><br><span class="line">plt.imshow(composite_image)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/16.jpg" height="241" width="359"></p>
<p>上图就是<code>10</code>张金字塔图像，下标为<code>0</code>的表示原始图像，后面每层的图像行和列变为上一层的一半，直至变为<code>1</code>。</p>
<h3 id="对比度与亮度调整"><a href="#对比度与亮度调整" class="headerlink" title="对比度与亮度调整"></a>对比度与亮度调整</h3><p>&emsp;&emsp;图像亮度与对比度的调整是放在<code>skimage</code>的<code>exposure</code>模块里面。</p>
<h4 id="gamma调整"><a href="#gamma调整" class="headerlink" title="gamma调整"></a>gamma调整</h4><p>&emsp;&emsp;原理是<code>I = I * g</code>，对原图像的像素进行幂运算，得到新的像素值，公式中的<code>g</code>就是<code>gamma</code>值。如果<code>gamma &gt; 1</code>，新图像比原图像暗；如果<code>gamma &lt; 1</code>，新图像比原图像亮。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.exposure.adjust_gamma(image, gamma=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>参数<code>gamma</code>默认为<code>1</code>，即原图像不发生变化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data, exposure, img_as_float</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">image = img_as_float(data.moon())</span><br><span class="line">gam1 = exposure.adjust_gamma(image, <span class="number">2</span>)  <span class="comment"># 调暗</span></span><br><span class="line">gam2 = exposure.adjust_gamma(image, <span class="number">0.5</span>)  <span class="comment"># 调亮</span></span><br><span class="line">plt.figure(<span class="string">'adjust_gamma'</span>, figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">plt.subplot(<span class="number">131</span>)</span><br><span class="line">plt.title(<span class="string">'origin image'</span>)</span><br><span class="line">plt.imshow(image, plt.cm.gray)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">132</span>)</span><br><span class="line">plt.title(<span class="string">'gamma = 2'</span>)</span><br><span class="line">plt.imshow(gam1, plt.cm.gray)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">133</span>)</span><br><span class="line">plt.title(<span class="string">'gamma = 0.5'</span>)</span><br><span class="line">plt.imshow(gam2, plt.cm.gray)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/17.jpg" height="139" width="418"></p>
<h4 id="log对数调整"><a href="#log对数调整" class="headerlink" title="log对数调整"></a>log对数调整</h4><p>&emsp;&emsp;这个函数刚好和<code>gamma</code>相反，原理是<code>I = log(I)</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data, exposure, img_as_float</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">image = img_as_float(data.moon())</span><br><span class="line">gam1 = exposure.adjust_log(image)  <span class="comment"># 对数调整</span></span><br><span class="line">plt.figure(<span class="string">'adjust_gamma'</span>, figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.title(<span class="string">'origin image'</span>)</span><br><span class="line">plt.imshow(image, plt.cm.gray)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.title(<span class="string">'log'</span>)</span><br><span class="line">plt.imshow(gam1, plt.cm.gray)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/18.jpg" height="206" width="419"></p>
<h4 id="判断图像对比度是否偏低"><a href="#判断图像对比度是否偏低" class="headerlink" title="判断图像对比度是否偏低"></a>判断图像对比度是否偏低</h4><p>&emsp;&emsp;函数是<code>is_low_contrast(img)</code>，返回一个<code>bool</code>型值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data, exposure</span><br><span class="line">image = data.moon()</span><br><span class="line">result = exposure.is_low_contrast(image)</span><br><span class="line">print(result)  <span class="comment"># 输出“False”</span></span><br></pre></td></tr></table></figure>
<h4 id="调整强度"><a href="#调整强度" class="headerlink" title="调整强度"></a>调整强度</h4><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.exposure.rescale_intensity(image, in_range=<span class="string">'image'</span>, out_range=<span class="string">'dtype'</span>)</span><br></pre></td></tr></table></figure>
<p>参数<code>in_range</code>表示输入图片的强度范围，默认为<code>image</code>，表示用图像的最大和最小像素值作为范围；参数<code>out_range</code>表示输出图片的强度范围，默认为<code>dtype</code>，表示用图像的类型的最大和最小值作为范围。默认情况下，输入图片的<code>[min, max]</code>范围被拉伸到<code>[dtype.min, dtype.max]</code>，如果<code>dtype=uint8</code>，那么<code>dtype.min</code>为<code>0</code>，<code>dtype.max</code>为<code>255</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> exposure</span><br><span class="line"></span><br><span class="line">image = np.array([<span class="number">51</span>, <span class="number">102</span>, <span class="number">153</span>], dtype=np.uint8)</span><br><span class="line">mat = exposure.rescale_intensity(image)</span><br><span class="line">print(mat)  <span class="comment"># 输出“[0 127 255]”</span></span><br></pre></td></tr></table></figure>
<p>即像素最小值由<code>51</code>变为<code>0</code>，最大值由<code>153</code>变为<code>255</code>，整体进行了拉伸，但是数据类型没有变，还是<code>uint8</code>。<br>&emsp;&emsp;前面我们讲过，可以通过<code>img_as_float</code>函数将<code>unit8</code>类型转换为<code>float</code>型，实际上还有更简单的方法，就是乘以<code>1.0</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">image = np.array([<span class="number">51</span>, <span class="number">102</span>, <span class="number">153</span>], dtype=np.uint8)</span><br><span class="line">print(image * <span class="number">1.0</span>)  <span class="comment"># 输出“[ 51. 102. 153.]”</span></span><br></pre></td></tr></table></figure>
<p>而<code>float</code>类型的范围是<code>[0, 1]</code>，因此对<code>float</code>进行<code>rescale_intensity</code>调整后，范围变为<code>[0, 1]</code>，而不是<code>[0, 255]</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> exposure</span><br><span class="line"></span><br><span class="line">image = np.array([<span class="number">51</span>, <span class="number">102</span>, <span class="number">153</span>], dtype=np.uint8)</span><br><span class="line">tmp = image * <span class="number">1.0</span></span><br><span class="line">mat = exposure.rescale_intensity(tmp)</span><br><span class="line">print(mat)  <span class="comment"># 输出“[0.  0.5 1. ]”</span></span><br></pre></td></tr></table></figure>
<p>如果原始像素值不想被拉伸，只是等比例缩小，就使用<code>in_range</code>参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> exposure</span><br><span class="line"></span><br><span class="line">image = np.array([<span class="number">51</span>, <span class="number">102</span>, <span class="number">153</span>], dtype=np.uint8)</span><br><span class="line">tmp = image * <span class="number">1.0</span></span><br><span class="line">mat = exposure.rescale_intensity(tmp, in_range=(<span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">print(mat)  <span class="comment"># 输出“[0.2 0.4 0.6]”，即原像素值除以255</span></span><br></pre></td></tr></table></figure>
<p>如果参数<code>in_range</code>的范围要比原始像素值的范围<code>[min, max]</code>大或者小，那就进行裁剪：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mat = exposure.rescale_intensity(tmp, in_range=(<span class="number">0</span>, <span class="number">102</span>))</span><br><span class="line">print(mat)  <span class="comment"># 输出“[0.5 1.  1. ]”，即原像素值除以102，超出1的变为1</span></span><br></pre></td></tr></table></figure>
<p>如果一个数组里面有负数，现在想调整到正数，就使用<code>out_range</code>参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> exposure</span><br><span class="line"></span><br><span class="line">image = np.array([<span class="number">-10</span>, <span class="number">0</span>, <span class="number">10</span>], dtype=np.int8)</span><br><span class="line">mat = exposure.rescale_intensity(image, out_range=(<span class="number">0</span>, <span class="number">127</span>))</span><br><span class="line">print(mat)  <span class="comment"># 输出“[  0  63 127]”</span></span><br></pre></td></tr></table></figure>
<h3 id="直方图与均衡化"><a href="#直方图与均衡化" class="headerlink" title="直方图与均衡化"></a>直方图与均衡化</h3><p>&emsp;&emsp;在<code>skimage</code>中，对直方图的处理是放在<code>exposure</code>模块中。</p>
<h4 id="计算直方图"><a href="#计算直方图" class="headerlink" title="计算直方图"></a>计算直方图</h4><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.exposure.histogram(image, nbins=<span class="number">256</span>)</span><br></pre></td></tr></table></figure>
<p><code>numpy</code>也提供了一个计算直方图的函数<code>histogram</code>，两者大同小义。该函数返回一个<code>tuple(hist, bins_center)</code>，前一个数组是直方图的统计量，后一个数组是每个<code>bin</code>的中间值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> exposure, data</span><br><span class="line"></span><br><span class="line">image = data.camera() * <span class="number">1.0</span></span><br><span class="line">hist1 = np.histogram(image, bins=<span class="number">2</span>)  <span class="comment"># 用numpy计算直方图</span></span><br><span class="line">hist2 = exposure.histogram(image, nbins=<span class="number">2</span>)  <span class="comment"># 用skimage计算直方图</span></span><br><span class="line">print(hist1)</span><br><span class="line">print(hist2)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(array([<span class="number">107432</span>, <span class="number">154712</span>], dtype=int64), array([  <span class="number">0.</span> , <span class="number">127.5</span>, <span class="number">255.</span> ]))</span><br><span class="line">(array([<span class="number">107432</span>, <span class="number">154712</span>], dtype=int64), array([ <span class="number">63.75</span>, <span class="number">191.25</span>]))</span><br></pre></td></tr></table></figure>
<p>每个<code>bin</code>的统计量是一样的，但<code>numpy</code>返回的是每个<code>bin</code>的两端的范围值，而<code>skimage</code>返回的是每个<code>bin</code>的中间值。</p>
<h4 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h4><p>&emsp;&emsp;绘图可以调用<code>matplotlib.pyplot</code>库来进行，其中的<code>hist</code>函数可以直接绘制直方图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n, bins, patches = plt.hist(</span><br><span class="line">    arr, bins=<span class="number">10</span>, normed=<span class="number">0</span>, facecolor=<span class="string">'black'</span>,</span><br><span class="line">    edgecolor=<span class="string">'black'</span>, alpha=<span class="number">1</span>, histtype=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>arr</code>: 显示直方图的一维数组。</li>
<li><code>bins</code>: 直方图的柱数。</li>
<li><code>normed</code>: 是否将得到的直方图向量归一化。</li>
<li><code>facecolor</code>: 直方图颜色。</li>
<li><code>edgecolor</code>: 直方图边框颜色。</li>
<li><code>alpha</code>: 透明度。</li>
<li><code>histtype</code>: 直方图类型，例如<code>bar</code>、<code>barstacked</code>、<code>step</code>和<code>stepfilled</code>。</li>
</ul>
<p>返回值如下：</p>
<ul>
<li><code>n</code>: 直方图向量，是否归一化由参数<code>normed</code>设定。</li>
<li><code>bins</code>: 返回各个<code>bin</code>的区间范围。</li>
<li><code>patches</code>: 返回每个<code>bin</code>里面包含的数据，是一个<code>list</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = data.camera()</span><br><span class="line">plt.figure(<span class="string">"hist"</span>)</span><br><span class="line">arr = img.flatten()</span><br><span class="line">n, bins, patches = plt.hist(arr, bins=<span class="number">256</span>, normed=<span class="number">1</span>, edgecolor=<span class="string">'None'</span>, facecolor=<span class="string">'red'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/19.png" height="268" width="370"></p>
<p>其中的<code>flatten</code>是<code>numpy</code>中的函数，用于将多维数组序列化成一维数组。</p>
<h4 id="彩色图片三通道直方图"><a href="#彩色图片三通道直方图" class="headerlink" title="彩色图片三通道直方图"></a>彩色图片三通道直方图</h4><p>&emsp;&emsp;一般来说直方图都是针对灰度图的，如果要画<code>rgb</code>图像的三通道直方图，实际上就是三个直方图的叠加：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = data.coffee()</span><br><span class="line">ar = img[:, :, <span class="number">0</span>].flatten()</span><br><span class="line">plt.hist(ar, bins=<span class="number">256</span>, normed=<span class="number">1</span>, facecolor=<span class="string">'r'</span>, edgecolor=<span class="string">'r'</span>, hold=<span class="number">1</span>)</span><br><span class="line">ag = img[:, :, <span class="number">1</span>].flatten()</span><br><span class="line">plt.hist(ag, bins=<span class="number">256</span>, normed=<span class="number">1</span>, facecolor=<span class="string">'g'</span>, edgecolor=<span class="string">'g'</span>, hold=<span class="number">1</span>)</span><br><span class="line">ab = img[:, :, <span class="number">2</span>].flatten()</span><br><span class="line">plt.hist(ab, bins=<span class="number">256</span>, normed=<span class="number">1</span>, facecolor=<span class="string">'b'</span>, edgecolor=<span class="string">'b'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>其中加一个参数<code>hold = 1</code>，表示可以叠加：</p>
<p><img src="/2019/02/19/Python语法/skimage模块/20.png" height="266" width="366"></p>
<h4 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h4><p>&emsp;&emsp;如果一幅图像的像素占有很多的灰度级而且分布均匀，那么这样的图像往往有高对比度和多变的灰度色调。直方图均衡化就是一种能仅靠输入图像直方图信息自动达到这种效果的变换函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data, exposure</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = data.moon()</span><br><span class="line">plt.figure(<span class="string">"hist"</span>, figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">arr = img.flatten()</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.imshow(img, plt.cm.gray)  <span class="comment"># 原始图像</span></span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.hist(arr, bins=<span class="number">256</span>, normed=<span class="number">1</span>, edgecolor=<span class="string">'None'</span>, facecolor=<span class="string">'red'</span>)  <span class="comment"># 原始图像直方图</span></span><br><span class="line">img1 = exposure.equalize_hist(img)</span><br><span class="line">arr1 = img1.flatten()</span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.imshow(img1, plt.cm.gray)  <span class="comment"># 均衡化图像</span></span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.hist(arr1, bins=<span class="number">256</span>, normed=<span class="number">1</span>, edgecolor=<span class="string">'None'</span>, facecolor=<span class="string">'red'</span>)  <span class="comment"># 均衡化直方图</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/21.jpg" height="324" width="332"></p>
<h3 id="HOG特征"><a href="#HOG特征" class="headerlink" title="HOG特征"></a>HOG特征</h3><p>&emsp;&emsp;该函数返回一维<code>hog</code>特征和<code>hog</code>特征的可视化图像：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">skimage.feature.hog(</span><br><span class="line">    image, orientations=<span class="number">9</span>, pixels_per_cell=(<span class="number">8</span>, <span class="number">8</span>), cells_per_block=(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    visualise=<span class="keyword">False</span>, transform_sqrt=<span class="keyword">False</span>, feature_vector=<span class="keyword">True</span>, normalise=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>image</code>：传入要进行<code>hog</code>特征计算的灰度图。</li>
<li><code>orientations</code>：设置方向梯度直方图的箱子个数。</li>
<li><code>pixels_per_cell</code>：设置每个单元的像素。</li>
<li><code>cells_per_block</code>：设置每个区块的单元数。</li>
<li><code>visualise</code>：设置是否返回可视化的<code>hog</code>特征。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data, color, exposure</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog</span><br><span class="line"></span><br><span class="line">image = color.rgb2gray(data.astronaut())</span><br><span class="line">fd, hog_image = hog(image, orientations=<span class="number">8</span>, pixels_per_cell=(<span class="number">16</span>, <span class="number">16</span>), cells_per_block=(<span class="number">1</span>, <span class="number">1</span>), visualize=<span class="keyword">True</span>)</span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), sharex=<span class="keyword">True</span>, sharey=<span class="keyword">True</span>)</span><br><span class="line">ax1.axis(<span class="string">'off'</span>)</span><br><span class="line">ax1.imshow(image, cmap=plt.cm.gray)</span><br><span class="line">ax1.set_title(<span class="string">'Input image'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rescale histogram for better display</span></span><br><span class="line">hog_image_rescaled = exposure.rescale_intensity(hog_image, in_range=(<span class="number">0</span>, <span class="number">0.02</span>))</span><br><span class="line">ax2.axis(<span class="string">'off'</span>)</span><br><span class="line">ax2.imshow(hog_image_rescaled, cmap=plt.cm.gray)</span><br><span class="line">ax2.set_title(<span class="string">'Histogram of Oriented Gradients'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/22.jpg" height="257" width="523"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/18/Qt语法详解/Qt之QMenu/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/Qt语法详解/Qt之QMenu/" itemprop="url">Qt之QMenu</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T19:51:39+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QMenu</code> class provides a menu widget for use in menu bars, context menus, and other popup menus.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QMenu</code></td>
<td><code>QWidget</code></td>
<td><code>Q3PopupMenu</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QMenu(QWidget * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>QMenu(const QString &amp; title, QWidget * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QMenu()</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>actionAt(const QPoint &amp; pt) const</code></td>
</tr>
<tr>
<td><code>QRect</code></td>
<td><code>actionGeometry(QAction * act) const</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>activeAction() const</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>addAction(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>addAction(const QIcon &amp; icon, const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>addAction(const QString &amp; text, const QObject * receiver, const char * member, const QKeySequence &amp; shortcut = 0)</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>addAction(const QIcon &amp; icon, const QString &amp; text, const QObject * receiver, const char * member, const QKeySequence &amp; shortcut = 0)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addAction(QAction * action)</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>addMenu(QMenu * menu)</code></td>
</tr>
<tr>
<td><code>QMenu *</code></td>
<td><code>addMenu(const QString &amp; title)</code></td>
</tr>
<tr>
<td><code>QMenu *</code></td>
<td><code>addMenu(const QIcon &amp; icon, const QString &amp; title)</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>addSeparator()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>defaultAction() const</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>exec()</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>exec(const QPoint &amp; p, QAction * action = 0)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>hideTearOffMenu()</code></td>
</tr>
<tr>
<td><code>QIcon</code></td>
<td><code>icon() const</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>insertMenu(QAction * before, QMenu * menu)</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>insertSeparator(QAction * before)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isTearOffEnabled() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isTearOffMenuVisible() const</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>menuAction() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>popup(const QPoint &amp; p, QAction * atAction = 0)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>separatorsCollapsible() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setActiveAction(QAction * act)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDefaultAction(QAction * act)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setIcon(const QIcon &amp; icon)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSeparatorsCollapsible(bool collapse)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTearOffEnabled(bool)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTitle(const QString &amp; title)</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>title() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Public-Functions"><a href="#Reimplemented-Public-Functions" class="headerlink" title="Reimplemented Public Functions"></a>Reimplemented Public Functions</h3><ul>
<li><code>virtual QSize sizeHint() const;</code></li>
</ul>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>aboutToHide();</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>aboutToShow();</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>hovered ( QAction *action );</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>triggered ( QAction *action );</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Static-Public-Members"><a href="#Static-Public-Members" class="headerlink" title="Static Public Members"></a>Static Public Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QAction *</code></td>
<td><code>exec ( QList&lt;QAction *&gt; actions, const QPoint &amp;pos, QAction *at, QWidget *parent );</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>exec ( QList&lt;QAction *&gt; actions, const QPoint &amp;pos, QAction *at = 0 );</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td><code>columnCount() const;</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>initStyleOption ( QStyleOptionMenuItem *option, const QAction *action ) const;</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Protected-Functions"><a href="#Reimplemented-Protected-Functions" class="headerlink" title="Reimplemented Protected Functions"></a>Reimplemented Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual void</code></td>
<td><code>actionEvent ( QActionEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>changeEvent ( QEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>enterEvent ( QEvent * );</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>event ( QEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>focusNextPrevChild ( bool next );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>hideEvent ( QHideEvent * );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>keyPressEvent ( QKeyEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>leaveEvent ( QEvent * );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>mouseMoveEvent ( QMouseEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>mousePressEvent ( QMouseEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>mouseReleaseEvent ( QMouseEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>paintEvent ( QPaintEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>timerEvent ( QTimerEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>wheelEvent ( QWheelEvent *e );</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QMenu</code> class provides a menu widget for use in menu bars, context menus, and other popup menus.<br>&emsp;&emsp;A menu widget is a selection menu. It can be either a <code>pull-down</code> menu in a menu bar or a standalone context menu. <code>Pull-down</code> menus are shown by the menu bar when the user clicks on the respective item or presses the specified shortcut key. Use <code>QMenuBar::addMenu()</code> to insert a menu into a menu bar. Context menus are usually invoked by some special keyboard key or by <code>right-clicking</code>. They can be executed either asynchronously with <code>popup()</code> or synchronously with <code>exec()</code>. Menus can also be invoked in response to button presses; these are just like context menus except for how they are invoked.</p>
<p><img src="/2019/02/18/Qt语法详解/Qt之QMenu/1.png"></p>
<p align="center" style="color:green">Fig. A menu shown in Plastique widget style, Windows XP widget style, and Macintosh widget style.</p>

<h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>&emsp;&emsp;A menu consists of a list of action items. Actions are added with the <code>addAction()</code>, <code>addActions()</code> and <code>insertAction()</code> functions. An action is represented vertically and rendered by <code>QStyle</code>. In addition, actions can have a text label, an optional icon drawn on the very left side, and shortcut key sequence such as <code>Ctrl + X</code>.<br>&emsp;&emsp;The existing actions held by a menu can be found with <code>actions()</code>.<br>&emsp;&emsp;There are four kinds of action items: separators, actions that show a submenu, widgets, and actions that perform an action. Separators are inserted with <code>addSeparator()</code>, submenus with <code>addMenu()</code>, and all other items are considered action items.<br>&emsp;&emsp;When inserting action items you usually specify a receiver and a slot. The receiver will be notifed whenever the item is <code>triggered()</code>. In addition, <code>QMenu</code> provides two signals, <code>activated()</code> and <code>highlighted()</code>, which signal the <code>QAction</code> that was triggered from the menu.<br>&emsp;&emsp;You clear a menu with <code>clear()</code> and remove individual action items with <code>removeAction()</code>.<br>&emsp;&emsp;A QMenu can also provide a tear-off menu. A <code>tear-off</code> menu is a <code>top-level</code> window that contains a copy of the menu. This makes it possible for the user to <code>tear off</code> frequently used menus and position them in a convenient place on the screen. If you want this functionality for a particular menu, insert a <code>tear-off</code> handle with <code>setTearOffEnabled()</code>. When using <code>tear-off</code> menus, bear in mind that the concept isn’t typically used on <code>Microsoft Windows</code> so some users may not be familiar with it. Consider using a <code>QToolBar</code> instead.<br>&emsp;&emsp;Widgets can be inserted into menus with the <code>QWidgetAction</code> class. Instances of this class are used to hold widgets, and are inserted into menus with the <code>addAction()</code> overload that takes a <code>QAction</code>.<br>&emsp;&emsp;Conversely, actions can be added to widgets with the <code>addAction()</code>, <code>addActions()</code> and <code>insertAction()</code> functions.<br>&emsp;&emsp;<strong>Warning</strong>: To make <code>QMenu</code> visible on the screen, <code>exec()</code> or <code>popup()</code> should be used instead of <code>show()</code>.</p>
<h3 id="Property-Documentation"><a href="#Property-Documentation" class="headerlink" title="Property Documentation"></a>Property Documentation</h3><ul>
<li><code>icon : QIcon</code>: This property holds the icon of the menu. This is equivalent to the <code>QAction::icon</code> property of the <code>menuAction()</code>. By default, if no icon is explicitly set, this property contains a null icon. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QIcon <span class="title">icon</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">setIcon</span> <span class="params">( <span class="keyword">const</span> QIcon &amp;icon )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>separatorsCollapsible : bool</code>: This property holds whether consecutive separators should be collapsed. This property specifies whether consecutive separators in the menu should be visually collapsed to a single one. Separators at the beginning or the end of the menu are also hidden. By default, this property is <code>true</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">separatorsCollapsible</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSeparatorsCollapsible</span> <span class="params">( <span class="keyword">bool</span> collapse )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tearOffEnabled : bool</code>: This property holds whether the menu supports being torn off. When <code>true</code>, the menu contains a special <code>tear-off</code> item (often shown as a dashed line at the top of the menu) that creates a copy of the menu when it is triggered. This <code>torn-off</code> copy lives in a separate window. It contains the same menu items as the original menu, with the exception of the <code>tear-off</code> handle. By default, this property is <code>false</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTearOffEnabled</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTearOffEnabled</span> <span class="params">( <span class="keyword">bool</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>title : QString</code>: This property holds the title of the menu. This is equivalent to the <code>QAction::text</code> property of the <code>menuAction()</code>. By default, this property contains an empty string. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">title</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTitle</span> <span class="params">( <span class="keyword">const</span> QString &amp;title )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QMenu::QMenu(QWidget * parent = 0)</code>: Constructs a menu with <code>parent</code>. Although a popup menu is always a <code>top-level</code> widget, if a parent is passed, the popup menu will be deleted when that parent is destroyed (as with any other <code>QObject</code>).</li>
<li><code>QMenu::QMenu(const QString &amp; title, QWidget * parent = 0)</code>: Constructs a menu with a <code>title</code> and a <code>parent</code>. Although a popup menu is always a <code>top-level</code> widget, if a parent is passed, the popup menu will be deleted when that parent is destroyed (as with any other <code>QObject</code>).</li>
<li><code>QMenu::~QMenu()</code>: Destroys the menu.</li>
<li><code>void QMenu::aboutToHide() [signal]</code>: This signal is emitted just before the menu is hidden from the user.</li>
<li><code>void QMenu::aboutToShow() [signal]</code>: This signal is emitted just before the menu is shown to the user.</li>
<li><code>QAction * QMenu::actionAt(const QPoint &amp; pt) const</code>: Returns the item at <code>pt</code>; returns <code>0</code> if there is no item there.</li>
<li><code>void QMenu::actionEvent(QActionEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::actionEvent()</code>.</li>
<li><code>QRect QMenu::actionGeometry(QAction * act) const</code>: Returns the geometry of action <code>act</code>.</li>
<li><code>QAction * QMenu::activeAction() const</code>: Returns the currently highlighted action, or <code>0</code> if no action is currently highlighted.</li>
<li><code>QAction * QMenu::addAction(const QString &amp; text)</code>: This is an overloaded function. This convenience function creates a new action with <code>text</code>. The function adds the newly created action to the menu’s list of actions, and returns it.</li>
<li><code>QAction * QMenu::addAction(const QIcon &amp; icon, const QString &amp; text)</code>: This is an overloaded function. This convenience function creates a new action with an <code>icon</code> and some <code>text</code>. The function adds the newly created action to the menu’s list of actions, and returns it.</li>
<li><code>QAction * QMenu::addAction(const QString &amp; text, const QObject * receiver, const char * member, const QKeySequence &amp; shortcut = 0)</code>: This is an overloaded function. This convenience function creates a new action with the <code>text</code> and an optional <code>shortcut</code>. The action’s <code>triggered()</code> signal is connected to the <code>receiver&#39;s</code> <code>member</code> slot. The function adds the newly created action to the menu’s list of actions and returns it.</li>
<li><code>QAction * QMenu::addAction(const QIcon &amp; icon, const QString &amp; text, const QObject * receiver, const char * member, const QKeySequence &amp; shortcut = 0)</code>: This is an overloaded function. This convenience function creates a new action with an <code>icon</code> and some <code>text</code> and an optional <code>shortcut</code>. The action’s <code>triggered()</code> signal is connected to the <code>member</code> slot of the <code>receiver</code> object. The function adds the newly created action to the menu’s list of actions, and returns it.</li>
<li><code>void QMenu::addAction(QAction * action)</code>: This is an overloaded function. Appends the <code>action</code> to the menu’s list of actions.</li>
<li><code>QAction * QMenu::addMenu(QMenu * menu)</code>: This convenience function adds <code>menu</code> as a submenu to this menu. It returns menu’s <code>menuAction()</code>. This <code>menu</code> does not take ownership of menu.</li>
<li><code>QMenu * QMenu::addMenu(const QString &amp; title)</code>: Appends a new <code>QMenu</code> with <code>title</code> to the menu. The <code>menu</code> takes ownership of the menu. Returns the new menu.</li>
<li><code>QMenu * QMenu::addMenu(const QIcon &amp; icon, const QString &amp; title)</code>: Appends a new <code>QMenu</code> with <code>icon</code> and <code>title</code> to the menu. The <code>menu</code> takes ownership of the menu. Returns the new menu.</li>
<li><code>QAction * QMenu::addSeparator()</code>: This convenience function creates a new separator action, i.e. an action with <code>QAction::isSeparator()</code> returning <code>true</code>, and adds the new action to this menu’s list of actions. It returns the newly created action.</li>
<li><code>void QMenu::changeEvent(QEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::changeEvent()</code>.</li>
<li><code>void QMenu::clear()</code>: Removes all the menu’s actions. Actions owned by the menu and not shown in any other widget are deleted.</li>
<li><code>int QMenu::columnCount() const [protected]</code>: If a menu does not fit on the screen it lays itself out so that it does fit. It is style dependent what layout means (for example, on <code>Windows</code> it will use multiple columns). This functions returns the number of columns necessary.</li>
<li><code>QAction * QMenu::defaultAction() const</code>: Returns the current default action.</li>
<li><code>void QMenu::enterEvent(QEvent *) [virtual protected]</code>: Reimplemented from <code>QWidget::enterEvent()</code>.</li>
<li><code>bool QMenu::event(QEvent * e) [virtual protected]</code>: Reimplemented from <code>QObject::event()</code>.</li>
<li><code>QAction * QMenu::exec()</code>: Executes this menu synchronously. This is equivalent to <code>exec(pos())</code>. This returns the triggered <code>QAction</code> in either the popup menu or one of its submenus, or <code>0</code> if no item was triggered (normally because the user pressed <code>Esc</code>). In most situations you’ll want to specify the position yourself, for example, the current mouse position:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec ( QCursor::pos() );</span><br></pre></td></tr></table></figure>
<p>or aligned to a <code>widget</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec ( somewidget.mapToGlobal ( QPoint ( <span class="number">0</span>, <span class="number">0</span> ) ) );</span><br></pre></td></tr></table></figure>
<p>or in reaction to a <code>QMouseEvent *e</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec ( e-&gt;globalPos() );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QAction * QMenu::exec(const QPoint &amp; p, QAction * action = 0)</code>: This is an overloaded function. Executes this menu synchronously. Pops up the menu so that the <code>action</code> will be at the specified global position <code>p</code>. To translate a widget’s local coordinates into global coordinates, use <code>QWidget::mapToGlobal()</code>. This returns the triggered <code>QAction</code> in either the popup menu or one of its submenus, or <code>0</code> if no item was triggered (normally because the user pressed <code>Esc</code>). Note that all signals are emitted as usual. If you connect a <code>QAction</code> to a slot and call the menu’s <code>exec()</code>, you get the result both via the <code>signal-slot</code> connection and in the return value of <code>exec()</code>. Common usage is to position the menu at the current mouse position:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec ( QCursor::pos() );</span><br></pre></td></tr></table></figure>
<p>or aligned to a <code>widget</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec ( somewidget.mapToGlobal ( QPoint ( <span class="number">0</span>, <span class="number">0</span> ) ) );</span><br></pre></td></tr></table></figure>
<p>or in reaction to a <code>QMouseEvent *e</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec ( e-&gt;globalPos() );</span><br></pre></td></tr></table></figure>
<p>When positioning a menu with <code>exec()</code> or <code>popup()</code>, bear in mind that you cannot rely on the menu’s current <code>size()</code>. For performance reasons, the menu adapts its size only when necessary. So in many cases, the size before and after the show is different. Instead, use <code>sizeHint()</code> which calculates the proper size depending on the menu’s current contents.</p>
<ul>
<li><code>QAction * QMenu::exec(QList&lt;QAction *&gt; actions, const QPoint &amp; pos, QAction * at, QWidget * parent) [static]</code>: This is an overloaded function. Executes a menu synchronously. The menu’s actions are specified by the list of <code>actions</code>. The menu will pop up so that the specified <code>action</code>, <code>at</code>, appears at global position <code>pos</code>. If <code>at</code> is not specified then the menu appears at position <code>pos</code>. <code>parent</code> is the menu’s parent widget; specifying the <code>parent</code> will provide context when <code>pos</code> alone is not enough to decide where the menu should go (e.g., with multiple desktops or when the parent is embedded in <code>QGraphicsView</code>). The function returns the triggered <code>QAction</code> in either the popup menu or one of its submenus, or <code>0</code> if no item was triggered (normally because the user pressed <code>Esc</code>). This is equivalent to:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QMenu menu;</span><br><span class="line">QAction *at = actions[<span class="number">0</span>]; <span class="comment">/* Assumes actions is not empty */</span></span><br><span class="line">​</span><br><span class="line">foreach ( QAction *a, actions ) &#123;</span><br><span class="line">    menu.addAction ( a );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">menu.exec ( pos, at );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QAction * QMenu::exec(QList&lt;QAction *&gt; actions, const QPoint &amp; pos, QAction * at = 0) [static]</code>: This is an overloaded function. Executes a menu synchronously. The menu’s actions are specified by the list of <code>actions</code>. The menu will pop up so that the specified <code>action</code>, <code>at</code>, appears at global position <code>pos</code>. If <code>at</code> is not specified then the menu appears at position <code>pos</code>. The function returns the triggered <code>QAction</code> in either the popup menu or one of its submenus, or <code>0</code> if no item was triggered (normally because the user pressed <code>Esc</code>). This is equivalent to:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QMenu menu;</span><br><span class="line">QAction *at = actions[<span class="number">0</span>]; <span class="comment">/* Assumes actions is not empty */</span></span><br><span class="line">​</span><br><span class="line">foreach ( QAction *a, actions ) &#123;</span><br><span class="line">    menu.addAction ( a );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">menu.exec ( pos, at );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>bool QMenu::focusNextPrevChild(bool next) [virtual protected]</code>: Reimplemented from <code>QWidget::focusNextPrevChild()</code>.</li>
<li><code>void QMenu::hideEvent(QHideEvent *) [virtual protected]</code>: Reimplemented from <code>QWidget::hideEvent()</code>.</li>
<li><code>void QMenu::hideTearOffMenu()</code>: This function will forcibly hide the torn off menu making it disappear from the users desktop.</li>
<li><code>void QMenu::hovered(QAction * action) [signal]</code>: This signal is emitted when a menu action is highlighted; <code>action</code> is the action that caused the signal to be emitted. Often this is used to update status information.</li>
<li><code>void QMenu::initStyleOption(QStyleOptionMenuItem * option, const QAction * action) const [protected]</code>: Initialize <code>option</code> with the values from this menu and information from <code>action</code>. This method is useful for subclasses when they need a <code>QStyleOptionMenuItem</code>, but don’t want to fill in all the information themselves.</li>
<li><code>QAction * QMenu::insertMenu(QAction * before, QMenu * menu)</code>: This convenience function inserts <code>menu</code> before action <code>before</code> and returns the menus <code>menuAction()</code>.</li>
<li><code>QAction * QMenu::insertSeparator(QAction * before)</code>: This convenience function creates a new separator action, i.e. an action with <code>QAction::isSeparator()</code> returning <code>true</code>. The function inserts the newly created action into this menu’s list of actions before action <code>before</code> and returns it.</li>
<li><code>bool QMenu::isEmpty() const</code>: Returns <code>true</code> if there are no visible actions inserted into the menu, <code>false</code> otherwise.</li>
<li><code>bool QMenu::isTearOffMenuVisible() const</code>: When a menu is torn off a second menu is shown to display the menu contents in a new window. When the menu is in this mode and the menu is visible returns <code>true</code>; otherwise <code>false</code>.</li>
<li><code>void QMenu::keyPressEvent(QKeyEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::keyPressEvent()</code>.</li>
<li><code>void QMenu::leaveEvent(QEvent *) [virtual protected]</code>: Reimplemented from <code>QWidget::leaveEvent()</code>.</li>
<li><code>QAction * QMenu::menuAction() const</code>: Returns the action associated with this menu.</li>
<li><code>void QMenu::mouseMoveEvent(QMouseEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::mouseMoveEvent()</code>.</li>
<li><code>void QMenu::mousePressEvent(QMouseEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::mousePressEvent()</code>.</li>
<li><code>void QMenu::mouseReleaseEvent(QMouseEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::mouseReleaseEvent()</code>.</li>
<li><code>void QMenu::paintEvent(QPaintEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::paintEvent()</code>.</li>
<li><code>void QMenu::popup(const QPoint &amp; p, QAction * atAction = 0)</code>: Displays the menu so that the action <code>atAction</code> will be at the specified global position <code>p</code>. To translate a widget’s local coordinates into global coordinates, use <code>QWidget::mapToGlobal()</code>. When positioning a menu with <code>exec()</code> or <code>popup()</code>, bear in mind that you cannot rely on the menu’s current <code>size()</code>. For performance reasons, the menu adapts its size only when necessary, so in many cases, the size before and after the show is different. Instead, use <code>sizeHint()</code> which calculates the proper size depending on the menu’s current contents.</li>
<li><code>void QMenu::setActiveAction(QAction * act)</code>: Sets the currently highlighted action to <code>act</code>.</li>
<li><code>void QMenu::setDefaultAction(QAction * act)</code>: This sets the default action to <code>act</code>. The default action may have a visual cue, depending on the current <code>QStyle</code>. A default action usually indicates what will happen by default when a drop occurs.</li>
<li><code>QSize QMenu::sizeHint() const [virtual]</code>: Reimplemented from <code>QWidget::sizeHint()</code>.</li>
<li><code>void QMenu::timerEvent(QTimerEvent * e) [virtual protected]</code>: Reimplemented from <code>QObject::timerEvent()</code>.</li>
<li><code>void QMenu::triggered(QAction * action) [signal]</code>: This signal is emitted when an action in this menu is triggered. <code>action</code> is the action that caused the signal to be emitted. Normally, you connect each menu action’s <code>triggered()</code> signal to its own custom slot, but sometimes you will want to connect several actions to a single slot, for example, when you have a group of closely related actions, such as <code>left justify</code>, <code>center</code>, <code>right justify</code>. <strong>Note</strong>: This signal is emitted for the main parent menu in a hierarchy. Hence, only the parent menu needs to be connected to a slot; <code>sub-menus</code> need not be connected.</li>
<li><code>void QMenu::wheelEvent(QWheelEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::wheelEvent()</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/19/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/96/">96</a><a class="extend next" rel="next" href="/page/21/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">955</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
