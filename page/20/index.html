<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="泥腿子出身">
<meta property="og:url" content="http://fukangwei.gitee.io/page/20/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="泥腿子出身">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/20/">





  <title>泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/18/Qt语法详解/Qt之QPrinter/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/Qt语法详解/Qt之QPrinter/" itemprop="url">Qt之QPrinter</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T11:15:19+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QPrinter</code> class is a paint device that paints on a printer.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter</code></td>
<td><code>QPaintDevice</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QPrinter(PrinterMode mode = ScreenResolution)</code></td>
</tr>
<tr>
<td></td>
<td><code>QPrinter(const QPrinterInfo &amp; printer, PrinterMode mode = ScreenResolution)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QPrinter()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>abort()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>collateCopies() const</code></td>
</tr>
<tr>
<td><code>ColorMode</code></td>
<td><code>colorMode() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>copyCount() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>creator() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>docName() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>doubleSidedPrinting() const</code></td>
</tr>
<tr>
<td><code>DuplexMode</code></td>
<td><code>duplex() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>fontEmbeddingEnabled() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>fromPage() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>fullPage() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>getPageMargins(qreal * left, qreal * top, qreal * right, qreal * bottom, Unit unit) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isValid() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>newPage()</code></td>
</tr>
<tr>
<td><code>Orientation</code></td>
<td><code>orientation() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>outputFileName() const</code></td>
</tr>
<tr>
<td><code>OutputFormat</code></td>
<td><code>outputFormat() const</code></td>
</tr>
<tr>
<td><code>PageOrder</code></td>
<td><code>pageOrder() const</code></td>
</tr>
<tr>
<td><code>QRect</code></td>
<td><code>pageRect() const</code></td>
</tr>
<tr>
<td><code>QRectF</code></td>
<td><code>pageRect(Unit unit) const</code></td>
</tr>
<tr>
<td><code>QRect</code></td>
<td><code>paperRect() const</code></td>
</tr>
<tr>
<td><code>QRectF</code></td>
<td><code>paperRect(Unit unit) const</code></td>
</tr>
<tr>
<td><code>PaperSize</code></td>
<td><code>paperSize() const</code></td>
</tr>
<tr>
<td><code>QSizeF</code></td>
<td><code>paperSize(Unit unit) const</code></td>
</tr>
<tr>
<td><code>PaperSource</code></td>
<td><code>paperSource() const</code></td>
</tr>
<tr>
<td><code>QPrintEngine *</code></td>
<td><code>printEngine() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>printProgram() const</code></td>
</tr>
<tr>
<td><code>PrintRange</code></td>
<td><code>printRange() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>printerName() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>printerSelectionOption() const</code></td>
</tr>
<tr>
<td><code>PrinterState</code></td>
<td><code>printerState() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>resolution() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCollateCopies(bool collate)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setColorMode(ColorMode newColorMode)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCopyCount(int count)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCreator(const QString &amp; creator)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDocName(const QString &amp; name)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDoubleSidedPrinting(bool doubleSided)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDuplex(DuplexMode duplex)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontEmbeddingEnabled(bool enable)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFromTo(int from, int to)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFullPage(bool fp)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setOrientation(Orientation orientation)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setOutputFileName(const QString &amp; fileName)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setOutputFormat(OutputFormat format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPageMargins(qreal left, qreal top, qreal right, qreal bottom, Unit unit)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPageOrder(PageOrder pageOrder)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPaperSize(PaperSize newPaperSize)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPaperSize(const QSizeF &amp; paperSize, Unit unit)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPaperSource(PaperSource source)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPrintProgram(const QString &amp; printProg)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPrintRange(PrintRange range)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPrinterName(const QString &amp; name)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPrinterSelectionOption(const QString &amp; option)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setResolution(int dpi)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setWinPageSize(int pageSize)</code></td>
</tr>
<tr>
<td><code>QList&lt;PaperSource&gt;</code></td>
<td><code>supportedPaperSources() const</code></td>
</tr>
<tr>
<td><code>QList&lt;int&gt;</code></td>
<td><code>supportedResolutions() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>supportsMultipleCopies() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>toPage() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>winPageSize() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Public-Functions"><a href="#Reimplemented-Public-Functions" class="headerlink" title="Reimplemented Public Functions"></a>Reimplemented Public Functions</h3><ul>
<li><code>virtual QPaintEngine * paintEngine() const;</code></li>
</ul>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><ul>
<li><code>void setEngines(QPrintEngine * printEngine, QPaintEngine * paintEngine);</code></li>
</ul>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QPrinter</code> class is a paint device that paints on a printer.<br>&emsp;&emsp;This device represents a series of pages of printed output, and is used in almost exactly the same way as other paint devices such as <code>QWidget</code> and <code>QPixmap</code>. A set of additional functions are provided to manage <code>device-specific</code> features, such as orientation and resolution, and to step through the pages in a document as it is generated.<br>&emsp;&emsp;When printing directly to a printer on <code>Windows</code> or <code>Mac OS X</code>, <code>QPrinter</code> uses the <code>built-in</code> printer drivers. On <code>X11</code>, <code>QPrinter</code> uses the <code>Common Unix Printing System</code> (<code>CUPS</code>) or the standard <code>Unix</code> lpr utility to send <code>PostScript</code> or <code>PDF</code> output to the printer. As an alternative, the <code>printProgram()</code> function can be used to specify the command or utility to use instead of the system default.<br>&emsp;&emsp;Note that setting parameters like paper size and resolution on an invalid printer is undefined. You can use <code>QPrinter::isValid()</code> to verify this before changing any parameters.<br>&emsp;&emsp;<code>QPrinter</code> supports a number of parameters, most of which can be changed by the end user through a print dialog. In general, <code>QPrinter</code> passes these functions onto the underlying <code>QPrintEngine</code>.<br>&emsp;&emsp;The most important parameters are:</p>
<ul>
<li><code>setOrientation()</code> tells <code>QPrinter</code> which page orientation to use.</li>
<li><code>setPaperSize()</code> tells <code>QPrinter</code> what paper size to expect from the printer.</li>
<li><code>setResolution()</code> tells <code>QPrinter</code> what resolution you wish the printer to provide, in dots per inch (<code>DPI</code>).</li>
<li><code>setFullPage()</code> tells <code>QPrinter</code> whether you want to deal with the full page or just with the part the printer can draw on.</li>
<li><code>setCopyCount()</code> tells <code>QPrinter</code> how many copies of the document it should print.</li>
</ul>
<p>&emsp;&emsp;Many of these functions can only be called before the actual printing begins (i.e., before <code>QPainter::begin()</code> is called). This usually makes sense because, for example, it’s not possible to change the number of copies when you are halfway through printing. There are also some settings that the user sets (through the printer dialog) and that applications are expected to obey.<br>&emsp;&emsp;When <code>QPainter::begin()</code> is called, the <code>QPrinter</code> it operates on is prepared for a new page, enabling the <code>QPainter</code> to be used immediately to paint the first page in a document. Once the first page has been painted, <code>newPage()</code> can be called to request a new blank page to paint on, or <code>QPainter::end()</code> can be called to finish printing. The second page and all following pages are prepared using a call to <code>newPage()</code> before they are painted.<br>&emsp;&emsp;The first page in a document does not need to be preceded by a call to <code>newPage()</code>. You only need to calling <code>newPage()</code> after <code>QPainter::begin()</code> if you need to insert a blank page at the beginning of a printed document. Similarly, calling <code>newPage()</code> after the last page in a document is painted will result in a trailing blank page appended to the end of the printed document.<br>&emsp;&emsp;If you want to abort the print job, <code>abort()</code> will try its best to stop printing. It may cancel the entire job or just part of it.<br>&emsp;&emsp;Since <code>QPrinter</code> can print to any <code>QPrintEngine</code> subclass, it is possible to extend printing support to cover new types of printing subsystem by subclassing <code>QPrintEngine</code> and reimplementing its interface.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QPrinter::ColorMode</code>: This enum type is used to indicate whether <code>QPrinter</code> should print in color or not.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::Color</code></td>
<td><code>1</code></td>
<td>print in color if available, otherwise in grayscale.</td>
</tr>
<tr>
<td><code>QPrinter::GrayScale</code></td>
<td><code>0</code></td>
<td>print in grayscale, even on color printers.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QPrinter::DuplexMode</code>: This enum is used to indicate whether printing will occur on one or both sides of each sheet of paper (simplex or duplex printing).</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::DuplexNone</code></td>
<td><code>0</code></td>
<td>Single sided (simplex) printing only.</td>
</tr>
<tr>
<td><code>QPrinter::DuplexAuto</code></td>
<td><code>1</code></td>
<td>The printer’s default setting is used to determine whether duplex printing is used.</td>
</tr>
<tr>
<td><code>QPrinter::DuplexLongSide</code></td>
<td><code>2</code></td>
<td>Both sides of each sheet of paper are used for printing. The paper is turned over its longest edge before the second side is printed</td>
</tr>
<tr>
<td><code>QPrinter::DuplexShortSide</code></td>
<td><code>3</code></td>
<td>Both sides of each sheet of paper are used for printing. The paper is turned over its shortest edge before the second side is printed</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QPrinter::Orientation</code>: This enum type (not to be confused with <code>Orientation</code>) is used to specify each page’s orientation.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::Portrait</code></td>
<td><code>0</code></td>
<td>the page’s height is greater than its width.</td>
</tr>
<tr>
<td><code>QPrinter::Landscape</code></td>
<td><code>1</code></td>
<td>the page’s width is greater than its height.</td>
</tr>
</tbody>
</table>
</div>
<p>This type interacts with <code>QPrinter::PaperSize</code> and <code>QPrinter::setFullPage()</code> to determine the final size of the page available to the application.</p>
<ul>
<li>enum <code>QPrinter::OutputFormat</code>: The <code>OutputFormat</code> enum is used to describe the format <code>QPrinter</code> should use for printing.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::NativeFormat</code></td>
<td><code>0</code></td>
<td><code>QPrinter</code> will print output using a method defined by the platform it is running on. This mode is the default when printing directly to a printer.</td>
</tr>
<tr>
<td><code>QPrinter::PdfFormat</code></td>
<td><code>1</code></td>
<td><code>QPrinter</code> will generate its output as a searchable <code>PDF</code> file. This mode is the default when printing to a file.</td>
</tr>
<tr>
<td><code>QPrinter::PostScriptFormat</code></td>
<td><code>2</code></td>
<td><code>QPrinter</code> will generate its output as in the <code>PostScript</code> format.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QPrinter::PageOrder</code>: This enum type is used by <code>QPrinter</code> to tell the application program how to print.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::FirstPageFirst</code></td>
<td><code>0</code></td>
<td>the <code>lowest-numbered</code> page should be printed first.</td>
</tr>
<tr>
<td><code>QPrinter::LastPageFirst</code></td>
<td><code>1</code></td>
<td>the <code>highest-numbered</code> page should be printed first.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QPrinter::PaperSize</code>: This enum type specifies what paper size <code>QPrinter</code> should use. <code>QPrinter</code> does not check that the paper size is available; it just uses this information, together with <code>QPrinter::Orientation</code> and <code>QPrinter::setFullPage()</code>, to determine the printable area.</li>
</ul>
<p>&emsp;&emsp;The defined sizes (with <code>setFullPage(true)</code>) are:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::A0</code></td>
<td><code>5</code></td>
<td><code>841 x 1189</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::A1</code></td>
<td><code>6</code></td>
<td><code>594 x 841</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::A2</code></td>
<td><code>7</code></td>
<td><code>420 x 594</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::A3</code></td>
<td><code>8</code></td>
<td><code>297 x 420</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::A4</code></td>
<td><code>0</code></td>
<td><code>210 x 297</code> mm, <code>8.26 x 11.69</code> inches</td>
</tr>
<tr>
<td><code>QPrinter::A5</code></td>
<td><code>9</code></td>
<td><code>148 x 210</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::A6</code></td>
<td><code>10</code></td>
<td><code>105 x 148</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::A7</code></td>
<td><code>11</code></td>
<td><code>74 x 105</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::A8</code></td>
<td><code>12</code></td>
<td><code>52 x 74</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::A9</code></td>
<td><code>13</code></td>
<td><code>37 x 52</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B0</code></td>
<td><code>14</code></td>
<td><code>1000 x 1414</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B1</code></td>
<td><code>15</code></td>
<td><code>707 x 1000</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B2</code></td>
<td><code>17</code></td>
<td><code>500 x 707</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B3</code></td>
<td><code>18</code></td>
<td><code>353 x 500</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B4</code></td>
<td><code>19</code></td>
<td><code>250 x 353</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B5</code></td>
<td><code>1</code></td>
<td><code>176 x 250</code> mm, <code>6.93 x 9.84</code> inches</td>
</tr>
<tr>
<td><code>QPrinter::B6</code></td>
<td><code>20</code></td>
<td><code>125 x 176</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B7</code></td>
<td><code>21</code></td>
<td><code>88 x 125</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B8</code></td>
<td><code>22</code></td>
<td><code>62 x 88</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B9</code></td>
<td><code>23</code></td>
<td><code>33 x 62</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B10</code></td>
<td><code>16</code></td>
<td><code>31 x 44</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::C5E</code></td>
<td><code>24</code></td>
<td><code>163 x 229</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::Comm10E</code></td>
<td><code>25</code></td>
<td><code>105 x 241</code> mm, U.S. Common <code>10</code> Envelope</td>
</tr>
<tr>
<td><code>QPrinter::DLE</code></td>
<td><code>26</code></td>
<td><code>110 x 220</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::Executive</code></td>
<td><code>4</code></td>
<td><code>7.5 x 10</code> inches, <code>190.5 x 254</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::Folio</code></td>
<td><code>27</code></td>
<td><code>210 x 330</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::Ledger</code></td>
<td><code>28</code></td>
<td><code>431.8 x 279.4</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::Legal</code></td>
<td><code>3</code></td>
<td><code>8.5 x 14</code> inches, <code>215.9 x 355.6</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::Letter</code></td>
<td><code>2</code></td>
<td><code>8.5 x 11</code> inches, <code>215.9 x 279.4</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::Tabloid</code></td>
<td><code>29</code></td>
<td><code>279.4 x 431.8</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::Custom</code></td>
<td><code>30</code></td>
<td>Unknown, or a user defined size.</td>
</tr>
</tbody>
</table>
</div>
<p>With <code>setFullPage(false)</code> (the default), the metrics will be a bit smaller; how much depends on the printer in use.</p>
<ul>
<li>enum <code>QPrinter::PaperSource</code>: This enum type specifies what paper source <code>QPrinter</code> is to use. <code>QPrinter</code> does not check that the paper source is available; it just uses this information to try and set the paper source. Whether it will set the paper source depends on whether the printer has that particular source. <strong>Warning</strong>: This is currently only implemented for <code>Windows</code>.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::Auto</code></td>
<td><code>6</code></td>
</tr>
<tr>
<td><code>QPrinter::Cassette</code></td>
<td><code>11</code></td>
</tr>
<tr>
<td><code>QPrinter::Envelope</code></td>
<td><code>4</code></td>
</tr>
<tr>
<td><code>QPrinter::EnvelopeManual</code></td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>QPrinter::FormSource</code></td>
<td><code>12</code></td>
</tr>
<tr>
<td><code>QPrinter::LargeCapacity</code></td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>QPrinter::LargeFormat</code></td>
<td><code>9</code></td>
</tr>
<tr>
<td><code>QPrinter::Lower</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>QPrinter::MaxPageSource</code></td>
<td><code>13</code></td>
</tr>
<tr>
<td><code>QPrinter::Middle</code></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>QPrinter::Manual</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td><code>QPrinter::OnlyOne</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>QPrinter::Tractor</code></td>
<td><code>7</code></td>
</tr>
<tr>
<td><code>QPrinter::SmallFormat</code></td>
<td><code>8</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QPrinter::PrintRange</code>: Used to specify the print range selection option.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::AllPages</code></td>
<td><code>0</code></td>
<td>All pages should be printed.</td>
</tr>
<tr>
<td><code>QPrinter::Selection</code></td>
<td><code>1</code></td>
<td>Only the selection should be printed.</td>
</tr>
<tr>
<td><code>QPrinter::PageRange</code></td>
<td><code>2</code></td>
<td>The specified page range should be printed.</td>
</tr>
<tr>
<td><code>QPrinter::CurrentPage</code></td>
<td><code>3</code></td>
<td>Only the current page should be printed.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QPrinter::PrinterMode</code>: This enum describes the mode the printer should work in. It basically presets a certain resolution and working mode.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::ScreenResolution</code></td>
<td><code>0</code></td>
<td>Sets the resolution of the print device to the screen resolution. This has the big advantage that the results obtained when painting on the printer will match more or less exactly the visible output on the screen. It is the easiest to use, as font metrics on the screen and on the printer are the same. This is the default value. <code>ScreenResolution</code> will produce a lower quality output than <code>HighResolution</code> and should only be used for drafts.</td>
</tr>
<tr>
<td><code>QPrinter::PrinterResolution</code></td>
<td><code>1</code></td>
<td>This value is deprecated. Is is equivalent to <code>ScreenResolution</code> on <code>Unix</code> and <code>HighResolution</code> on <code>Windows</code> and <code>Mac</code>. Due do the difference between <code>ScreenResolution</code> and <code>HighResolution</code>, use of this value may lead to <code>non-portable</code> printer code.</td>
</tr>
<tr>
<td><code>QPrinter::HighResolution</code></td>
<td><code>2</code></td>
<td>On <code>Windows</code>, sets the printer resolution to that defined for the printer in use. For <code>PostScript</code> printing, sets the resolution of the <code>PostScript</code> driver to <code>1200</code> dpi.</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: When rendering text on a <code>QPrinter</code> device, it is important to realize that the size of text, when specified in points, is independent of the resolution specified for the device itself. Therefore, it may be useful to specify the font size in pixels when combining text with graphics to ensure that their relative sizes are what you expect.</p>
<ul>
<li>enum <code>QPrinter::PrinterState</code>:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::Idle</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>QPrinter::Active</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>QPrinter::Aborted</code></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>QPrinter::Error</code></td>
<td><code>3</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QPrinter::Unit</code>: This enum type is used to specify the measurement unit for page and paper sizes.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::Millimeter</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>QPrinter::Point</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>QPrinter::Inch</code></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>QPrinter::Pica</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td><code>QPrinter::Didot</code></td>
<td><code>4</code></td>
</tr>
<tr>
<td><code>QPrinter::Cicero</code></td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>QPrinter::DevicePixel</code></td>
<td><code>6</code></td>
</tr>
</tbody>
</table>
</div>
<p>Note the difference between <code>Point</code> and <code>DevicePixel</code>. The <code>Point</code> unit is defined to be <code>1/72th</code> of an inch, while the <code>DevicePixel</code> unit is resolution dependant and is based on the actual pixels, or dots, on the printer.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QPrinter::QPrinter(PrinterMode mode = ScreenResolution)</code>: Creates a new printer object with the given <code>mode</code>.</li>
<li><code>QPrinter::QPrinter(const QPrinterInfo &amp; printer, PrinterMode mode = ScreenResolution)</code>: Creates a new printer object with the given <code>printer</code> and <code>mode</code>.</li>
<li><code>QPrinter::~QPrinter()</code>: Destroys the printer object and frees any allocated resources. If the printer is destroyed while a print job is in progress this may or may not affect the print job.</li>
<li><code>bool QPrinter::abort()</code>: Aborts the current print run. Returns <code>true</code> if the print run was successfully aborted and <code>printerState()</code> will return <code>QPrinter::Aborted</code>; otherwise returns <code>false</code>. It is not always possible to abort a print job. For example, all the data has gone to the printer but the printer cannot or will not cancel the job when asked to.</li>
<li><code>bool QPrinter::collateCopies() const</code>: Returns <code>true</code> if collation is turned on when multiple copies is selected. Returns <code>false</code> if it is turned off when multiple copies is selected. When collating is turned off the printing of each individual page will be repeated the <code>numCopies()</code> amount before the next page is started. With collating turned on all pages are printed before the next copy of those pages is started.</li>
<li><code>ColorMode QPrinter::colorMode() const</code>: Returns the current color mode.</li>
<li>int <code>QPrinter::copyCount() const</code>: Returns the number of copies that will be printed. The default value is <code>1</code>.</li>
<li><code>QString QPrinter::creator() const</code>: Returns the name of the application that created the document.</li>
<li><code>QString QPrinter::docName() const</code>: Returns the document name.</li>
<li><code>bool QPrinter::doubleSidedPrinting() const</code>: Returns <code>true</code> if double side printing is enabled. Currently this option is only supported on <code>X11</code>.</li>
<li><code>DuplexMode QPrinter::duplex() const</code>: Returns the current duplex mode. Currently this option is only supported on <code>X11</code>.</li>
<li><code>bool QPrinter::fontEmbeddingEnabled() const</code>: Returns <code>true</code> if font embedding is enabled. Currently this option is only supported on <code>X11</code>.</li>
<li><code>int QPrinter::fromPage() const</code>: Returns the number of the first page in a range of pages to be printed (the <code>from page</code> setting). Pages in a document are numbered according to the convention that the first page is page <code>1</code>. By default, this function returns a special value of <code>0</code>, meaning that the <code>from page</code> setting is unset. <strong>Note</strong>: If <code>fromPage()</code> and <code>toPage()</code> both return <code>0</code>, this indicates that the whole document will be printed.</li>
<li><code>bool QPrinter::fullPage() const</code>: Returns <code>true</code> if the origin of the printer’s coordinate system is at the corner of the page and <code>false</code> if it is at the edge of the printable area.</li>
<li><code>void QPrinter::getPageMargins(qreal * left, qreal * top, qreal * right, qreal * bottom, Unit unit) const</code>: Returns the page margins for this printer in <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>. The <code>unit</code> of the returned margins are specified with the <code>unit</code> parameter.</li>
<li><code>bool QPrinter::isValid() const</code>: Returns <code>true</code> if the printer currently selected is a valid printer in the system, or a pure <code>PDF/PostScript</code> printer; otherwise returns <code>false</code>. To detect other failures check the output of <code>QPainter::begin()</code> or <code>QPrinter::newPage()</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">QPrinter printer;</span><br><span class="line">printer.setOutputFormat ( QPrinter::PdfFormat );</span><br><span class="line">printer.setOutputFileName ( <span class="string">"/foobar/nonwritable.pdf"</span> );</span><br><span class="line">QPainter painter;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ! painter.begin ( &amp;printer ) ) &#123; <span class="comment">/* failed to open file */</span></span><br><span class="line">    qWarning ( <span class="string">"failed to open file, is it writable?"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">painter.drawText ( <span class="number">10</span>, <span class="number">10</span>, <span class="string">"Test"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ! printer.newPage() ) &#123;</span><br><span class="line">    qWarning ( <span class="string">"failed in flushing page to disk, disk full?"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">painter.drawText ( <span class="number">10</span>, <span class="number">10</span>, <span class="string">"Test 2"</span> );</span><br><span class="line">painter.end();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>bool QPrinter::newPage()</code>: Tells the printer to eject the current page and to continue printing on a new page. Returns <code>true</code> if this was successful; otherwise returns <code>false</code>. Calling <code>newPage()</code> on an inactive <code>QPrinter</code> object will always fail.</li>
<li><code>Orientation QPrinter::orientation() const</code>: Returns the orientation setting. This is <code>driver-dependent</code>, but is usually <code>QPrinter::Portrait</code>.</li>
<li><code>QString QPrinter::outputFileName() const</code>: Returns the name of the output file. By default, this is an empty string (indicating that the printer shouldn’t print to file).</li>
<li><code>OutputFormat QPrinter::outputFormat() const</code>: Returns the output format for this printer.</li>
<li><code>PageOrder QPrinter::pageOrder() const</code>: Returns the current page order. The default page order is <code>FirstPageFirst</code>.</li>
<li><code>QRect QPrinter::pageRect() const</code>: Returns the page’s rectangle; this is usually smaller than the <code>paperRect()</code> since the page normally has margins between its borders and the paper. The unit of the returned rectangle is <code>DevicePixel</code>.</li>
<li><code>QRectF QPrinter::pageRect(Unit unit) const</code>: Returns the page’s rectangle in <code>unit</code>; this is usually smaller than the <code>paperRect()</code> since the page normally has margins between its borders and the paper.</li>
<li><code>QPaintEngine * QPrinter::paintEngine() const [virtual]</code>: Reimplemented from <code>QPaintDevice::paintEngine()</code>. Returns the paint engine used by the printer.</li>
<li><code>QRect QPrinter::paperRect() const</code>: Returns the paper’s rectangle; this is usually larger than the <code>pageRect()</code>. The unit of the returned rectangle is <code>DevicePixel</code>.</li>
<li><code>QRectF QPrinter::paperRect(Unit unit) const</code>: Returns the paper’s rectangle in <code>unit</code>; this is usually larger than the <code>pageRect()</code>.</li>
<li><code>PaperSize QPrinter::paperSize() const</code>: Returns the printer paper size. The default value is <code>driver-dependent</code>.</li>
<li><code>QSizeF QPrinter::paperSize(Unit unit) const</code>: Returns the paper size in <code>unit</code>.</li>
<li><code>PaperSource QPrinter::paperSource() const</code>: Returns the printer’s paper source. This is <code>Manual</code> or a printer tray or paper cassette.</li>
<li><code>QPrintEngine * QPrinter::printEngine() const</code>: Returns the print engine used by the printer.</li>
<li><code>QString QPrinter::printProgram() const</code>: Returns the name of the program that sends the print output to the printer. The default is to return an empty string; meaning that <code>QPrinter</code> will try to be smart in a <code>system-dependent</code> way. On <code>X11</code> only, you can set it to something different to use a specific print program. On the other platforms, this returns an empty string.</li>
<li><code>PrintRange QPrinter::printRange() const</code>: Returns the page range of the <code>QPrinter</code>. After the print setup dialog has been opened, this function returns the value selected by the user.</li>
<li><code>QString QPrinter::printerName() const</code>: Returns the printer name. This value is initially set to the name of the default printer.</li>
<li><code>QString QPrinter::printerSelectionOption() const</code>: Returns the printer options selection string. This is useful only if the print command has been explicitly set. The default value (an empty string) implies that the printer should be selected in a <code>system-dependent</code> manner. Any other value implies that the given value should be used. <strong>Warning</strong>: This function is not available on <code>Windows</code>.</li>
<li><code>PrinterState QPrinter::printerState() const</code>: Returns the current state of the printer. This may not always be accurate (for example if the printer doesn’t have the capability of reporting its state to the operating system).</li>
<li><code>int QPrinter::resolution() const</code>: Returns the current assumed resolution of the printer, as set by <code>setResolution()</code> or by the printer driver.</li>
<li><code>void QPrinter::setCollateCopies(bool collate)</code>: Sets the default value for collation checkbox when the print dialog appears. If <code>collate</code> is <code>true</code>, it will enable <code>setCollateCopiesEnabled()</code>. The default value is <code>false</code>. This value will be changed by what the user presses in the print dialog.</li>
<li><code>void QPrinter::setColorMode(ColorMode newColorMode)</code>: Sets the printer’s color mode to <code>newColorMode</code>, which can be either <code>Color</code> or <code>GrayScale</code>.</li>
<li><code>void QPrinter::setCopyCount(int count)</code>: Sets the number of copies to be printed to <code>count</code>. The printer driver reads this setting and prints the specified number of copies.</li>
<li><code>void QPrinter::setCreator(const QString &amp; creator)</code>: Sets the name of the application that created the document to <code>creator</code>. This function is only applicable to the <code>X11</code> version of <code>Qt</code>. If no <code>creator</code> name is specified, the <code>creator</code> will be set to <code>Qt</code> followed by some version number.</li>
<li><code>void QPrinter::setDocName(const QString &amp; name)</code>: Sets the document name to <code>name</code>. On <code>X11</code>, the document name is for example used as the default output filename in <code>QPrintDialog</code>. Note that the document name does not affect the file name if the printer is printing to a file. Use the <code>setOutputFile()</code> function for this.</li>
<li><code>void QPrinter::setDoubleSidedPrinting(bool doubleSided)</code>: Enables double sided printing if <code>doubleSided</code> is <code>true</code>; otherwise disables it. Currently this option is only supported on <code>X11</code>.</li>
<li><code>void QPrinter::setDuplex(DuplexMode duplex)</code>: Enables double sided printing based on the <code>duplex</code> mode. Currently this option is only supported on <code>X11</code>.</li>
<li><code>void QPrinter::setEngines(QPrintEngine * printEngine, QPaintEngine * paintEngine) [protected]</code>: This function is used by subclasses of <code>QPrinter</code> to specify custom print and paint engines (<code>printEngine</code> and <code>paintEngine</code>, respectively). <code>QPrinter</code> does not take ownership of the engines, so you need to manage these engine instances yourself. Note that changing the engines will reset the printer state and all its properties.</li>
<li><code>void QPrinter::setFontEmbeddingEnabled(bool enable)</code>: Enabled or disables font embedding depending on <code>enable</code>. Currently this option is only supported on <code>X11</code>.</li>
<li><code>void QPrinter::setFromTo(int from, int to)</code>: Sets the range of pages to be printed to cover the pages with numbers specified by <code>from</code> and <code>to</code>, where <code>from</code> corresponds to the first page in the range and <code>to</code> corresponds to the last. <strong>Note</strong>: Pages in a document are numbered according to the convention that the first page is page <code>1</code>. However, if <code>from</code> and <code>to</code> are both set to <code>0</code>, the whole document will be printed. This function is mostly used to set a default value that the user can override in the print dialog when you call <code>setup()</code>.</li>
<li><code>void QPrinter::setFullPage(bool fp)</code>: If <code>fp</code> is <code>true</code>, enables support for painting over the entire page; otherwise restricts painting to the printable area reported by the device. By default, full page printing is disabled. In this case, the origin of the <code>QPrinter&#39;s</code> coordinate system coincides with the <code>top-left</code> corner of the printable area. If full page printing is enabled, the origin of the <code>QPrinter&#39;s</code> coordinate system coincides with the <code>top-left</code> corner of the paper itself. In this case, the device metrics will report the exact same dimensions as indicated by <code>PaperSize</code>. It may not be possible to print on the entire physical page because of the printer’s margins, so the application must account for the margins itself.</li>
<li><code>void QPrinter::setOrientation(Orientation orientation)</code>: Sets the print orientation to <code>orientation</code>. The <code>orientation</code> can be either <code>QPrinter::Portrait</code> or <code>QPrinter::Landscape</code>. The printer driver reads this setting and prints using the specified orientation. On <code>Windows</code>, this option can be changed while printing and will take effect from the next call to <code>newPage()</code>. On <code>Mac OS X</code>, changing the orientation during a print job has no effect.</li>
<li><code>void QPrinter::setOutputFileName(const QString &amp; fileName)</code>: Sets the name of the output file to <code>fileName</code>. Setting a null or empty name (<code>0</code> or <code>&quot;&quot;</code>) disables printing to a file. Setting a <code>non-empty</code> name enables printing to a file. This can change the value of <code>outputFormat()</code>. If the file name has the suffix <code>.ps</code> then <code>PostScript</code> is automatically selected as output format. If the file name has the <code>.pdf</code> suffix <code>PDF</code> is generated. If the file name has a suffix other than <code>.ps</code> and <code>.pdf</code>, the output format used is the one set with <code>setOutputFormat()</code>. <code>QPrinter</code> uses <code>Qt&#39;s</code> <code>cross-platform</code> <code>PostScript</code> or <code>PDF</code> print engines respectively. If you can produce this format natively, for example <code>Mac OS X</code> can generate <code>PDF&#39;s</code> from its print engine, set the output format back to <code>NativeFormat</code>.</li>
<li><code>void QPrinter::setOutputFormat(OutputFormat format)</code>: Sets the output format for this printer to <code>format</code>.</li>
<li><code>void QPrinter::setPageMargins(qreal left, qreal top, qreal right, qreal bottom, Unit unit)</code>: This function sets the <code>left</code>, <code>top</code>, <code>right</code> and <code>bottom</code> page margins for this printer. The unit of the margins are specified with the <code>unit</code> parameter.</li>
<li><code>void QPrinter::setPageOrder(PageOrder pageOrder)</code>: Sets the page order to <code>pageOrder</code>. The page order can be <code>QPrinter::FirstPageFirst</code> or <code>QPrinter::LastPageFirst</code>. The application is responsible for reading the page order and printing accordingly. This function is mostly useful for setting a default value that the user can override in the print dialog. This function is only supported under <code>X11</code>.</li>
<li><code>void QPrinter::setPaperSize(PaperSize newPaperSize)</code>: Sets the printer paper size to <code>newPaperSize</code> if that size is supported. The result is undefined if <code>newPaperSize</code> is not supported. The default paper size is <code>driver-dependent</code>. This function is useful mostly for setting a default value that the user can override in the print dialog.</li>
<li><code>void QPrinter::setPaperSize(const QSizeF &amp; paperSize, Unit unit)</code>: Sets the paper size based on <code>paperSize</code> in <code>unit</code>.</li>
<li><code>void QPrinter::setPaperSource(PaperSource source)</code>: Sets the paper source setting to <code>source</code>. <code>Windows</code> only: This option can be changed while printing and will take effect from the next call to <code>newPage()</code>.</li>
<li><code>void QPrinter::setPrintProgram(const QString &amp; printProg)</code>: Sets the name of the program that should do the print job to <code>printProg</code>. On <code>X11</code>, this function sets the program to call with the <code>PostScript</code> output. On other platforms, it has no effect.</li>
<li><code>void QPrinter::setPrintRange(PrintRange range)</code>: Sets the print range option in to be <code>range</code>.</li>
<li><code>void QPrinter::setPrinterName(const QString &amp; name)</code>: Sets the printer name to <code>name</code>.</li>
<li><code>void QPrinter::setPrinterSelectionOption(const QString &amp; option)</code>: Sets the printer to use <code>option</code> to select the printer. <code>option</code> is null by default (which implies that <code>Qt</code> should be smart enough to guess correctly), but it can be set to other values to use a specific printer selection option. If the printer selection option is changed while the printer is active, the current print job may or may not be affected. Warning: This function is not available on <code>Windows</code>.</li>
<li><code>void QPrinter::setResolution(int dpi)</code>: Requests that the printer prints at <code>dpi</code> or as near to <code>dpi</code> as possible. This setting affects the coordinate system as returned by, for example <code>QPainter::viewport()</code>. This function must be called before <code>QPainter::begin()</code> to have an effect on all platforms.</li>
<li><code>void QPrinter::setWinPageSize(int pageSize)</code>: Sets the page size to be used by the printer under Windows to <code>pageSize</code>. <strong>Warning</strong>: This function is not portable so you may prefer to use <code>setPaperSize()</code> instead.</li>
<li><code>QList&lt;PaperSource&gt; QPrinter::supportedPaperSources() const</code>: Returns the supported paper sizes for this printer. The values will be either a value that matches an entry in the <code>QPrinter::PaperSource</code> enum or a driver spesific value. The driver spesific values are greater than the constant <code>DMBIN_USER</code> declared in <code>wingdi.h</code>. <strong>Warning</strong>: This function is only available in <code>Windows</code>.</li>
<li><code>QList&lt;int&gt; QPrinter::supportedResolutions() const</code>: Returns a list of the resolutions (a list of <code>dots-per-inch</code> integers) that the printer says it supports. For <code>X11</code> where all printing is directly to postscript, this function will always return a one item list containing only the postscript resolution.</li>
<li><code>bool QPrinter::supportsMultipleCopies() const</code>: Returns <code>true</code> if the printer supports printing multiple copies of the same document in one job; otherwise <code>false</code> is returned. On most systems this function will return <code>true</code>. However, on <code>X11</code> systems that do not support <code>CUPS</code>, this function will return <code>false</code>. That means the application has to handle the number of copies by printing the same document the required number of times.</li>
<li><code>int QPrinter::toPage() const</code>: Returns the number of the last page in a range of pages to be printed (the <code>to page</code> setting). Pages in a document are numbered according to the convention that the first page is page <code>1</code>. By default, this function returns a special value of <code>0</code>, meaning that the <code>to page</code> setting is unset. <strong>Note</strong>: If <code>fromPage()</code> and <code>toPage()</code> both return <code>0</code>, this indicates that the whole document will be printed. The programmer is responsible for reading this setting and printing accordingly.</li>
<li><code>int QPrinter::winPageSize() const</code>: Returns the page size used by the printer under <code>Windows</code>. <strong>Warning</strong>: This function is not portable so you may prefer to use <code>paperSize()</code> instead.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/18/Qt语法详解/Qt之QErrorMessage/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/Qt语法详解/Qt之QErrorMessage/" itemprop="url">Qt之QErrorMessage</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T11:03:47+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>QErrorMessage</code>类提供了错误消息显示对话框，其头文件为<code>qerrormessage.h</code>，它继承了<code>QDialog</code>。所有成员函数的列表如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 公有成员 */</span></span><br><span class="line">QErrorMessage ( QWidget *parent, <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="number">0</span> );</span><br><span class="line">~QErrorMessage ();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">message</span> <span class="params">( <span class="keyword">const</span> QString &amp;m )</span></span>; <span class="comment">/* 公有槽 */</span></span><br><span class="line"><span class="function">QErrorMessage * <span class="title">qtHandler</span> <span class="params">()</span></span>; <span class="comment">/* 静态公有成员 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;成员函数详解如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造并安装一个错误处理器窗口。父对象parent和名称name都被传递给QDialog的构造函数 */</span></span><br><span class="line">QErrorMessage::QErrorMessage ( QWidget *parent, <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="number">0</span> );</span><br><span class="line"><span class="comment">/* 销毁这个对象并且释放任何已经分配的资源。特别地，“do not show again”消息列表也被删除 */</span></span><br><span class="line">QErrorMessage::~QErrorMessage ();</span><br><span class="line"><span class="comment">/* 显示消息m并且立即返回。如果用户要求m不被显示，这个函数将什么都不做。</span></span><br><span class="line"><span class="comment">   通常m会被立即显示，但是如果存在未处理的消息，m将被排到队列中，稍后会显示 */</span></span><br><span class="line"><span class="keyword">void</span> QErrorMessage::message ( <span class="keyword">const</span> QString &amp;m ); [槽]</span><br><span class="line"><span class="comment">/* 返回输出默认Qt消息的QErrorMessage对象的指针。如果没有这样的对象存在，这个函数创建一个这样的对象 */</span></span><br><span class="line">QErrorMessage * QErrorMessage::qtHandler (); [静态]</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/18/Qt语法详解/Qt之QErrorMessage/1.png"></p>
<p>&emsp;&emsp;使用示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QErrorMessage *dialog = <span class="keyword">new</span> QErrorMessage ( <span class="keyword">this</span> );</span><br><span class="line">dialog-&gt;setWindowTitle ( tr ( <span class="string">"错误信息对话框"</span> ) );</span><br><span class="line">dialog-&gt;showMessage ( tr ( <span class="string">"这里是出错信息！"</span> ) );</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/18/Qt语法详解/Qt之QCheckBox/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/Qt语法详解/Qt之QCheckBox/" itemprop="url">Qt之QCheckBox</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T10:45:00+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>&emsp;&emsp;<code>QCheckBox</code>继承自<code>QAbstractButton</code>，它提供了一个带文本标签的复选框。<code>QCheckBox</code>(复选框)和<code>QRadioButton</code>(单选框)都是选项按钮，这是因为它们都可以在开(选中)或者关(未选中)之间切换。区别是对用户选择的限制：单选框定义了<code>多选一</code>的选择，而复选框提供的是<code>多选多</code>的选择。尽管在技术上可以通过复选框来实现单选框的行为，反之亦然，但还是强烈建议使用众所周知的约定。</p>
<h3 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h3><p>&emsp;&emsp;<code>QButtonGroup</code>可以用来在视觉上把许多复选框组织在一起。只要复选框被选中或者清除，都会发射一个<code>stateChanged</code>信号。如果想在复选框状态改变的时候触发一个行为，请连接这个信号，可以使用<code>isChecked</code>来查询复选框是否被选中。除了常用的选中和未选中两个状态，<code>QCheckBox</code>还可选地提供了第三种状态(半选)来表明<code>没有变化</code>。当需要给用户一个选中或者未选中复选框的选择时，这是很有用的。如果需要第三种状态，可以通过<code>setTristate</code>来使它生效，并使用<code>checkState</code>来查询当前的切换状态。<br>&emsp;&emsp;和<code>QPushButton</code>一样，复选框可以显示文本或者图标。文本可以通过构造函数或者<code>setText</code>来设置，图标可以通过<code>setIcon</code>来设置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QCheckBox *checkbox = <span class="keyword">new</span> QCheckBox ( <span class="string">"C&amp;ase sensitive"</span>, <span class="keyword">this</span> );</span><br></pre></td></tr></table></figure>
<p>这个例子中，快捷键为<code>Alt + a</code>。要显示一个实际的符号<code>&amp;</code>，使用<code>&amp;&amp;</code>。</p>
<h3 id="公有函数"><a href="#公有函数" class="headerlink" title="公有函数"></a>公有函数</h3><p>&emsp;&emsp;公有函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回复选框的选中状态。如果不需要三态的支持，可以使用QAbstractButton::isChecked，它返回一个布尔值 */</span></span><br><span class="line">Qt::<span class="function">CheckState <span class="title">checkState</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">/* 复选框是否为一个三态复选框。默认的是false，也就是说复选框只有两个状态 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTristate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">/* 设置复选框的选中状态。如果不需要三态的支持，可以使用QAbstractButton:setChecked，它接受一个布尔值 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCheckState</span><span class="params">(Qt::CheckState state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTristate</span><span class="params">(<span class="keyword">bool</span> y = <span class="literal">true</span>)</span> <span class="comment">/* 设置复选框为一个三态复选框 */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>&emsp;&emsp;信号如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当复选框状态发生改变，这个信号就会被发射，即用户选中或者取消选中 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">int</span> state)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="三态复选框"><a href="#三态复选框" class="headerlink" title="三态复选框"></a>三态复选框</h3><p>&emsp;&emsp;下面实现一个三态复选框，并监听状态变化：</p>
<p><img src="/2019/02/18/Qt语法详解/Qt之QCheckBox/1.png" height="103" width="178"></p>
<p>&emsp;&emsp;构造一个复选框<code>QCheckBox</code>，然后使用<code>setTristate</code>开启三态模式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QCheckBox *pCheckBox = <span class="keyword">new</span> QCheckBox ( <span class="keyword">this</span> );</span><br><span class="line">m_pLabel = <span class="keyword">new</span> QLabel ( <span class="keyword">this</span> );</span><br><span class="line">m_pLabel-&gt;setText ( <span class="string">"Click CheckBox..."</span> );</span><br><span class="line">pCheckBox-&gt;setText ( QString::fromLocal8Bit ( <span class="string">"三态复选框"</span> ) );</span><br><span class="line">pCheckBox-&gt;setTristate(); <span class="comment">/* 开启三态模式 */</span></span><br><span class="line"><span class="comment">/* 连接信号槽 */</span></span><br><span class="line">connect ( pCheckBox, SIGNAL ( stateChanged ( <span class="keyword">int</span> ) ), <span class="keyword">this</span>, SLOT ( onStateChanged ( <span class="keyword">int</span> ) ) );</span><br></pre></td></tr></table></figure>
<p>槽函数是用来判断当前复选框状态，其中包括选中(<code>Qt::Checked</code>)、半选(<code>Qt::PartiallyChecked</code>)、未选中(<code>Qt::Unchecked</code>)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::onStateChanged ( <span class="keyword">int</span> state ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( state == Qt::Checked ) &#123; <span class="comment">/* 选中 */</span></span><br><span class="line">        m_pLabel-&gt;setText ( <span class="string">"Checked"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Qt::PartiallyChecked ) &#123; <span class="comment">/* 半选 */</span></span><br><span class="line">        m_pLabel-&gt;setText ( <span class="string">"PartiallyChecked"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* 未选中，即Qt::Unchecked */</span></span><br><span class="line">        m_pLabel-&gt;setText ( <span class="string">"Unchecked"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接<code>stateChanged</code>信号和槽函数，当用户点击复选框时，状态发生改变就会调用槽函数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/18/Linux驱动程序/蜂鸣器驱动_字符设备/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/Linux驱动程序/蜂鸣器驱动_字符设备/" itemprop="url">蜂鸣器驱动_字符设备</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T10:29:25+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;电路图如下：</p>
<p><img src="/2019/02/18/Linux驱动程序/蜂鸣器驱动_字符设备/1.jpg" height="162" width="251"></p>
<p>&emsp;&emsp;<code>Linux-2.6.32.2</code>内核重要头文件目录如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">linux<span class="number">-2.6</span><span class="number">.32</span><span class="number">.2</span>/arch/arm/mach-s3c2410/include/mach/regs-gpio.h</span><br><span class="line">linux<span class="number">-2.6</span><span class="number">.32</span><span class="number">.2</span>/arch/arm/mach-s3c2410/include/mach/gpio-nrs.h</span><br><span class="line">linux<span class="number">-2.6</span><span class="number">.32</span><span class="number">.2</span>/arch/arm/plat-s3c24xx/gpio.c</span><br><span class="line">linux<span class="number">-2.6</span><span class="number">.32</span><span class="number">.2</span>/include/linux/<span class="keyword">asm</span>-generic/io.h</span><br><span class="line">linux<span class="number">-2.6</span><span class="number">.32</span><span class="number">.2</span>/include/linux/wait.h</span><br></pre></td></tr></table></figure>
<p>注意链接关系，例如出现<code>asm</code>，则链接之后的内容为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>  -&gt; linux<span class="number">-2.6</span><span class="number">.32</span><span class="number">.2</span>/include/linux/<span class="keyword">asm</span>-generic</span><br><span class="line">mach -&gt; linux<span class="number">-2.6</span><span class="number">.32</span><span class="number">.2</span>/arch/arm/mach-s3c2410/include/mach</span><br><span class="line">plat -&gt; linux<span class="number">-2.6</span><span class="number">.32</span><span class="number">.2</span>/arch/arm/plat-s3c24xx/include/plat</span><br><span class="line">        linux<span class="number">-2.6</span><span class="number">.32</span><span class="number">.2</span>/arch/arm/plat-s3c/include/plat</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>beep_drv.c</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/serio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/clk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt; /* 平台相关的文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/irq.h&gt; /* 出现asm，它会连接到“linux-2.6.32.2/include/linux/asm-generic” */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/regs-clock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;plat/regs-timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 该文件在“linux-2.6.32.2/arch/arm/mach-s3c2410/include/mach/regs-gpio.h”中 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/regs-gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> beep_major = <span class="number">0</span>; <span class="comment">/* 全局主设备号 */</span></span><br><span class="line">module_param ( beep_major, <span class="keyword">int</span>, <span class="number">0</span> );</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEEP_MAGIC <span class="meta-string">'k'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEEP_START_CMD _IO (BEEP_MAGIC, 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEEP_STOP_CMD  _IO (BEEP_MAGIC, 2) <span class="comment">/* “_IO(type，nr)”用于构造无参数的命令编号 */</span></span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/* Open the device; in fact, there's nothing to do here */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">beep_open</span> <span class="params">( struct inode *inode, struct file *filp )</span> </span>&#123; <span class="comment">/* 没有用到，但必须保持完整性 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">ssize_t</span> beep_read ( struct file *file, <span class="keyword">char</span> __user *buff, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *offp ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">ssize_t</span> beep_write ( struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buff, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *offp ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beep_stop</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    s3c2410_gpio_cfgpin ( S3C2410_GPB ( <span class="number">0</span> ), S3C2410_GPIO_OUTPUT );</span><br><span class="line">    s3c2410_gpio_setpin ( S3C2410_GPB ( <span class="number">0</span> ), <span class="number">0</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beep_start</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    s3c2410_gpio_pullup ( S3C2410_GPB ( <span class="number">0</span> ), <span class="number">1</span> ); <span class="comment">/* 上拉电阻 */</span></span><br><span class="line">    s3c2410_gpio_cfgpin ( S3C2410_GPB ( <span class="number">0</span> ), S3C2410_GPIO_OUTPUT ); <span class="comment">/* 配置 */</span></span><br><span class="line">    s3c2410_gpio_setpin ( S3C2410_GPB ( <span class="number">0</span> ), <span class="number">1</span> ); <span class="comment">/* 置位 */</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">beep_ioctl</span> <span class="params">( struct inode *inode, struct file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> ( cmd ) &#123;</span><br><span class="line">        <span class="keyword">case</span> BEEP_START_CMD: &#123;</span><br><span class="line">            beep_start();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> BEEP_STOP_CMD: &#123;</span><br><span class="line">            beep_stop();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">beep_release</span> <span class="params">( struct inode *node, struct file *file )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* Set up the cdev structure for a device */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beep_setup_cdev</span> <span class="params">( struct cdev *dev, <span class="keyword">int</span> minor, struct file_operations *fops )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err, devno = MKDEV ( beep_major, minor ); <span class="comment">/* 由主次设备号生成设备号 */</span></span><br><span class="line">    cdev_init ( dev, fops ); <span class="comment">/* 初始化cdev */</span></span><br><span class="line">    dev-&gt;owner = THIS_MODULE;</span><br><span class="line">    dev-&gt;ops = fops;</span><br><span class="line">    err = cdev_add ( dev, devno, <span class="number">1</span> ); <span class="comment">/* 注册设备 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( err ) &#123; <span class="comment">/* Fail gracefully if need be */</span></span><br><span class="line">        printk ( KERN_NOTICE <span class="string">"Error %d adding beep%d"</span>, err, minor );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* Our various sub-devices */</span></span><br><span class="line"><span class="comment">/* Device 0 uses remap_pfn_range */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">beep_remap_ops</span> = &#123;</span> <span class="comment">/* file_operations的对象beep_remap_ops，并对其赋值 */</span></span><br><span class="line">    .owner   = THIS_MODULE, <span class="comment">/* 指向模块本身 */</span></span><br><span class="line">    .open    = beep_open, <span class="comment">/* 把open和beep_open函数关联起来 */</span></span><br><span class="line">    .release = beep_release,</span><br><span class="line">    .read    = beep_read,</span><br><span class="line">    .write   = beep_write,</span><br><span class="line">    .ioctl   = beep_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* There's no need for us to maintain any special housekeeping info, so we just deal with raw cdevs */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">BeepDevs</span>;</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/* Module housekeeping */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">beep_init</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123; <span class="comment">/* 模块加载时调用beep_init函数进行加载 */</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">dev_t</span> dev = MKDEV ( beep_major, <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">char</span> dev_name[] = <span class="string">"beep"</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* Figure out our device number */</span></span><br><span class="line">    <span class="keyword">if</span> ( beep_major ) &#123; <span class="comment">/* 设备号的分配 */</span></span><br><span class="line">        result = register_chrdev_region ( dev, <span class="number">1</span>, dev_name ); <span class="comment">/* 手工分配 */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 系统分配一个设备号，“0”表示第一个次设备号，“1”表示一个设备 */</span></span><br><span class="line">        result = alloc_chrdev_region ( &amp;dev, <span class="number">0</span>, <span class="number">1</span>, dev_name );</span><br><span class="line">        beep_major = MAJOR ( dev ); <span class="comment">/* 取得主设备号 */</span></span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( result &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        printk ( KERN_WARNING <span class="string">"beep: unable to get major %d\n"</span>, beep_major );</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( beep_major == <span class="number">0</span> ) &#123;</span><br><span class="line">        beep_major = result;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* Now set up cdev */</span></span><br><span class="line">    beep_setup_cdev ( &amp;BeepDevs, <span class="number">0</span>, &amp;beep_remap_ops );</span><br><span class="line">    printk ( <span class="string">"beep device installed, with major %d\n"</span>, beep_major );</span><br><span class="line">    printk ( <span class="string">"The device name is: %s\n"</span>, dev_name );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beep_cleanup</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123; <span class="comment">/* 模块卸载时调用beep_cleanup函数进行清除 */</span></span><br><span class="line">    cdev_del ( &amp;BeepDevs ); <span class="comment">/* 注销设备 */</span></span><br><span class="line">    unregister_chrdev_region ( MKDEV ( beep_major, <span class="number">0</span> ), <span class="number">1</span> ); <span class="comment">/* 释放占用的设备号 */</span></span><br><span class="line">    printk ( <span class="string">"beep device uninstalled\n"</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">module_init ( beep_init ); <span class="comment">/* 模块加载时调用beep_init函数进行加载 */</span></span><br><span class="line">module_exit ( beep_cleanup ); <span class="comment">/* 模块卸载时调用beep_cleanup函数进行清除 */</span></span><br><span class="line">EXPORT_SYMBOL ( beep_major );</span><br><span class="line">MODULE_LICENSE ( <span class="string">"Dual BSD/GPL"</span> );</span><br></pre></td></tr></table></figure>
<p>相应的<code>Makefile</code>文件如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CROSS_COMPILE := arm-linux-</span><br><span class="line">CC :=<span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">KERNEL_DIR := /home/linux-2.6.32.2</span><br><span class="line"></span><br><span class="line">obj-m := beep_drv.o</span><br><span class="line"></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -fr *.o *.ko *.mod.o *.mod.c .*.cmd *.order *.*s *~ .tmp*</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;创建设备节点的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod /dev/node_name c major minor  <span class="comment"># 这里的node_name为beep</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;测试程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEEP_MAGIC <span class="meta-string">'k'</span> <span class="comment">/* 宏是和驱动里一样的 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEEP_START_CMD _IO (BEEP_MAGIC, 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEEP_STOP_CMD  _IO (BEEP_MAGIC, 2)</span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dev_fd;</span><br><span class="line">    <span class="comment">/* 打开设备文件可读可写、非阻塞 */</span></span><br><span class="line">    dev_fd = open ( <span class="string">"/dev/beep"</span>, O_RDWR | O_NONBLOCK );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( dev_fd == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Cann't open file /dev/beep\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Start beep\n"</span> );</span><br><span class="line">    ioctl ( dev_fd, BEEP_START_CMD, <span class="number">0</span> );</span><br><span class="line">    getchar();</span><br><span class="line">    ioctl ( dev_fd, BEEP_STOP_CMD, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Stop beep and Close device\n"</span> );</span><br><span class="line">    close ( dev_fd ); <span class="comment">/* 关闭设备文件 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写其<code>Makefile</code>文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KERNELKDIR ?= /opt/linux-2.6.32.2/<span class="keyword">include</span></span><br><span class="line">​</span><br><span class="line"><span class="section">all: test</span></span><br><span class="line"><span class="section">test: test.c</span></span><br><span class="line">    arm-linux-gcc -I <span class="variable">$(KERNELDIR)</span> -o S@ S^  <span class="comment"># “-I $(KERNELDIR)”表示包含头文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf test</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/18/Linux驱动程序/蜂鸣器驱动_字符设备/2.jpg" height="255" width="304"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/17/深度学习/迁移学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/17/深度学习/迁移学习/" itemprop="url">迁移学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T15:37:49+08:00">
                2019-02-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><p>&emsp;&emsp;一个人的成功往往取决于先辈们累积的知识，如果把这句话放在机器学习中，这就是迁移学习(<code>transfer learning</code>)。</p>
<p><img src="/2019/02/17/深度学习/迁移学习/1.jpg" height="208" width="285"></p>
<h3 id="怎么迁移"><a href="#怎么迁移" class="headerlink" title="怎么迁移"></a>怎么迁移</h3><p>&emsp;&emsp;迁移学习这就好比<code>KFC</code>和麦当劳的关系，同一类型的事业不用自己完全从头做，借鉴对方的经验往往能节省很多时间。有这样的思路，我们也能偷偷懒，不用花时间重新训练一个无比庞大的神经网络，借鉴借鉴一个已经训练好的神经网络就行。<br>&emsp;&emsp;比如这样的一个神经网络，我花了两天训练完之后，它已经能正确区分图片中具体描述的是男人、女人还是眼镜，说明这个神经网络已经具备对图片信息一定的理解能力，这些理解能力就以参数的形式存放在每一个神经节点中。</p>
<p><img src="/2019/02/17/深度学习/迁移学习/2.jpg" height="180" width="387"></p>
<p>&emsp;&emsp;不巧的是，领导下达了一个紧急任务，要求今天之内训练出来一个预测图片里实物价值的模型。我想这下可完蛋了，上一个图片模型都要花两天，如果要再搭个模型重新训练，今天肯定出不来呀，于是迁移学习来拯救我了。因为这个训练好的模型中已经有了一些对图片的理解能力，而模型最后输出层的作用是分类之前的图片，对于现在计算价值的任务是用不到的。所以将最后一层替换掉，变为服务于现在这个任务的输出层。接着只训练新加的输出层，让理解力保持始终不变，前面的神经层庞大的参数不用再训练，节省了很多时间。</p>
<p><img src="/2019/02/17/深度学习/迁移学习/3.jpg" height="256" width="550"></p>
<p>&emsp;&emsp;但并不是所有的情况都需要用到迁移学习，比如训练小的神经网络并不需要特别多的时间，我们完全可以直接重头开始训练，从头开始训练也是有好处的。如果固定住之前的理解力，或者使用更小的学习率来更新借鉴来的模型，就变得有点像认识一个人时的第一印象。如果迁移前的数据和迁移后的数据差距很大，或者说我对于这个人的第一印象和后续印象差距很大，我还不如不要管我的第一印象。同理，这时迁移来的模型并不会起多大作用，还可能干扰我后续的决策。</p>
<hr>
<p>&emsp;&emsp;深度学习是人工智能领域近年来最火热的话题之一，但是对于个人来说，以往想要玩转深度学习除了要具备高超的编程技巧，还需要有海量的数据和强劲的硬件。不过<code>TensorFlow</code>和<code>Keras</code>等框架的出现大大降低了编程的复杂度，而迁移学习的思想也允许我们利用现有的模型加上少量数据和训练时间，取得不俗的效果。<br>&emsp;&emsp;这篇文章将示范如何利用迁移学习训练一个能从图片中分类不同种类的花的模型，它在五种花中能达到<code>80%</code>以上的准确度，而且只需要普通的家用电脑就可以完成训练过程。</p>
<p><img src="/2019/02/17/深度学习/迁移学习/4.jpg" height="158" width="611"></p>
<h3 id="什么是迁移学习"><a href="#什么是迁移学习" class="headerlink" title="什么是迁移学习"></a>什么是迁移学习</h3><p>&emsp;&emsp;人类的思维可以将一个领域学习到的知识和经验，应用到其他相似的领域中去。所以当面临新的情景时，如果该情景与之前的经验越相似，那么人就能越快掌握该领域的知识。而传统的机器学习方法则会把不同的任务看成是完全独立的，比如一个识别猫的模型，如果训练集中的图片都是白天的，那么训练出来的模型对于识别夜晚的猫这个任务就可能表现得非常差。迁移学习便是受此启发，试图将模型从源任务上训练到的知识迁移到目标任务的应用上。<br>&emsp;&emsp;举例来说，源任务可以是识别图片中车辆，而目标任务可以是识别卡车、轿车、公交车等。合理的使用迁移学习可以避免针对每个目标任务单独训练模型，从而极大的节约了计算资源。<br>&emsp;&emsp;此外，迁移学习并不是一种特定的机器学习模型，它更像是一种优化技巧。通常来说，机器学习任务要求测试集和训练集有相同的概率分布，然而在一些情况下往往会缺乏足够大的有针对性的数据集来满足一个特定的训练任务。迁移学习提出我们可以在一个通用的大数据集上进行一定量的训练后，再用针对性的小数据集进一步强化训练。<br>&emsp;&emsp;接下来的例子中将示范如何将一个图像识别的深度卷积网络(<code>VGG</code>)，迁移到识别花朵类型的新任务上。在原先的任务中，<code>VGG</code>只能识别花，但是迁移学习可以让模型不但能识别花，还能识别花的具体品种。</p>
<h3 id="VGG介绍"><a href="#VGG介绍" class="headerlink" title="VGG介绍"></a>VGG介绍</h3><p>&emsp;&emsp;<code>VGG</code>是视觉领域竞赛<code>ILSVRC</code>在<code>2014</code>年的获胜模型，以<code>7.3%</code>的错误率在<code>ImageNet</code>数据集上大幅刷新了前一年<code>11.7%</code>的世界纪录。<code>VGG16</code>基本上继承了<code>AlexNet</code>的思想，并且发扬光大，做到了更深。<code>AlexNet</code>只用到了<code>8</code>层网络，而<code>VGG</code>的两个版本分别是<code>16</code>层网络版和<code>19</code>层网络版。在接下来的迁移学习实践中，我们会采用稍微简单的一些的<code>VGG16</code>，它和<code>VGG19</code>有几乎完全一样的准确度，但是运算起来更快一些。<br>&emsp;&emsp;<code>VGG</code>的结构图如下：</p>
<p><img src="/2019/02/17/深度学习/迁移学习/5.jpg" height="131" width="608"></p>
<p><code>VGG</code>的输入数据格式是<code>244 * 224 * 3</code>的像素数据，经过一系列的卷积神经网络和池化网络处理之后，输出的是一个<code>4096</code>维的特征数据，然后再通过<code>3</code>层全连接的神经网络处理，最终由<code>softmax</code>规范化得到分类结果。<br>&emsp;&emsp;<code>VGG16</code>模型是一个<code>npy</code>文件，本质上是一个巨大的<code>numpy</code>对象，包含了<code>VGG16</code>模型中的所有参数。该文件大约有<code>500M</code>，所以可见如果是从头训练这样一个模型是非常耗时的，借助于迁移学习的思想，我们可以直接在这个模型的基础上进行训练。</p>
<h3 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h3><p>&emsp;&emsp;卷积神经网络在图像数据中使用得尤其多，不同于一般的全连接的神经网络需要对上下两层网络中的任意两个节点之间训练权值，每层卷积网络仅仅训练若干个卷积核，下一层的网络的输入即是前一个层的输出的卷积，因此多层卷积神经网络会把一个薄薄的图片数据，转化为更小但是也更厚的数组，如下图所示：</p>
<p><img src="/2019/02/17/深度学习/迁移学习/6.jpg" height="183" width="540"></p>
<p>&emsp;&emsp;卷积神经网络具有良好的统计不变性，而且每个层可以学习到不同层次的知识。比如第一层会学习到识别图片中的简单形状，例如直线和纯色块等。而之后的层将会上升到更高的抽象层次，比如例如形状，物体的组成部分，直到能够识别整个物体。<br>&emsp;&emsp;如果我们将卷积神经网络中激活神经元的图像可视化出来，那么会得到如下的结果。首先第一层能识别出一些对角线和颜色的分界：</p>
<p><img src="/2019/02/17/深度学习/迁移学习/7.jpg" height="334" width="243"></p>
<p>然后第二层网络可以学习到了一些稍微复杂的概念，比如圈和条纹：</p>
<p><img src="/2019/02/17/深度学习/迁移学习/8.jpg" height="255" width="519"></p>
<p>第三层学习到了一些简单的物体，比如轮胎和脸：</p>
<p><img src="/2019/02/17/深度学习/迁移学习/9.jpg" height="266" width="707"></p>
<p>到了更高的层数，卷积神经网络能够识别出越来越复杂的物体，这个过程也非常符合人类识别物体的过程，即从简单模式越来越复杂的模式：</p>
<p><img src="/2019/02/17/深度学习/迁移学习/10.jpg" height="262" width="426"></p>
<h3 id="识花数据集"><a href="#识花数据集" class="headerlink" title="识花数据集"></a>识花数据集</h3><p>&emsp;&emsp;<code>flower_photos</code>数据集有包含如下数据：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>花的种类</th>
<th>图片数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>daisy</td>
<td>633</td>
</tr>
<tr>
<td>dandelion</td>
<td>898</td>
</tr>
<tr>
<td>roses</td>
<td>641</td>
</tr>
<tr>
<td>sunflowers</td>
<td>699</td>
</tr>
<tr>
<td>tulips</td>
<td>799</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;首先我们会将所有的图片交给<code>VGG16</code>，利用<code>VGG16</code>的深度网络结构中的五轮卷积网络层和池化层，对每张图片得到一个4096维的特征向量，然后我们直接用这个特征向量替代原来的图片，再加若干层全连接的神经网络，对花朵数据集进行训练。<br>&emsp;&emsp;因此本质上，我们是将<code>VGG16</code>作为一个图片特征提取器，然后在此基础上再进行一次普通的神经网络学习，这样就将原先的<code>244 * 224 * 3</code>维度的数据转化为了<code>4096</code>维的，而每一维度的信息量大大提高，从而大大降低了计算资源的消耗，实现了把学习物体识别中得到的知识应用到特殊的花朵分类问题上。</p>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>&emsp;&emsp;为了更加方便地使用<code>VGG</code>网络，我们可以直接使用<code>tensorflow</code>提供的<code>VGG</code>加载模块。首先保证代码工作目录下有<code>flowerphotos</code>、<code>tensorflowvgg</code>这两个文件夹，分别是花朵数据集和<code>tensorflowvgg</code>，然后将之前下载的<code>VGG16</code>拷贝到<code>tensorflowvgg</code>文件夹中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── transfer_learning.py(运行代码)</span><br><span class="line">├── flower_phtots</span><br><span class="line">│ ├── daisy</span><br><span class="line">│ ├── dandelion</span><br><span class="line">│ ├── roses</span><br><span class="line">│ └── ...</span><br><span class="line">└── tensorflow_vgg</span><br><span class="line">├── vgg16.py</span><br><span class="line">├── vgg16.npy</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>
<p>然后导入需要用的<code>python</code>模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow_vgg <span class="keyword">import</span> vgg16</span><br><span class="line"><span class="keyword">from</span> tensorflow_vgg <span class="keyword">import</span> utils</span><br></pre></td></tr></table></figure>
<h3 id="加载识花数据集"><a href="#加载识花数据集" class="headerlink" title="加载识花数据集"></a>加载识花数据集</h3><p>&emsp;&emsp;接下来我们将<code>flower_photos</code>文件夹中的花朵图片都载入到进来，并且用图片所在的子文件夹作为标签值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data_dir = <span class="string">'flower_photos/'</span></span><br><span class="line">contents = os.listdir(data_dir)</span><br><span class="line">classes = [each <span class="keyword">for</span> each <span class="keyword">in</span> contents <span class="keyword">if</span> os.path.isdir(data_dir + each)]</span><br></pre></td></tr></table></figure>
<h3 id="利用VGG16计算得到特征值"><a href="#利用VGG16计算得到特征值" class="headerlink" title="利用VGG16计算得到特征值"></a>利用VGG16计算得到特征值</h3><p>&emsp;&emsp;代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">10</span>  <span class="comment"># 首先设置计算batch的值，运算平台的内存越大，这个值可以设置得越高</span></span><br><span class="line">codes_list = []  <span class="comment"># 用codes_list来存储特征值</span></span><br><span class="line">labels = []  <span class="comment"># 用labels来存储花的类别</span></span><br><span class="line">batch = []  <span class="comment"># batch数组用来临时存储图片数据</span></span><br><span class="line">codes = <span class="keyword">None</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    vgg = vgg16.Vgg16()  <span class="comment"># 构建VGG16模型对象</span></span><br><span class="line">    input_ = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">224</span>, <span class="number">224</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">"content_vgg"</span>):</span><br><span class="line">        vgg.build(input_)  <span class="comment"># 载入VGG16模型</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> classes:  <span class="comment"># 对每个不同种类的花分别用VGG16计算特征值</span></span><br><span class="line">        print(<span class="string">"Starting &#123;&#125; images"</span>.format(each))</span><br><span class="line">        class_path = data_dir + each</span><br><span class="line">        files = os.listdir(class_path)</span><br><span class="line">        <span class="keyword">for</span> ii, file <span class="keyword">in</span> enumerate(files, <span class="number">1</span>):</span><br><span class="line">            img = utils.load_image(os.path.join(class_path, file))  <span class="comment"># 载入图片并放入batch数组中</span></span><br><span class="line">            batch.append(img.reshape((<span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>, <span class="number">3</span>)))</span><br><span class="line">            labels.append(each)</span><br><span class="line">            <span class="keyword">if</span> ii % batch_size == <span class="number">0</span> <span class="keyword">or</span> ii == len(files):  <span class="comment"># 如果图片数量到了batch_size，则开始运算</span></span><br><span class="line">                images = np.concatenate(batch)</span><br><span class="line">                feed_dict = &#123;input_: images&#125;</span><br><span class="line">                codes_batch = sess.run(vgg.relu6, feed_dict=feed_dict)  <span class="comment"># 计算特征值</span></span><br><span class="line">​</span><br><span class="line">                <span class="keyword">if</span> codes <span class="keyword">is</span> <span class="keyword">None</span>:  <span class="comment"># 将结果放入到codes数组中</span></span><br><span class="line">                    codes = codes_batch</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    codes = np.concatenate((codes, codes_batch))</span><br><span class="line">                batch = []  <span class="comment"># 清空数组，准备下一个batch的计算</span></span><br><span class="line">                print(<span class="string">'&#123;&#125; images processed'</span>.format(ii))</span><br></pre></td></tr></table></figure>
<p>这样就可以得到一个<code>codes</code>数组和一个<code>labels</code>数组，分别存储了所有花朵的特征值和类别。可以用如下代码将这两个数组保存到硬盘上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'codes'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    codes.tofile(f)</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">​</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'labels'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    writer = csv.writer(f, delimiter=<span class="string">'\n'</span>)</span><br><span class="line">    writer.writerow(labels)</span><br></pre></td></tr></table></figure>
<h3 id="准备训练集、验证集和测试集"><a href="#准备训练集、验证集和测试集" class="headerlink" title="准备训练集、验证集和测试集"></a>准备训练集、验证集和测试集</h3><p>&emsp;&emsp;一次严谨的模型训练一定是要包含验证和测试这两个部分的。首先把<code>labels</code>数组中的分类标签用<code>One Hot Encode</code>的方式替换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelBinarizer</span><br><span class="line">​</span><br><span class="line">lb = LabelBinarizer()</span><br><span class="line">lb.fit(labels)</span><br><span class="line">labels_vecs = lb.transform(labels)</span><br></pre></td></tr></table></figure>
<p>接下来就是抽取数据，因为不同类型的花的数据数量并不是完全一样的，而且<code>labels</code>数组中的数据也还没有被打乱，所以最合适的方法是使用<code>StratifiedShuffleSplit</code>方法来进行分层随机划分。假设使用训练集、验证集和测试集的比例是<code>8:1:1</code>，那么代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedShuffleSplit</span><br><span class="line">​</span><br><span class="line">ss = StratifiedShuffleSplit(n_splits=<span class="number">1</span>, test_size=<span class="number">0.2</span>)</span><br><span class="line">train_idx, val_idx = next(ss.split(codes, labels))</span><br><span class="line">​</span><br><span class="line">half_val_len = int(len(val_idx) / <span class="number">2</span>)</span><br><span class="line">val_idx, test_idx = val_idx[:half_val_len], val_idx[half_val_len:]</span><br><span class="line">​</span><br><span class="line">train_x, train_y = codes[train_idx], labels_vecs[train_idx]</span><br><span class="line">val_x, val_y = codes[val_idx], labels_vecs[val_idx]</span><br><span class="line">test_x, test_y = codes[test_idx], labels_vecs[test_idx]</span><br><span class="line">​</span><br><span class="line">print(<span class="string">"Train shapes (x, y):"</span>, train_x.shape, train_y.shape)</span><br><span class="line">print(<span class="string">"Validation shapes (x, y):"</span>, val_x.shape, val_y.shape)</span><br><span class="line">print(<span class="string">"Test shapes (x, y):"</span>, test_x.shape, test_y.shape)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Train shapes (x, y): (<span class="number">2936</span>, <span class="number">4096</span>) (<span class="number">2936</span>, <span class="number">5</span>)</span><br><span class="line">Validation shapes (x, y): (<span class="number">367</span>, <span class="number">4096</span>) (<span class="number">367</span>, <span class="number">5</span>)</span><br><span class="line">Test shapes (x, y): (<span class="number">367</span>, <span class="number">4096</span>) (<span class="number">367</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="训练网络"><a href="#训练网络" class="headerlink" title="训练网络"></a>训练网络</h3><p>&emsp;&emsp;分好了数据集之后，就可以开始对数据集进行训练了。假设我们使用一个<code>256</code>维的全连接层，一个<code>5</code>维的全连接层(因为我们要分类五种不同类的花朵)和一个<code>softmax</code>层。当然这里的网络结构可以任意修改，你可以不断尝试其他的结构。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inputs_ = tf.placeholder(tf.float32, shape=[<span class="keyword">None</span>, codes.shape[<span class="number">1</span>]])  <span class="comment"># 输入数据的维度</span></span><br><span class="line">labels_ = tf.placeholder(tf.int64, shape=[<span class="keyword">None</span>, labels_vecs.shape[<span class="number">1</span>]])  <span class="comment"># 标签数据的维度</span></span><br><span class="line">fc = tf.contrib.layers.fully_connected(inputs_, <span class="number">256</span>)  <span class="comment"># 加入一个256维的全连接的层</span></span><br><span class="line">logits = tf.contrib.layers.fully_connected(fc, labels_vecs.shape[<span class="number">1</span>], activation_fn=<span class="keyword">None</span>)  <span class="comment"># 加入一个5维的全连接层</span></span><br><span class="line">cross_entropy = tf.nn.softmax_cross_entropy_with_logits(labels=labels_, logits=logits)  <span class="comment"># 计算“cross entropy”值</span></span><br><span class="line">cost = tf.reduce_mean(cross_entropy)  <span class="comment"># 计算损失函数</span></span><br><span class="line">optimizer = tf.train.AdamOptimizer().minimize(cost)  <span class="comment"># 采用AdamOptimizer优化器</span></span><br><span class="line">predicted = tf.nn.softmax(logits)  <span class="comment"># 得到最后的预测分布</span></span><br><span class="line"><span class="comment"># 计算准确度</span></span><br><span class="line">correct_pred = tf.equal(tf.argmax(predicted, <span class="number">1</span>), tf.argmax(labels_, <span class="number">1</span>))</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_pred, tf.float32))</span><br></pre></td></tr></table></figure>
<p>为了方便把数据分成一个个<code>batch</code>，还可以再用一个函数专门用来生成<code>batch</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_batches</span><span class="params">(x, y, n_batches=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="string">""" 这是一个生成器函数，按照n_batches的大小将数据划分了小块 """</span></span><br><span class="line">    batch_size = len(x) // n_batches</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(<span class="number">0</span>, n_batches * batch_size, batch_size):</span><br><span class="line">        <span class="comment"># 如果不是最后一个batch，那么这个batch中应该有batch_size个数据</span></span><br><span class="line">        <span class="keyword">if</span> ii != (n_batches - <span class="number">1</span>) * batch_size:</span><br><span class="line">            X, Y = x[ii: ii + batch_size], y[ii: ii + batch_size]</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 否则的话，那剩余的不够batch_size的数据都凑入到一个batch中</span></span><br><span class="line">            X, Y = x[ii:], y[ii:]</span><br><span class="line">        <span class="keyword">yield</span> X, Y  <span class="comment"># 生成器语法，返回X和Y</span></span><br></pre></td></tr></table></figure>
<p>训练过程如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">epochs = <span class="number">20</span>  <span class="comment"># 运行轮次</span></span><br><span class="line">iteration = <span class="number">0</span>  <span class="comment"># 统计训练的频率</span></span><br><span class="line">saver = tf.train.Saver()  <span class="comment"># 训练模型的保存器</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> range(epochs):</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> get_batches(train_x, train_y):</span><br><span class="line">            feed = &#123;inputs_: x, labels_: y&#125;</span><br><span class="line">            loss, _ = sess.run([cost, optimizer], feed_dict=feed)  <span class="comment"># 训练模型</span></span><br><span class="line">            print(<span class="string">"Epoch: &#123;&#125;/&#123;&#125;"</span>.format(e + <span class="number">1</span>, epochs), <span class="string">"Iteration: &#123;&#125;"</span>.format(iteration), \</span><br><span class="line">                  <span class="string">"Training loss: &#123;:.5f&#125;"</span>.format(loss))</span><br><span class="line">            iteration += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> iteration % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                feed = &#123;inputs_: val_x, labels_: val_y&#125;</span><br><span class="line">                val_acc = sess.run(accuracy, feed_dict=feed)</span><br><span class="line">                <span class="comment"># 输出用验证集验证训练精度</span></span><br><span class="line">                print(<span class="string">"Epoch: &#123;&#125;/&#123;&#125;"</span>.format(e, epochs), <span class="string">"Iteration: &#123;&#125;"</span>.format(iteration), \</span><br><span class="line">                      <span class="string">"Validation Acc: &#123;:.4f&#125;"</span>.format(val_acc))</span><br><span class="line">    saver.save(sess, <span class="string">"checkpoints/flowers.ckpt"</span>)  <span class="comment"># 保存模型</span></span><br></pre></td></tr></table></figure>
<h3 id="测试网络"><a href="#测试网络" class="headerlink" title="测试网络"></a>测试网络</h3><p>&emsp;&emsp;接下来就是用测试集来测试模型效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    saver.restore(sess, tf.train.latest_checkpoint(<span class="string">'checkpoints'</span>))</span><br><span class="line">    feed = &#123;inputs_: test_x, labels_: test_y&#125;</span><br><span class="line">    test_acc = sess.run(accuracy, feed_dict=feed)</span><br><span class="line">    print(<span class="string">"Test accuracy: &#123;:.4f&#125;"</span>.format(test_acc))</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/17/深度学习/COCO数据集/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/17/深度学习/COCO数据集/" itemprop="url">COCO数据集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T14:49:45+08:00">
                2019-02-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>COCO</code>的全称是<code>Common Objects in Context</code>，是微软团队提供的一个可以用来进行图像识别的数据集。<code>MS COCO</code>数据集中的图像分为训练、验证和测试集。<br>&emsp;&emsp;<code>COCO</code>数据集现在有3种标注类型：<code>object instances</code>(目标实例)、<code>object keypoints</code>(目标上的关键点)和<code>image captions</code>(看图说话)，使用<code>JSON</code>文件存储。比如下面就是<code>COCO</code>的<code>2017</code>年训练集中的标注文件：</p>
<ul>
<li><code>captions_train2017.json</code></li>
<li><code>captions_val2017.json</code></li>
<li><code>instances_train2017.json</code></li>
<li><code>instances_val2017.json</code></li>
<li><code>person_keypoints_train2017.json</code></li>
<li><code>person_keypoints_val2017.json</code></li>
</ul>
<p>可以看到其中有上面所述的三种类型，每种类型又包含了训练和验证，所以共<code>6</code>个<code>JSON</code>文件。</p>
<h3 id="基本的JSON结构体类型"><a href="#基本的JSON结构体类型" class="headerlink" title="基本的JSON结构体类型"></a>基本的JSON结构体类型</h3><p>&emsp;&emsp;<code>object instances</code>、<code>object keypoints</code>、<code>image captions</code>这<code>3</code>种类型共享这些基本类型：<code>info</code>、<code>image</code>、<code>license</code>。<br>&emsp;&emsp;<code>annotation</code>类型则呈现出了多态：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"info"</span>: info,</span><br><span class="line">    <span class="attr">"licenses"</span>: [license],</span><br><span class="line">    <span class="attr">"images"</span>: [image],</span><br><span class="line">    <span class="attr">"annotations"</span>: [annotation],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info &#123;</span><br><span class="line">    "year": int,</span><br><span class="line">    "version": str,</span><br><span class="line">    "description": str,</span><br><span class="line">    "contributor": str,</span><br><span class="line">    "url": str,</span><br><span class="line">    "date_created": datetime,</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">license &#123;</span><br><span class="line">    "id": int,</span><br><span class="line">    "name": str,</span><br><span class="line">    "url": str,</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">image &#123;</span><br><span class="line">    "id": int,</span><br><span class="line">    "width": int,</span><br><span class="line">    "height": int,</span><br><span class="line">    "file_name": str,</span><br><span class="line">    "license": int,</span><br><span class="line">    "flickr_url": str,</span><br><span class="line">    "coco_url": str,</span><br><span class="line">    "date_captured": datetime,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;一个<code>info</code>类型的实例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"info": &#123;</span><br><span class="line">    "description":"This is stable 1.0 version of the 2014 MS COCO dataset.",</span><br><span class="line">    "url":"http:\\mscoco.org",</span><br><span class="line">    "version":"1.0","year":2014,</span><br><span class="line">    "contributor":"Microsoft COCO group",</span><br><span class="line">    "date_created":"2015-01-27 09:11:52.357475"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>images</code>是包含多个<code>image</code>实例的数组，一个<code>image</code>类型的实例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"image": &#123;</span><br><span class="line">    "license":3,</span><br><span class="line">    "file_name":"COCO_val2014_000000391895.jpg",</span><br><span class="line">    "coco_url":"http:\\mscoco.org\images\391895",</span><br><span class="line">    "height":360,</span><br><span class="line">    "width":640,</span><br><span class="line">    "date_captured":"2013-11-14 11:18:45",</span><br><span class="line">    "flickr_url":"http:\\farm9.staticflickr.com\8186\8119368305_4e622c8349_z.jpg",</span><br><span class="line">    "id":391895</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>licenses</code>是包含多个<code>license</code>实例的数组，一个<code>license</code>类型的实例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"license": &#123;</span><br><span class="line">    "url":"http:\\creativecommons.org\licenses\by-nc-sa\2.0\",</span><br><span class="line">    "id":1,</span><br><span class="line">    "name":"Attribution-NonCommercial-ShareAlike License"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object-Instance类型的标注格式"><a href="#Object-Instance类型的标注格式" class="headerlink" title="Object Instance类型的标注格式"></a>Object Instance类型的标注格式</h3><h4 id="整体JSON文件格式"><a href="#整体JSON文件格式" class="headerlink" title="整体JSON文件格式"></a>整体JSON文件格式</h4><p>&emsp;&emsp;比如上图中的<code>instances_train2017.json</code>、<code>instances_val2017.json</code>这两个文件就是这种格式。<code>Object Instance</code>这种格式的文件从头至尾按照顺序分为以下段落：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"info"</span>: info,</span><br><span class="line">    <span class="attr">"licenses"</span>: [license],</span><br><span class="line">    <span class="attr">"images"</span>: [image],</span><br><span class="line">    <span class="attr">"annotations"</span>: [annotation],</span><br><span class="line">    <span class="attr">"categories"</span>: [category]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你打开这两个文件，虽然内容很多，但从文件开始到结尾按照顺序就是这<code>5</code>段。其中，<code>info</code>、<code>licenses</code>、<code>images</code>这三个类型在上一节中已经说了，在不同的<code>JSON</code>文件中这三个类型是一样的，定义是共享的。不共享的是<code>annotation</code>和<code>category</code>这两种结构体，它们在不同类型的<code>JSON</code>文件中是不一样的。<code>images</code>数组元素的数量等同于划入训练集(或者测试集)的图片的数量；<code>annotations</code>数组元素的数量等同于训练集(或者测试集)中<code>bounding box</code>的数量；<code>categories</code>数组元素的数量为<code>80</code>(<code>2017</code>年版本)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pycocotools.coco <span class="keyword">import</span> COCO</span><br><span class="line">​</span><br><span class="line">dataDir = <span class="string">'..'</span></span><br><span class="line">dataType = <span class="string">'val2017'</span></span><br><span class="line">annFile = <span class="string">'&#123;&#125;/annotations/instances_&#123;&#125;.json'</span>.format(dataDir, dataType)</span><br><span class="line">coco_train = COCO(annFile)  <span class="comment"># initialize COCO api for instance annotations</span></span><br><span class="line">​</span><br><span class="line">print(len(coco_train.dataset[<span class="string">'categories'</span>]))</span><br><span class="line">print(len(coco_train.dataset[<span class="string">'images'</span>]))</span><br><span class="line">print(len(coco_train.dataset[<span class="string">'annotations'</span>]))</span><br></pre></td></tr></table></figure>
<h4 id="annotations字段"><a href="#annotations字段" class="headerlink" title="annotations字段"></a>annotations字段</h4><p>&emsp;&emsp;<code>annotations</code>字段是包含多个<code>annotation</code>实例的一个数组，<code>annotation</code>类型本身又包含了一系列的字段，例如这个目标的<code>category id</code>和<code>segmentation mask</code>。<code>segmentation</code>格式取决于这个实例是一个单个的对象(即<code>iscrowd = 0</code>，将使用<code>polygons</code>格式)还是一组对象(即<code>iscrowd = 1</code>，将使用<code>RLE</code>格式)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">annotation &#123;</span><br><span class="line">    "id": int,</span><br><span class="line">    "image_id": int,</span><br><span class="line">    "category_id": int,</span><br><span class="line">    "segmentation": RLE or [polygon],</span><br><span class="line">    "area": float,</span><br><span class="line">    "bbox": [x,y,width,height],</span><br><span class="line">    "iscrowd": 0 or 1,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，单个的对象(<code>iscrowd = 0</code>)可能需要多个<code>polygon</code>来表示，比如这个对象在图像中被挡住了；而<code>iscrowd = 1</code>时(将标注一组对象，比如一群人)的<code>segmentation</code>使用的就是<code>RLE</code>格式。另外，每个对象(不管是<code>iscrowd = 0</code>还是<code>iscrowd = 1</code>)都会有一个矩形框<code>bbox</code>，矩形框左上角的坐标和矩形框的长宽会以数组的形式提供，数组第一个元素就是左上角的横坐标值。<br>&emsp;&emsp;<code>area</code>是<code>area of encoded masks</code>，即标注区域的面积。如果是矩形框，那就是高乘宽；如果是<code>polygon</code>或者<code>RLE</code>，那就稍微有点复杂点。<code>annotation</code>结构中的<code>categories</code>字段存储的是当前对象所属的<code>category</code>的<code>id</code>，以及所属的<code>supercategory</code>的<code>name</code>。<br>&emsp;&emsp;下面是从<code>instances_val2017.json</code>文件中摘出的一个<code>annotation</code>的实例，这里的<code>segmentation</code>就是<code>polygon</code>格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"segmentation"</span>: [[<span class="number">510.66</span>, <span class="number">423.01</span>, <span class="number">511.72</span>, <span class="number">420.03</span>, <span class="number">510.45</span>, ...]],</span><br><span class="line">    <span class="attr">"area"</span>: <span class="number">702.1057499999998</span>,</span><br><span class="line">    <span class="attr">"iscrowd"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"image_id"</span>: <span class="number">289343</span>,</span><br><span class="line">    <span class="attr">"bbox"</span>: [<span class="number">473.07</span>,<span class="number">395.93</span>,<span class="number">38.65</span>,<span class="number">28.67</span>],</span><br><span class="line">    <span class="attr">"category_id"</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1768</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>polygon</code>格式比较简单，这些数按照相邻的顺序两两组成一个点的<code>xy</code>坐标，如果有<code>n</code>个数(必定是偶数)，那么就是<code>n/2</code>个点坐标。下面就是一段解析<code>polygon</code>格式的<code>segmentation</code>并且显示多边形的示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Polygon</span><br><span class="line"><span class="keyword">from</span> matplotlib.collections <span class="keyword">import</span> PatchCollection</span><br><span class="line">​</span><br><span class="line">_, ax = plt.subplots()</span><br><span class="line">polygons = []</span><br><span class="line">gemfield_polygons = [</span><br><span class="line">    [<span class="number">239.97</span>, <span class="number">260.24</span>, <span class="number">222.04</span>, <span class="number">270.49</span>, <span class="number">199.84</span>, <span class="number">253.41</span>, <span class="number">213.5</span>,</span><br><span class="line">     <span class="number">227.79</span>, <span class="number">259.62</span>, <span class="number">200.46</span>, <span class="number">274.13</span>, <span class="number">202.17</span>, <span class="number">277.55</span>, <span class="number">210.71</span>,</span><br><span class="line">     <span class="number">249.37</span>, <span class="number">253.41</span>, <span class="number">237.41</span>, <span class="number">264.51</span>, <span class="number">242.54</span>, <span class="number">261.95</span>, <span class="number">228.87</span>, <span class="number">271.34</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">gemfield_polygon = gemfield_polygons[<span class="number">0</span>]</span><br><span class="line">max_value = max(gemfield_polygon) * <span class="number">1.3</span></span><br><span class="line">gemfield_polygon = [i * <span class="number">1.0</span> / max_value <span class="keyword">for</span> i <span class="keyword">in</span> gemfield_polygon]</span><br><span class="line">poly = np.array(gemfield_polygon).reshape((int(len(gemfield_polygon) / <span class="number">2</span>), <span class="number">2</span>))</span><br><span class="line">polygons.append(Polygon(poly, <span class="keyword">True</span>))</span><br><span class="line">p = PatchCollection(polygons, cmap=matplotlib.cm.jet, alpha=<span class="number">0.4</span>)</span><br><span class="line">ax.add_collection(p)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果<code>iscrowd = 1</code>，那么<code>segmentation</code>就是<code>RLE</code>格式(<code>segmentation</code>字段会含有<code>counts</code>和<code>size</code>数组)。在<code>json</code>文件中挑出一个这样的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">segmentation: &#123;</span><br><span class="line">    u'counts': [272, 2, 4, 4, 4, 4, 2, 9, 1, 2, 16, 43, 143, 24, ...],</span><br><span class="line">    u'size': [240, 320]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>COCO</code>数据集的<code>RLE</code>都是<code>uncompressed RLE</code>格式(与之相对的是<code>compact RLE</code>)。<code>RLE</code>所占字节的大小和边界上的像素数量是正相关的。<code>RLE</code>格式带来的好处就是，当基于<code>RLE</code>去计算目标区域的面积以及两个目标之间的<code>unoin</code>和<code>intersection</code>时会非常有效率。上面的<code>segmentation</code>中的<code>counts</code>数组和<code>size</code>数组共同组成了这幅图片中的分割<code>mask</code>，其中<code>size</code>是这幅图片的宽高。然后在这幅图像中，每一个像素点要么在被分割(标注)的目标区域中，要么在背景中。很明显这是一个<code>bool</code>量：如果该像素在目标区域中，则为<code>true</code>；如果在背景中，就是<code>False</code>(如果该像素在目标区域中，则为<code>1</code>；如果在背景中，则为<code>0</code>)。对于一个<code>240 * 320</code>的图片来说，一共有<code>76800</code>个像素点，根据每一个像素点在不在目标区域中，我们就有了<code>76800</code>个<code>bit</code>，比如像这样：<code>00000111100111110...</code>。但是这样写很明显浪费空间，我们直接写上<code>0</code>或者<code>1</code>的个数不就可以吗(<code>Run-length encoding</code>)？于是就成了<code>54251...</code>，这就是上文中的<code>counts</code>数组。下面这个<code>python</code>代码片段直观的显示了这些<code>bit</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rle = [<span class="number">272</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">43</span>, <span class="number">143</span>, <span class="number">24</span>, <span class="number">5</span>, <span class="number">8</span>, ...]</span><br><span class="line"><span class="keyword">assert</span> sum(rle) == <span class="number">240</span> * <span class="number">320</span></span><br></pre></td></tr></table></figure>
<p>也可以使用下面的代码将这个<code>rle</code>数组表示的分割区域画出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">​</span><br><span class="line">rle = [</span><br><span class="line">    <span class="number">66083</span>, <span class="number">9</span>, <span class="number">627</span>, <span class="number">14</span>, <span class="number">618</span>, <span class="number">23</span>, <span class="number">616</span>, <span class="number">25</span>, <span class="number">614</span>,</span><br><span class="line">    <span class="number">26</span>, <span class="number">613</span>, <span class="number">27</span>, <span class="number">612</span>, <span class="number">28</span>, <span class="number">611</span>, <span class="number">30</span>, <span class="number">610</span>, <span class="number">31</span>, ...</span><br><span class="line">]</span><br><span class="line">​</span><br><span class="line"><span class="keyword">assert</span> sum(rle) == <span class="number">640</span> * <span class="number">480</span></span><br><span class="line">M = np.zeros(<span class="number">640</span> * <span class="number">480</span>)</span><br><span class="line">N = len(rle)</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">val = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pos <span class="keyword">in</span> range(N):</span><br><span class="line">    val = <span class="keyword">not</span> val</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(rle[pos]):</span><br><span class="line">        M[n] = val</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">​</span><br><span class="line">GEMFIELD = M.reshape(([<span class="number">640</span>, <span class="number">480</span>]), order=<span class="string">'F'</span>)</span><br><span class="line">plt.imshow(GEMFIELD)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h4 id="categories字段"><a href="#categories字段" class="headerlink" title="categories字段"></a>categories字段</h4><p>&emsp;&emsp;<code>categories</code>是一个包含多个<code>category</code>实例的数组，而<code>category</code>结构体描述如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: int,</span><br><span class="line">    <span class="attr">"name"</span>: str,</span><br><span class="line">    <span class="attr">"supercategory"</span>: str,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>instances_val2017.json</code>文件中摘出的<code>2</code>个<code>category</code>实例如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"supercategory"</span>: <span class="string">"person"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"person"</span></span><br><span class="line">&#125;,</span><br><span class="line">​</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"supercategory"</span>: <span class="string">"vehicle"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"bicycle"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object-Keypoint类型的标注格式"><a href="#Object-Keypoint类型的标注格式" class="headerlink" title="Object Keypoint类型的标注格式"></a>Object Keypoint类型的标注格式</h3><h4 id="整体JSON文件格式-1"><a href="#整体JSON文件格式-1" class="headerlink" title="整体JSON文件格式"></a>整体JSON文件格式</h4><p>&emsp;&emsp;比如上图中的<code>person_keypoints_train2017.json</code>、<code>person_keypoints_val2017.json</code>这两个文件就是这种格式。<br>&emsp;&emsp;<code>Object Keypoint</code>这种格式的文件从头至尾按照顺序分为以下段落，看起来和<code>Object Instance</code>一样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"info"</span>: info,</span><br><span class="line">    <span class="attr">"licenses"</span>: [license],</span><br><span class="line">    <span class="attr">"images"</span>: [image],</span><br><span class="line">    <span class="attr">"annotations"</span>: [annotation],</span><br><span class="line">    <span class="attr">"categories"</span>: [category]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>images</code>数组元素数量是划入训练集(测试集)的图片的数量；<code>annotations</code>是<code>bounding box</code>的数量，在这里只有人这个类别的<code>bounding box</code>；<code>categories</code>数组元素的数量为<code>1</code>，即<code>person</code>(<code>2017</code>年版本)。</p>
<h4 id="annotations字段-1"><a href="#annotations字段-1" class="headerlink" title="annotations字段"></a>annotations字段</h4><p>&emsp;&emsp;这个类型中的<code>annotation</code>结构体包含了<code>Object Instance</code>中<code>annotation</code>结构体的所有字段，再加上<code>2</code>个额外的字段。<br>&emsp;&emsp;新增的<code>keypoints</code>是一个长度为<code>3 * k</code>的数组，其中<code>k</code>是<code>category</code>中<code>keypoints</code>的总数量。每一个<code>keypoint</code>是一个长度为<code>3</code>的数组，第一和第二个元素分别是<code>x</code>和<code>y</code>坐标值，第三个元素是个标志位<code>v</code>，<code>v</code>为<code>0</code>时表示这个关键点没有标注(这种情况下<code>x = y = v = 0</code>)，<code>v</code>为<code>1</code>时表示这个关键点标注了但是不可见(被遮挡了)，<code>v</code>为<code>2</code>时表示这个关键点标注了同时也可见。<code>num_keypoints</code>表示这个目标上被标注的关键点的数量(<code>v &gt; 0</code>)，比较小的目标上可能就无法标注关键点。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">annotation &#123;</span><br><span class="line">    "keypoints": [x1,y1,v1,...],</span><br><span class="line">    "num_keypoints": int,</span><br><span class="line">    "id": int,</span><br><span class="line">    "image_id": int,</span><br><span class="line">    "category_id": int,</span><br><span class="line">    "segmentation": RLE or [polygon],</span><br><span class="line">    "area": float,</span><br><span class="line">    "bbox": [x,y,width,height],</span><br><span class="line">    "iscrowd": 0 or 1,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从<code>person_keypoints_val2017.json</code>文件中摘出一个<code>annotation</code>实例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"segmentation"</span>: [[<span class="number">125.12</span>, <span class="number">539.69</span>, <span class="number">140.94</span>, <span class="number">522.43</span>, ...]],</span><br><span class="line">    <span class="attr">"num_keypoints"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">"area"</span>: <span class="number">47803.27955</span>,</span><br><span class="line">    <span class="attr">"iscrowd"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"keypoints"</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                  <span class="number">142</span>, <span class="number">309</span>, <span class="number">1</span>, <span class="number">177</span>, <span class="number">320</span>, <span class="number">2</span>, <span class="number">191</span>, <span class="number">398</span>, ...],</span><br><span class="line">    <span class="attr">"image_id"</span>: <span class="number">425226</span>, <span class="attr">"bbox"</span>: [<span class="number">73.35</span>,<span class="number">206.02</span>,<span class="number">300.58</span>,<span class="number">372.5</span>], <span class="attr">"category_id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">183126</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="categories字段-1"><a href="#categories字段-1" class="headerlink" title="categories字段"></a>categories字段</h4><p>&emsp;&emsp;对于每一个<code>category</code>结构体，相比<code>Object Instance</code>中的<code>category</code>新增了<code>2</code>个额外的字段，<code>keypoints</code>是一个长度为<code>k</code>的数组，包含了每个关键点的名字；<code>skeleton</code>定义了各个关键点之间的连接性(比如人的左手腕和左肘就是连接的，但是左手腕和右手腕就不是)。目前，<code>COCO</code>的<code>keypoints</code>只标注了<code>person category</code>(分类为人)。<br>&emsp;&emsp;定义如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: int,</span><br><span class="line">    <span class="attr">"name"</span>: str,</span><br><span class="line">    <span class="attr">"supercategory"</span>: str,</span><br><span class="line">    <span class="attr">"keypoints"</span>: [str],</span><br><span class="line">    <span class="attr">"skeleton"</span>: [edge]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>person_keypoints_val2017.json</code>文件中摘出一个<code>category</code>实例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"supercategory"</span>: <span class="string">"person"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"person"</span>,</span><br><span class="line">    <span class="attr">"keypoints"</span>: [<span class="string">"nose"</span>, <span class="string">"left_eye"</span>, <span class="string">"right_eye"</span>, <span class="string">"left_ear"</span>, <span class="string">"right_ear"</span>,</span><br><span class="line">                  <span class="string">"left_shoulder"</span>, <span class="string">"right_shoulder"</span>, <span class="string">"left_elbow"</span>, <span class="string">"right_elbow"</span>,</span><br><span class="line">                  <span class="string">"left_wrist"</span>, <span class="string">"right_wrist"</span>, <span class="string">"left_hip"</span>, <span class="string">"right_hip"</span>,</span><br><span class="line">                  <span class="string">"left_knee"</span>, <span class="string">"right_knee"</span>, <span class="string">"left_ankle"</span>, <span class="string">"right_ankle"</span>],</span><br><span class="line">    <span class="attr">"skeleton"</span>: [[<span class="number">16</span>, <span class="number">14</span>], [<span class="number">14</span>, <span class="number">12</span>], [<span class="number">17</span>, <span class="number">15</span>], [<span class="number">15</span>, <span class="number">13</span>], [<span class="number">12</span>, <span class="number">13</span>], [<span class="number">6</span>, <span class="number">12</span>], [<span class="number">7</span>, <span class="number">13</span>],</span><br><span class="line">                 [<span class="number">6</span>, <span class="number">7</span>], [<span class="number">6</span>, <span class="number">8</span>], [<span class="number">7</span>, <span class="number">9</span>], [<span class="number">8</span>, <span class="number">10</span>], [<span class="number">9</span>, <span class="number">11</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">                 [<span class="number">2</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">6</span>], [<span class="number">5</span>, <span class="number">7</span>]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>OpenPose</code>的姿态识别用了<code>COCO</code>数据库，<code>COCO</code>有<code>17</code>个<code>keypoint</code>，<code>OpenPose</code>增加了一个，就是编号为<code>1</code>的人体中心点：</p>
<p><img src="/2019/02/17/深度学习/COCO数据集/1.png" height="423" width="189"></p>
<h3 id="Image-Caption的标注格式"><a href="#Image-Caption的标注格式" class="headerlink" title="Image Caption的标注格式"></a>Image Caption的标注格式</h3><h4 id="整体JSON文件格式-2"><a href="#整体JSON文件格式-2" class="headerlink" title="整体JSON文件格式"></a>整体JSON文件格式</h4><p>&emsp;&emsp;比如上图中的<code>captions_train2017.json</code>、<code>captions_val2017.json</code>这两个文件就是这种格式。<br>&emsp;&emsp;<code>Image Caption</code>这种格式的文件从头至尾按照顺序分为以下段落，看起来和<code>Object Instance</code>一样，不过没有最后的<code>categories</code>字段：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"info"</span>: info,</span><br><span class="line">    <span class="attr">"licenses"</span>: [license],</span><br><span class="line">    <span class="attr">"images"</span>: [image],</span><br><span class="line">    <span class="attr">"annotations"</span>: [annotation]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>images</code>数组的元素数量等于划入训练集(或者测试集)的图片的数量；<code>annotations</code>的数量要多于图片的数量，这是因为一个图片可以有多个场景描述。</p>
<h4 id="annotations字段-2"><a href="#annotations字段-2" class="headerlink" title="annotations字段"></a>annotations字段</h4><p>&emsp;&emsp;这个类型中的<code>annotation</code>用来存储描述图片的语句。每个语句描述了对应图片的内容，而每个图片至少有<code>5</code>个描述语句(有的图片更多)。<code>annotation</code>定义如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">annotation &#123;</span><br><span class="line">    "id": int,</span><br><span class="line">    "image_id": int,</span><br><span class="line">    "caption": str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>captions_val2017.json</code>中摘取一个<code>annotation</code>实例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"image_id"</span>: <span class="number">179765</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">38</span>,</span><br><span class="line">    <span class="attr">"caption"</span>: <span class="string">"A black Honda motorcycle parked in front of a garage."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/17/Java/重写和重载/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/17/Java/重写和重载/" itemprop="url">重写和重载</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T14:29:39+08:00">
                2019-02-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h3><p>&emsp;&emsp;重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变(即外壳不变，核心重写)。<br>&emsp;&emsp;重写的好处在于子类可以根据需要，定义特定于自己的行为，也就是说子类能够根据需要实现父类的方法。<br>&emsp;&emsp;重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如父类的一个方法声明了一个检查异常<code>IOException</code>，但是子类在重写这个方法时不能抛出<code>Exception</code>异常，因为<code>Exception</code>是<code>IOException</code>的父类，只能抛出<code>IOException</code>的子类异常。<br>&emsp;&emsp;在面向对象原则里，重写意味着可以重写任何现有方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"动物可以移动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗可以跑和走"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal b = <span class="keyword">new</span> Dog();</span><br><span class="line">        a.move();</span><br><span class="line">        b.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动物可以移动</span><br><span class="line">狗可以跑和走</span><br></pre></td></tr></table></figure>
<p>在上面的例子中可以看到，尽管<code>b</code>属于<code>Animal</code>类型，但是它运行的是<code>Dog</code>类的<code>move</code>方法。这是由于在编译阶段，只是检查参数的引用类型；然而在运行时，<code>Java</code>虚拟机指定对象的类型并且运行该对象的方法。因此在上面的例子之所以能编译成功，是因为<code>Animal</code>类中存在<code>move</code>方法，然而在运行时，运行的是特定对象的方法。<br>&emsp;&emsp;思考以下例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"动物可以移动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗可以跑和走"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗可以吠叫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal b = <span class="keyword">new</span> Dog();</span><br><span class="line">        a.move();</span><br><span class="line">        b.move();</span><br><span class="line">        b.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TestDog.java:<span class="number">30</span>: cannot find symbol</span><br><span class="line">symbol  : <span class="function">method <span class="title">bark</span><span class="params">()</span></span></span><br><span class="line"><span class="function">location: class Animal</span></span><br><span class="line"><span class="function">                b.<span class="title">bark</span><span class="params">()</span></span>;</span><br><span class="line">                 ^</span><br></pre></td></tr></table></figure>
<p>该程序将抛出一个编译错误，因为<code>b</code>的引用类型<code>Animal</code>没有<code>bark</code>方法。</p>
<h4 id="方法的重写规则"><a href="#方法的重写规则" class="headerlink" title="方法的重写规则"></a>方法的重写规则</h4><ul>
<li>参数列表必须完全与被重写方法的相同，返回类型必须完全与被重写方法的返回类型相同。</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。例如如果父类的一个方法被声明为<code>public</code>，那么在子类中重写该方法就不能声明为<code>protected</code>。</li>
<li>父类的成员方法只能被它的子类重写。</li>
<li>声明为<code>final</code>的方法不能被重写；声明为<code>static</code>的方法不能被重写，但是能够被再次声明。</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为<code>private</code>和<code>final</code>的方法。</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为<code>public</code>和<code>protected</code>的非<code>final</code>方法。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>
<li>构造方法不能被重写。</li>
<li>如果不能继承一个方法，则不能重写这个方法。</li>
</ul>
<h4 id="super关键字的使用"><a href="#super关键字的使用" class="headerlink" title="super关键字的使用"></a>super关键字的使用</h4><p>&emsp;&emsp;当需要在子类中调用父类的被重写方法时，要使用<code>super</code>关键字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"动物可以移动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.move(); <span class="comment">/* 调用super类的方法 */</span></span><br><span class="line">        System.out.println(<span class="string">"狗可以跑和走"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Animal b = <span class="keyword">new</span> Dog();</span><br><span class="line">        b.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动物可以移动</span><br><span class="line">狗可以跑和走</span><br></pre></td></tr></table></figure>
<h3 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h3><p>&emsp;&emsp;重载是在一个类里面，方法名字相同，而参数不同，返回类型可以相同也可以不同。每个重载的方法(或者构造函数)都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。<br>&emsp;&emsp;重载规则如下：</p>
<ul>
<li>被重载的方法必须改变参数列表(参数个数或类型不一样)。</li>
<li>被重载的方法可以改变返回类型。</li>
<li>被重载的方法可以改变访问修饰符。</li>
<li>被重载的方法可以声明新的或更广的检查异常。</li>
<li>方法能够在同一个类中或者在一个子类中被重载。</li>
<li>无法以返回值类型作为重载函数的区分标准。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overloading</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 以下两个参数类型顺序不同 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test3"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"returntest3"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String s, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test4"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"returntest4"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Overloading o = <span class="keyword">new</span> Overloading();</span><br><span class="line">        System.out.println(o.test());</span><br><span class="line">        o.test(<span class="number">1</span>);</span><br><span class="line">        System.out.println(o.test(<span class="number">1</span>, <span class="string">"test3"</span>));</span><br><span class="line">        System.out.println(o.test(<span class="string">"test4"</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test1</span><br><span class="line"><span class="number">1</span></span><br><span class="line">test2</span><br><span class="line">test3</span><br><span class="line">returntest3</span><br><span class="line">test4</span><br><span class="line">returntest4</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;重写与重载之间的区别：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可以修改</td>
<td>可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td>访问</td>
<td>可以修改</td>
<td>一定不能做更严格的限制(可以降低限制)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;方法的重写和重载是<code>java</code>多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>
<ul>
<li>方法重载是一个类中定义了多个方法名相同，而它们的参数的数量不同，或数量相同而类型和次序不同。</li>
<li>方法重写是在子类存在方法与父类的方法的名字相同，而且参数的个数与类型一样，返回值也一样的方法。</li>
</ul>
<p><img src="/2019/02/17/Java/重写和重载/1.png" height="195" width="890"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/17/深度学习/多任务学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/17/深度学习/多任务学习/" itemprop="url">多任务学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T13:51:14+08:00">
                2019-02-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="单任务学习和多任务学习"><a href="#单任务学习和多任务学习" class="headerlink" title="单任务学习和多任务学习"></a>单任务学习和多任务学习</h3><p>&emsp;&emsp;单任务学习一次只学习一个任务(<code>task</code>)，大部分的机器学习任务都属于单任务学习；多任务学习是把多个相关(<code>related</code>)的任务放在一起学习，同时学习多个任务。<br>&emsp;&emsp;对于复杂的问题，也可以分解为简单且相互独立的子问题来单独解决，然后再合并结果，得到最初复杂问题的结果。这样做看似合理，其实是不正确的，因为现实世界中很多问题不能分解为几个独立的子问题，即使可以分解，各个子问题之间也是相互关联的，通过一些共享因素或共享表示(<code>share representation</code>)联系在一起。把现实问题当做几个独立的单任务处理，忽略了问题之间所富含的丰富的关联信息。<br>&emsp;&emsp;多任务学习就是为了解决这个问题而诞生的，把多个相关(<code>related</code>)的任务(<code>task</code>)放在一起学习。这样做真的有效吗？答案是肯定的。多个任务之间共享一些因素，它们可以在学习过程中，共享它们所学到的信息，这是单任务学习所不具备的。相关联的多任务学习比单任务学习具有更好的泛化(<code>generalization</code>)效果。<br>&emsp;&emsp;单任务与多任务对比如下图所示，单任务学习时，各个任务之间的模型空间(<code>Trained Model</code>)是相互独立的；多任务学习时，多个任务之间的模型空间是共享的：</p>
<p><img src="/2019/02/17/深度学习/多任务学习/1.png" height="149" width="570"></p>
<h3 id="两种多任务学习模式"><a href="#两种多任务学习模式" class="headerlink" title="两种多任务学习模式"></a>两种多任务学习模式</h3><p>&emsp;&emsp;为了使得多任务学习的思想更加具体，如下展示了基于深度神经网络的两种多任务学习模式：隐层参数的硬共享与软共享。</p>
<ul>
<li>参数的硬共享机制(左图)：参数的硬共享机制是神经网络的多任务学习中最常见的一种方式。一般来讲，它可以应用到所有任务的所有隐层上，而保留任务相关的输出层。硬共享机制降低了过拟合的风险。越多任务同时学习，模型就能捕捉到越多任务的同一个表示，从而导致在原始任务上的过拟合风险越小。</li>
<li>参数的软共享机制(右图)：每个任务都有自己的模型以及自己的参数，对模型参数的距离进行正则化来保障参数的相似。</li>
</ul>
<p><img src="/2019/02/17/深度学习/多任务学习/2.png" height="256" width="948"></p>
<h3 id="利用TensorFlow一步一步构建一个多任务学习模型"><a href="#利用TensorFlow一步一步构建一个多任务学习模型" class="headerlink" title="利用TensorFlow一步一步构建一个多任务学习模型"></a>利用TensorFlow一步一步构建一个多任务学习模型</h3><p>&emsp;&emsp;当你在思考新事物的时候，通常会利用以前的经验和获得的知识来加速现在的学习过程。例如当学习一门新语言时，尤其是相关的语言时，通常会使用我们以前学过的语言知识来加快这一门新语言的学习过程。这个过程也可以用另一种方式来理解 — 学习一种新的语言可以帮助你更好的理解和说出自己的想法。<br>&emsp;&emsp;我们的大脑会同时学习多种不同的任务，无论是想将英文翻译成中文，还是想将中文翻译成德语，都是使用相同的大脑架构，也就是我们自己的脑袋。同理在机器学习模型中，如果采用的是同一个网络来同时完成这两个任务，那么就可以把这个任务称为<code>多任务学习</code>。<br>&emsp;&emsp;多任务学习是最近几年或者说未来几年非常有趣和令人兴奋的一个研究领域，因为这个学习模式从根本上减少了学习新概念所需的数据量。深度学习其中一个最伟大的地方是，我们可以利用模型之间的参数共享来优化我们的模型，而这种方法在多任务学习中将显得尤为突出。<br>&emsp;&emsp;在开始这个领域的学习之前，我遇到了一些障碍：虽然我们很容易理解实现多任务学习所需要的网络架构，但是很难弄清楚在<code>TensorFlow</code>中是如何实现它的。除了<code>TensorFlow</code>中的标准网络之外，我们做任何事情都需要对其工作原理有一个很好的理解，但是网上大多数的教程都是没有一个很好的指导教学功能。我希望以下教程可以简单解释一些关键概念，并帮助学习困难的你。</p>
<h4 id="简单的例子-线性变换"><a href="#简单的例子-线性变换" class="headerlink" title="简单的例子(线性变换)"></a>简单的例子(线性变换)</h4><p>&emsp;&emsp;<code>TensorFlow</code>的计算图能让<code>TensorFlow</code>运行的更加快，它是深度学习中一个很重要的组成部分，虽然这部分时常让人感到困惑。计算图可以能容易整理清楚模型的组织架构，这对我们进行多任务学习是非常有意义的。首先，对计算图进行简单的计算 — 对输入数据进行线性变换，并计算平方根损失：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Create Placeholders For X And Y (for feeding in data)</span></span><br><span class="line">X = tf.placeholder(<span class="string">"float"</span>, [<span class="number">10</span>, <span class="number">10</span>], name=<span class="string">"X"</span>)  <span class="comment"># Our input is “10 * 10”</span></span><br><span class="line">Y = tf.placeholder(<span class="string">"float"</span>, [<span class="number">10</span>, <span class="number">1</span>], name=<span class="string">"Y"</span>)  <span class="comment"># Our output is “10 * 1”</span></span><br><span class="line">​</span><br><span class="line"><span class="comment"># Create a Trainable Variable, "W", our weights for the linear transformation</span></span><br><span class="line">initial_W = np.zeros((<span class="number">10</span>, <span class="number">1</span>))</span><br><span class="line">W = tf.Variable(initial_W, name=<span class="string">"W"</span>, dtype=<span class="string">"float32"</span>)</span><br><span class="line">​</span><br><span class="line">Loss = tf.pow(tf.add(Y, -tf.matmul(X, W)), <span class="number">2</span>, name=<span class="string">"Loss"</span>)  <span class="comment"># Define Your Loss Function</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:  <span class="comment"># set up the session</span></span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    Model_Loss = sess.run(</span><br><span class="line">        Loss,  <span class="comment"># the first argument is the name of the tensorflow variabl you want to return</span></span><br><span class="line">        &#123;  <span class="comment"># the second argument is the data for the placeholders</span></span><br><span class="line">            X: np.random.rand(<span class="number">10</span>, <span class="number">10</span>),</span><br><span class="line">            Y: np.random.rand(<span class="number">10</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">​</span><br><span class="line">    print(Model_Loss)</span><br><span class="line">    sess.close()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/17/深度学习/多任务学习/3.png" height="230" width="396"></p>
<h4 id="如何使用计算图来进行多任务学习？"><a href="#如何使用计算图来进行多任务学习？" class="headerlink" title="如何使用计算图来进行多任务学习？"></a>如何使用计算图来进行多任务学习？</h4><p>&emsp;&emsp;当创建一个执行多任务学习的神经网络时，我们希望网络中的某些神经元是被共享的，而网络的其它部分则是针对不同任务而单独设计的。当进行训练的时候，我们希望每个独立的任务都可以对共享神经元起到修改功能。<br>&emsp;&emsp;首先绘制一个简单的双任务网络结构，该网络具有共享层和每个单独任务的特定网络层：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Define the Placeholders</span></span><br><span class="line">X = tf.placeholder(<span class="string">"float"</span>, [<span class="number">10</span>, <span class="number">10</span>], name=<span class="string">"X"</span>)</span><br><span class="line">Y1 = tf.placeholder(<span class="string">"float"</span>, [<span class="number">10</span>, <span class="number">20</span>], name=<span class="string">"Y1"</span>)</span><br><span class="line">Y2 = tf.placeholder(<span class="string">"float"</span>, [<span class="number">10</span>, <span class="number">20</span>], name=<span class="string">"Y2"</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Define the weights for the layers</span></span><br><span class="line">initial_shared_layer_weights = np.random.rand(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">initial_Y1_layer_weights = np.random.rand(<span class="number">20</span>, <span class="number">20</span>)</span><br><span class="line">initial_Y2_layer_weights = np.random.rand(<span class="number">20</span>, <span class="number">20</span>)</span><br><span class="line">​</span><br><span class="line">shared_layer_weights = tf.Variable(initial_shared_layer_weights, name=<span class="string">"share_W"</span>, dtype=<span class="string">"float32"</span>)</span><br><span class="line">Y1_layer_weights = tf.Variable(initial_Y1_layer_weights, name=<span class="string">"share_Y1"</span>, dtype=<span class="string">"float32"</span>)</span><br><span class="line">Y2_layer_weights = tf.Variable(initial_Y2_layer_weights, name=<span class="string">"share_Y2"</span>, dtype=<span class="string">"float32"</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Construct the Layers with RELU Activations</span></span><br><span class="line">shared_layer = tf.nn.relu(tf.matmul(X, shared_layer_weights))</span><br><span class="line">Y1_layer = tf.nn.relu(tf.matmul(shared_layer, Y1_layer_weights))</span><br><span class="line">Y2_layer = tf.nn.relu(tf.matmul(shared_layer, Y2_layer_weights))</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Calculate Loss</span></span><br><span class="line">Y1_Loss = tf.nn.l2_loss(Y1 - Y1_layer)</span><br><span class="line">Y2_Loss = tf.nn.l2_loss(Y2 - Y2_layer)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/17/深度学习/多任务学习/4.png" height="234" width="404"></p>
<p>&emsp;&emsp;当训练这个网络时，我们希望在训练任务<code>2</code>的时候，不会改变任务<code>1</code>的参数。但在训练两个中的任何一个任务时，共享层的参数都会改变。这可能看起来有点困难，通常我们在图中只有一个优化器，因为只优化一个损失函数。值得庆幸的是，我们可以巧妙的利用图的性质来通过两种方式来训练这种模型。</p>
<h4 id="交替训练"><a href="#交替训练" class="headerlink" title="交替训练"></a>交替训练</h4><p>&emsp;&emsp;第一种解决方案特别适用于需要一批任务<code>1</code>数据，然后再需要一批任务<code>2</code>数据的情况。请记住，<code>TensorFlow</code>会自动判断你所需要的操作都需要进行哪些计算，并且只进行这些计算。这意味着如果我们只对其中一个任务定义一个优化器，它将只训练计算该任务所需要的参数，并且将其余的参数单独保留下来。由于任务<code>1</code>仅依赖于任务<code>1</code>层和共享层，所以任务<code>2</code>层的参数是不会改变的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Define the Placeholders</span></span><br><span class="line">X = tf.placeholder(<span class="string">"float"</span>, [<span class="number">10</span>, <span class="number">10</span>], name=<span class="string">"X"</span>)</span><br><span class="line">Y1 = tf.placeholder(<span class="string">"float"</span>, [<span class="number">10</span>, <span class="number">20</span>], name=<span class="string">"Y1"</span>)</span><br><span class="line">Y2 = tf.placeholder(<span class="string">"float"</span>, [<span class="number">10</span>, <span class="number">20</span>], name=<span class="string">"Y2"</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Define the weights for the layers</span></span><br><span class="line">initial_shared_layer_weights = np.random.rand(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">initial_Y1_layer_weights = np.random.rand(<span class="number">20</span>, <span class="number">20</span>)</span><br><span class="line">initial_Y2_layer_weights = np.random.rand(<span class="number">20</span>, <span class="number">20</span>)</span><br><span class="line">​</span><br><span class="line">shared_layer_weights = tf.Variable(initial_shared_layer_weights, name=<span class="string">"share_W"</span>, dtype=<span class="string">"float32"</span>)</span><br><span class="line">Y1_layer_weights = tf.Variable(initial_Y1_layer_weights, name=<span class="string">"share_Y1"</span>, dtype=<span class="string">"float32"</span>)</span><br><span class="line">Y2_layer_weights = tf.Variable(initial_Y2_layer_weights, name=<span class="string">"share_Y2"</span>, dtype=<span class="string">"float32"</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Construct the Layers with RELU Activations</span></span><br><span class="line">shared_layer = tf.nn.relu(tf.matmul(X, shared_layer_weights))</span><br><span class="line">Y1_layer = tf.nn.relu(tf.matmul(shared_layer, Y1_layer_weights))</span><br><span class="line">Y2_layer = tf.nn.relu(tf.matmul(shared_layer, Y2_layer_weights))</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Calculate Loss</span></span><br><span class="line">Y1_Loss = tf.nn.l2_loss(Y1 - Y1_layer)</span><br><span class="line">Y2_Loss = tf.nn.l2_loss(Y2 - Y2_layer)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># optimisers</span></span><br><span class="line">Y1_op = tf.train.AdamOptimizer().minimize(Y1_Loss)</span><br><span class="line">Y2_op = tf.train.AdamOptimizer().minimize(Y2_Loss)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/17/深度学习/多任务学习/5.png" height="283" width="639"></p>
<p>我们可以通过交替调用每个任务优化器来进行多任务学习，这意味着可以不断地将每个任务的某些信息传送给另一个任务，因为这是通过共享层来完成的。不严格的说，我们正在发现一些任务之间的<code>共性</code>。下面的代码简单地实现了这一个过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> session:</span><br><span class="line">    session.run(tf.global_variables_initializer())</span><br><span class="line">    <span class="keyword">for</span> iters <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span> np.random.rand() &lt; <span class="number">0.5</span>:</span><br><span class="line">            _, Y1_loss = session.run(</span><br><span class="line">                [Y1_op, Y1_Loss],</span><br><span class="line">                &#123;</span><br><span class="line">                    X: np.random.rand(<span class="number">10</span>, <span class="number">10</span>) * <span class="number">10</span>,</span><br><span class="line">                    Y1: np.random.rand(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span>,</span><br><span class="line">                    Y2: np.random.rand(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span></span><br><span class="line">                &#125;)</span><br><span class="line">            print(<span class="string">"Y1_loss:"</span>, Y1_loss)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            _, Y2_loss = session.run(</span><br><span class="line">                [Y2_op, Y2_Loss],</span><br><span class="line">                &#123;</span><br><span class="line">                    X: np.random.rand(<span class="number">10</span>, <span class="number">10</span>) * <span class="number">10</span>,</span><br><span class="line">                    Y1: np.random.rand(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span>,</span><br><span class="line">                    Y2: np.random.rand(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span></span><br><span class="line">                &#125;)</span><br><span class="line">            print(<span class="string">"Y2_loss:"</span>, Y2_loss)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;什么时候适合交替训练？当你为每个不同的任务有不同的数据集的时候，交替训练是一个很好的注意(例如，从英语翻译成法语和从英语翻译成德语)。通过以这种方式设计网络，我们可以提高每项任务的性能，而不需去寻找更多的训练数据。交替训练是我们最常见的一种情况，因为没有那么多的数据集可以同时满足你两个需求。我们来举一个例子，例如在机器视觉中，你可能需要执行其中的一项任务是来预测对象是否进行了旋转，而另一个任务可能需要你去改变相机对象，这两个任务显然是相关。<br>&emsp;&emsp;什么时候不适合交替训练？交替训练很容易偏向特定的任务，如果你的其中一个任务比别的任务有更大的数据集，那么如果按照数据集的大小比例来进行训练，你的共享层将包含拥有更多数据的任务的信息。</p>
<h4 id="联合训练"><a href="#联合训练" class="headerlink" title="联合训练"></a>联合训练</h4><p>&emsp;&emsp;当每个输入都是具有多个标签的数据集时，那么你真正想要的是联合训练这些任务。问题是，你如何保持各个不同任务之间的独立性？答案非常简单，只需要将单个任务的损失函数相加并优化就行了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Define the Placeholders</span></span><br><span class="line">X = tf.placeholder(<span class="string">"float"</span>, [<span class="number">10</span>, <span class="number">10</span>], name=<span class="string">"X"</span>)</span><br><span class="line">Y1 = tf.placeholder(<span class="string">"float"</span>, [<span class="number">10</span>, <span class="number">20</span>], name=<span class="string">"Y1"</span>)</span><br><span class="line">Y2 = tf.placeholder(<span class="string">"float"</span>, [<span class="number">10</span>, <span class="number">20</span>], name=<span class="string">"Y2"</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Define the weights for the layers</span></span><br><span class="line">initial_shared_layer_weights = np.random.rand(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">initial_Y1_layer_weights = np.random.rand(<span class="number">20</span>, <span class="number">20</span>)</span><br><span class="line">initial_Y2_layer_weights = np.random.rand(<span class="number">20</span>, <span class="number">20</span>)</span><br><span class="line">​</span><br><span class="line">shared_layer_weights = tf.Variable(initial_shared_layer_weights, name=<span class="string">"share_W"</span>, dtype=<span class="string">"float32"</span>)</span><br><span class="line">Y1_layer_weights = tf.Variable(initial_Y1_layer_weights, name=<span class="string">"share_Y1"</span>, dtype=<span class="string">"float32"</span>)</span><br><span class="line">Y2_layer_weights = tf.Variable(initial_Y2_layer_weights, name=<span class="string">"share_Y2"</span>, dtype=<span class="string">"float32"</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Construct the Layers with RELU Activations</span></span><br><span class="line">shared_layer = tf.nn.relu(tf.matmul(X, shared_layer_weights))</span><br><span class="line">Y1_layer = tf.nn.relu(tf.matmul(shared_layer, Y1_layer_weights))</span><br><span class="line">Y2_layer = tf.nn.relu(tf.matmul(shared_layer, Y2_layer_weights))</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Calculate Loss</span></span><br><span class="line">Y1_Loss = tf.nn.l2_loss(Y1 - Y1_layer)</span><br><span class="line">Y2_Loss = tf.nn.l2_loss(Y2 - Y2_layer)</span><br><span class="line">Joint_Loss = Y1_Loss + Y2_Loss</span><br><span class="line">​</span><br><span class="line"><span class="comment"># optimisers</span></span><br><span class="line">Optimiser = tf.train.AdamOptimizer().minimize(Joint_Loss)</span><br><span class="line">Y1_op = tf.train.AdamOptimizer().minimize(Y1_Loss)</span><br><span class="line">Y2_op = tf.train.AdamOptimizer().minimize(Y2_Loss)</span><br><span class="line">​</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> session:</span><br><span class="line">    session.run(tf.global_variables_initializer())</span><br><span class="line">    _, Joint_Loss = session.run(</span><br><span class="line">        [Optimiser, Joint_Loss],</span><br><span class="line">        &#123;</span><br><span class="line">            X: np.random.rand(<span class="number">10</span>, <span class="number">10</span>) * <span class="number">10</span>,</span><br><span class="line">            Y1: np.random.rand(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span>,</span><br><span class="line">            Y2: np.random.rand(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span></span><br><span class="line">        &#125;)</span><br><span class="line">    print(Joint_Loss)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/17/深度学习/多任务学习/6.png" height="286" width="757"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/17/深度学习/TensorFlow编程模型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/17/深度学习/TensorFlow编程模型/" itemprop="url">TensorFlow编程模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T12:42:22+08:00">
                2019-02-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>TensorFlow</code>的计算可以表示为一种有向图(<code>directed graph</code>)，或者称计算图(<code>computation graph</code>)。图中每一个运算操作(<code>operation</code>)是一个节点(<code>node</code>)，节点之间的连接线称为边(<code>edge</code>)。计算图中的节点可以有任意多个输入和任意多个输出，每个节点都只有一个运算操作。在计算图中流动(<code>flow</code>)的数据被称为张量(<code>tensor</code>)，故得名<code>TensorFlow</code>。<br>&emsp;&emsp;计算图示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">​</span><br><span class="line">b = tf.Variable(tf.zeros([<span class="number">100</span>]))  <span class="comment"># 生成100维的向量，初始化为0</span></span><br><span class="line">W = tf.Variable(tf.random_uniform([<span class="number">784</span>, <span class="number">100</span>], <span class="number">-1</span>, <span class="number">1</span>))  <span class="comment"># 生成“784 * 100”的随机矩阵W</span></span><br><span class="line">x = tf.placeholder(name = <span class="string">"x"</span>)  <span class="comment"># 输入的Placeholder</span></span><br><span class="line">relu = tf.nn.relu(tf.matmul(W, x) + b)  <span class="comment"># ReLU(Wx+b)</span></span><br><span class="line">C = [...]  <span class="comment"># 根据ReLU函数的结果计算Cost</span></span><br><span class="line">s = tf.Session()</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">    input = construct <span class="number">100</span>-D input array  <span class="comment"># 为输入创建一个100维的向量</span></span><br><span class="line">    result = s.run(C, feed_dict = &#123;x: input&#125;)  <span class="comment"># 获取Cost，供给输入x</span></span><br><span class="line">    print(step, result)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/17/深度学习/TensorFlow编程模型/1.png" height="380" width="194"></p>
<p><code>Session</code>是用户使用<code>TensorFlow</code>时交互的接口。<code>Session</code>可以通过<code>Extend</code>方法添加节点(<code>node</code>)和边(<code>edge</code>)，用以创建计算图，然后就可以通过<code>Session</code>的<code>Run</code>方法执行计算图。<code>Variable</code>是一类特殊的运算操作，可以将<code>tensor</code>存储在内存或显存中，比如神经网络模型中的参数。</p>
<hr>
<p>&emsp;&emsp;<code>TensorFlow</code>是一个编程系统，使用图来表示计算任务。图中的节点被称之为<code>op</code>(<code>operation</code>的缩写)，一个<code>op</code>获得<code>0</code>个或多个<code>Tensor</code>，执行计算并产生<code>0</code>个或多个<code>Tensor</code>。每个<code>Tensor</code>是一个类型化的多维数组，例如你可以将一小组图像集表示为一个四维浮点数数组，这四个维度分别是<code>[batch, height, width, channels]</code>。<br>&emsp;&emsp;一个<code>TensorFlow</code>图描述了计算的过程。为了进行计算，图必须在会话里被启动。会话将图的<code>op</code>分发到诸如<code>CPU</code>或<code>GPU</code>之类的设备上，同时提供执行<code>op</code>的方法。这些方法执行后，将产生的<code>tensor</code>返回。在<code>Python</code>语言中，返回的<code>tensor</code>是<code>numpy</code>的<code>ndarray</code>对象；在<code>C/C++</code>语言中，返回的<code>tensor</code>是<code>tensorflow::Tensor</code>实例。</p>
<h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><p>&emsp;&emsp;<code>TensorFlow</code>程序通常被组织成一个构建阶段和一个执行阶段。在构建阶段，<code>op</code>的执行步骤被描述成一个图；在执行阶段，使用会话执行执行图中的<code>op</code>。例如，通常在构建阶段创建一个图来表示和训练神经网络，然后在执行阶段反复执行图中的训练<code>op</code>。</p>
<h3 id="构建图"><a href="#构建图" class="headerlink" title="构建图"></a>构建图</h3><p>&emsp;&emsp;构建图的第一步是创建源<code>op</code>(即<code>source op</code>)。源<code>op</code>不需要任何输入，例如常量(<code>Constant</code>)；源<code>op</code>的输出被传递给其它<code>op</code>做运算。<br>&emsp;&emsp;在<code>Python</code>库中，<code>op</code>构造器的返回值代表被构造出的<code>op</code>的输出，这些返回值可以传递给其它<code>op</code>构造器作为输入。<code>TensorFlow</code>的<code>Python</code>库有一个默认图(<code>default graph</code>)，<code>op</code>构造器可以为其增加节点，这个默认图对许多程序来说已经足够用了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">​</span><br><span class="line"><span class="comment"># 创建一个常量op，产生一个“1 * 2”矩阵，这个op被作为一个节点加到默认图中</span></span><br><span class="line">matrix1 = tf.constant([[<span class="number">3.</span>, <span class="number">3.</span>]])</span><br><span class="line"><span class="comment"># 创建另外一个常量op，产生一个“2 * 1”矩阵</span></span><br><span class="line">matrix2 = tf.constant([[<span class="number">2.</span>], [<span class="number">2.</span>]])</span><br><span class="line"><span class="comment"># 创建一个矩阵乘法“matmul op”，把matrix1和matrix2作为输入，返回值product代表矩阵乘法的结果</span></span><br><span class="line">product = tf.matmul(matrix1, matrix2)</span><br></pre></td></tr></table></figure>
<p>默认图现在有三个节点，两个<code>constant</code>的<code>op</code>和一个<code>matmul</code>的<code>op</code>。为了真正进行矩阵相乘运算，并得到矩阵乘法的结果，你必须在会话里启动这个图。</p>
<h3 id="启动图"><a href="#启动图" class="headerlink" title="启动图"></a>启动图</h3><p>&emsp;&emsp;构造阶段完成后，才能启动图。启动图的第一步是创建一个<code>Session</code>对象，如果无任何创建参数，会话构造器将启动默认图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sess = tf.Session()  <span class="comment"># 启动默认图</span></span><br><span class="line"><span class="comment"># 调用sess的run方法来执行矩阵乘法op，传入product作为该方法的参数。product代表了矩阵乘法op的输出，</span></span><br><span class="line"><span class="comment"># 传入它是向run方法表明，我们希望取回矩阵乘法op的输出。整个执行过程是自动化的，会话负责传递op所需的</span></span><br><span class="line"><span class="comment"># 全部输入，op通常是并发执行的函数调用run(product)触发了图中三个op(两个常量op和一个矩阵乘法op)</span></span><br><span class="line"><span class="comment"># 的执行，返回值result是一个numpy的ndarray对象</span></span><br><span class="line">result = sess.run(product)</span><br><span class="line">print(result)  <span class="comment"># 结果为[[ 12.]]</span></span><br><span class="line">sess.close()  <span class="comment"># 任务完成，关闭会话</span></span><br></pre></td></tr></table></figure>
<p><code>Session</code>对象在使用完后，需要关闭以释放资源。除了显式调用<code>close</code>外，也可以使用<code>with</code>代码块来自动完成关闭动作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    result = sess.run([product])</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>TensorFlow</code>将图形定义转换成分布式执行的操作，以充分利用可用的计算资源(如<code>CPU</code>或<code>GPU</code>)。一般你不需要显式指定使用<code>CPU</code>还是<code>GPU</code>，<code>TensorFlow</code>能自动检测。如果检测到<code>GPU</code>，<code>TensorFlow</code>会尽可能地利用找到的第一个<code>GPU</code>来执行操作。如果机器上有超过一个可用的<code>GPU</code>，除第一个外的其它<code>GPU</code>默认是不参与计算的。为了让<code>TensorFlow</code>使用这些<code>GPU</code>，你必须将<code>op</code>明确指派给它们执行。<code>with ... Device</code>语句用来指派特定的<code>CPU</code>或<code>GPU</code>执行操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="keyword">with</span> tf.device(<span class="string">"/gpu:1"</span>):</span><br><span class="line">        matrix1 = tf.constant([[<span class="number">3.</span>, <span class="number">3.</span>]])</span><br><span class="line">        matrix2 = tf.constant([[<span class="number">2.</span>], [<span class="number">2.</span>]])</span><br><span class="line">        product = tf.matmul(matrix1, matrix2)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Tensors-generalized-matrices"><a href="#Tensors-generalized-matrices" class="headerlink" title="Tensors - generalized matrices"></a>Tensors - generalized matrices</h3><p>&emsp;&emsp;Tensors have a shape that’s described with a vector:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10000</span>, <span class="number">256</span>, <span class="number">256</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p><code>10000</code> images, each image has <code>256</code> rows, each row has <code>256</code> pixels, each pixel has <code>3</code> channels (<code>RGB</code>).</p>
<h3 id="Computation-is-a-dataflow-graph"><a href="#Computation-is-a-dataflow-graph" class="headerlink" title="Computation is a dataflow graph"></a>Computation is a dataflow graph</h3><p>&emsp;&emsp;With tensors:</p>
<p><img src="/2019/02/17/深度学习/TensorFlow编程模型/2.png" height="167" width="537"></p>
<p>with state:</p>
<p><img src="/2019/02/17/深度学习/TensorFlow编程模型/3.png" height="158" width="565"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/17/深度学习/TensorFlow实现卷积神经网络/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/17/深度学习/TensorFlow实现卷积神经网络/" itemprop="url">TensorFlow实现卷积神经网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T11:17:50+08:00">
                2019-02-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="卷积神经网络概述"><a href="#卷积神经网络概述" class="headerlink" title="卷积神经网络概述"></a>卷积神经网络概述</h3><p>&emsp;&emsp;卷积神经网络(<code>Convolutional Neural Network</code>，<code>CNN</code>)最初是为解决图像识别等问题设计的，<code>CNN</code>现在的应用已经不限于图像和视频，也可用于时间序列信号，比如音频信号和文本数据等。在早期的图像识别研究中，最大的挑战是如何组织特征，因为图像数据不向其他类型的数据那样可以通过人工理解提取特征。在深度学习之前，我们必须借助<code>SIFT</code>、<code>HoG</code>等算法提取具有良好区分性的特征，再集合<code>SVM</code>等机器学习的算法进行图像识别。</p>
<p><img src="/2019/02/17/深度学习/TensorFlow实现卷积神经网络/1.png" height="228" width="297"></p>
<p>&emsp;&emsp;<code>CNN</code>作为一个深度学习架构被提出的最初诉求，是降低对图像数据预处理的要求，避免复杂的特征工程。<code>CNN</code>可以直接使用图像的原始像素作为输入，而不必先使用<code>SIFT</code>等算法提取特征，减轻了使用传统算法如<code>SVM</code>时需要做的大量重复、繁琐的数据预处理工作。和<code>SIFT</code>算法类似，<code>CNN</code>训练的模型同样对缩放、平移、旋转等畸变具有不变性，有很强的泛化性。<br>&emsp;&emsp;在卷积神经网络中，第一个卷积层会直接接受图像像素级的输入，每一个卷积只操作一小块图像，进行卷积变化后再传到后面的网络。每一层卷积(滤波器)都会提取数据中最有效的特征，这种方法可以提取到图像中最基础的特征，比如不同方向的边或角，而后再进行组合和抽象形成更高阶的特征，因此<code>CNN</code>在理论上具有对图像缩放、平移和旋转的不变性。<br>&emsp;&emsp;卷积的意义就是让神经网络不再是对每个像素的输入信息做处理，而是图片上每一小块像素区域进行处理，这种做法加强了图片信息的连续性，使得神经网络能看到图形，而非一个点。这种做法同时也加深了神经网络对图片的理解，具体来说，卷积神经网络有一个批量过滤器，它会持续不断地在图片上滚动并收集图片里的信息。每一次收集的时候都只是收集一小块像素区，然后把收集来的信息进行整理，这时候整理出来的信息有了一些实际上的呈现，比如这时的神经网络能看到一些边缘的图片信息。然后再以同样的步骤，用类似的批量过滤器扫过产生的这些边缘信息，神经网络从这些边缘信息里面总结出更高层的信息结构，比如说总结的边缘能够画出眼睛、鼻子等。再经过一次过滤，脸部的信息也从这些眼睛鼻子的信息中被总结出来。最后我们再把这些信息套入几层普通的全连接神经层进行分类，这样就能得到输入的图片能被分为哪一类的结果了。</p>
<p><img src="/2019/02/17/深度学习/TensorFlow实现卷积神经网络/2.png" height="198" width="397"></p>
<p>&emsp;&emsp;一般的卷积神经网络由多个卷积层构成，每个卷积层中通常有如下几个操作：</p>
<ol>
<li>图像通过多个不同的卷积核的滤波，并加偏置(<code>bias</code>)，提取局部特征，每一个卷积核会映射出一个新的<code>2D</code>图像。</li>
<li>将前面卷积核的滤波输出结果，进行非线性的激活函数处理。</li>
<li>对激活函数的结果再进行池化操作(即降采样，比如将<code>2 * 2</code>的图片降为<code>1 * 1</code>的图片)，一般是使用最大池化，保留最显著的特征，并提升模型的畸变容忍能力。</li>
</ol>
<p>&emsp;&emsp;一个卷积层中可以有多个不同的卷积核，而每一个卷积核都对应一个滤波后的映射新图像，同一个新图像中每一个像素都来自完全相同的卷积核，这就是卷积核的权值共享。为什么要共享卷积核的权值参数呢？答案很简单，降低模型复杂度，减轻过拟合并降低计算量。假设输入图像尺寸是<code>1000 * 1000</code>，并且假定是灰度图像，即只有一个颜色通道，那么一张图片就有<code>100</code>万个像素点，输入维度就是<code>100</code>万。如果采用全连接层(<code>Fully Connected Layer</code>，<code>FCL</code>)的话，隐含层与输入层相同大小(<code>100</code>万个隐含层节点)，那么将产生<code>100万 * 100万 = 1万亿</code>个连接，仅此就有<code>1</code>万亿个参数需要去训练，这是不可想象的。<br>&emsp;&emsp;考虑到人的视觉感受野的概念，每一个感受野只接受一小块区域的信号，每一个神经元不需要接收全部像素点的信息，只需要接收局部像素点作为输入，而将所有这些神经元接收的局部信息综合起来就可以得到全局的信息。于是将之前的全连接模式修改为局部连接，假设局部感受野大小是<code>10 * 10</code>，即每个隐含节点只与<code>10 * 10</code>个像素点相连，那么现在只需要<code>10 * 10 * 100万 = 1亿</code>个连接了，相比之前的<code>1</code>万亿已经缩小了<code>10000</code>倍。</p>
<p><img src="/2019/02/17/深度学习/TensorFlow实现卷积神经网络/3.png" height="146" width="328"></p>
<p>&emsp;&emsp;假设我们的局部连接方式是卷积操作，即默认每一个隐含节点的参数都完全一样，那么我们的参数将会是<code>10 * 10 = 100</code>个。不论图像尺寸有多大，都是这<code>100</code>个参数，即卷积核的尺寸，这就是卷积对减小参数量的贡献。这也就是所谓的权值共享。如果我们只有一个卷积核，就只能提取一种卷积滤波的结果，即只能提取一种图片特征，这不是我们期望的结果。好在图像中最基本的特征很少，我们可以增加卷积核的数量来多提取一些特征。图像中的基本特征无非就是点和边，无论多么复杂的图像都是点和边组合而成。我们采取增加卷积核的数量来多提取一些特征，每一个卷积核滤波得到的图像就是一类特征的映射，即一个<code>Feature Map</code>。一般来说，我们使用<code>100</code>个卷积核在第一个卷积层就足够了，这样我们有<code>100 * 100 = 10000</code>个参数相比之前的<code>1</code>亿又缩小了<code>10000</code>倍。卷积的好处是，不管图片尺寸如何，需要训练的参数数量只跟卷积核大小和数量有关，我们可以使用非常少的参数量处理任意大小的图片。每一个卷积层提取的特征，在后面的层中都会抽象组合成更高阶的特征，而且多层抽象的卷积网络表达能力更强，效率更高。当然需要注意的是，尽管需要训练的参数数量大大下降了，但是隐含节点的数量并没有下降，隐含节点的数量只跟卷积的步长有关系。如果步长为<code>1</code>，那么隐含节点的数量和输入图像像素数量一致；如果步长为<code>5</code>，那么每<code>5 * 5</code>的像素才需要一个隐含节点，隐含节点的数量就是输入像素数量的<code>1 / 25</code>。</p>
<p><img src="/2019/02/17/深度学习/TensorFlow实现卷积神经网络/4.png" height="174" width="358"></p>
<p>&emsp;&emsp;卷积神经网络<code>CNN</code>的要点就是局部连接(<code>Local Connection</code>)、权值共享(<code>Weights Sharing</code>)和池化层(<code>Pooling</code>)中的降采样(<code>Down-Sampling</code>)。其中，局部连接和权值共享降低了参数量，使训练复杂度大大下降，并减轻了过拟合。同时权值共享还赋予了卷积网络对平移的容忍性，池化层降采样则进一步降低了输出参数量，并赋予模型对轻度形变的容忍性，提高了模型的泛化能力。可以把卷积层卷积操作理解为用少量参数在图像的多个位置上提取相似特征的过程。</p>
<h3 id="TensorFlow实现简单的卷积网络"><a href="#TensorFlow实现简单的卷积网络" class="headerlink" title="TensorFlow实现简单的卷积网络"></a>TensorFlow实现简单的卷积网络</h3><p>&emsp;&emsp;首先载入<code>MNIST</code>数据集，采用独热编码，并创建<code>tf.InteractiveSession</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line">​</span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">"MNIST_data/"</span>, one_hot=<span class="keyword">True</span>)</span><br><span class="line">sess = tf.InteractiveSession()</span><br></pre></td></tr></table></figure>
<p>为了创建这个模型，我们需要创建大量的权重和偏置项。这个模型中的权重在初始化时应该加入少量的噪声来打破对称性以及避免<code>0</code>梯度。由于我们使用的是<code>ReLU</code>神经元，因此比较好的做法是用一个较小的正数来初始化偏置项，以避免神经元节点输出恒为<code>0</code>的问题(<code>dead neurons</code>)。为了不在建立模型的时候反复做初始化操作，我们定义两个函数用于初始化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span><span class="params">(shape)</span>:</span></span><br><span class="line">    initial = tf.truncated_normal(shape, stddev=<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span><span class="params">(shape)</span>:</span></span><br><span class="line">    initial = tf.constant(<span class="number">0.1</span>, shape=shape)</span><br><span class="line">    <span class="keyword">return</span> tf.Variable(initial)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;卷积层、池化层是接下来重复使用的，这里的<code>tf.nn.conv2d</code>是<code>TensorFlow</code>中的<code>2</code>维卷积函数，参数<code>x</code>是输入，<code>W</code>是卷积的参数，比如<code>[5, 5, 1, 32]</code>，前两个数字代表卷积核的尺寸，第三个数字代表有多少个<code>channel</code>(这里用灰度图像，所以设为<code>1</code>，彩色图像则设为<code>3</code>)。最后一个数字代表卷积核的数量，也就是这个卷积层会提取多少类的特征。<code>Strides</code>代表卷积模板移动的步长，都是<code>1</code>代表会不遗漏地划过图片的每一个点。<code>Padding</code>代表边界的处理方式，这里的<code>SAME</code>代表给边界加上<code>Padding</code>，让卷积的输出和输入保持同样的尺寸。<br>&emsp;&emsp;<code>tf.nn.max_pool</code>是<code>TensorFlow</code>中的最大池化函数，我们这里使用<code>2 * 2</code>的最大池化，最大池化会保留原始像素块中灰度值最高的那一个像素，即保留最显著的特征。因为希望整体上缩小图片尺寸，因此池化层的<code>stride</code>也设为横竖两个方向以<code>2</code>为步长。如果步长还是<code>1</code>，那么我们会得到一个尺寸不变的图片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv2d</span><span class="params">(x, W)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.conv2d(x, W, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_pool_2x2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.max_pool(x, ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在正式设计卷积神经网络之前，先定义输入的<code>placeholder</code>，其中<code>x</code>是特征，<code>y</code>是真实的<code>label</code>。因为卷积神经网络会利用到空间结构信息，因此需要将<code>1D</code>的输入向量转为<code>2D</code>的图片结构，即从<code>1 * 784</code>的形式转为<code>28 * 28</code>的结构。因为只有一个颜色通道，故最终尺寸为<code>[-1, 28, 28, 1]</code>，<code>-1</code>代表样本数量不固定，第<code>2</code>和第<code>3</code>维对应图片的宽、高，<code>1</code>代表颜色通道数量。这里我们使用<code>tensor</code>变形函数是<code>tf.reshape</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n_input  = <span class="number">784</span> <span class="comment"># “28 * 28”的灰度图，像素个数784</span></span><br><span class="line">n_output = <span class="number">10</span>  <span class="comment"># 10分类问题</span></span><br><span class="line">​</span><br><span class="line">x = tf.placeholder(tf.float32, [<span class="keyword">None</span>, n_input])</span><br><span class="line">y = tf.placeholder(tf.float32, [<span class="keyword">None</span>, n_output])</span><br><span class="line">x_image = tf.reshape(x, [<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来定义第一个卷积层，使用前面写好的函数进行参数初始化，包括<code>weight</code>和<code>bias</code>，这里的<code>[5, 5, 1, 32]</code>代表卷积核尺寸为<code>5 * 5</code>，<code>1</code>个颜色通道，<code>32</code>个不同的卷积核。然后使用<code>conv2d</code>函数进行卷积操作，并加上偏置，接着再使用<code>ReLU</code>函数进行非线性处理。最后使用最大池化函数<code>max_pool_2x2</code>对卷积的结果进行池化操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">W_conv1 = weight_variable([<span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">32</span>])</span><br><span class="line">b_conv1 = bias_variable([<span class="number">32</span>])</span><br><span class="line">h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)</span><br><span class="line">h_pool1 = max_pool_2x2(h_conv1)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;为了构建一个更深的网络，我们会把几个类似的层堆叠起来。现在定义第二个卷积层，基本上和第一个卷积层一样，唯一不同的是卷积核的数量变成了<code>64</code>，也就是说这一层的卷积会提取<code>64</code>种特征：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">W_conv2 = weight_variable([<span class="number">5</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">64</span>])</span><br><span class="line">b_conv2 = bias_variable([<span class="number">64</span>])</span><br><span class="line">h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)</span><br><span class="line">h_pool2 = max_pool_2x2(h_conv2)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;前面经过两次步长为<code>2 * 2</code>的最大池化，所以变长已经只有<code>1/4</code>了，图片的尺寸由<code>28 * 28</code>变成了<code>7 * 7</code>。而第二个卷积层的卷积核数量为<code>64</code>，其输出的<code>tensor</code>尺寸即为<code>7 * 7 * 64</code>。我们使用<code>tf.reshape</code>函数对第二个卷积层的输出<code>tensor</code>进行变形，将其转成<code>1D</code>的向量，然后连接一个全连接层，隐含节点为<code>1024</code>，并使用<code>ReLU</code>激活函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">W_fc1 = weight_variable([<span class="number">7</span> * <span class="number">7</span> * <span class="number">64</span>, <span class="number">1024</span>])</span><br><span class="line">b_fc1 = bias_variable([<span class="number">1024</span>])</span><br><span class="line">h_pool2_flat = tf.reshape(h_pool2, [<span class="number">-1</span>, <span class="number">7</span> * <span class="number">7</span> * <span class="number">64</span>])</span><br><span class="line">h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)</span><br></pre></td></tr></table></figure>
<p>为了减少过拟合，我们在输出层之前加入<code>dropout</code>。我们用一个<code>placeholder</code>来代表一个神经元的输出在<code>dropout</code>中保持不变的概率，这样可以在训练过程中启用<code>dropout</code>，在测试过程中关闭<code>dropout</code>。<code>TensorFlow</code>的<code>tf.nn.dropout</code>操作除了可以屏蔽神经元的输出外，还会自动处理神经元输出值的<code>scale</code>，所以用<code>dropout</code>的时候可以不用考虑<code>scale</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keep_prob = tf.placeholder(tf.float32)</span><br><span class="line">h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)</span><br></pre></td></tr></table></figure>
<p>最后将<code>Dropout</code>层的输出连接一个<code>Softmax</code>层，得到最后的概率输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">W_fc2 = weight_variable([<span class="number">1024</span>, <span class="number">10</span>])</span><br><span class="line">b_fc2 = bias_variable([<span class="number">10</span>])</span><br><span class="line">pred = tf.nn.softmax(tf.matmul(h_fc1_drop, W_fc2) + b_fc2)</span><br></pre></td></tr></table></figure>
<p>损失函数和优化器如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cost = tf.reduce_mean(-tf.reduce_sum(y * tf.log(pred), reduction_indices=[<span class="number">1</span>]))</span><br><span class="line">optm = tf.train.AdamOptimizer(<span class="number">0.001</span>).minimize(cost)</span><br></pre></td></tr></table></figure>
<p>再继续定义评测准确率的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corr = tf.equal(tf.argmax(pred, <span class="number">1</span>), tf.argmax(y, <span class="number">1</span>))</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(corr, tf.float32))</span><br></pre></td></tr></table></figure>
<p>为了进行训练和评估，我们使用与之前简单的单层<code>Softmax</code>神经网络模型几乎相同的一套代码，只是我们会用更加复杂的<code>ADAM</code>优化器来做梯度最速下降。在<code>feed_dict</code>中加入额外的参数<code>keep_prob</code>来控制<code>dropout</code>比例，然后每<code>10</code>次迭代输出一次日志：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tf.global_variables_initializer().run()</span><br><span class="line">training_epochs = <span class="number">200</span></span><br><span class="line">batch_size = <span class="number">100</span></span><br><span class="line">display_step = <span class="number">10</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(training_epochs):</span><br><span class="line">    batch = mnist.train.next_batch(batch_size)</span><br><span class="line">    optm.run(feed_dict=&#123;x: batch[<span class="number">0</span>], y: batch[<span class="number">1</span>], keep_prob: <span class="number">0.7</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> i % display_step == <span class="number">0</span>:</span><br><span class="line">        train_accuracy = accuracy.eval(feed_dict=&#123;x: batch[<span class="number">0</span>], y: batch[<span class="number">1</span>], keep_prob: <span class="number">1.0</span>&#125;)</span><br><span class="line">        test_accuracy = accuracy.eval(feed_dict=&#123;x: mnist.test.images, y: mnist.test.labels, keep_prob: <span class="number">1.0</span>&#125;)</span><br><span class="line">        print(<span class="string">"step: %d TRAIN ACCURACY: %.3f TEST ACCURACY: %.3f"</span> % (i, train_accuracy, test_accuracy))</span><br></pre></td></tr></table></figure>
<p>最后，这个<code>CNN</code>模型的准确率为<code>99.2%</code>，基本上可以满足手写数字识别的要求。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/19/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/94/">94</a><a class="extend next" rel="next" href="/page/21/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">939</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
