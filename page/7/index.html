<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="暴徒">
<meta property="og:url" content="http://fukangwei.gitee.io/page/7/index.html">
<meta property="og:site_name" content="暴徒">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="暴徒">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/7/">





  <title>暴徒</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">暴徒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/10/HTML笔记/HTTP请求和响应报文/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/10/HTML笔记/HTTP请求和响应报文/" itemprop="url">HTTP请求和响应报文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-10T15:36:13+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><p>&emsp;&emsp;一个<code>HTTP</code>请求报文由请求行(<code>request line</code>)、请求头部(<code>header</code>)、空行和请求数据这<code>4</code>个部分组成，下图给出了请求报文的一般格式：</p>
<p><img src="/2019/03/10/HTML笔记/HTTP请求和响应报文/1.png"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">request-line</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">headers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blank</span> <span class="attr">line</span>&gt;</span></span><br><span class="line">[<span class="tag">&lt;<span class="name">request-body</span>&gt;</span>]</span><br></pre></td></tr></table></figure>
<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>&emsp;&emsp;请求行由请求方法字段、<code>URL</code>字段和<code>HTTP</code>协议版本字段这<code>3</code>个字段组成，它们用空格分隔：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br></pre></td></tr></table></figure>
<p>HTTP协议的请求方法有<code>GET</code>、<code>POST</code>、<code>HEAD</code>、<code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>TRACE</code>、<code>CONNECT</code>。</p>
<h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>&emsp;&emsp;最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是<code>GET</code>方式。<code>GET</code>方法要求服务器将<code>URL</code>定位的资源放在响应报文的数据部分，回送给客户端。使用<code>GET</code>方法时，请求参数和对应的值附加在<code>URL</code>后面，利用一个问号<code>?</code>代表<code>URL</code>的结尾与请求参数的开始，传递参数长度受限制，例如<code>/index.jsp?id=100&amp;op=bind</code>。以使用<code>google</code>搜索<code>domety</code>为例，<code>Request</code>格式如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1</span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint,</span><br><span class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */*</span><br><span class="line">Referer: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.cn/"</span>&gt;</span>http://www.google.cn/<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">Accept-Language: zh-cn</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)</span><br><span class="line">Host: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.cn"</span>&gt;</span>www.google.cn<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g;</span><br><span class="line">NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-</span><br><span class="line">FxlRugatx63JLv7CWMD6UB_O_r</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>GET</code>方式的请求一般不包含<code>请求内容</code>部分，请求数据以地址的形式表现在请求行。地址链接如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.cn/search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq="</span>&gt;</span></span><br><span class="line">http://www.google.cn/search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq=<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>地址中<code>?</code>之后的部分就是通过<code>GET</code>发送的请求数据，可以在地址栏中清楚地看到，各个数据之间用<code>&amp;</code>符号隔开。显然这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别<code>1024</code>个字符，所以如果需要传送大量数据的时候，也不适合使用<code>GET</code>方式。</p>
<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>&emsp;&emsp;对于上面提到的不适合使用<code>GET</code>方式的情况，可以考虑使用<code>POST</code>方式，因为使用<code>POST</code>方法允许客户端给服务器提供较多信息。<code>POST</code>方法将请求参数封装在<code>HTTP</code>请求数据中，以<code>名称/值</code>的形式出现，可以传输大量数据，这样<code>POST</code>方式对传送的数据大小没有限制，而且也不会显示在<code>URL</code>中。还以上面的搜索<code>domety</code>为例，如果使用<code>POST</code>方式，格式如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1</span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint,</span><br><span class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */*</span><br><span class="line">Referer: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.cn/"</span>&gt;</span>http://www.google.cn/<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">Accept-Language: zh-cn</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)</span><br><span class="line">Host: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.cn"</span>&gt;</span>www.google.cn<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g;</span><br><span class="line">NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-</span><br><span class="line">FxlRugatx63JLv7CWMD6UB_O_r</span><br><span class="line"></span><br><span class="line">hl=zh-CN&amp;source=hp&amp;q=domety</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>POST</code>方式请求行中不包含数据字符串，这些数据保存在<code>请求内容</code>部分，各数据之间也是使用<code>&amp;</code>符号隔开。<code>POST</code>方式大多用于页面的表单中。因为<code>POST</code>也能完成<code>GET</code>的功能，因此多数人在设计表单的时候一律都使用<code>POST</code>方式，其实这是一个误区。<code>GET</code>方式也有自己的特点和优势，应该根据不同的情况来选择是使用<code>GET</code>还是使用<code>POST</code>。</p>
<h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>&emsp;&emsp;<code>HEAD</code>就像<code>GET</code>，只不过服务端接受到<code>HEAD</code>请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用<code>HEAD</code>是非常高效的，因为在传输的过程中省去了页面内容。</p>
<ul>
<li>请求头部：请求头部由<code>关键字/值</code>对组成，每行一对，关键字和值用英文冒号<code>:</code>分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：</li>
</ul>
<ol>
<li><code>User-Agent</code>：产生请求的浏览器类型。</li>
<li><code>Accept</code>：客户端可识别的内容类型列表。</li>
<li><code>Host</code>：请求的主机名，允许多个域名同处一个<code>IP</code>地址，即虚拟主机。</li>
</ol>
<ul>
<li>空行：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</li>
<li>请求数据：请求数据不在<code>GET</code>方法中使用，而是在<code>POST</code>方法中使用。<code>POST</code>方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是<code>Content-Type</code>和<code>Content-Length</code>。</li>
</ul>
<h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><p>&emsp;&emsp;<code>HTTP</code>响应报文也由三个部分组成：状态行、消息报头、响应正文。<code>HTTP</code>响应的格式与请求的格式十分类似：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">status-line</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">headers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blank</span> <span class="attr">line</span>&gt;</span></span><br><span class="line">[<span class="tag">&lt;<span class="name">response-body</span>&gt;</span>]</span><br></pre></td></tr></table></figure>
<p>在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行(<code>status line</code>)通过提供一个状态码来说明所请求的资源情况。状态行格式如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP-Version Status-Code Reason-Phrase CRLF</span><br></pre></td></tr></table></figure>
<p>其中，<code>HTTP-Version</code>表示服务器<code>HTTP</code>协议的版本；<code>Status-Code</code>表示服务器发回的响应状态代码；<code>Reason-Phrase</code>表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：</p>
<ol>
<li><code>1xx</code>：指示信息，表示请求已接收，继续处理。</li>
<li><code>2xx</code>：成功，表示请求已被成功接收、理解并接受。</li>
<li><code>3xx</code>：重定向，要完成请求必须进行更进一步的操作。</li>
<li><code>4xx</code>：客户端错误，请求有语法错误或请求无法实现。</li>
<li><code>5xx</code>：服务器端错误 服务器未能实现合法的请求。</li>
</ol>
<p>常见的状态代码如下：</p>
<ul>
<li><code>200</code>(<code>OK</code>)：客户端请求成功。</li>
<li><code>400</code>(<code>Bad Request</code>)：客户端请求有语法错误，不能被服务器所理解。</li>
<li><code>401</code>(<code>Unauthorized</code>)：请求未经授权，这个状态代码必须和<code>WWW-Authenticate</code>报头域一起使用。</li>
<li><code>403</code>(<code>Forbidden</code>)：服务器收到请求，但是拒绝提供服务。</li>
<li><code>404</code>(<code>Not Found</code>)：请求资源不存在，例如输入了错误的<code>URL</code>。</li>
<li><code>500</code>(<code>Internal Server Error</code>)：服务器发生不可预期的错误。</li>
<li><code>503</code>(<code>Server Unavailable</code>)：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</li>
</ul>
<p>&emsp;&emsp;下面给出一个<code>HTTP</code>响应报文：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 31 Dec 2005 23:59:59 GMT</span><br><span class="line">Content-Type: text/html;charset=ISO-8859-1</span><br><span class="line">Content-Length: 122</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Wrox Homepage<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- body goes here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="关于HTTP请求GET和POST的区别"><a href="#关于HTTP请求GET和POST的区别" class="headerlink" title="关于HTTP请求GET和POST的区别"></a>关于HTTP请求GET和POST的区别</h3><h4 id="提交请求数据的区别"><a href="#提交请求数据的区别" class="headerlink" title="提交请求数据的区别"></a>提交请求数据的区别</h4><p>&emsp;&emsp;<code>GET</code>提交：请求的数据会附在<code>URL</code>之后(就是把数据放置在<code>HTTP</code>协议头<code>&lt;request-line&gt;</code>中)，以<code>?</code>分割<code>URL</code>和传输数据，多个参数用<code>&amp;</code>连接。例如<code>login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD</code>。如果数据是英文字母或数字，原样发送；如果是空格，转换为<code>+</code>，如果是中文或其他字符，则直接把字符串用<code>BASE64</code>加密，得出如<code>%E4%BD%A0%E5%A5%BD</code>，其中<code>%XX</code>中的<code>XX</code>是该符号以<code>16</code>进制表示的<code>ASCII</code>。<br>&emsp;&emsp;<code>POST</code>提交：把提交的数据放置在<code>HTTP</code>包的包体<code>&lt;request-body&gt;</code>中。<br>&emsp;&emsp;因此<code>GET</code>提交的数据会在地址栏中显示出来，而对于<code>POST</code>提交，地址栏不会改变。</p>
<h4 id="传输数据的大小"><a href="#传输数据的大小" class="headerlink" title="传输数据的大小"></a>传输数据的大小</h4><p>&emsp;&emsp;首先声明，<code>HTTP</code>协议没有对传输的数据大小进行限制，<code>HTTP</code>协议规范也没有对<code>URL</code>长度进行限制。而在实际开发中存在的限制主要有：<br>&emsp;&emsp;<code>GET</code>：特定浏览器和服务器对<code>URL</code>长度有限制，例如<code>IE</code>对<code>URL</code>长度的限制是<code>2083</code>字节(<code>2K + 35</code>)。对于其他浏览器，如<code>Netscape</code>、<code>FireFox</code>等，理论上没有长度限制，其限制取决于操作系统的支持。因此对于<code>GET</code>提交时，传输数据就会受到<code>URL</code>长度的限制。<br>&emsp;&emsp;<code>POST</code>：由于不是通过<code>URL</code>传值，理论上数据不受限。但实际各个<code>WEB</code>服务器会规定对<code>post</code>提交数据大小进行限制，<code>Apache</code>、<code>IIS6</code>都有各自的配置。</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>&emsp;&emsp;<code>POST</code>的安全性要比<code>GET</code>的安全性高，注意这里所说的安全性和上面<code>GET</code>提到的<code>安全</code>不是同个概念。上面<code>安全</code>的含义仅仅是不作数据修改，而这里<code>安全</code>的含义是真正的<code>Security</code>。比如通过<code>GET</code>提交数据，用户名和密码将明文出现在<code>URL</code>上，因为登录页面有可能被浏览器缓存，其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/10/外语/日语五十音图/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/10/外语/日语五十音图/" itemprop="url">日语五十音图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-10T13:39:23+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/外语/" itemprop="url" rel="index">
                    <span itemprop="name">外语</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="日语五十音"><a href="#日语五十音" class="headerlink" title="日语五十音"></a>日语五十音</h3><div class="table-container">
<table>
<thead>
<tr>
<th>あ段</th>
<th>い段</th>
<th>う段</th>
<th>え段</th>
<th>お段</th>
</tr>
</thead>
<tbody>
<tr>
<td>あ ア a</td>
<td>い イ i</td>
<td>う ウ u</td>
<td>え エ e</td>
<td>お オ o</td>
</tr>
<tr>
<td>か カ ka</td>
<td>き キ ki</td>
<td>く ク ku</td>
<td>け ケ ke</td>
<td>こ コ ko</td>
</tr>
<tr>
<td>さ サ sa</td>
<td>し シ shi</td>
<td>す ス su</td>
<td>せ セ se</td>
<td>そ ソ so</td>
</tr>
<tr>
<td>た タ ta</td>
<td>ち チ chi</td>
<td>つ ツ tsu</td>
<td>て テ te</td>
<td>と ト to</td>
</tr>
<tr>
<td>な ナ na</td>
<td>に ニ ni</td>
<td>ぬ ヌ nu</td>
<td>ね ネ ne</td>
<td>の ノ no</td>
</tr>
<tr>
<td>は ハ ha</td>
<td>ひ ヒ hi</td>
<td>ふ フ fu</td>
<td>へ ヘ he</td>
<td>ほ ホ ho</td>
</tr>
<tr>
<td>ま マ ma</td>
<td>み ミ mi</td>
<td>む ム mu</td>
<td>め メ me</td>
<td>も モ mo</td>
</tr>
<tr>
<td>や ヤ ya</td>
<td></td>
<td>ゆ ユ yu</td>
<td></td>
<td>よ ヨ yo</td>
</tr>
<tr>
<td>ら ラ ra</td>
<td>り リ ri</td>
<td>る ル ru</td>
<td>れ レ re</td>
<td>ろ ロ ro</td>
</tr>
<tr>
<td>わ ワ wa</td>
<td></td>
<td></td>
<td></td>
<td>を ヲ o</td>
</tr>
<tr>
<td>ん ン n</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>が ガ ga</td>
<td>ぎ ギ gi</td>
<td>ぐ グ gu</td>
<td>げ ゲ ge</td>
<td>ご ゴ go</td>
</tr>
<tr>
<td>ざ ザ za</td>
<td>じ ジ ji</td>
<td>ず ズ zu</td>
<td>ぜ ゼ ze</td>
<td>ぞ ゾ zo</td>
</tr>
<tr>
<td>だ ダ da</td>
<td>ぢ ヂ ji</td>
<td>づ ヅ zu</td>
<td>で デ de</td>
<td>ど ド do</td>
</tr>
<tr>
<td>ば バ ba</td>
<td>び ビ bi</td>
<td>ぶ ブ bu</td>
<td>べ ベ be</td>
<td>ぼ ボ bo</td>
</tr>
<tr>
<td>ぱ パ pa</td>
<td>ぴ ピ pi</td>
<td>ぷ プ pu</td>
<td>ぺ ペ pe</td>
<td>ぽ ポ po</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>あ段</th>
<th>う段</th>
<th>お段</th>
</tr>
</thead>
<tbody>
<tr>
<td>きゃ キャ kya</td>
<td>きゅ キュ kyu</td>
<td>きょ キョ kyo</td>
</tr>
<tr>
<td>しゃ シャ sya</td>
<td>しゅ シュ syu</td>
<td>しょ ショ syo</td>
</tr>
<tr>
<td>ちゃ チャ cya</td>
<td>ちゅ チュ cyu</td>
<td>ちょ チョ cyo</td>
</tr>
<tr>
<td>にゃ ニャ nya</td>
<td>にゅ ニュ nyu</td>
<td>にょ ニョ nyo</td>
</tr>
<tr>
<td>ひゃ ヒャ hya</td>
<td>ひゅ ヒュ hyu</td>
<td>ひょ ヒョ hyo</td>
</tr>
<tr>
<td>みゃ ミャ mya</td>
<td>みゅ ミュ myu</td>
<td>みょ ミョ myo</td>
</tr>
<tr>
<td>りゃ リャ rya</td>
<td>りゅ リュ ryu</td>
<td>りょ リョ ryo</td>
</tr>
<tr>
<td>ぎゃ ギャ gya</td>
<td>ぎゅ ギュ gyu</td>
<td>ぎょ ギョ gyo</td>
</tr>
<tr>
<td>じゃ ジャ ja</td>
<td>じゅ ジュ ju</td>
<td>じょ ジョ jo</td>
</tr>
<tr>
<td>びゃ ビャ bya</td>
<td>びゅ ビュ byu</td>
<td>びょ ビョ byo</td>
</tr>
<tr>
<td>ぴゃ ピャ pya</td>
<td>ぴゅ ピュ pyu</td>
<td>ぴょ ピョ pyo</td>
</tr>
</tbody>
</table>
</div>
<h3 id="日语罗马音输入"><a href="#日语罗马音输入" class="headerlink" title="日语罗马音输入"></a>日语罗马音输入</h3><ol>
<li><code>っ</code>(促音)：假名的罗马字发音的第一个辅音双打，例如<code>ちょっと</code>为<code>chotto</code>。</li>
<li><code>ん</code>：输入为<code>nn</code>，例如<code>にほん</code>为<code>nihonn</code>。</li>
<li>小写的<code>あ</code>、<code>い</code>、<code>う</code>、<code>え</code>、<code>お</code>用<code>la</code>、<code>li</code>、<code>lu</code>、<code>le</code>和<code>lo</code>。</li>
<li>一些特殊单词的拼写：<code>ウォ</code>为<code>who</code>，<code>ティ</code>为<code>thi</code>，<code>ディ</code>是<code>dhi</code>。</li>
<li><code>ウォークマン</code>中的<code>ー</code>就是<code>-</code>号键。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/08/HTML笔记/网站添加favicon.ico/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/HTML笔记/网站添加favicon.ico/" itemprop="url">网站添加favicon.ico</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T10:49:06+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>favicon.ico</code>图标是网站的缩略标志，可以显示在浏览器标签、地址栏左边和收藏夹。它是展示网站个性的缩略<code>logo</code>标志，也可以说是网站头像。<br>&emsp;&emsp;准备一张长宽一样的图片，然后打开在线工具<code>aTool</code>(<code>http://www.atool.org/ico.php</code>)生成<code>ico</code>图标。点击选择文件，可以浏览你刚刚生成的宽高相同的图片。选择生成的图片尺寸大小，建议采用<code>32 * 32</code>的大小。点击<code>生成favicon.ico图标</code>按钮，即可结束。<br>&emsp;&emsp;点击<code>保存</code>链接即可将图片另存到本地磁盘，然后将文件重命名为<code>favicon.ico</code>，放到网站的根目录，强烈建议放在根目录。然后在网站的每一个页面的<code>head</code>标签内加入如下两行代码。清空浏览器缓存，刷新网页网址即可看到网站的图标。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">href</span>=<span class="string">"/favicon.ico"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"bookmark"</span> <span class="attr">href</span>=<span class="string">"/favicon.ico"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>补充说明</strong>：在线转换之前一定要转换成长宽相等的图片，否则转换成<code>ico</code>之后，图片会被拉伸或者压缩。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/07/HTML笔记/content-type和MIME TYPE/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/HTML笔记/content-type和MIME TYPE/" itemprop="url">content-type和MIME TYPE</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T19:35:57+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;首先，我们要了解浏览器是如何处理内容的。在浏览器中显示的内容有<code>HTML</code>、<code>XML</code>、<code>GIF</code>等，那么浏览器是如何区分它们，决定以什么形式来显示呢？答案是<code>MIME Type</code>，也就是该资源的媒体类型。<br>&emsp;&emsp;媒体类型通常是通过<code>HTTP</code>协议，由<code>Web</code>服务器告知浏览器的，更准确地说，是通过<code>Content-Type</code>来表示的。例如<code>Content-Type: text/HTML</code>表示内容是<code>text/HTML</code>类型，也就是超文本文件。<br>&emsp;&emsp;通常只有一些在互联网上获得广泛应用的格式才会获得一个<code>MIME Type</code>，如果是某个客户端自己定义的格式，一般只能以<code>application/x-</code>开头。<code>XHTML</code>正是一个获得广泛应用的格式。因此在<code>RFC 3236</code>中，说明了<code>XHTML</code>格式文件的<code>MIME Type</code>应该是<code>application/xHTML+XML</code>。<br>&emsp;&emsp;在把输出结果传送到浏览器上时，浏览器必须启动适当的应用程序来处理这个输出文档。这可以通过多种类型<code>MIME</code>(多功能网际邮件扩充协议)来完成。在<code>HTTP</code>中，<code>MIME</code>类型被定义在<code>Content-Type header</code>中。<br>&emsp;&emsp;假如你要传送一个<code>Microsoft Excel</code>文件到客户端，那么这时的<code>MIME</code>类型就是<code>application/vnd.ms-excel</code>。在大多数实际情况中，这个文件然后将传送给<code>Execl</code>来处理(假设我们设定<code>Execl</code>为处理特殊<code>MIME</code>类型的应用程序)。</p>
<h3 id="多媒体文件格式MIME"><a href="#多媒体文件格式MIME" class="headerlink" title="多媒体文件格式MIME"></a>多媒体文件格式MIME</h3><p>&emsp;&emsp;最早的<code>HTTP</code>协议并没有附加的数据类型信息，所有传送的数据都被客户程序解释为超文本标记语言<code>HTML</code>文档。为了支持多媒体数据类型，<code>HTTP</code>协议中就使用了附加在文档之前的<code>MIME</code>数据类型信息来标识数据类型。<br>&emsp;&emsp;<code>MIME</code>设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。当它被<code>HTTP</code>协议支持之后，它的意义就更为显著了，它使得<code>HTTP</code>传输的不仅是普通的文本。<br>&emsp;&emsp;每个<code>MIME</code>类型由两部分组成，前面是数据的大类别，例如声音<code>audio</code>、图像<code>image</code>等，后面定义具体的种类。常见的<code>MIME</code>类型如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>后缀名</th>
<th>MIME</th>
</tr>
</thead>
<tbody>
<tr>
<td>超文本标记语言文本</td>
<td><code>.html</code>或<code>.html</code></td>
<td><code>text/html</code></td>
</tr>
<tr>
<td>普通文本</td>
<td><code>.txt</code></td>
<td><code>text/plain</code></td>
</tr>
<tr>
<td><code>RTF</code>文本</td>
<td><code>.rtf</code></td>
<td><code>application/rtf</code></td>
</tr>
<tr>
<td><code>GIF</code>图形</td>
<td><code>.gif</code></td>
<td><code>image/gif</code></td>
</tr>
<tr>
<td><code>JPEG</code>图形</td>
<td><code>.jpeg</code>或<code>.jpg</code></td>
<td><code>image/jpeg</code></td>
</tr>
<tr>
<td><code>au</code>声音文件</td>
<td><code>.au</code></td>
<td><code>audio/basic</code></td>
</tr>
<tr>
<td><code>MIDI</code>音乐文件</td>
<td><code>.mid</code>和<code>.midi</code></td>
<td><code>audio/midi</code>和<code>audio/x-midi</code></td>
</tr>
<tr>
<td><code>RealAudio</code>音乐文件</td>
<td><code>.ra</code>和<code>.ram</code></td>
<td><code>audio/x-pn-realaudio</code></td>
</tr>
<tr>
<td><code>MPEG</code>文件</td>
<td><code>.mpg</code>和<code>.mpeg</code></td>
<td><code>video/mpeg</code></td>
</tr>
<tr>
<td><code>AVI</code>文件</td>
<td><code>.avi</code></td>
<td><code>video/x-msvideo</code></td>
</tr>
<tr>
<td><code>GZIP</code>文件</td>
<td><code>.gz</code></td>
<td><code>application/x-gzip</code></td>
</tr>
<tr>
<td><code>TAR</code>文件</td>
<td><code>.tar</code></td>
<td><code>application/x-tar</code></td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;<code>Internet</code>中有一个专门组织<code>IANA</code>来确认标准的<code>MIME</code>类型，但<code>Internet</code>发展得太快，很多应用程序等不及<code>IANA</code>来确认它们使用的<code>MIME</code>类型为标准类型。因此它们使用在类别中以<code>x-</code>开头的方法标识这个类别还没有成为标准，例如<code>x-gzip</code>、<code>x-tar</code>等。事实上这些类型运用的很广泛，已经成为了事实标准。只要客户机和服务器共同承认这个<code>MIME</code>类型，即使它是不标准的类型也没有关系，客户程序就能根据<code>MIME</code>类型，采用具体的处理手段来处理数据。而<code>Web</code>服务器和浏览器(包括操作系统)中，缺省都设置了标准的和常见的<code>MIME</code>类型，只有对于不常见的<code>MIME</code>类型，才需要同时设置服务器和客户浏览器，以进行识别。<br>&emsp;&emsp;由于<code>MIME</code>类型与文档的后缀相关，因此服务器使用文档的后缀来区分不同文件的<code>MIME</code>类型，服务器中必须定义文档后缀和<code>MIME</code>类型之间的对应关系。而客户程序从服务器上接收数据的时候，它只是从服务器接受数据流，并不了解文档的名字，因此服务器必须使用附加信息来告诉客户程序数据的<code>MIME</code>类型。服务器在发送真正的数据之前，就要先发送标志数据的<code>MIME</code>类型的信息，这个信息使用<code>Content-type</code>关键字进行定义。例如对于<code>HTML</code>文档，服务器将首先发送以下两行<code>MIME</code>标识信息，这个标识并不是真正的数据文件的一部分。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-type: text/html</span><br><span class="line">(空行)</span><br></pre></td></tr></table></figure>
<p>注意第二行为一个空行，这是必须的。使用这个空行的目的是将<code>MIME</code>信息与真正的数据内容分隔开。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/07/HTML笔记/URL格式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/HTML笔记/URL格式/" itemprop="url">URL格式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T19:19:42+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;在<code>WWW</code>上，每一个信息资源都有在网上唯一的地址，该地址就叫<code>URL</code>(<code>Uniform Resource Locator</code>，统一资源定位符)。<code>URL</code>由三部分组成：资源类型、存放资源的主机域名、资源文件名。其一般语法格式为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protocol://hostname[:port]/path/[;parameters][?query]#fragment (带方括号的为可选项)</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.imailtone.com:80/WebApplication1/WebForm1.aspx?name=tom&amp;;age=20#resume</span><br></pre></td></tr></table></figure>
<p>格式说明如下：</p>
<ul>
<li><code>protocol</code>：指定使用的传输协议，最常用的是<code>HTTP</code>协议，它也是目前<code>WWW</code>应用最广的协议。</li>
</ul>
<ol>
<li><code>file</code>：资源是本地计算机上的文件，格式为<code>file://</code>。</li>
<li><code>ftp</code>：通过<code>FTP</code>访问资源，格式为<code>FTP://</code>。</li>
<li><code>gopher</code>：通过Gopher协议访问该资源。</li>
<li><code>http</code>：通过<code>HTTP</code>访问该资源，格式为<code>HTTP://</code>。</li>
<li><code>https</code>：通过<code>HTTPS</code>访问该资源，格式为<code>HTTPS://</code>。</li>
<li><code>mailto</code>：资源为电子邮件地址，通过<code>SMTP</code>访问，格式为<code>mailto://</code>。</li>
<li><code>MMS</code>：通过支持<code>MMS</code>(流媒体)协议的播放该资源，代表软件是<code>Windows Media Player</code>，格式为<code>MMS://</code>。</li>
<li><code>ed2k</code>：通过支持<code>ed2k</code>(专用下载链接)协议的<code>P2P</code>软件访问该资源，代表软件是电驴，格式为<code>ed2k://</code>。</li>
<li><code>news</code>：通过<code>NNTP</code>访问该资源。</li>
</ol>
<ul>
<li><code>hostname</code>：指存放资源的服务器的域名系统(<code>DNS</code>)主机名或<code>IP</code>地址。在主机名前也可以包含连接到服务器所需的用户名和密码，格式为<code>username@password</code>。</li>
<li><code>:port</code>：它是一个整数，省略时使用方案的默认端口，各种传输协议都有默认的端口号，如http的默认端口为80。有时候出于安全或其他考虑，可以在服务器上对端口进行重定义，即采用非标准端口号，此时URL中就不能省略端口号这一项。</li>
<li><code>path</code>：由零或多个<code>/</code>符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。</li>
<li><code>;parameters</code>：这是用于指定特殊参数的可选项。</li>
<li><code>?query</code>：可选项，用于给动态网页(如使用<code>CGI</code>、<code>ISAPI</code>、<code>PHP/JSP/ASP/ASP.NET</code>等技术制作的网页)传递参数，可以有多个参数，用<code>&amp;</code>符号隔开，每个参数的名和值用<code>=</code>符号隔开。</li>
<li><code>fragment</code>：用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用<code>fragment</code>直接定位到某一名词解释。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/07/opencv和图像处理/位操作/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/opencv和图像处理/位操作/" itemprop="url">位操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T17:21:23+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>OpenCV</code>提供了<code>4</code>种位操作：<code>AND</code>、<code>OR</code>、<code>NOT</code>和<code>XOR</code>。函数为相关的操作加上<code>cv2.bitwise_</code>前缀，例如<code>cv2.bitwise_not</code>。对于<code>2</code>元操作而言，至少两个参数(<code>src1</code>和<code>src2</code>)。参数<code>dst</code>用于返回结果，它是可选的；<code>msk</code>参数也是可选的，指定<code>msk</code>区域进行相关操作。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitwise_and(src1, src2[, dst[, mask]]) -&gt; dst</span><br></pre></td></tr></table></figure>
<p>因此可以使用参数返回结果，也可以使用赋值操作返回结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">​</span><br><span class="line"><span class="comment"># 画矩形</span></span><br><span class="line">Rectangle = np.zeros((<span class="number">300</span>, <span class="number">300</span>), dtype=<span class="string">"uint8"</span>)</span><br><span class="line">cv2.rectangle(Rectangle, (<span class="number">25</span>, <span class="number">25</span>), (<span class="number">275</span>, <span class="number">275</span>), <span class="number">255</span>, <span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Rectangle"</span>, Rectangle)</span><br><span class="line"><span class="comment"># 画圆形</span></span><br><span class="line">Circle = np.zeros((<span class="number">300</span>, <span class="number">300</span>), dtype=<span class="string">"uint8"</span>)</span><br><span class="line">cv2.circle(Circle, (<span class="number">150</span>, <span class="number">150</span>), <span class="number">150</span>, <span class="number">255</span>, <span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Circle"</span>, Circle)</span><br><span class="line"><span class="comment"># 图像的交操作</span></span><br><span class="line">bitwiseAnd = cv2.bitwise_and(Rectangle, Circle)</span><br><span class="line">cv2.imshow(<span class="string">"AND"</span>, bitwiseAnd)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/07/opencv和图像处理/位操作/1.png" height="222" width="628"></p>
<p>&emsp;&emsp;代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">​</span><br><span class="line"><span class="comment"># 画矩形</span></span><br><span class="line">Rectangle = np.zeros((<span class="number">300</span>, <span class="number">300</span>), dtype=<span class="string">"uint8"</span>)</span><br><span class="line">cv2.rectangle(Rectangle, (<span class="number">25</span>, <span class="number">25</span>), (<span class="number">275</span>, <span class="number">275</span>), <span class="number">255</span>, <span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Rectangle"</span>, Rectangle)</span><br><span class="line"><span class="comment"># 画圆形</span></span><br><span class="line">Circle = np.zeros((<span class="number">300</span>, <span class="number">300</span>), dtype=<span class="string">"uint8"</span>)</span><br><span class="line">cv2.circle(Circle, (<span class="number">150</span>, <span class="number">150</span>), <span class="number">150</span>, <span class="number">255</span>, <span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Circle"</span>, Circle)</span><br><span class="line"><span class="comment"># 图像的或操作</span></span><br><span class="line">bitwiseOr = cv2.bitwise_or(Rectangle, Circle)</span><br><span class="line">cv2.imshow(<span class="string">"OR"</span>, bitwiseOr)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/07/opencv和图像处理/位操作/2.png" height="220" width="628"></p>
<p>&emsp;&emsp;代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">​</span><br><span class="line"><span class="comment"># 画矩形</span></span><br><span class="line">Rectangle = np.zeros((<span class="number">300</span>, <span class="number">300</span>), dtype=<span class="string">"uint8"</span>)</span><br><span class="line">cv2.rectangle(Rectangle, (<span class="number">25</span>, <span class="number">25</span>), (<span class="number">275</span>, <span class="number">275</span>), <span class="number">255</span>, <span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Rectangle"</span>, Rectangle)</span><br><span class="line"><span class="comment"># 画圆形</span></span><br><span class="line">Circle = np.zeros((<span class="number">300</span>, <span class="number">300</span>), dtype=<span class="string">"uint8"</span>)</span><br><span class="line">cv2.circle(Circle, (<span class="number">150</span>, <span class="number">150</span>), <span class="number">150</span>, <span class="number">255</span>, <span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Circle"</span>, Circle)</span><br><span class="line"><span class="comment"># 图像的异或操作</span></span><br><span class="line">bitwiseXor = cv2.bitwise_xor(Rectangle, Circle)</span><br><span class="line">cv2.imshow(<span class="string">"XOR"</span>, bitwiseXor)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/07/opencv和图像处理/位操作/3.png" height="221" width="628"></p>
<p>&emsp;&emsp;代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">​</span><br><span class="line"><span class="comment"># 画圆形</span></span><br><span class="line">Circle = np.zeros((<span class="number">300</span>, <span class="number">300</span>), dtype=<span class="string">"uint8"</span>)</span><br><span class="line">cv2.circle(Circle, (<span class="number">150</span>, <span class="number">150</span>), <span class="number">150</span>, <span class="number">255</span>, <span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Circle"</span>, Circle)</span><br><span class="line"><span class="comment"># 圆形的非运算操作</span></span><br><span class="line">bitwiseNot = cv2.bitwise_not(Circle)</span><br><span class="line">cv2.imshow(<span class="string">"NOT"</span>, bitwiseNot)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/07/opencv和图像处理/位操作/4.png" height="219" width="417"></p>
<h3 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h3><p>&emsp;&emsp;该函数用于图像矩阵相加：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(src1, src2, dst=<span class="keyword">None</span>, mask=<span class="keyword">None</span>, dtype=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<p>参数<code>src1</code>是图像矩阵<code>1</code>，src2是图像矩阵<code>2</code>，<code>dst</code>、<code>mask</code>和<code>dtype</code>一般采用默认选项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">​</span><br><span class="line">image = cv2.imread(<span class="string">"timg.jpg"</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>, image)</span><br><span class="line"><span class="comment"># 图像image各像素加100</span></span><br><span class="line">M = np.ones(image.shape, dtype=<span class="string">"uint8"</span>) * <span class="number">100</span>  <span class="comment"># 与image大小一样的全100矩阵</span></span><br><span class="line">added = cv2.add(image, M)  <span class="comment"># 将图像image与M相加</span></span><br><span class="line">cv2.imshow(<span class="string">"Added"</span>, added)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/07/opencv和图像处理/位操作/5.png" height="278" width="543"></p>
<h3 id="subtract函数"><a href="#subtract函数" class="headerlink" title="subtract函数"></a>subtract函数</h3><p>&emsp;&emsp;该函数用于图像矩阵相减：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subtract(src1, src2, dst=<span class="keyword">None</span>, mask=<span class="keyword">None</span>, dtype=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<p>参数<code>src1</code>是图像矩阵<code>1</code>，<code>src2</code>是图像矩阵<code>2</code>，<code>dst</code>、<code>mask</code>和<code>dtype</code>一般采用默认选项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">​</span><br><span class="line">image = cv2.imread(<span class="string">"timg.jpg"</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>, image)</span><br><span class="line"><span class="comment"># 图像image各像素减去50</span></span><br><span class="line">M = np.ones(image.shape, dtype=<span class="string">"uint8"</span>) * <span class="number">50</span>  <span class="comment"># 与image大小一样的全50矩阵</span></span><br><span class="line">subtracted = cv2.subtract(image, M)  <span class="comment"># 将图像image与M相减</span></span><br><span class="line">cv2.imshow(<span class="string">"Subtracted"</span>, subtracted)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/07/opencv和图像处理/位操作/6.png" height="279" width="542"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/07/opencv和图像处理/全景拼接/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/opencv和图像处理/全景拼接/" itemprop="url">全景拼接</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T15:04:09+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;官方代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui/highgui.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/stitching/stitcher.hpp"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">bool</span> try_use_gpu = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Mat&gt; imgs;</span><br><span class="line"><span class="built_in">string</span> result_name = <span class="string">"result.jpg"</span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUsage</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseCmdArgs</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval = parseCmdArgs ( argc, argv );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( retval ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    Mat pano;</span><br><span class="line">    Stitcher stitcher = Stitcher::createDefault ( try_use_gpu );</span><br><span class="line">    Stitcher::Status status = stitcher.stitch ( imgs, pano );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( status != Stitcher::OK ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Can't stitch images, error code = "</span> &lt;&lt; <span class="keyword">int</span> ( status ) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    imwrite ( result_name, pano );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUsage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">         <span class="string">"Rotation model images stitcher.\n\n"</span></span><br><span class="line">         <span class="string">"stitching img1 img2 [...imgN]\n\n"</span></span><br><span class="line">         <span class="string">"Flags:\n"</span></span><br><span class="line">         <span class="string">"  --try_use_gpu (yes|no)\n"</span></span><br><span class="line">         <span class="string">"      Try to use GPU. The default value is 'no'. All default values\n"</span></span><br><span class="line">         <span class="string">"      are for CPU mode.\n"</span></span><br><span class="line">         <span class="string">"  --output &lt;result_img&gt;\n"</span></span><br><span class="line">         <span class="string">"      The default is 'result.jpg'.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseCmdArgs</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc == <span class="number">1</span> ) &#123;</span><br><span class="line">        printUsage();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; ++i ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">string</span> ( argv[i] ) == <span class="string">"--help"</span> || <span class="built_in">string</span> ( argv[i] ) == <span class="string">"/?"</span> ) &#123;</span><br><span class="line">            printUsage();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">string</span> ( argv[i] ) == <span class="string">"--try_use_gpu"</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">string</span> ( argv[i + <span class="number">1</span>] ) == <span class="string">"no"</span> ) &#123;</span><br><span class="line">                try_use_gpu = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">string</span> ( argv[i + <span class="number">1</span>] ) == <span class="string">"yes"</span> ) &#123;</span><br><span class="line">                try_use_gpu = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad --try_use_gpu flag value\n"</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">string</span> ( argv[i] ) == <span class="string">"--output"</span> ) &#123;</span><br><span class="line">            result_name = argv[i + <span class="number">1</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Mat img = imread ( argv[i] );</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( img.empty() ) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Can't read image '"</span> &lt;&lt; argv[i] &lt;&lt; <span class="string">"'\n"</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            imgs.push_back ( img );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/07/opencv和图像处理/全景拼接/1.png"></p>
<p>&emsp;&emsp;基于不同模式的全景拼接如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui/highgui.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/stitching/stitcher.hpp"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">bool</span> try_use_gpu = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Mat&gt; imgs;</span><br><span class="line"><span class="built_in">string</span> result_name = <span class="string">"result.jpg"</span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseCmdArgs</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 输入的图片全部填充到容器imgs中，并将输入的图片显示出来 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        Mat img = imread(argv[i]);</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> (img.empty()) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Can't read image '"</span> &lt;&lt; argv[i] &lt;&lt; <span class="string">"'\n"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        imgs.push_back(img);</span><br><span class="line">        imshow(argv[i], img);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval = parseCmdArgs(argc, argv);</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    Mat pano;</span><br><span class="line">    <span class="comment">/* 创建一个stitcher对象 */</span></span><br><span class="line">    Stitcher stitcher = Stitcher::createDefault(try_use_gpu);</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">3</span>][<span class="number">0</span>] == <span class="string">'1'</span>) &#123;  <span class="comment">/* 1是平面拼接 */</span></span><br><span class="line">        PlaneWarper *cw = <span class="keyword">new</span> PlaneWarper();</span><br><span class="line">        stitcher.setWarper(cw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argv[<span class="number">3</span>][<span class="number">0</span>] == <span class="string">'2'</span>) &#123; <span class="comment">/* 2是柱面拼接 */</span></span><br><span class="line">        SphericalWarper *cw = <span class="keyword">new</span> SphericalWarper();</span><br><span class="line">        stitcher.setWarper(cw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argv[<span class="number">3</span>][<span class="number">0</span>] == <span class="string">'3'</span>) &#123; <span class="comment">/* 3是立体画面拼接 */</span></span><br><span class="line">        StereographicWarper *cw = <span class="keyword">new</span> cv::StereographicWarper();</span><br><span class="line">        stitcher.setWarper(cw);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 使用Surf算法来寻找特征点，支持Surf和Orb两种方式 */</span></span><br><span class="line">    detail::SurfFeaturesFinder *featureFinder = <span class="keyword">new</span> detail::SurfFeaturesFinder();</span><br><span class="line">    stitcher.setFeaturesFinder(featureFinder);</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 匹配给定的图像和估计相机的旋转 */</span></span><br><span class="line">    Stitcher::Status status = stitcher.estimateTransform(imgs);</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> (status != Stitcher::OK) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Can't stitch images, error code = "</span> &lt;&lt; <span class="keyword">int</span>(status) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    status = stitcher.composePanorama(pano); <span class="comment">/* 生成全景图像 */</span>  </span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> (status != Stitcher::OK) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Can't stitch images, error code = "</span> &lt;&lt; <span class="keyword">int</span>(status) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    imwrite(result_name, pano);</span><br><span class="line">    imshow(<span class="string">"show"</span>, pano);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/07/opencv和图像处理/全景拼接/2.png"></p>
<hr>
<h3 id="基于OpenCV全景拼接"><a href="#基于OpenCV全景拼接" class="headerlink" title="基于OpenCV全景拼接"></a>基于OpenCV全景拼接</h3><p>&emsp;&emsp;基于<code>OpenCV</code>的图片拼接和全景图构建，用于<code>缝合</code>两张有重叠区域的图来创建一张全景图。构建全景图利用到的计算机视觉和图像处理技术有：关键点检测、局部不变特征、关键点匹配、<code>RANSAC</code>和透视变形。因为处理关键点检测和局部不变性在<code>OpenCV 2.4.X</code>和<code>OpenCV 3.X</code>中有很大的不同，比如<code>SIFT</code>和<code>SURF</code>，这里将给出兼容两个版本的代码。<br>&emsp;&emsp;全景拼接算法由四部分组成：</p>
<ul>
<li><code>Step 1</code>: Detect keypoints (<code>DoG</code>, <code>Harris</code> etc) and extract local invariant descriptors (<code>SIFT</code>, <code>SURF</code> etc) from the two input images.</li>
<li><code>Step 2</code>: Match the descriptors between the two images.</li>
<li><code>Step 3</code>: Use the <code>RANSAC</code> algorithm to estimate a homography matrix using our matched feature vectors.</li>
<li><code>Step 4</code>: Apply a warping transformation using the homography matrix obtained from <code>Step 3</code>.</li>
</ul>
<p>将所有的步骤都封装在<code>panorama.py</code>，定义一个<code>Stitcher</code>类来构建全图。<br>&emsp;&emsp;<code>panorama.py</code>如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> imutils</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stitcher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.isv3 = imutils.is_cv3()  <span class="comment"># determine if we are using OpenCV v3.X</span></span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stitch</span><span class="params">(self, images, ratio=<span class="number">0.75</span>, reprojThresh=<span class="number">4.0</span>, showMatches=False)</span>:</span></span><br><span class="line">        <span class="comment"># unpack the images, then detect keypoints and extract local invariant descriptors from them</span></span><br><span class="line">        (imageB, imageA) = images</span><br><span class="line">        (kpsA, featuresA) = self.detectAndDescribe(imageA)</span><br><span class="line">        (kpsB, featuresB) = self.detectAndDescribe(imageB)</span><br><span class="line">        <span class="comment"># match features between the two images</span></span><br><span class="line">        M = self.matchKeypoints(kpsA, kpsB, featuresA, featuresB, ratio, reprojThresh)</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> M <span class="keyword">is</span> <span class="keyword">None</span>:  <span class="comment"># if the match is None, then there aren't enough matched keypoints to create a panorama</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">​</span><br><span class="line">        (matches, H, status) = M  <span class="comment"># otherwise, apply a perspective warp to stitch the images together</span></span><br><span class="line">        result = cv2.warpPerspective(imageA, H, (imageA.shape[<span class="number">1</span>] + imageB.shape[<span class="number">1</span>], imageA.shape[<span class="number">0</span>]))</span><br><span class="line">        result[<span class="number">0</span>:imageB.shape[<span class="number">0</span>], <span class="number">0</span>:imageB.shape[<span class="number">1</span>]] = imageB</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> showMatches:  <span class="comment"># check to see if the keypoint matches should be visualized</span></span><br><span class="line">            vis = self.drawMatches(imageA, imageB, kpsA, kpsB, matches, status)</span><br><span class="line">            <span class="keyword">return</span> (result, vis)  <span class="comment"># return a tuple of the stitched image and the visualization</span></span><br><span class="line">​</span><br><span class="line">        <span class="keyword">return</span> result  <span class="comment"># return the stitched image</span></span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectAndDescribe</span><span class="params">(self, image)</span>:</span></span><br><span class="line">        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  <span class="comment"># convert the image to grayscale</span></span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> self.isv3:  <span class="comment"># check to see if we are using OpenCV 3.X</span></span><br><span class="line">            descriptor = cv2.xfeatures2d.SIFT_create()  <span class="comment"># detect and extract features from the image</span></span><br><span class="line">            (kps, features) = descriptor.detectAndCompute(image, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># otherwise, we are using OpenCV 2.4.X</span></span><br><span class="line">            detector = cv2.FeatureDetector_create(<span class="string">"SIFT"</span>)  <span class="comment"># detect keypoints in the image</span></span><br><span class="line">            kps = detector.detect(gray)</span><br><span class="line">            extractor = cv2.DescriptorExtractor_create(<span class="string">"SIFT"</span>)  <span class="comment"># extract features from the image</span></span><br><span class="line">            (kps, features) = extractor.compute(gray, kps)</span><br><span class="line">​</span><br><span class="line">        kps = np.float32([kp.pt <span class="keyword">for</span> kp <span class="keyword">in</span> kps])  <span class="comment"># convert the keypoints from KeyPoint objects to NumPy arrays</span></span><br><span class="line">        <span class="keyword">return</span> (kps, features)  <span class="comment"># return a tuple of keypoints and features</span></span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matchKeypoints</span><span class="params">(self, kpsA, kpsB, featuresA, featuresB, ratio, reprojThresh)</span>:</span></span><br><span class="line">        <span class="comment"># compute the raw matches and initialize the list of actual matches</span></span><br><span class="line">        matcher = cv2.DescriptorMatcher_create(<span class="string">"BruteForce"</span>)</span><br><span class="line">        rawMatches = matcher.knnMatch(featuresA, featuresB, <span class="number">2</span>)</span><br><span class="line">        matches = []</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> rawMatches:  <span class="comment"># loop over the raw matches</span></span><br><span class="line">            <span class="comment"># ensure the distance is within a certain ratio of each other (i.e. Lowe's ratio test)</span></span><br><span class="line">            <span class="keyword">if</span> len(m) == <span class="number">2</span> <span class="keyword">and</span> m[<span class="number">0</span>].distance &lt; m[<span class="number">1</span>].distance * ratio:</span><br><span class="line">                matches.append((m[<span class="number">0</span>].trainIdx, m[<span class="number">0</span>].queryIdx))</span><br><span class="line">        <span class="keyword">if</span> len(matches) &gt; <span class="number">4</span>:  <span class="comment"># computing a homography requires at least 4 matches</span></span><br><span class="line">            <span class="comment"># construct the two sets of points</span></span><br><span class="line">            ptsA = np.float32([kpsA[i] <span class="keyword">for</span> (_, i) <span class="keyword">in</span> matches])</span><br><span class="line">            ptsB = np.float32([kpsB[i] <span class="keyword">for</span> (i, _) <span class="keyword">in</span> matches])</span><br><span class="line">            <span class="comment"># compute the homography between the two sets of points</span></span><br><span class="line">            (H, status) = cv2.findHomography(ptsA, ptsB, cv2.RANSAC, reprojThresh)</span><br><span class="line">            <span class="comment"># return the matches along with the homograpy matrix and status of each matched point</span></span><br><span class="line">            <span class="keyword">return</span> (matches, H, status)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span>  <span class="comment"># otherwise, no homograpy could be computed</span></span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drawMatches</span><span class="params">(self, imageA, imageB, kpsA, kpsB, matches, status)</span>:</span></span><br><span class="line">        <span class="comment"># initialize the output visualization image</span></span><br><span class="line">        (hA, wA) = imageA.shape[:<span class="number">2</span>]</span><br><span class="line">        (hB, wB) = imageB.shape[:<span class="number">2</span>]</span><br><span class="line">        vis = np.zeros((max(hA, hB), wA + wB, <span class="number">3</span>), dtype=<span class="string">"uint8"</span>)</span><br><span class="line">        vis[<span class="number">0</span>:hA, <span class="number">0</span>:wA] = imageA</span><br><span class="line">        vis[<span class="number">0</span>:hB, wA:] = imageB</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">for</span> ((trainIdx, queryIdx), s) <span class="keyword">in</span> zip(matches, status):  <span class="comment"># loop over the matches</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="number">1</span>:  <span class="comment"># only process the match if the keypoint was successfully matched</span></span><br><span class="line">                <span class="comment"># draw the match</span></span><br><span class="line">                ptA = (int(kpsA[queryIdx][<span class="number">0</span>]), int(kpsA[queryIdx][<span class="number">1</span>]))</span><br><span class="line">                ptB = (int(kpsB[trainIdx][<span class="number">0</span>]) + wA, int(kpsB[trainIdx][<span class="number">1</span>]))</span><br><span class="line">                cv2.line(vis, ptA, ptB, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> vis  <span class="comment"># return the visualization</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Let’s go ahead and get started by reviewing <code>panorama.py</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> imutils</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stitcher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.isv3 = imutils.is_cv3()  <span class="comment"># determine if we are using OpenCV v3.X</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;We start off on <code>Lines 1-3</code> by importing our necessary packages. We’ll be using <code>NumPy</code> for <code>matrix/array</code> operations, <code>imutils</code> for a set of <code>OpenCV</code> convenience methods, and finally <code>cv2</code> for our <code>OpenCV</code> bindings.<br>&emsp;&emsp;From there, we define the <code>Stitcher</code> class on <code>Line 5</code>. The constructor to <code>Stitcher</code> simply checks which version of <code>OpenCV</code> we are using by making a call to the <code>is_cv3</code> method. Since there are major differences in how <code>OpenCV 2.4</code> and <code>OpenCV 3</code> handle keypoint detection and local invariant descriptors, it’s important that we determine the version of <code>OpenCV</code> that we are using.<br>&emsp;&emsp;Next up, let’s start working on the <code>stitch</code> method:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stitch</span><span class="params">(self, images, ratio=<span class="number">0.75</span>, reprojThresh=<span class="number">4.0</span>, showMatches=False)</span>:</span></span><br><span class="line">    <span class="comment"># unpack the images, then detect keypoints and extract local invariant descriptors from them</span></span><br><span class="line">    (imageB, imageA) = images</span><br><span class="line">    (kpsA, featuresA) = self.detectAndDescribe(imageA)</span><br><span class="line">    (kpsB, featuresB) = self.detectAndDescribe(imageB)</span><br><span class="line">    <span class="comment"># match features between the two images</span></span><br><span class="line">    M = self.matchKeypoints(kpsA, kpsB, featuresA, featuresB, ratio, reprojThresh)</span><br><span class="line">    <span class="keyword">if</span> M <span class="keyword">is</span> <span class="keyword">None</span>:  <span class="comment"># if the match is None, then there aren't enough matched keypoints to create a panorama</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>stitch</code> method requires only a single parameter, <code>images</code>, which is the list of (two) images that we are going to <code>stitch</code> together to form the panorama.<br>&emsp;&emsp;We can also optionally supply <code>ratio</code>, used for <code>David Lowe&#39;s</code> ratio test when matching features, <code>reprojThresh</code> which is the maximum pixel <code>wiggle room</code> allowed by the <code>RANSAC</code> algorithm, and finally <code>showMatches</code>, a <code>boolean</code> used to indicate if the keypoint matches should be visualized or not.<br>&emsp;&emsp;<code>Line 3</code> unpacks the <code>images</code> list (which again, we presume to contain only two images). The ordering to the <code>images</code> list is important: we expect <code>images</code> to be supplied in <code>left-to-right</code> order. If <code>images</code> are not supplied in this order, then our code will still run, but our output panorama will only contain one image, not both.<br>&emsp;&emsp;Once we have unpacked the <code>images</code> list, we make a call to the <code>detectAndDescribe</code> method on <code>Lines 4</code> and <code>5</code>. This method simply detects keypoints and extracts local invariant descriptors (i.e. <code>SIFT</code>) from the two images.<br>&emsp;&emsp;Given the keypoints and features, we use <code>matchKeypoints</code> (Lines <code>7</code>) to match the features in the two images. We’ll define this method later in the lesson.<br>&emsp;&emsp;If the returned matches <code>M</code> are <code>None</code>, then not enough keypoints were matched to create a panorama, so we simply return to the calling function.<br>&emsp;&emsp;Otherwise, we are now ready to apply the perspective transform:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(matches, H, status) = M  <span class="comment"># otherwise, apply a perspective warp to stitch the images together</span></span><br><span class="line">result = cv2.warpPerspective(imageA, H, (imageA.shape[<span class="number">1</span>] + imageB.shape[<span class="number">1</span>], imageA.shape[<span class="number">0</span>]))</span><br><span class="line">result[<span class="number">0</span>:imageB.shape[<span class="number">0</span>], <span class="number">0</span>:imageB.shape[<span class="number">1</span>]] = imageB</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> showMatches:  <span class="comment"># check to see if the keypoint matches should be visualized</span></span><br><span class="line">    vis = self.drawMatches(imageA, imageB, kpsA, kpsB, matches, status)</span><br><span class="line">    <span class="keyword">return</span> (result, vis)  <span class="comment"># return a tuple of the stitched image and the visualization</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">return</span> result  <span class="comment"># return the stitched image</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Provided that <code>M</code> is not <code>None</code>, we unpack the tuple on <code>Line 1</code>, giving us a list of keypoint matches, the homography matrix <code>H</code> derived from the <code>RANSAC</code> algorithm, and finally status, a list of indexes to indicate which keypoints in matches were successfully spatially verified using <code>RANSAC</code>.<br>&emsp;&emsp;Given our homography matrix <code>H</code>, we are now ready to stitch the two images together. First, we make a call to <code>cv2.warpPerspective</code> which requires three arguments: the image we want to warp (in this case, the right image), the <code>3 x 3</code> transformation matrix (<code>H</code>), and finally the shape out of the output image. We derive the shape out of the output image by taking the sum of the widths of both images and then using the height of the second image.<br>&emsp;&emsp;<code>Line 5</code> makes a check to see if we should visualize the keypoint matches, and if so, we make a call to <code>drawMatches</code> and return a tuple of both the panorama and visualization to the calling method. Otherwise, we simply returned the stitched image.<br>&emsp;&emsp;Now that the stitch method has been defined, let’s look into some of the helper methods that it calls. We’ll start with <code>detectAndDescribe</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectAndDescribe</span><span class="params">(self, image)</span>:</span></span><br><span class="line">    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  <span class="comment"># convert the image to grayscale</span></span><br><span class="line">    <span class="keyword">if</span> self.isv3:  <span class="comment"># check to see if we are using OpenCV 3.X</span></span><br><span class="line">        descriptor = cv2.xfeatures2d.SIFT_create()  <span class="comment"># detect and extract features from the image</span></span><br><span class="line">        (kps, features) = descriptor.detectAndCompute(image, <span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># otherwise, we are using OpenCV 2.4.X</span></span><br><span class="line">        detector = cv2.FeatureDetector_create(<span class="string">"SIFT"</span>)  <span class="comment"># detect keypoints in the image</span></span><br><span class="line">        kps = detector.detect(gray)</span><br><span class="line">        extractor = cv2.DescriptorExtractor_create(<span class="string">"SIFT"</span>)  <span class="comment"># extract features from the image</span></span><br><span class="line">        (kps, features) = extractor.compute(gray, kps)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># convert the keypoints from KeyPoint objects to NumPy arrays</span></span><br><span class="line">    kps = np.float32([kp.pt <span class="keyword">for</span> kp <span class="keyword">in</span> kps])</span><br><span class="line">    <span class="keyword">return</span> (kps, features)  <span class="comment"># return a tuple of keypoints and features</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;As the name suggests, the <code>detectAndDescribe</code> method accepts an image, then detects keypoints and extracts local invariant descriptors. In our implementation we use the <code>Difference of Gaussian</code> (<code>DoG</code>) keypoint detector and the <code>SIFT</code> feature extractor.<br>&emsp;&emsp;On <code>Line 3</code> we check to see if we are using <code>OpenCV 3.X</code>. If we are, then we use the <code>cv2.xfeatures2d.SIFT_create</code> function to instantiate both our <code>DoG</code> keypoint detector and <code>SIFT</code> feature extractor. A call to <code>detectAndCompute</code> handles extracting the keypoints and features.<br>&emsp;&emsp;<code>Lines 7-10</code> handle if we are using <code>OpenCV 2.4</code>. The <code>cv2.FeatureDetector_create</code> function instantiates our keypoint detector (<code>DoG</code>). A call to detect returns our set of keypoints.<br>&emsp;&emsp;From there, we need to initialize <code>cv2.DescriptorExtractor_create</code> using the <code>SIFT</code> keyword to setup our <code>SIFT</code> feature extractor. Calling the compute method of the extractor returns a set of feature vectors which quantify the region surrounding each of the detected keypoints in the image.<br>&emsp;&emsp;Finally, our keypoints are converted from <code>KeyPoint</code> objects to a <code>NumPy</code> array and returned to the calling method.<br>&emsp;&emsp;Next up, let’s look at the <code>matchKeypoints</code> method:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matchKeypoints</span><span class="params">(self, kpsA, kpsB, featuresA, featuresB, ratio, reprojThresh)</span>:</span></span><br><span class="line">    <span class="comment"># compute the raw matches and initialize the list of actual matches</span></span><br><span class="line">    matcher = cv2.DescriptorMatcher_create(<span class="string">"BruteForce"</span>)</span><br><span class="line">    rawMatches = matcher.knnMatch(featuresA, featuresB, <span class="number">2</span>)</span><br><span class="line">    matches = []</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> rawMatches:  <span class="comment"># loop over the raw matches</span></span><br><span class="line">        <span class="comment"># ensure the distance is within a certain ratio of each other (i.e. Lowe's ratio test)</span></span><br><span class="line">        <span class="keyword">if</span> len(m) == <span class="number">2</span> <span class="keyword">and</span> m[<span class="number">0</span>].distance &lt; m[<span class="number">1</span>].distance * ratio:</span><br><span class="line">            matches.append((m[<span class="number">0</span>].trainIdx, m[<span class="number">0</span>].queryIdx))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>matchKeypoints</code> function requires four arguments: the keypoints and feature vectors associated with the first image, followed by the keypoints and feature vectors associated with the second image. <code>David Lowe&#39;s</code> ratio test variable and <code>RANSAC</code> <code>re-projection</code> threshold are also be supplied.<br>&emsp;&emsp;Matching features together is actually a fairly straightforward process. We simply loop over the descriptors from both images, compute the distances, and find the smallest distance for each pair of descriptors. Since this is a very common practice in computer vision, <code>OpenCV</code> has a <code>built-in</code> function called <code>cv2.DescriptorMatcher_create</code> that constructs the feature matcher for us. The <code>BruteForce</code> value indicates that we are going to exhaustively compute the <code>Euclidean</code> distance between all feature vectors from both images and find the pairs of descriptors that have the smallest distance.<br>&emsp;&emsp;A call to <code>knnMatch</code> on <code>Line 4</code> performs <code>k-NN</code> matching between the two feature vector sets using <code>k=2</code> (indicating the top two matches for each feature vector are returned).<br>&emsp;&emsp;The reason we want the top two matches rather than just the top one match is because we need to apply <code>David Lowe&#39;s</code> ratio test for <code>false-positive</code> match pruning.<br>&emsp;&emsp;Again, <code>Line 4</code> computes the <code>rawMatches</code> for each pair of descriptors, but there is a chance that some of these pairs are <code>false</code> positives, meaning that the image patches are not actually true matches. In an attempt to prune these <code>false-positive</code> matches, we can loop over each of the <code>rawMatches</code> individually and apply <code>Lowe&#39;s</code> ratio test, which is used to determine <code>high-quality</code> feature matches. Typical values for <code>Lowe&#39;s</code> ratio are normally in the range <code>[0.7, 0.8]</code>.<br>&emsp;&emsp;Once we have obtained the matches using <code>Lowe&#39;s</code> ratio test, we can compute the homography between the two sets of keypoints:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> len(matches) &gt; <span class="number">4</span>:  <span class="comment"># computing a homography requires at least 4 matches</span></span><br><span class="line">    <span class="comment"># construct the two sets of points</span></span><br><span class="line">    ptsA = np.float32([kpsA[i] <span class="keyword">for</span> (_, i) <span class="keyword">in</span> matches])</span><br><span class="line">    ptsB = np.float32([kpsB[i] <span class="keyword">for</span> (i, _) <span class="keyword">in</span> matches])</span><br><span class="line">    <span class="comment"># compute the homography between the two sets of points</span></span><br><span class="line">    (H, status) = cv2.findHomography(ptsA, ptsB, cv2.RANSAC, reprojThresh)</span><br><span class="line">    <span class="comment"># return the matches along with the homograpy matrix and status of each matched point</span></span><br><span class="line">    <span class="keyword">return</span> (matches, H, status)</span><br><span class="line">​</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">None</span> <span class="comment"># otherwise, no homograpy could be computed</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Computing a homography between two sets of points requires at a bare minimum an initial set of four matches. For a more reliable homography estimation, we should have substantially more than just four matched points.<br>&emsp;&emsp;Finally, the last method in our <code>Stitcher</code> method, <code>drawMatches</code> is used to visualize keypoint correspondences between two images:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawMatches</span><span class="params">(self, imageA, imageB, kpsA, kpsB, matches, status)</span>:</span></span><br><span class="line">    <span class="comment"># initialize the output visualization image</span></span><br><span class="line">    (hA, wA) = imageA.shape[:<span class="number">2</span>]</span><br><span class="line">    (hB, wB) = imageB.shape[:<span class="number">2</span>]</span><br><span class="line">    vis = np.zeros((max(hA, hB), wA + wB, <span class="number">3</span>), dtype=<span class="string">"uint8"</span>)</span><br><span class="line">    vis[<span class="number">0</span>:hA, <span class="number">0</span>:wA] = imageA</span><br><span class="line">    vis[<span class="number">0</span>:hB, wA:] = imageB</span><br><span class="line">    <span class="keyword">for</span> ((trainIdx, queryIdx), s) <span class="keyword">in</span> zip(matches, status):  <span class="comment"># loop over the matches</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="number">1</span>:  <span class="comment"># only process the match if the keypoint was successfully matched</span></span><br><span class="line">            <span class="comment"># draw the match</span></span><br><span class="line">            ptA = (int(kpsA[queryIdx][<span class="number">0</span>]), int(kpsA[queryIdx][<span class="number">1</span>]))</span><br><span class="line">            ptB = (int(kpsB[trainIdx][<span class="number">0</span>]) + wA, int(kpsB[trainIdx][<span class="number">1</span>]))</span><br><span class="line">            cv2.line(vis, ptA, ptB, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> vis  <span class="comment"># return the visualization</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;This method requires that we pass in the two original images, the set of keypoints associated with each image, the initial matches after applying <code>Lowe&#39;s</code> ratio test, and finally the status list provided by the homography calculation. Using these variables, we can visualize the <code>inlier</code> keypoints by drawing a straight line from keypoint <code>N</code> in the first image to keypoint <code>M</code> in the second image.<br>&emsp;&emsp;示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> imutils</span><br><span class="line"><span class="keyword">from</span> panorama <span class="keyword">import</span> Stitcher</span><br><span class="line">​</span><br><span class="line">imageA = cv2.imread(<span class="string">"Panorama-1.png"</span>)</span><br><span class="line">imageB = cv2.imread(<span class="string">"Panorama-2.png"</span>)</span><br><span class="line">​</span><br><span class="line">print(<span class="string">"former size is:"</span>)</span><br><span class="line">print(imageA.shape)</span><br><span class="line">print(imageB.shape)</span><br><span class="line"><span class="comment"># 使图片的高度相等</span></span><br><span class="line">height, width = imageA.shape[:<span class="number">2</span>]</span><br><span class="line">imageB = imutils.resize(imageB, height=height)</span><br><span class="line">print(<span class="string">"after size is:"</span>)</span><br><span class="line">print(imageA.shape)</span><br><span class="line">print(imageB.shape)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># stitch the images together to create a panorama</span></span><br><span class="line">stitcher = Stitcher()</span><br><span class="line">(result, vis) = stitcher.stitch([imageA, imageB], showMatches=<span class="keyword">True</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># show the images</span></span><br><span class="line">cv2.imshow(<span class="string">"Image A"</span>, imageA)</span><br><span class="line">cv2.imshow(<span class="string">"Image B"</span>, imageB)</span><br><span class="line">cv2.imshow(<span class="string">"Keypoint Matches"</span>, vis)</span><br><span class="line">cv2.imshow(<span class="string">"Result"</span>, result)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/07/opencv和图像处理/全景拼接/3.png" height="236" width="572"></p>
<p><img src="/2019/03/07/opencv和图像处理/全景拼接/4.png" height="470" width="573"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/07/opencv和图像处理/meanshift跟踪算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/opencv和图像处理/meanshift跟踪算法/" itemprop="url">meanshift跟踪算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T14:05:39+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;首先介绍一下<code>meanshift</code>算法，它的本质是一个迭代的过程，能够在一组数据的密度分布中寻找到局部极值。它比较稳定，而且是无参密度估计(不需要事先知道样本数据的概率密度分布函数，完全依靠对样本点的计算)，而且在采样充分的情况下，一定会收敛，即可以对服从任意分布的数据进行密度估计。<br>&emsp;&emsp;这里就不把<code>meanshift</code>的数学公式都写出来了，只为了让大家知道<code>meanshift</code>的作用是什么；高维的部分也先不考虑，以二维来说明可能更容易理解。下图中的很多的红点就是我们的样本特征点，<code>meanshift</code>就是在这些点中的任意一个点为圆心，然后以半径<code>R</code>画一个圆(在<code>OpenCV</code>中是一个矩形)，然后落在这个圆中的所有点和圆心都会有对应的一个向量，把所有这些向量相加(注意是向量相加)，最终只得到一个向量，就是下图中用黄色箭头表示的向量，这个向量就是<code>meanshift</code>向量。</p>
<p><img src="/2019/03/07/opencv和图像处理/meanshift跟踪算法/1.png" height="193" width="295"></p>
<p>然后再以这个<code>meanshift</code>向量的终点为圆心，继续上述过程，又可以得到一个<code>meanshift</code>向量：</p>
<p><img src="/2019/03/07/opencv和图像处理/meanshift跟踪算法/2.png" height="184" width="293"></p>
<p>然后不断地继续这样的过程，可以得到很多连续的<code>meanshift</code>向量。将这些向量首尾相连，最终会在一个地方停下来(即<code>meanshift</code>算法会收敛)，最后的那个<code>meanshift</code>向量的终点就是最终结果(一个点)：</p>
<p><img src="/2019/03/07/opencv和图像处理/meanshift跟踪算法/3.png" height="180" width="290"></p>
<p>从上述的过程可以看出，<code>meanshift</code>算法的最终效果就是：从起点开始，最终会一步一步到达样本特征点最密集的点那里(当然在哪个点是终点就要取决于设定的阈值)。<br>&emsp;&emsp;到这里可能只知道<code>meanshift</code>算法的作用是向数据密集的地方走的一个效果，但是还是不明白它是怎么在运动跟踪中发挥作用的，尤其是不理解它这个样本特征点(就是上图中的红点)到底和我们图像中的什么对应的。<br>&emsp;&emsp;对于上面这个问题，我们需要先了解一下运动跟踪算法是一个什么样的过程，知道了这个过程之后，就可以知道<code>meanshift</code>算法在这个过程中发挥的作用了。运动跟踪说到底就是在一开始告诉程序一个跟踪目标，然后程序就在接下来的视频帧中去寻找这个目标。给定跟踪目标很简单，直接在图像中给一个<code>ROI</code>给程序就可以了，那么程序接下来要做的就是在下一帧图像中去找这个<code>ROI</code>。但这个<code>ROI</code>是移动了的，已经不在之前的那个位置了，那么此时程序要怎么来找到这个<code>ROI</code>呢？在计算机视觉中，我们是这么来解决的：首先对跟踪目标进行描述，这个描述是将跟踪目标区域转换为颜色<code>HSV</code>空间，然后得到H的这个通道的分布直方图，有了这个描述之后，我们就是要在下一个视频帧中找到和这个描述的一样的区域。但是我们知道要找到完全一样的区域很难，所以我们就用了一个相似函数来衡量找到的区域和目标区域的相似度，通过这个相似函数，相似函数值越大说明我们寻找的区域和目标区域越相似，所以目标就是要找这个对应最大相似值的区域。那么怎么来寻找呢？这时<code>meanshift</code>就排上用场了，它可以通过不断地迭代得到有最大相似值的区域。<code>meanshift</code>的作用可以让我们的搜索窗口不断向两个模型相比颜色变化最大的方向不断移动，直到最后两次移动距离小于阈值，即找到当前帧的位置，并以此作为下一帧的起始搜索窗口中心。重复这个过程，每两帧之间都会产生一个<code>meanshift</code>向量，整个过程的<code>meanshift</code>向量连起来就是目标的运动路径。<br>&emsp;&emsp;整个运动跟踪过程就是如下：</p>
<p><img src="/2019/03/07/opencv和图像处理/meanshift跟踪算法/4.png"></p>
<hr>
<h3 id="Meanshift"><a href="#Meanshift" class="headerlink" title="Meanshift"></a>Meanshift</h3><p>&emsp;&emsp;The intuition behind the <code>meanshift</code> is simple. Consider you have a set of points. (It can be a pixel distribution like histogram backprojection). You are given a small window (may be a circle) and you have to move that window to the area of maximum pixel density (or maximum number of points). It is illustrated in the simple image given below:</p>
<p><img src="/2019/03/07/opencv和图像处理/meanshift跟踪算法/5.png" height="222" width="296"></p>
<p>&emsp;&emsp;The initial window is shown in blue circle with the name <code>C1</code>. Its original center is marked in blue rectangle, named <code>C1_o</code>. But if you find the centroid of the points inside that window, you will get the point <code>C1_r</code> (marked in small blue circle) which is the real centroid of window. Surely they don’t match. So move your window such that circle of the new window matches with previous centroid. Again find the new centroid. Most probably, it won’t match. So move it again, and continue the iterations such that center of window and its centroid falls on the same location (or with a small desired error). So finally what you obtain is a window with maximum pixel distribution. It is marked with green circle, named <code>C2</code>. As you can see in image, it has maximum number of points.<br>&emsp;&emsp;So we normally pass the histogram backprojected image and initial target location. When the object moves, obviously the movement is reflected in histogram backprojected image. As a result, <code>meanshift</code> algorithm moves our window to the new location with maximum density.</p>
<h3 id="Meanshift-in-OpenCV"><a href="#Meanshift-in-OpenCV" class="headerlink" title="Meanshift in OpenCV"></a>Meanshift in OpenCV</h3><p>&emsp;&emsp;To use <code>meanshift</code> in <code>OpenCV</code>, first we need to setup the target, find its histogram so that we can backproject the target on each frame for calculation of <code>meanshift</code>. We also need to provide initial location of window. For histogram, only <code>Hue</code> is considered here. Also, to avoid <code>false</code> values due to low light, low light values are discarded using <code>cv2.inRange()</code> function.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">​</span><br><span class="line">cap = cv2.VideoCapture(<span class="string">'output_2.avi'</span>)</span><br><span class="line">ret, frame = cap.read()  <span class="comment"># take first frame of the video</span></span><br><span class="line">print(frame.shape)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># setup initial location of window</span></span><br><span class="line">r, h, c, w = <span class="number">200</span>, <span class="number">170</span>, <span class="number">260</span>, <span class="number">100</span>  <span class="comment"># simply hardcoded the values</span></span><br><span class="line">track_window = (c, r, w, h)</span><br><span class="line">​</span><br><span class="line">cv2.rectangle(frame, (c, r), (c + w, r + h), <span class="number">255</span>, <span class="number">2</span>)</span><br><span class="line">cv2.imshow(<span class="string">"frame"</span>, frame)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># set up the ROI for tracking</span></span><br><span class="line">roi = frame[r:r + h, c:c + w]</span><br><span class="line">hsv_roi = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</span><br><span class="line">mask = cv2.inRange(hsv_roi, np.array((<span class="number">140.</span>, <span class="number">140.</span>, <span class="number">140.</span>)), np.array((<span class="number">290.</span>, <span class="number">290.</span>, <span class="number">290.</span>)))</span><br><span class="line">roi_hist = cv2.calcHist([hsv_roi], [<span class="number">0</span>], mask, [<span class="number">180</span>], [<span class="number">0</span>, <span class="number">180</span>])</span><br><span class="line">cv2.normalize(roi_hist, roi_hist, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Setup the termination criteria, either 10 iteration or move by at least 1 pt</span></span><br><span class="line">term_crit = (cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, <span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">True</span>):</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ret == <span class="keyword">True</span>:</span><br><span class="line">        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</span><br><span class="line">        dst = cv2.calcBackProject([hsv], [<span class="number">0</span>], roi_hist, [<span class="number">0</span>, <span class="number">180</span>], <span class="number">1</span>)</span><br><span class="line">​</span><br><span class="line">        <span class="comment"># apply meanshift to get the new location</span></span><br><span class="line">        ret, track_window = cv2.meanShift(dst, track_window, term_crit)</span><br><span class="line">​</span><br><span class="line">        <span class="comment"># Draw it on image</span></span><br><span class="line">        x, y, w, h = track_window</span><br><span class="line">        img2 = cv2.rectangle(frame, (x, y), (x + w, y + h), <span class="number">255</span>, <span class="number">2</span>)</span><br><span class="line">        cv2.imshow(<span class="string">'img2'</span>, img2)</span><br><span class="line">​</span><br><span class="line">        k = cv2.waitKey(<span class="number">60</span>) &amp; <span class="number">0xff</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cv2.imwrite(chr(k) + <span class="string">".jpg"</span>, img2)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">​</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line">cap.release()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/07/opencv和图像处理/meanshift跟踪算法/6.png" height="236" width="224"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/07/opencv和图像处理/RANSAC算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/opencv和图像处理/RANSAC算法/" itemprop="url">RANSAC算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T13:13:26+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;随机抽样一致算法(<code>random sample consensus</code>，<code>RANSAC</code>)采用迭代的方式从一组包含离群的被观测数据中估算出数学模型的参数。它是一种不确定的算法，即有一定的概率得出一个合理的结果；为了提高概率必须提高迭代次数。<br>&emsp;&emsp;<code>RANSAC</code>算法的基本假设是样本中包含正确数据(<code>inliers</code>，可以被模型描述的数据)，也包含异常数据(<code>outliers</code>，偏离正常范围很远、无法适应数学模型的数据)，即数据集中含有噪声。这些异常数据可能是由于错误的测量、错误的假设、错误的计算等产生的。同时<code>RANSAC</code>也假设，给定一组正确的数据，存在可以计算出符合这些数据的模型参数的方法。<br>&emsp;&emsp;一个简单的例子是从一组观测数据中找出合适的<code>2</code>维直线。假设观测数据中包含局内点和局外点，其中局内点近似的被直线所通过，而局外点远离于直线。简单的最小二乘法不能找到适应于局内点的直线，原因是最小二乘法尽量去适应包括局外点在内的所有点。相反，<code>RANSAC</code>能得出一个仅仅用局内点计算出模型，并且概率还足够高。但是，<code>RANSAC</code>并不能保证结果一定正确，为了保证算法有足够高的合理概率，我们必须小心的选择算法的参数。左图是包含很多局外点的数据集，右图是<code>RANSAC</code>找到的直线，注意局外点并不影响结果。</p>
<p><img src="/2019/03/07/opencv和图像处理/RANSAC算法/1.png"></p>
<p>&emsp;&emsp;<code>RANSAC</code>算法的输入是一组观测数据，一个可以解释或者适应于观测数据的参数化模型，一些可信的参数。<code>RANSAC</code>通过反复选择数据中的一组随机子集来达成目标。被选取的子集被假设为局内点，并用下述方法进行验证：</p>
<ol>
<li>有一个模型适应于假设的局内点，即所有的未知参数都能从假设的局内点计算得出。</li>
<li>用<code>1</code>中得到的模型去测试所有的其它数据，如果某个点适用于估计的模型，认为它也是局内点。</li>
<li>如果有足够多的点被归类为假设的局内点，那么估计的模型就足够合理。</li>
<li>然后，用所有假设的局内点去重新估计模型，因为它仅仅被初始的假设局内点估计过。</li>
<li>最后，通过估计局内点与模型的错误率来评估模型。</li>
</ol>
<p>这个过程被重复执行固定的次数，每次产生的模型要么因为局内点太少而被舍弃，要么因为比现有的模型更好而被选用。该流程如下：</p>
<p><img src="/2019/03/07/opencv和图像处理/RANSAC算法/2.png" height="370" width="844"></p>
<p>&emsp;&emsp;<code>wiki</code>上的伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Given:</span><br><span class="line">    data - a <span class="built_in">set</span> of observed data points</span><br><span class="line">    model - a model that can be fitted to data points</span><br><span class="line">    n - the minimum number of data values required to fit the model</span><br><span class="line">    k - the maximum number of iterations allowed in the algorithm</span><br><span class="line">    t - a threshold value <span class="keyword">for</span> determining when a data point fits a model</span><br><span class="line">    d - the number of close data values required to assert that a model fits well to data</span><br><span class="line">Return:</span><br><span class="line">    bestfit - <span class="function">model parameters which best fit the <span class="title">data</span> <span class="params">(<span class="keyword">or</span> nil <span class="keyword">if</span> no good model is found)</span></span></span><br><span class="line">​</span><br><span class="line">iterations = <span class="number">0</span></span><br><span class="line">bestfit = nil</span><br><span class="line">besterr = something really large</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> iterations &lt; k &#123;</span><br><span class="line">    maybeinliers = n randomly selected values from data</span><br><span class="line">    maybemodel = model parameters fitted to maybeinliers</span><br><span class="line">    alsoinliers = empty <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> every point in data <span class="keyword">not</span> in maybeinliers &#123;</span><br><span class="line">        <span class="keyword">if</span> point fits maybemodel with an error smaller than t</span><br><span class="line">             add point to alsoinliers</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> the number of elements in alsoinliers is &gt; d &#123;</span><br><span class="line">        % <span class="keyword">this</span> implies that we may have found a good model</span><br><span class="line">        % now test how good it is</span><br><span class="line">        bettermodel = model parameters fitted to all points in maybeinliers <span class="keyword">and</span> alsoinliers</span><br><span class="line">        thiserr = a measure of how well model fits these points</span><br><span class="line">        <span class="keyword">if</span> thiserr &lt; besterr &#123;</span><br><span class="line">            bestfit = bettermodel</span><br><span class="line">            besterr = thiserr</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    increment iterations</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">return</span> bestfit</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;While the parameter values of <code>t</code> and <code>d</code> have to be calculated from the individual requirements it can be experimentally determined. The interesting parameter of the <code>RANSAC</code> algorithm is <code>k</code>. To calculate the parameter <code>k</code> given the known probability <code>w</code> of a good data value, the probability <code>z</code> of seeing only bad data values is used:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = (<span class="number">1</span> - w^n)^k</span><br></pre></td></tr></table></figure>
<p>which leads to:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="built_in">log</span>(z)/<span class="built_in">log</span>(<span class="number">1</span> - w^n)</span><br></pre></td></tr></table></figure>
<p>To gain additional confidence, the standard deviation or multiples thereof can be added to <code>k</code>. The standard deviation of <code>k</code> is defined as:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SD(x) = <span class="built_in">sqrt</span>(<span class="number">1</span> - w^n)/w^n</span><br></pre></td></tr></table></figure>
<p>A common case is that <code>w</code> is not well known beforehand, but some rough value can be given. If <code>n</code> data values are given, the probability of success is <code>w^n</code>.<br>&emsp;&emsp;<code>python</code>代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> scipy  <span class="comment"># use numpy if scipy unavailable</span></span><br><span class="line"><span class="keyword">import</span> scipy.linalg  <span class="comment"># use numpy if scipy unavailable</span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ransac</span><span class="params">(data, model, n, k, t, d, debug=False, return_all=False)</span>:</span></span><br><span class="line">    iterations = <span class="number">0</span></span><br><span class="line">    bestfit = <span class="keyword">None</span></span><br><span class="line">    besterr = numpy.inf</span><br><span class="line">    best_inlier_idxs = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> iterations &lt; k:</span><br><span class="line">        maybe_idxs, test_idxs = random_partition(n, data.shape[<span class="number">0</span>])</span><br><span class="line">        maybeinliers = data[maybe_idxs, :]</span><br><span class="line">        test_points = data[test_idxs]</span><br><span class="line">        maybemodel = model.fit(maybeinliers)</span><br><span class="line">        test_err = model.get_error(test_points, maybemodel)</span><br><span class="line">        also_idxs = test_idxs[test_err &lt; t]  <span class="comment"># select indices of rows with accepted points</span></span><br><span class="line">        alsoinliers = data[also_idxs, :]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            print(<span class="string">'test_err.min()'</span>, test_err.min())</span><br><span class="line">            print(<span class="string">'test_err.max()'</span>, test_err.max())</span><br><span class="line">            print(<span class="string">'numpy.mean(test_err)'</span>, numpy.mean(test_err))</span><br><span class="line">            print(<span class="string">'iteration %d:len(alsoinliers) = %d'</span> % (iterations, len(alsoinliers)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(alsoinliers) &gt; d:</span><br><span class="line">            betterdata = numpy.concatenate((maybeinliers, alsoinliers))</span><br><span class="line">            bettermodel = model.fit(betterdata)</span><br><span class="line">            better_errs = model.get_error(betterdata, bettermodel)</span><br><span class="line">            thiserr = numpy.mean(better_errs)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> thiserr &lt; besterr:</span><br><span class="line">                bestfit = bettermodel</span><br><span class="line">                besterr = thiserr</span><br><span class="line">                best_inlier_idxs = numpy.concatenate((maybe_idxs, also_idxs))</span><br><span class="line"></span><br><span class="line">        iterations += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bestfit <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"did not meet fit acceptance criteria"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> return_all:</span><br><span class="line">        <span class="keyword">return</span> bestfit, &#123;<span class="string">'inliers'</span>: best_inlier_idxs&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> bestfit</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_partition</span><span class="params">(n, n_data)</span>:</span></span><br><span class="line">    <span class="string">""" return n random rows of data (and also the other len(data) - n rows) """</span></span><br><span class="line">    all_idxs = numpy.arange(n_data)</span><br><span class="line">    numpy.random.shuffle(all_idxs)</span><br><span class="line">    idxs1 = all_idxs[:n]</span><br><span class="line">    idxs2 = all_idxs[n:]</span><br><span class="line">    <span class="keyword">return</span> idxs1, idxs2</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearLeastSquaresModel</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    linear system solved using linear least squares</span></span><br><span class="line"><span class="string">    This class serves as an example that fulfills the model interface</span></span><br><span class="line"><span class="string">    needed by the ransac() function.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_columns, output_columns, debug=False)</span>:</span></span><br><span class="line">        self.input_columns = input_columns</span><br><span class="line">        self.output_columns = output_columns</span><br><span class="line">        self.debug = debug</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        A = numpy.vstack([data[:, i] <span class="keyword">for</span> i <span class="keyword">in</span> self.input_columns]).T</span><br><span class="line">        B = numpy.vstack([data[:, i] <span class="keyword">for</span> i <span class="keyword">in</span> self.output_columns]).T</span><br><span class="line">        x, resids, rank, s = scipy.linalg.lstsq(A, B)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_error</span><span class="params">(self, data, model)</span>:</span></span><br><span class="line">        A = numpy.vstack([data[:, i] <span class="keyword">for</span> i <span class="keyword">in</span> self.input_columns]).T</span><br><span class="line">        B = numpy.vstack([data[:, i] <span class="keyword">for</span> i <span class="keyword">in</span> self.output_columns]).T</span><br><span class="line">        B_fit = scipy.dot(A, model)</span><br><span class="line">        err_per_point = numpy.sum((B - B_fit) ** <span class="number">2</span>, axis=<span class="number">1</span>)  <span class="comment"># sum squared error per row</span></span><br><span class="line">        <span class="keyword">return</span> err_per_point</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># generate perfect input data</span></span><br><span class="line">    n_samples = <span class="number">500</span></span><br><span class="line">    n_inputs = <span class="number">1</span></span><br><span class="line">    n_outputs = <span class="number">1</span></span><br><span class="line">    A_exact = <span class="number">20</span> * numpy.random.random((n_samples, n_inputs))</span><br><span class="line">    perfect_fit = <span class="number">60</span> * numpy.random.normal(size=(n_inputs, n_outputs))  <span class="comment"># the model</span></span><br><span class="line">    B_exact = scipy.dot(A_exact, perfect_fit)</span><br><span class="line">    <span class="keyword">assert</span> B_exact.shape == (n_samples, n_outputs)</span><br><span class="line">​</span><br><span class="line">    <span class="comment"># add a little gaussian noise (linear least squares alone should handle this well)</span></span><br><span class="line">    A_noisy = A_exact + numpy.random.normal(size=A_exact.shape)</span><br><span class="line">    B_noisy = B_exact + numpy.random.normal(size=B_exact.shape)</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># add some outliers</span></span><br><span class="line">        n_outliers = <span class="number">100</span></span><br><span class="line">        all_idxs = numpy.arange(A_noisy.shape[<span class="number">0</span>])</span><br><span class="line">        numpy.random.shuffle(all_idxs)</span><br><span class="line">        outlier_idxs = all_idxs[:n_outliers]</span><br><span class="line">        non_outlier_idxs = all_idxs[n_outliers:]</span><br><span class="line">        A_noisy[outlier_idxs] = <span class="number">20</span> * numpy.random.random((n_outliers, n_inputs))</span><br><span class="line">        B_noisy[outlier_idxs] = <span class="number">50</span> * numpy.random.normal(size=(n_outliers, n_outputs))</span><br><span class="line">​</span><br><span class="line">    <span class="comment"># setup model</span></span><br><span class="line">    all_data = numpy.hstack((A_noisy, B_noisy))</span><br><span class="line">    input_columns = range(n_inputs)  <span class="comment"># the first columns of the array</span></span><br><span class="line">    output_columns = [n_inputs + i <span class="keyword">for</span> i <span class="keyword">in</span> range(n_outputs)]  <span class="comment"># the last columns of the array</span></span><br><span class="line">    debug = <span class="keyword">True</span></span><br><span class="line">    model = LinearLeastSquaresModel(input_columns, output_columns, debug=debug)</span><br><span class="line">​</span><br><span class="line">    linear_fit, resids, rank, s = scipy.linalg.lstsq(all_data[:, input_columns], all_data[:, output_columns])</span><br><span class="line">​</span><br><span class="line">    <span class="comment"># run RANSAC algorithm</span></span><br><span class="line">    ransac_fit, ransac_data = ransac(all_data, model,</span><br><span class="line">                                     <span class="number">50</span>, <span class="number">1000</span>, <span class="number">7e3</span>, <span class="number">300</span>,  <span class="comment"># misc. parameters</span></span><br><span class="line">                                     debug=debug, return_all=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">import</span> pylab</span><br><span class="line">​</span><br><span class="line">        sort_idxs = numpy.argsort(A_exact[:, <span class="number">0</span>])</span><br><span class="line">        A_col0_sorted = A_exact[sort_idxs]  <span class="comment"># maintain as rank-2 array</span></span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> <span class="number">1</span>:</span><br><span class="line">            pylab.plot(A_noisy[:, <span class="number">0</span>], B_noisy[:, <span class="number">0</span>], <span class="string">'k.'</span>, label=<span class="string">'data'</span>)</span><br><span class="line">            pylab.plot(A_noisy[ransac_data[<span class="string">'inliers'</span>], <span class="number">0</span>], \</span><br><span class="line">                B_noisy[ransac_data[<span class="string">'inliers'</span>], <span class="number">0</span>], <span class="string">'bx'</span>, label=<span class="string">'RANSAC data'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pylab.plot(A_noisy[non_outlier_idxs, <span class="number">0</span>], B_noisy[non_outlier_idxs, <span class="number">0</span>], <span class="string">'k.'</span>, label=<span class="string">'noisy data'</span>)</span><br><span class="line">            pylab.plot(A_noisy[outlier_idxs, <span class="number">0</span>], B_noisy[outlier_idxs, <span class="number">0</span>], <span class="string">'r.'</span>, label=<span class="string">'outlier data'</span>)</span><br><span class="line">        pylab.plot(A_col0_sorted[:, <span class="number">0</span>], numpy.dot(A_col0_sorted, ransac_fit)[:, <span class="number">0</span>], label=<span class="string">'RANSAC fit'</span>)</span><br><span class="line">        pylab.plot(A_col0_sorted[:, <span class="number">0</span>], numpy.dot(A_col0_sorted, perfect_fit)[:, <span class="number">0</span>], label=<span class="string">'exact system'</span>)</span><br><span class="line">        pylab.plot(A_col0_sorted[:, <span class="number">0</span>], numpy.dot(A_col0_sorted, linear_fit)[:, <span class="number">0</span>], label=<span class="string">'linear fit'</span>)</span><br><span class="line">        pylab.legend()</span><br><span class="line">        pylab.show()</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/07/opencv和图像处理/RANSAC算法/3.png" height="310" width="318"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/07/opencv和图像处理/使用摄像头/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/opencv和图像处理/使用摄像头/" itemprop="url">使用摄像头</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T09:25:17+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;摄像头的使用在<code>OpenCV</code>中十分简单，仅仅调用一个函数，就能从摄像头中读取一帧帧的画面。准备工作极为简单，找一个普通的摄像头，然后插到<code>USB</code>口中，在使用该摄像头前，需要对其进行测试，看它是否可以正常工作。核心代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CvCapture *capture = cvCreateCameraCapture ( <span class="number">0</span> );</span><br><span class="line">IplImage *frame = cvQueryFrame ( capture );</span><br></pre></td></tr></table></figure>
<p>第一行创建一个来自摄像头的<code>capture</code>，注意其参数为<code>0</code>，表示随机取一个摄像头(为<code>-1</code>也是可以的)。当电脑上只有一个摄像头时，就填<code>0</code>；如果有多个时，还需要指定设备<code>id</code>。第二行是从该<code>capture</code>中读取下一帧画面，不断地调用该代码，就能不断地得到新的画面。<br>&emsp;&emsp;获取摄像头并且创建窗口显示的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cxcore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;highgui.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    IplImage *pFrame = <span class="literal">NULL</span>; <span class="comment">/* 声明IplImage指针 */</span></span><br><span class="line">    CvCapture *pCapture = cvCreateCameraCapture ( <span class="number">-1</span> ); <span class="comment">/* 获取摄像头 */</span></span><br><span class="line">    cvNamedWindow ( <span class="string">"video"</span>, <span class="number">1</span> ); <span class="comment">/* 创建窗口 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123; <span class="comment">/* 显示视频 */</span></span><br><span class="line">        pFrame = cvQueryFrame ( pCapture );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( !pFrame ) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        cvShowImage ( <span class="string">"video"</span>, pFrame );</span><br><span class="line">        <span class="keyword">char</span> c = cvWaitKey ( <span class="number">33</span> );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( c == <span class="number">27</span> ) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    cvReleaseCapture ( &amp;pCapture );</span><br><span class="line">    cvDestroyWindow ( <span class="string">"video"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/07/opencv和图像处理/使用摄像头/1.png" height="244" width="314"></p>
<p>上述代码是以图片方式读取摄像头数据，我们可以在其显示到窗口前，对图片进行操作。下面的代码在每帧图片显示在窗口前，对它进行<code>cvCanny</code>的操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cv.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"highgui.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    cvNamedWindow ( <span class="string">"video"</span> );</span><br><span class="line">    CvCapture *capture = cvCreateCameraCapture ( <span class="number">0</span> );</span><br><span class="line">    IplImage *frame = cvQueryFrame ( capture );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        frame = cvQueryFrame ( capture );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( !frame ) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        IplImage *out = cvCreateImage ( cvGetSize ( frame ), frame-&gt;depth, <span class="number">1</span> );</span><br><span class="line">        cvCanny ( frame, out, <span class="number">10</span>, <span class="number">100</span>, <span class="number">3</span> );</span><br><span class="line">        cvShowImage ( <span class="string">"video"</span>, out );</span><br><span class="line">        cvReleaseImage ( &amp;out );</span><br><span class="line">        <span class="keyword">char</span> c = cvWaitKey ( <span class="number">50</span> );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( c == <span class="number">27</span> ) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    cvReleaseCapture ( &amp;capture );</span><br><span class="line">    cvDestroyWindow ( <span class="string">"video"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/07/opencv和图像处理/使用摄像头/2.png" height="244" width="309"></p>
<p>&emsp;&emsp;<code>ubuntu</code>下安装摄像头驱动使用如下命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cheese</span><br><span class="line">sudo apt-get install camorama</span><br></pre></td></tr></table></figure>
<p>然后打开应用<code>cheese</code>，对摄像头进行测试。</p>
<hr>
<p>&emsp;&emsp;<code>python</code>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">​</span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">True</span>):</span><br><span class="line">    <span class="comment"># Capture frame-by-frame</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">​</span><br><span class="line">    <span class="comment"># Our operations on the frame come here</span></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">​</span><br><span class="line">    <span class="comment"># Display the resulting frame</span></span><br><span class="line">    cv2.imshow(<span class="string">'frame'</span>, gray)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">​</span><br><span class="line"><span class="comment"># When everything done, release the capture</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/07/opencv和图像处理/使用摄像头/3.png" height="254" width="324"></p>
<p>&emsp;&emsp;对视频进行保存：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">​</span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Define the codec and create VideoWriter object</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">'XVID'</span>)</span><br><span class="line">out = cv2.VideoWriter(<span class="string">'output.avi'</span>, fourcc, <span class="number">20.0</span>, (<span class="number">640</span>, <span class="number">480</span>))</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> (cap.isOpened()):</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> ret == <span class="keyword">True</span>:</span><br><span class="line">        out.write(frame)  <span class="comment"># write the frame</span></span><br><span class="line">        cv2.imshow(<span class="string">'frame'</span>, frame)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">​</span><br><span class="line"><span class="comment"># Release everything if job is finished</span></span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">​</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>读取视频并保存为另一种格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">​</span><br><span class="line"><span class="comment"># 如果要调用摄像头，则VideoCapture的参数为0；如果读取本地视频，则要用视频地址</span></span><br><span class="line">video_path = <span class="string">"a07_s01_e01_rgb.avi"</span></span><br><span class="line">cap = cv2.VideoCapture(video_path)</span><br><span class="line">fps = cap.get(cv2.CAP_PROP_FPS)  <span class="comment"># 获取视频的帧率</span></span><br><span class="line"><span class="comment"># 获取视频的大小</span></span><br><span class="line">size = (int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)), int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))</span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(<span class="string">'m'</span>, <span class="string">'p'</span>, <span class="string">'4'</span>, <span class="string">'v'</span>)  <span class="comment"># 要保存的视频格式</span></span><br><span class="line">output_viedo = cv2.VideoWriter()  <span class="comment"># 把处理过的视频保存下来</span></span><br><span class="line">video_save_path = <span class="string">'HJH_dealt.mp4'</span>  <span class="comment"># 保存的视频地址</span></span><br><span class="line">output_viedo.open(video_save_path, fourcc, fps, size, <span class="keyword">True</span>)</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    ret, image_np = cap.read()</span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        <span class="comment"># 此处省略对image_np的处理，此为一帧图片</span></span><br><span class="line">        cv2.imshow(<span class="string">'object detection'</span>, cv2.resize(image_np, (<span class="number">800</span>, <span class="number">600</span>)))</span><br><span class="line">        output_viedo.write(image_np)  <span class="comment"># 把帧写入到视频中</span></span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">25</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">            cv2.destroyAllWindows()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">​</span><br><span class="line">output_viedo.release()  <span class="comment"># 释放</span></span><br><span class="line">cap.release()  <span class="comment"># 释放</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/94/">94</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">934</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
