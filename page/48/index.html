<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="泥腿子出身">
<meta property="og:url" content="http://fukangwei.gitee.io/page/48/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="泥腿子出身">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/48/">





  <title>泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/31/Qt语法详解/Qt之QList/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/31/Qt语法详解/Qt之QList/" itemprop="url">Qt之QList</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-31T19:46:43+08:00">
                2019-01-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QList</code> class is a template class that provides lists.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QList</code></td>
<td><code>QItemSelection</code>, <code>QQueue</code>, <code>QSignalSpy</code>, <code>QStringList</code> and <code>QTestEventList</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QList()</code></td>
</tr>
<tr>
<td></td>
<td><code>QList(const QList&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td></td>
<td><code>QList(std::initializer_list&lt;T&gt; args)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QList()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>append(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>append(const QList&lt;T&gt; &amp; value)</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>at(int i) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>back()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>back() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>begin()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constBegin() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constEnd() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>contains(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>empty() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>end()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>endsWith(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator pos)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator begin, iterator end)</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>first()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>first() const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>front()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>front() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>indexOf(const T &amp; value, int from = 0) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insert(int i, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insert(iterator before, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>last()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>last() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lastIndexOf(const T &amp; value, int from = -1) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>length() const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>mid(int pos, int length = -1) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>move(int from, int to)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>pop_back()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>pop_front()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>prepend(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>push_back(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>push_front(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>removeAll(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeAt(int i)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeFirst()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeLast()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>removeOne(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>replace(int i, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>reserve(int alloc)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>startsWith(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(QList&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(int i, int j)</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>takeAt(int i)</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>takeFirst()</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>takeLast()</code></td>
</tr>
<tr>
<td><code>QSet&lt;T&gt;</code></td>
<td><code>toSet() const</code></td>
</tr>
<tr>
<td><code>std::list&lt;T&gt;</code></td>
<td><code>toStdList() const</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>toVector() const</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>value(int i) const</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>value(int i, const T &amp; defaultValue) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QList&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>operator+(const QList&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt; &amp;</code></td>
<td><code>operator+=(const QList&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt; &amp;</code></td>
<td><code>operator+=(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt; &amp;</code></td>
<td><code>operator&lt;&lt;(const QList&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt; &amp;</code></td>
<td><code>operator&lt;&lt;(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt; &amp;</code></td>
<td><code>operator=(const QList&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QList &amp;</code></td>
<td><code>operator=(QList &amp;&amp; other)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QList&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>operator[](int i)</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>operator[](int i) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Static-Public-Members"><a href="#Static-Public-Members" class="headerlink" title="Static Public Members"></a>Static Public Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>fromSet ( const QSet&lt;T&gt; &amp;set );</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>fromStdList ( const std::list&lt;T&gt; &amp;list );</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>fromVector ( const QVector&lt;T&gt; &amp;vector );</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&lt;&lt; ( QDataStream &amp;out, const QList&lt;T&gt; &amp;list );</code></td>
</tr>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&gt;&gt; ( QDataStream &amp;in, QList&lt;T&gt; &amp;list );</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QList</code> class is a template class that provides lists.<br>&emsp;&emsp;<code>QList&lt;T&gt;</code> is one of <code>Qt&#39;s</code> generic container classes. It stores a list of values and provides fast <code>index-based</code> access as well as fast insertions and removals.<br>&emsp;&emsp;<code>QList&lt;T&gt;</code>, <code>QLinkedList&lt;T&gt;</code>, and <code>QVector&lt;T&gt;</code> provide similar functionality. Here’s an overview:<br>&emsp;&emsp;For most purposes, <code>QList</code> is the right class to use. Its <code>index-based</code> <code>API</code> is more convenient than <code>QLinkedList&#39;s</code> <code>iterator-based</code> <code>API</code>, and it is usually faster than <code>QVector</code> because of the way it stores its items in memory. It also expands to less code in your executable.<br>&emsp;&emsp;If you need a real linked list, with guarantees of constant time insertions in the middle of the list and iterators to items rather than indexes, use <code>QLinkedList</code>.<br>&emsp;&emsp;If you want the items to occupy adjacent memory positions, use <code>QVector</code>.<br>&emsp;&emsp;Internally, <code>QList&lt;T&gt;</code> is represented as an array of pointers to items of type <code>T</code>. If <code>T</code> is itself a pointer type or a basic type that is no larger than a pointer, or if <code>T</code> is one of Qt’s shared classes, then <code>QList&lt;T&gt;</code> stores the items directly in the pointer array. For lists under a thousand items, this array representation allows for very fast insertions in the middle, and it allows <code>index-based</code> access. Furthermore, operations like <code>prepend()</code> and <code>append()</code> are very fast, because <code>QList</code> preallocates memory at both ends of its internal array. Note, however, that for unshared list items that are larger than a pointer, each append or insert of a new item requires allocating the new item on the heap, and this per item allocation might make <code>QVector</code> a better choice in cases that do lots of appending or inserting, since <code>QVector</code> allocates memory for its items in a single heap allocation.<br>&emsp;&emsp;Note that the internal array only ever gets bigger over the life of the list. It never shrinks. The internal array is deallocated by the destructor, by <code>clear()</code>, and by the assignment operator, when one list is assigned to another.<br>&emsp;&emsp;Here’s an example of a <code>QList</code> that stores integers and a <code>QList</code> that stores <code>QDate</code> values:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;<span class="keyword">int</span>&gt; integerList;</span><br><span class="line">QList&lt;QDate&gt; dateList;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Qt includes a <code>QStringList</code> class that inherits <code>QList&lt;QString&gt;</code> and adds a convenience function <code>QStringList::join()</code> (<code>QString::split()</code> creates <code>QStringLists</code> from strings).<br>&emsp;&emsp;<code>QList</code> stores a list of items. The default constructor creates an empty list. To insert items into the list, you can use <code>operator&lt;&lt;()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "one" &lt;&lt; "two" &lt;&lt; "three"; /* <span class="built_in">list</span>: ["one", "two", "three"] */</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>QList</code> provides these basic functions to add, move, and remove items: <code>insert()</code>, <code>replace()</code>, <code>removeAt()</code>, <code>move()</code>, and <code>swap()</code>. In addition, it provides the following convenience functions: <code>append()</code>, <code>prepend()</code>, <code>removeFirst()</code> and <code>removeLast()</code>.<br>&emsp;&emsp;<code>QList</code> uses <code>0-based</code> indexes, just like <code>C++</code> arrays. To access the item at a particular index position, you can use <code>operator[]()</code>. On <code>non-const</code> lists, <code>operator[]()</code> returns a reference to the item and can be used on the left side of an assignment:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">list</span>[<span class="number">0</span>] == <span class="string">"Bob"</span> ) &#123;</span><br><span class="line">    <span class="built_in">list</span>[<span class="number">0</span>] = <span class="string">"Robert"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Because <code>QList</code> is implemented as an array of pointers, this operation is very fast (constant time). For <code>read-only</code> access, an alternative syntax is to use <code>at()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">list</span>.at ( i ) == <span class="string">"Jane"</span> ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found Jane at position "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>at()</code> can be faster than <code>operator[]()</code>, because it never causes a deep copy to occur.<br>&emsp;&emsp;A common requirement is to remove an item from a list and do something with it. For this, <code>QList</code> provides <code>takeAt()</code>, <code>takeFirst()</code>, and <code>takeLast()</code>. Here’s a loop that removes the items from a list one at a time and calls delete on them:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QWidget *&gt; <span class="built_in">list</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( !<span class="built_in">list</span>.isEmpty() ) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">list</span>.takeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Inserting and removing items at either ends of the list is very fast (constant time in most cases), because <code>QList</code> preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.<br>&emsp;&emsp;If you want to find all occurrences of a particular value in a list, use <code>indexOf()</code> or <code>lastIndexOf()</code>. The former searches forward starting from a given index position, the latter searches backward. Both return the index of a matching item if they find it; otherwise, they return <code>-1</code>. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="built_in">list</span>.indexOf ( <span class="string">"Jane"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( i != <span class="number">-1</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"First occurrence of Jane is at position "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If you simply want to check whether a list contains a particular value, use <code>contains()</code>. If you want to find out how many times a particular value occurs in the list, use <code>count()</code>. If you want to replace all occurrences of a particular value with another, use <code>replace()</code>.<br>&emsp;&emsp;<code>QList&#39;s</code> value type must be an assignable data type. This covers most data types that are commonly used, but the compiler won’t let you, for example, store a <code>QWidget</code> as a value; instead, store a <code>QWidget *</code>. A few functions have additional requirements; for example, <code>indexOf()</code> and <code>lastIndexOf()</code> expect the value type to support <code>operator==()</code>. These requirements are documented on a <code>per-function</code> basis.<br>&emsp;&emsp;Like the other container classes, <code>QList</code> provides <code>Java-style</code> iterators (<code>QListIterator</code> and <code>QMutableListIterator</code>) and <code>STL-style</code> iterators (<code>QList::const_iterator</code> and <code>QList::iterator</code>). In practice, these are rarely used, because you can use indexes into the <code>QList</code>. <code>QList</code> is implemented in such a way that direct <code>index-based</code> access is just as fast as using iterators.<br>&emsp;&emsp;<code>QList</code> does not support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.<br>&emsp;&emsp;To make <code>QList</code> as efficient as possible, its member functions don’t validate their input before using it. Except for <code>isEmpty()</code>, member functions always assume the list is not empty. Member functions that take index values as parameters always assume their index value parameters are in the valid range. This means <code>QList</code> member functions can fail. If you define <code>QT_NO_DEBUG</code> when you compile, failures will not be detected. If you don’t define <code>QT_NO_DEBUG</code>, failures will be detected using <code>Q_ASSERT()</code> or <code>Q_ASSERT_X()</code> with an appropriate message.<br>&emsp;&emsp;To avoid failures when your list can be empty, call <code>isEmpty()</code> before calling other member functions. If you must pass an index value that might not be in the valid range, check that it is less than the value returned by <code>size()</code> but not less than <code>0</code>.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>typedef <code>QList::ConstIterator</code>: <code>Qt-style</code> synonym for <code>QList::const_iterator</code>.</li>
<li>typedef <code>QList::Iterator</code>: <code>Qt-style</code> synonym for <code>QList::iterator</code>.</li>
<li>typedef <code>QList::const_pointer</code>: Typedef for <code>const T *</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::const_reference</code>: Typedef for <code>const T &amp;</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::difference_type</code>: Typedef for <code>ptrdiff_t</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::pointer</code>: Typedef for <code>T *</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::reference</code>: Typedef for <code>T &amp;</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::size_type</code>: Typedef for <code>int</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QList::value_type</code>: Typedef for <code>T</code>. Provided for <code>STL</code> compatibility.</li>
</ul>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QList::QList()</code>: Constructs an empty list.</li>
<li><code>QList::QList(const QList&lt;T&gt; &amp; other)</code>: Constructs a copy of <code>other</code>. This operation takes constant time, because <code>QList</code> is implicitly shared. This makes returning a <code>QList</code> from a function very fast. If a shared instance is modified, it will be copied (<code>copy-on-write</code>), and that takes linear time.</li>
<li><code>QList::QList(std::initializer_list&lt;T&gt; args)</code>: Construct a list from the <code>std::initializer_list specified</code> by <code>args</code>. This constructor is only enabled if the compiler supports <code>C++0x</code>.</li>
<li><code>QList::~QList()</code>: Destroys the list. References to the values in the list and all iterators of this list become invalid.</li>
<li><code>void QList::append(const T &amp; value)</code>: Inserts <code>value</code> at the end of the list. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span>.append ( <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">list</span>.append ( <span class="string">"two"</span> );</span><br><span class="line"><span class="built_in">list</span>.append ( <span class="string">"three"</span> ); <span class="comment">/* list: ["one", "two", "three"] */</span></span><br></pre></td></tr></table></figure>
<p>This is the same as <code>list.insert(size(), value)</code>. This operation is typically very fast (constant time), because <code>QList</code> preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.</p>
<ul>
<li><code>void QList::append(const QList&lt;T&gt; &amp; value)</code>: This is an overloaded function. Appends the items of the <code>value</code> list to this list.</li>
<li><code>const T &amp; QList::at(int i) const</code>: Returns the item at index position <code>i</code> in the list. <code>i</code> must be a valid index position in the list (i.e., <code>0 &lt;= i &lt; size()</code>). This function is very fast (constant time).</li>
<li><code>T &amp; QList::back()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>last()</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>const T &amp; QList::back() const</code>: This is an overloaded function.</li>
<li><code>iterator QList::begin()</code>: Returns an <code>STL-style</code> iterator pointing to the first item in the list.</li>
<li><code>const_iterator QList::begin() const</code>: This is an overloaded function.</li>
<li><code>void QList::clear()</code>: Removes all items from the list.</li>
<li><code>const_iterator QList::constBegin() const</code>: Returns a const <code>STL-style</code> iterator pointing to the first item in the list.</li>
<li><code>const_iterator QList::constEnd() const</code>: Returns a const <code>STL-style</code> iterator pointing to the imaginary item after the last item in the list.</li>
<li><code>bool QList::contains(const T &amp; value) const</code>: Returns <code>true</code> if the list contains an occurrence of <code>value</code>; otherwise returns <code>false</code>. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>int QList::count(const T &amp; value) const</code>: Returns the number of occurrences of <code>value</code> in the list. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>int QList::count() const</code>: Returns the number of items in the list. This is effectively the same as <code>size()</code>.</li>
<li><code>bool QList::empty() const</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>isEmpty()</code> and returns <code>true</code> if the list is empty.</li>
<li><code>iterator QList::end()</code>: Returns an <code>STL-style</code> iterator pointing to the imaginary item after the last item in the list.</li>
<li><code>const_iterator QList::end() const</code>: This is an overloaded function.</li>
<li><code>bool QList::endsWith(const T &amp; value) const</code>: Returns <code>true</code> if this list is not empty and its last item is equal to <code>value</code>; otherwise returns <code>false</code>.</li>
<li><code>iterator QList::erase(iterator pos)</code>: Removes the item associated with the iterator <code>pos</code> from the list, and returns an iterator to the next item in the list (which may be <code>end()</code>).</li>
<li><code>iterator QList::erase(iterator begin, iterator end)</code>: This is an overloaded function. Removes all the items from <code>begin</code> up to (but not including) <code>end</code>. Returns an iterator to the same item that end referred to before the call.</li>
<li><code>T &amp; QList::first()</code>: Returns a reference to the first item in the list. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>const T &amp; QList::first() const</code>: This is an overloaded function.</li>
<li><code>QList&lt;T&gt; QList::fromSet(const QSet&lt;T&gt; &amp; set) [static]</code>: Returns a <code>QList</code> object with the data contained in <code>set</code>. The order of the elements in the <code>QList</code> is undefined. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QSet&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line"><span class="built_in">set</span> &lt;&lt; 20 &lt;&lt; 30 &lt;&lt; 40 &lt;&lt; ... &lt;&lt; 70;</span><br><span class="line">​</span><br><span class="line">QList&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span> = QList&lt;<span class="keyword">int</span>&gt;::fromSet ( <span class="built_in">set</span> );</span><br><span class="line">qSort ( <span class="built_in">list</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QList&lt;T&gt; QList::fromStdList(const std::list&lt;T&gt; &amp; list) [static]</code>: Returns a <code>QList</code> object with the data contained in <code>list</code>. The order of the elements in the <code>QList</code> is the same as in <code>list</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; stdlist;</span><br><span class="line"><span class="built_in">list</span>.push_back ( <span class="number">1.2</span> );</span><br><span class="line"><span class="built_in">list</span>.push_back ( <span class="number">0.5</span> );</span><br><span class="line"><span class="built_in">list</span>.push_back ( <span class="number">3.14</span> );</span><br><span class="line">​</span><br><span class="line">QList&lt;<span class="keyword">double</span>&gt; <span class="built_in">list</span> = QList&lt;<span class="keyword">double</span>&gt;::fromStdList ( stdlist );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QList&lt;T&gt; QList::fromVector(const QVector&lt;T&gt; &amp; vector) [static]</code>: Returns a <code>QList</code> object with the data contained in <code>vector</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">double</span>&gt; vect;</span><br><span class="line">vect &lt;&lt; <span class="number">20.0</span> &lt;&lt; <span class="number">30.0</span> &lt;&lt; <span class="number">40.0</span> &lt;&lt; <span class="number">50.0</span>;</span><br><span class="line">​</span><br><span class="line">QList&lt;<span class="keyword">double</span>&gt; <span class="built_in">list</span> = QVector&lt;T&gt;::fromVector ( vect ); <span class="comment">/* list: [20.0, 30.0, 40.0, 50.0] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>T &amp; QList::front()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>first()</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>const T &amp; QList::front() const</code>: This is an overloaded function.</li>
<li><code>int QList::indexOf(const T &amp; value, int from = 0) const</code>: Returns the index position of the first occurrence of <code>value</code> in the list, searching forward from index position <code>from</code>. Returns <code>-1</code> if no item matched. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "B" &lt;&lt; "A";</span><br><span class="line"><span class="built_in">list</span>.indexOf ( "B" ); /* returns 1 */</span><br><span class="line"><span class="built_in">list</span>.indexOf ( "B", 1 ); /* returns 1 */</span><br><span class="line"><span class="built_in">list</span>.indexOf ( "B", 2 ); /* returns 3 */</span><br><span class="line"><span class="built_in">list</span>.indexOf ( "X" ); /* returns -1 */</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>. Note that <code>QList</code> uses <code>0-based</code> indexes, just like <code>C++</code> arrays. Negative indexes are not supported with the exception of the value mentioned above.</p>
<ul>
<li><code>void QList::insert(int i, const T &amp; value)</code>: Inserts <code>value</code> at index position <code>i</code> in the list. If <code>i</code> is <code>0</code>, the <code>value</code> is prepended to the list. If <code>i</code> is <code>size()</code>, the <code>value</code> is appended to the list. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "alpha" &lt;&lt; "beta" &lt;&lt; "delta";</span><br><span class="line"><span class="built_in">list</span>.insert ( 2, "gamma" ); /* <span class="built_in">list</span>: ["alpha", "beta", "gamma", "delta"] */</span><br></pre></td></tr></table></figure>
<ul>
<li><code>iterator QList::insert(iterator before, const T &amp; value)</code>: This is an overloaded function. Inserts <code>value</code> in front of the item pointed to by the iterator <code>before</code>. Returns an iterator pointing at the inserted item. Note that the iterator passed to the function will be invalid after the call; the returned iterator should be used instead.</li>
<li><code>bool QList::isEmpty() const</code>: Returns <code>true</code> if the list contains no items; otherwise returns <code>false</code>.</li>
<li><code>T &amp; QList::last()</code>: Returns a reference to the last item in the list. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>const T &amp; QList::last() const</code>: This is an overloaded function.</li>
<li><code>int QList::lastIndexOf(const T &amp; value, int from = -1) const</code>: Returns the index position of the last occurrence of <code>value</code> in the list, searching backward from index position <code>from</code>. If <code>from</code> is <code>-1</code> (the default), the search starts at the last item. Returns <code>-1</code> if no item matched. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "B" &lt;&lt; "A";</span><br><span class="line"><span class="built_in">list</span>.lastIndexOf ( "B" ); /* returns 3 */</span><br><span class="line"><span class="built_in">list</span>.lastIndexOf ( "B", 3 ); /* returns 3 */</span><br><span class="line"><span class="built_in">list</span>.lastIndexOf ( "B", 2 ); /* returns 1 */</span><br><span class="line"><span class="built_in">list</span>.lastIndexOf ( "X" ); /* returns -1 */</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>. Note that <code>QList</code> uses <code>0-based</code> indexes, just like <code>C++</code> arrays. Negative indexes are not supported with the exception of the value mentioned above.</p>
<ul>
<li><code>int QList::length() const</code>: This function is identical to <code>count()</code>.</li>
<li><code>QList&lt;T&gt; QList::mid(int pos, int length = -1) const</code>: Returns a list whose elements are copied from this list, starting at position <code>pos</code>. If <code>length</code> is <code>-1</code> (the default), all elements from <code>pos</code> are copied; otherwise <code>length</code> elements (or all remaining elements if there are less than <code>length</code> elements) are copied.</li>
<li><code>void QList::move(int from, int to)</code>: Moves the item at index position <code>from</code> to index position <code>to</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "D" &lt;&lt; "E" &lt;&lt; "F";</span><br><span class="line"><span class="built_in">list</span>.move ( 1, 4 ); /* <span class="built_in">list</span>: ["A", "C", "D", "E", "B", "F"] */</span><br></pre></td></tr></table></figure>
<p>This is the same as <code>insert(to, takeAt(from))</code>. This function assumes that both from and to are at least <code>0</code> but less than <code>size()</code>. To avoid failure, test that both from and to are at least <code>0</code> and less than <code>size()</code>.</p>
<ul>
<li><code>void QList::pop_back()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>removeLast()</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>void QList::pop_front()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>removeFirst()</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>void QList::prepend(const T &amp; value)</code>: Inserts <code>value</code> at the beginning of the list. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span>.prepend ( <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">list</span>.prepend ( <span class="string">"two"</span> );</span><br><span class="line"><span class="built_in">list</span>.prepend ( <span class="string">"three"</span> ); <span class="comment">/* list: ["three", "two", "one"] */</span></span><br></pre></td></tr></table></figure>
<p>This is the same as <code>list.insert(0, value)</code>. This operation is usually very fast (constant time), because <code>QList</code> preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.</p>
<ul>
<li><code>void QList::push_back(const T &amp; value)</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>append(value)</code>.</li>
<li><code>void QList::push_front(const T &amp; value)</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>prepend(value)</code>.</li>
<li><code>int QList::removeAll(const T &amp; value)</code>: Removes all occurrences of <code>value</code> in the list and returns the number of entries removed. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "sun" &lt;&lt; "cloud" &lt;&lt; "sun" &lt;&lt; "rain";</span><br><span class="line"><span class="built_in">list</span>.removeAll("sun"); /* <span class="built_in">list</span>: ["cloud", "rain"] */</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>.</p>
<ul>
<li><code>void QList::removeAt(int i)</code>: Removes the item at index position <code>i</code>. <code>i</code> must be a valid index position in the list (i.e., <code>0 &lt;= i &lt; size()</code>).</li>
<li><code>void QList::removeFirst()</code>: Removes the first item in the list. Calling this function is equivalent to calling <code>removeAt(0)</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>void QList::removeLast()</code>: Removes the last item in the list. Calling this function is equivalent to calling <code>removeAt(size() - 1)</code>. The list must not be empty. If the list can be empty, call <code>isEmpty()</code> before calling this function.</li>
<li><code>bool QList::removeOne(const T &amp; value)</code>: Removes the first occurrence of <code>value</code> in the list and returns <code>true</code> on success; otherwise returns <code>false</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "sun" &lt;&lt; "cloud" &lt;&lt; "sun" &lt;&lt; "rain";</span><br><span class="line"><span class="built_in">list</span>.removeOne("sun"); /* <span class="built_in">list</span>: ["cloud", ,"sun", "rain"] */</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>.</p>
<ul>
<li><code>void QList::replace(int i, const T &amp; value)</code>: Replaces the item at index position <code>i</code> with <code>value</code>. <code>i</code> must be a valid index position in the list (i.e., <code>0 &lt;= i &lt; size()</code>).</li>
<li><code>void QList::reserve(int alloc)</code>: Reserve space for <code>alloc</code> elements. If <code>alloc</code> is smaller than the current size of the list, nothing will happen. Use this function to avoid repetetive reallocation of <code>QList&#39;s</code> internal data if you can predict how many elements will be appended. Note that the reservation applies only to the internal pointer array.</li>
<li><code>int QList::size() const</code>: Returns the number of items in the list.</li>
<li><code>bool QList::startsWith(const T &amp; value) const</code>: Returns <code>true</code> if this list is not empty and its first item is equal to <code>value</code>; otherwise returns <code>false</code>.</li>
<li><code>void QList::swap(QList&lt;T&gt; &amp; other)</code>: Swaps list <code>other</code> with this list. This operation is very fast and never fails.</li>
<li><code>void QList::swap(int i, int j)</code>: Exchange the item at index position <code>i</code> with the item at index position <code>j</code>. This function assumes that both <code>i</code> and <code>j</code> are at least <code>0</code> but less than <code>size()</code>. To avoid failure, test that both <code>i</code> and <code>j</code> are at least <code>0</code> and less than <code>size()</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "D" &lt;&lt; "E" &lt;&lt; "F";</span><br><span class="line"><span class="built_in">list</span>.swap ( 1, 4 ); /* <span class="built_in">list</span>: ["A", "E", "C", "D", "B", "F"] */</span><br></pre></td></tr></table></figure>
<ul>
<li><code>T QList::takeAt(int i)</code>: Removes the item at index position <code>i</code> and returns it. <code>i</code> must be a valid index position in the list (i.e., <code>0 &lt;= i &lt; size()</code>). If you don’t use the return value, <code>removeAt()</code> is more efficient.</li>
<li><code>T QList::takeFirst()</code>: Removes the first item in the list and returns it. This is the same as <code>takeAt(0)</code>. This function assumes the list is not empty. To avoid failure, call <code>isEmpty()</code> before calling this function. This operation takes constant time. If you don’t use the return value, <code>removeFirst()</code> is more efficient.</li>
<li><code>T QList::takeLast()</code>: Removes the last item in the list and returns it. This is the same as <code>takeAt(size() - 1)</code>. This function assumes the list is not empty. To avoid failure, call <code>isEmpty()</code> before calling this function. This operation takes constant time. If you don’t use the return value, <code>removeLast()</code> is more efficient.</li>
<li><code>QSet&lt;T&gt; QList::toSet() const</code>: Returns a <code>QSet</code> object with the data contained in this <code>QList</code>. Since <code>QSet</code> doesn’t allow duplicates, the resulting <code>QSet</code> might be smaller than the original list was. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QStringList <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "Julia" &lt;&lt; "Mike" &lt;&lt; "Mike" &lt;&lt; "Julia" &lt;&lt; "Julia";</span><br><span class="line">​</span><br><span class="line">QSet&lt;QString&gt; <span class="built_in">set</span> = <span class="built_in">list</span>.toSet();</span><br><span class="line"><span class="built_in">set</span>.contains ( <span class="string">"Julia"</span> ); <span class="comment">/* returns true */</span></span><br><span class="line"><span class="built_in">set</span>.contains ( <span class="string">"Mike"</span> ); <span class="comment">/* returns true */</span></span><br><span class="line"><span class="built_in">set</span>.size(); <span class="comment">/* returns 2 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::list&lt;T&gt; QList::toStdList() const</code>: Returns a <code>std::list</code> object with the data contained in this <code>QList</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;<span class="keyword">double</span>&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; 1.2 &lt;&lt; 0.5 &lt;&lt; 3.14;</span><br><span class="line">​</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; stdlist = <span class="built_in">list</span>.toStdList();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QVector&lt;T&gt; QList::toVector() const</code>: Returns a <code>QVector</code> object with the data contained in this <code>QList</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QStringList <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "Sven" &lt;&lt; "Kim" &lt;&lt; "Ola";</span><br><span class="line">​</span><br><span class="line">QVector&lt;QString&gt; vect = <span class="built_in">list</span>.toVector(); <span class="comment">/* vect: ["Sven", "Kim", "Ola"] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>T QList::value(int i) const</code>: Returns the value at index position <code>i</code> in the list. If the index <code>i</code> is out of bounds, the function returns a <code>default-constructed</code> value. If you are certain that the index is going to be within bounds, you can use <code>at()</code> instead, which is slightly faster.</li>
<li><code>T QList::value(int i, const T &amp; defaultValue) const</code>: This is an overloaded function. If the index <code>i</code> is out of bounds, the function returns <code>defaultValue</code>.</li>
<li><code>bool QList::operator!=(const QList&lt;T&gt; &amp; other) const</code>: Returns <code>true</code> if other is not equal to this list; otherwise returns <code>false</code>. Two lists are considered equal if they contain the same values in the same order. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>QList&lt;T&gt; QList::operator+(const QList&lt;T&gt; &amp; other) const</code>: Returns a list that contains all the items in this list followed by all the items in the <code>other</code> list.</li>
<li><code>QList&lt;T&gt; &amp; QList::operator+=(const QList&lt;T&gt; &amp; other)</code>: Appends the items of the <code>other</code> list to this list and returns a reference to this list.</li>
<li><code>QList&lt;T&gt; &amp; QList::operator+=(const T &amp; value)</code>: This is an overloaded function. Appends <code>value</code> to the list.</li>
<li><code>QList&lt;T&gt; &amp; QList::operator&lt;&lt;(const QList&lt;T&gt; &amp; other)</code>: Appends the items of the <code>other</code> list to this list and returns a reference to this list.</li>
<li><code>QList&lt;T&gt; &amp; QList::operator&lt;&lt;(const T &amp; value)</code>: This is an overloaded function. Appends <code>value</code> to the list.</li>
<li><code>QList&lt;T&gt; &amp; QList::operator=(const QList&lt;T&gt; &amp; other)</code>: Assigns <code>other</code> to this list and returns a reference to this list.</li>
<li><code>bool QList::operator==(const QList&lt;T&gt; &amp; other) const</code>: Returns <code>true</code> if <code>other</code> is equal to this list; otherwise returns <code>false</code>. Two lists are considered equal if they contain the same values in the same order. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>T &amp; QList::operator[](int i)</code>: Returns the item at index position <code>i</code> as a modifiable reference. <code>i</code> must be a valid index position in the list (i.e., <code>0 &lt;= i &lt; size()</code>). This function is very fast (constant time).</li>
<li><code>const T &amp; QList::operator[](int i) const</code>: This is an overloaded function. Same as <code>at()</code>.</li>
</ul>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; out, const QList&lt;T&gt; &amp; list)</code>: Writes the <code>list</code> to stream <code>out</code>. This function requires the value type to implement <code>operator&lt;&lt;()</code>.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; in, QList&lt;T&gt; &amp; list)</code>: Reads a list from stream <code>in</code> into <code>list</code>. This function requires the value type to implement <code>operator&gt;&gt;()</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/30/Qt语法详解/Qt之QVector/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/30/Qt语法详解/Qt之QVector/" itemprop="url">Qt之QVector</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-30T20:04:17+08:00">
                2019-01-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QVector</code> class is a template class that provides a dynamic array.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QVector</code></td>
<td><code>Q3ValueVector</code>, <code>QPolygon</code>, <code>QPolygonF</code>, <code>QStack</code>, and <code>QXmlStreamAttributes</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QVector()</code></td>
</tr>
<tr>
<td></td>
<td><code>QVector(int size)</code></td>
</tr>
<tr>
<td></td>
<td><code>QVector(int size, const T &amp; value)</code></td>
</tr>
<tr>
<td></td>
<td><code>QVector(const QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td></td>
<td><code>QVector(std::initializer_list&lt;T&gt; args)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QVector()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>append(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>at(int i) const</code></td>
</tr>
<tr>
<td><code>reference</code></td>
<td><code>back()</code></td>
</tr>
<tr>
<td><code>const_reference</code></td>
<td><code>back() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>begin()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>capacity() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constBegin() const</code></td>
</tr>
<tr>
<td><code>const T *</code></td>
<td><code>constData() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constEnd() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>contains(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count() const</code></td>
</tr>
<tr>
<td><code>T *</code></td>
<td><code>data()</code></td>
</tr>
<tr>
<td><code>const T *</code></td>
<td><code>data() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>empty() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>end()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>endsWith(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator pos)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator begin, iterator end)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>fill(const T &amp; value, int size = -1)</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>first()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>first() const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>front()</code></td>
</tr>
<tr>
<td><code>const_reference</code></td>
<td><code>front() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>indexOf(const T &amp; value, int from = 0) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insert(int i, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insert(iterator before, int count, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insert(int i, int count, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insert(iterator before, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>last()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>last() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lastIndexOf(const T &amp; value, int from = -1) const</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>mid(int pos, int length = -1) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>pop_back()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>pop_front()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>prepend(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>push_back(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>push_front(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>remove(int i)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>remove(int i, int count)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>replace(int i, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>reserve(int size)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>resize(int size)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>squeeze()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>startsWith(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>toList() const</code></td>
</tr>
<tr>
<td><code>std::vector&lt;T&gt;</code></td>
<td><code>toStdVector() const</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>value(int i) const</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>value(int i, const T &amp; defaultValue) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QVector&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>operator+(const QVector&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator+=(const QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator+=(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator&lt;&lt;(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator&lt;&lt;(const QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator=(const QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>operator=(QVector&lt;T&gt; &amp;&amp; other)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QVector&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>operator[](int i)</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>operator[](int i) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Static-Public-Members"><a href="#Static-Public-Members" class="headerlink" title="Static Public Members"></a>Static Public Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>fromList(const QList&lt;T&gt; &amp; list)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>fromStdVector(const std::vector&lt;T&gt; &amp; vector)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&lt;&lt;(QDataStream &amp; out, const QVector&lt;T&gt; &amp; vector)</code></td>
</tr>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&gt;&gt;(QDataStream &amp; in, QVector&lt;T&gt; &amp; vector)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QVector</code> class is a template class that provides a dynamic array.<br>&emsp;&emsp;<code>QVector&lt;T&gt;</code> is one of Qt’s generic container classes. It stores its items in adjacent memory locations and provides fast <code>index-based</code> access.<br>&emsp;&emsp;<code>QList&lt;T&gt;</code>, <code>QLinkedList&lt;T&gt;</code>, and <code>QVarLengthArray&lt;T&gt;</code> provide similar functionality. Here’s an overview:</p>
<ul>
<li>For most purposes, <code>QList</code> is the right class to use. Operations like <code>prepend()</code> and <code>insert()</code> are usually faster than with <code>QVector</code> because of the way <code>QList</code> stores its items in memory, and its <code>index-based</code> <code>API</code> is more convenient than <code>QLinkedList&#39;s</code> <code>iterator-based</code> <code>API</code>. It also expands to less code in your executable.</li>
<li>If you need a real linked list, with guarantees of constant time insertions in the middle of the list and iterators to items rather than indexes, use <code>QLinkedList</code>.</li>
<li>If you want the items to occupy adjacent memory positions, or if your items are larger than a pointer and you want to avoid the overhead of allocating them on the heap individually at insertion time, then use <code>QVector</code>.</li>
<li>If you want a <code>low-level</code> <code>variable-size</code> array, <code>QVarLengthArray</code> may be sufficient.</li>
</ul>
<p>&emsp;&emsp;Here’s an example of a <code>QVector</code> that stores integers and a <code>QVector</code> that stores <code>QString</code> values:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; integerVector;</span><br><span class="line">QVector&lt;QString&gt; stringVector;</span><br></pre></td></tr></table></figure>
<p><code>QVector</code> stores a vector (or array) of items. Typically, vectors are created with an initial size. For example, the following code constructs a <code>QVector</code> with <code>200</code> elements:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span> ( <span class="number">200</span> );</span><br></pre></td></tr></table></figure>
<p>The elements are automatically initialized with a <code>default-constructed</code> value. If you want to initialize the vector with a different value, pass that value as the second argument to the constructor:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span> ( <span class="number">200</span>, <span class="string">"Pass"</span> );</span><br></pre></td></tr></table></figure>
<p>You can also call <code>fill()</code> at any time to fill the vector with a value.<br>&emsp;&emsp;<code>QVector</code> uses <code>0-based</code> indexes, just like <code>C++</code> arrays. To access the item at a particular index position, you can use <code>operator[]()</code>. On <code>non-const</code> vectors, <code>operator[]()</code> returns a reference to the item that can be used on the left side of an assignment:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">vector</span>[<span class="number">0</span>] == <span class="string">"Liz"</span> ) &#123;</span><br><span class="line">    <span class="built_in">vector</span>[<span class="number">0</span>] = <span class="string">"Elizabeth"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For <code>read-only</code> access, an alternative syntax is to use <code>at()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.size(); ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">vector</span>.at ( i ) == <span class="string">"Alfonso"</span> ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found Alfonso at position "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>at()</code> can be faster than <code>operator[]()</code>, because it never causes a deep copy to occur.<br>&emsp;&emsp;Another way to access the data stored in a <code>QVector</code> is to call <code>data()</code>. The function returns a pointer to the first item in the vector. You can use the pointer to directly access and modify the elements stored in the vector. The pointer is also useful if you need to pass a <code>QVector</code> to a function that accepts a plain <code>C++</code> array.<br>&emsp;&emsp;If you want to find all occurrences of a particular value in a vector, use <code>indexOf()</code> or <code>lastIndexOf()</code>. The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return <code>-1</code>. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="built_in">vector</span>.indexOf ( <span class="string">"Harumi"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( i != <span class="number">-1</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"First occurrence of Harumi is at position "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If you simply want to check whether a vector contains a particular value, use <code>contains()</code>. If you want to find out how many times a particular value occurs in the vector, use <code>count()</code>.<br>&emsp;&emsp;<code>QVector</code> provides these basic functions to add, move, and remove items: <code>insert()</code>, <code>replace()</code>, <code>remove()</code>, <code>prepend()</code>, <code>append()</code>. With the exception of <code>append()</code> and <code>replace()</code>, these functions can be slow (linear time) for large vectors, because they require moving many items in the vector by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use <code>QList</code> or <code>QLinkedList</code> instead.<br>&emsp;&emsp;Unlike plain <code>C++</code> arrays, <code>QVectors</code> can be resized at any time by calling <code>resize()</code>. If the new size is larger than the old size, <code>QVector</code> might need to reallocate the whole vector. <code>QVector</code> tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.<br>&emsp;&emsp;If you know in advance approximately how many items the <code>QVector</code> will contain, you can call <code>reserve()</code>, asking <code>QVector</code> to preallocate a certain amount of memory. You can also call <code>capacity()</code> to find out how much memory <code>QVector</code> actually allocated.<br>&emsp;&emsp;Note that using <code>non-const</code> operators and functions can cause <code>QVector</code> to do a deep copy of the data. This is due to implicit sharing.<br>&emsp;&emsp;<code>QVector&#39;s</code> value type must be an assignable data type. This covers most data types that are commonly used, but the compiler won’t let you, for example, store a <code>QWidget</code> as a value; instead, store a <code>QWidget *</code>. A few functions have additional requirements; for example, <code>indexOf()</code> and <code>lastIndexOf()</code> expect the value type to support <code>operator==()</code>. These requirements are documented on a <code>per-function</code> basis.<br>&emsp;&emsp;Like the other container classes, <code>QVector</code> provides <code>Java-style</code> iterators (<code>QVectorIterator</code> and <code>QMutableVectorIterator</code>) and <code>STL-style</code> iterators (<code>QVector::const_iterator</code> and <code>QVector::iterator</code>). In practice, these are rarely used, because you can use indexes into the <code>QVector</code>.<br>&emsp;&emsp;In addition to <code>QVector</code>, Qt also provides <code>QVarLengthArray</code>, a very <code>low-level</code> class with little functionality that is optimized for speed.<br>&emsp;&emsp;<code>QVector</code> does not support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>typedef <code>QVector::ConstIterator</code>: <code>Qt-style</code> synonym for <code>QVector::const_iterator</code>.</li>
<li>typedef <code>QVector::Iterator</code>: <code>Qt-style</code> synonym for <code>QVector::iterator</code>.</li>
<li>typedef <code>QVector::const_iterator</code>: The <code>QVector::const_iterator</code> typedef provides an <code>STL-style</code> const iterator for <code>QVector</code> and <code>QStack</code>. <code>QVector</code> provides both <code>STL-style</code> iterators and <code>Java-style</code> iterators. The <code>STL-style</code> const iterator is simply a typedef for <code>const T *</code> (pointer to <code>const T</code>).</li>
<li>typedef <code>QVector::const_pointer</code>: Typedef for <code>const T *</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::const_reference</code>: Typedef for <code>T &amp;</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::difference_type</code>: Typedef for <code>ptrdiff_t</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::iterator</code>: The <code>QVector::iterator</code> typedef provides an <code>STL-style</code> <code>non-const</code> iterator for <code>QVector</code> and <code>QStack</code>. <code>QVector</code> provides both <code>STL-style</code> iterators and <code>Java-style</code> iterators. The <code>STL-style</code> <code>non-const</code> iterator is simply a typedef for <code>T *</code> (pointer to <code>T</code>).</li>
<li>typedef <code>QVector::pointer</code>: Typedef for <code>T *</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::reference</code>: Typedef for <code>T &amp;</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::size_type</code>: Typedef for <code>int</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::value_type</code>: Typedef for <code>T</code>. Provided for <code>STL</code> compatibility.</li>
</ul>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QVector::QVector()</code>: Constructs an empty vector.</li>
<li><code>QVector::QVector(int size)</code>: Constructs a vector with an initial size of <code>size</code> elements. The elements are initialized with a <code>default-constructed</code> value.</li>
<li><code>QVector::QVector(int size, const T &amp; value)</code>: Constructs a vector with an initial size of <code>size</code> elements. Each element is initialized with <code>value</code>.</li>
<li><code>QVector::QVector(const QVector&lt;T&gt; &amp; other)</code>: Constructs a copy of <code>other</code>. This operation takes constant time, because <code>QVector</code> is implicitly shared. This makes returning a <code>QVector</code> from a function very fast. If a shared instance is modified, it will be copied (<code>copy-on-write</code>), and that takes linear time.</li>
<li><code>QVector::QVector(std::initializer_list&lt;T&gt; args)</code>: Construct a vector from the <code>std::initilizer_list</code> given by <code>args</code>. This constructor is only enabled if the compiler supports <code>C++0x</code>.</li>
<li><code>QVector::~QVector()</code>: Destroys the vector.</li>
<li><code>void QVector::append(const T &amp; value)</code>: Inserts <code>value</code> at the end of the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span> ( <span class="number">0</span> );</span><br><span class="line"><span class="built_in">vector</span>.append ( <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">vector</span>.append ( <span class="string">"two"</span> );</span><br><span class="line"><span class="built_in">vector</span>.append ( <span class="string">"three"</span> ); <span class="comment">/* vector: ["one", "two", "three"] */</span></span><br></pre></td></tr></table></figure>
<p>This is the same as calling <code>resize(size() + 1)</code> and assigning value to the new last element in the vector. This operation is relatively fast, because <code>QVector</code> typically allocates more memory than necessary, so it can grow without reallocating the entire vector each time.</p>
<ul>
<li><code>const T &amp; QVector::at(int i) const</code>: Returns the item at index position <code>i</code> in the vector. <code>i</code> must be a valid index position in the vector (i.e., <code>0 &lt;= i &lt; size()</code>).</li>
<li><code>reference QVector::back()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>last()</code>.</li>
<li><code>const_reference QVector::back() const</code>: This is an overloaded function.</li>
<li><code>iterator QVector::begin()</code>: Returns an <code>STL-style</code> iterator pointing to the first item in the vector.</li>
<li><code>const_iterator QVector::begin() const</code>: This is an overloaded function.</li>
<li><code>int QVector::capacity() const</code>: Returns the maximum number of items that can be stored in the vector without forcing a reallocation. The sole purpose of this function is to provide a means of fine tuning <code>QVector&#39;s</code> memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the vector, call <code>size()</code>.</li>
<li><code>void QVector::clear()</code>: Removes all the elements from the vector and releases the memory used by the vector.</li>
<li><code>const_iterator QVector::constBegin() const</code>: Returns a const <code>STL-style</code> iterator pointing to the first item in the vector.</li>
<li><code>const T * QVector::constData() const</code>: Returns a const pointer to the data stored in the vector. The pointer can be used to access the items in the vector. The pointer remains valid as long as the vector isn’t reallocated. This function is mostly useful to pass a vector to a function that accepts a plain <code>C++</code> array.</li>
<li><code>const_iterator QVector::constEnd() const</code>: Returns a const <code>STL-style</code> iterator pointing to the imaginary item after the last item in the vector.</li>
<li><code>bool QVector::contains(const T &amp; value) const</code>: Returns <code>true</code> if the vector contains an occurrence of <code>value</code>; otherwise returns <code>false</code>. This function requires the <code>value</code> type to have an implementation of <code>operator==()</code>.</li>
<li><code>int QVector::count(const T &amp; value) const</code>: Returns the number of occurrences of <code>value</code> in the vector. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>int QVector::count() const</code>: This is an overloaded function. Same as <code>size()</code>.</li>
<li><code>T * QVector::data()</code>: Returns a pointer to the data stored in the vector. The pointer can be used to access and modify the items in the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; <span class="built_in">vector</span> ( <span class="number">10</span> );</span><br><span class="line"><span class="keyword">int</span> *data = <span class="built_in">vector</span>.data();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i ) &#123;</span><br><span class="line">    data[i] = <span class="number">2</span> * i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The pointer remains valid as long as the vector isn’t reallocated. This function is mostly useful to pass a vector to a function that accepts a plain <code>C++</code> array.</p>
<ul>
<li><code>const T * QVector::data() const</code>: This is an overloaded function.</li>
<li><code>bool QVector::empty() const</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>isEmpty()</code>, returning <code>true</code> if the vector is empty; otherwise returns <code>false</code>.</li>
<li><code>iterator QVector::end()</code>: Returns an <code>STL-style</code> iterator pointing to the imaginary item after the last item in the vector.</li>
<li><code>const_iterator QVector::end() const</code>: This is an overloaded function.</li>
<li><code>bool QVector::endsWith(const T &amp; value) const</code>: Returns <code>true</code> if this vector is not empty and its last item is equal to <code>value</code>; otherwise returns <code>false</code>.</li>
<li><code>iterator QVector::erase(iterator pos)</code>: Removes the item pointed to by the iterator <code>pos</code> from the vector, and returns an iterator to the next item in the vector (which may be <code>end()</code>).</li>
<li><code>iterator QVector::erase(iterator begin, iterator end)</code>: This is an overloaded function. Removes all the items from <code>begin</code> up to (but not including) <code>end</code>. Returns an iterator to the same item that end referred to before the call.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::fill(const T &amp; value, int size = -1)</code>: Assigns <code>value</code> to all items in the vector. If <code>size</code> is different from <code>-1</code> (the default), the vector is resized to <code>size</code> beforehand. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span> ( <span class="number">3</span> );</span><br><span class="line"><span class="built_in">vector</span>.fill ( <span class="string">"Yes"</span> ); <span class="comment">/* vector: ["Yes", "Yes", "Yes"] */</span></span><br><span class="line"><span class="built_in">vector</span>.fill ( <span class="string">"oh"</span>, <span class="number">5</span> ); <span class="comment">/* vector: ["oh", "oh", "oh", "oh", "oh"] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>T &amp; QVector::first()</code>: Returns a reference to the first item in the vector. This function assumes that the vector isn’t empty.</li>
<li><code>const T &amp; QVector::first() const</code>: This is an overloaded function.</li>
<li><code>QVector&lt;T&gt; QVector::fromList(const QList&lt;T&gt; &amp; list) [static]</code>: Returns a <code>QVector</code> object with the data contained in <code>list</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QStringList <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "Sven" &lt;&lt; "Kim" &lt;&lt; "Ola";</span><br><span class="line">QVector&lt;QString&gt; vect = QVector&lt;QString&gt;::fromList ( <span class="built_in">list</span> ); <span class="comment">/* vect: ["Sven", "Kim", "Ola"] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>QVector&lt;T&gt; QVector::fromStdVector(const std::vector&lt;T&gt; &amp; vector) [static]</code>: Returns a <code>QVector</code> object with the data contained in <code>vector</code>. The order of the elements in the <code>QVector</code> is the same as in vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; stdvector;</span><br><span class="line"><span class="built_in">vector</span>.push_back ( <span class="number">1.2</span> );</span><br><span class="line"><span class="built_in">vector</span>.push_back ( <span class="number">0.5</span> );</span><br><span class="line"><span class="built_in">vector</span>.push_back ( <span class="number">3.14</span> );</span><br><span class="line">QVector&lt;<span class="keyword">double</span>&gt; <span class="built_in">vector</span> = QVector&lt;<span class="keyword">double</span>&gt;::fromStdVector ( stdvector );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>T &amp; QVector::front()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>first()</code>.</li>
<li><code>const_reference QVector::front() const</code>: This is an overloaded function.</li>
<li><code>int QVector::indexOf(const T &amp; value, int from = 0) const</code>: Returns the index position of the first occurrence of <code>value</code> in the vector, searching forward <code>from</code> index position <code>from</code>. Returns <code>-1</code> if no item matched. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "B" &lt;&lt; "A";</span><br><span class="line"><span class="built_in">vector</span>.indexOf ( "B" );    // returns 1</span><br><span class="line"><span class="built_in">vector</span>.indexOf ( "B", 1 ); // returns 1</span><br><span class="line"><span class="built_in">vector</span>.indexOf ( "B", 2 ); // returns 3</span><br><span class="line"><span class="built_in">vector</span>.indexOf ( "X" );    // returns -1</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>.</p>
<ul>
<li><code>void QVector::insert(int i, const T &amp; value)</code>: Inserts <code>value</code> at index position <code>i</code> in the vector. If <code>i</code> is <code>0</code>, the <code>value</code> is prepended to the vector. If <code>i</code> is <code>size()</code>, the <code>value</code> is appended to the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; "alpha" &lt;&lt; "beta" &lt;&lt; "delta";</span><br><span class="line"><span class="built_in">vector</span>.insert ( 2, "gamma" ); /* <span class="built_in">vector</span>: ["alpha", "beta", "gamma", "delta"] */</span><br></pre></td></tr></table></figure>
<p>For large vectors, this operation can be slow (linear time), because it requires moving all the items at indexes i and above by one position further in memory. If you want a container class that provides a fast <code>insert()</code> function, use <code>QLinkedList</code> instead.</p>
<ul>
<li><code>iterator QVector::insert(iterator before, int count, const T &amp; value)</code>: Inserts <code>count</code> copies of <code>value</code> in front of the item pointed to by the iterator <code>before</code>. Returns an iterator pointing at the first of the inserted items.</li>
<li><code>void QVector::insert(int i, int count, const T &amp; value)</code>: This is an overloaded function. Inserts <code>count</code> copies of <code>value</code> at index position <code>i</code> in the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">double</span>&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; 2.718 &lt;&lt; 1.442 &lt;&lt; 0.4342;</span><br><span class="line"><span class="built_in">vector</span>.insert ( 1, 3, 9.9 ); /* <span class="built_in">vector</span>: [2.718, 9.9, 9.9, 9.9, 1.442, 0.4342] */</span><br></pre></td></tr></table></figure>
<ul>
<li><code>iterator QVector::insert(iterator before, const T &amp; value)</code>: This is an overloaded function. Inserts <code>value</code> in front of the item pointed to by the iterator <code>before</code>. Returns an iterator pointing at the inserted item.</li>
<li><code>bool QVector::isEmpty() const</code>: Returns <code>true</code> if the vector has size <code>0</code>; otherwise returns <code>false</code>.</li>
<li><code>T &amp; QVector::last()</code>: Returns a reference to the last item in the vector. This function assumes that the vector isn’t empty.</li>
<li><code>const T &amp; QVector::last() const</code>: This is an overloaded function.</li>
<li><code>int QVector::lastIndexOf(const T &amp; value, int from = -1) const</code>: Returns the index position of the last occurrence of the <code>value</code> in the vector, searching backward from index position <code>from</code>. If <code>from</code> is <code>-1</code> (the default), the search starts at the last item. Returns <code>-1</code> if no item matched. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "B" &lt;&lt; "A";</span><br><span class="line"><span class="built_in">vector</span>.lastIndexOf ( "B" );    // returns 3</span><br><span class="line"><span class="built_in">vector</span>.lastIndexOf ( "B", 3 ); // returns 3</span><br><span class="line"><span class="built_in">vector</span>.lastIndexOf ( "B", 2 ); // returns 1</span><br><span class="line"><span class="built_in">vector</span>.lastIndexOf ( "X" );    // returns -1</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>.</p>
<ul>
<li><code>QVector&lt;T&gt; QVector::mid(int pos, int length = -1) const</code>: Returns a vector whose elements are copied from this vector, starting at position <code>pos</code>. If <code>length</code> is <code>-1</code> (the default), all elements after <code>pos</code> are copied; otherwise <code>length</code> elements (or all remaining elements if there are less than <code>length</code> elements) are copied.</li>
<li><code>void QVector::pop_back()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>erase(end() - 1)</code>.</li>
<li><code>void QVector::pop_front()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>erase(begin())</code>.</li>
<li><code>void QVector::prepend(const T &amp; value)</code>: Inserts <code>value</code> at the beginning of the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span>.prepend ( <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">vector</span>.prepend ( <span class="string">"two"</span> );</span><br><span class="line"><span class="built_in">vector</span>.prepend ( <span class="string">"three"</span> ); <span class="comment">/* vector: ["three", "two", "one"] */</span></span><br></pre></td></tr></table></figure>
<p>This is the same as <code>vector.insert(0, value)</code>. For large vectors, this operation can be slow (linear time), because it requires moving all the items in the vector by one position further in memory. If you want a container class that provides a fast <code>prepend()</code> function, use <code>QList</code> or <code>QLinkedList</code> instead.</p>
<ul>
<li><code>void QVector::push_back(const T &amp; value)</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>append(value)</code>.</li>
<li><code>void QVector::push_front(const T &amp; value)</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>prepend(value)</code>.</li>
<li><code>void QVector::remove(int i)</code>: This is an overloaded function. Removes the element at index position <code>i</code>.</li>
<li><code>void QVector::remove(int i, int count)</code>: This is an overloaded function. Removes <code>count</code> elements from the middle of the vector, starting at index position <code>i</code>.</li>
<li><code>void QVector::replace(int i, const T &amp; value)</code>: Replaces the item at index position <code>i</code> with <code>value</code>. <code>i</code> must be a valid index position in the vector (i.e., <code>0 &lt;= i &lt; size()</code>).</li>
<li><code>void QVector::reserve(int size)</code>: Attempts to allocate memory for at least <code>size</code> elements. If you know in advance how large the vector will be, you can call this function, and if you call <code>resize()</code> often you are likely to get better performance. If size is an underestimate, the worst that will happen is that the <code>QVector</code> will be a bit slower. The sole purpose of this function is to provide a means of fine tuning <code>QVector&#39;s</code> memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the vector, call <code>resize()</code>.</li>
<li><code>void QVector::resize(int size)</code>: Sets the size of the vector to <code>size</code>. If <code>size</code> is greater than the current size, elements are added to the end; the new elements are initialized with a <code>default-constructed</code> value. If <code>size</code> is less than the current size, elements are removed from the end.</li>
<li><code>int QVector::size() const</code>: Returns the number of items in the vector.</li>
<li><code>void QVector::squeeze()</code>: Releases any memory not required to store the items. The sole purpose of this function is to provide a means of fine tuning <code>QVector&#39;s</code> memory usage. In general, you will rarely ever need to call this function.</li>
<li><code>bool QVector::startsWith(const T &amp; value) const</code>: Returns <code>true</code> if this vector is not empty and its first item is equal to <code>value</code>; otherwise returns <code>false</code>.</li>
<li><code>void QVector::swap(QVector&lt;T&gt; &amp; other)</code>: Swaps vector <code>other</code> with this vector. This operation is very fast and never fails.</li>
<li><code>QList&lt;T&gt; QVector::toList() const</code>: Returns a <code>QList</code> object with the data contained in this <code>QVector</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; vect;</span><br><span class="line">vect &lt;&lt; <span class="string">"red"</span> &lt;&lt; <span class="string">"green"</span> &lt;&lt; <span class="string">"blue"</span> &lt;&lt; <span class="string">"black"</span>;</span><br><span class="line">QList&lt;QString&gt; <span class="built_in">list</span> = vect.toList(); <span class="comment">/* list: ["red", "green", "blue", "black"] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::vector&lt;T&gt; QVector::toStdVector() const</code>: Returns a <code>std::vector</code> object with the data contained in this <code>QVector</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">double</span>&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; 1.2 &lt;&lt; 0.5 &lt;&lt; 3.14;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; stdvector = <span class="built_in">vector</span>.toStdVector();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>T QVector::value(int i) const</code>: Returns the value at index position <code>i</code> in the vector. If the index <code>i</code> is out of bounds, the function returns a <code>default-constructed</code> value. If you are certain that <code>i</code> is within bounds, you can use <code>at()</code> instead, which is slightly faster.</li>
<li><code>T QVector::value(int i, const T &amp; defaultValue) const</code>: This is an overloaded function. If the index <code>i</code> is out of bounds, the function returns <code>defaultValue</code>.</li>
<li><code>bool QVector::operator!=(const QVector&lt;T&gt; &amp; other) const</code>: Returns <code>true</code> if <code>other</code> is not equal to this vector; otherwise returns <code>false</code>. Two vectors are considered equal if they contain the same values in the same order. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>QVector&lt;T&gt; QVector::operator+(const QVector&lt;T&gt; &amp; other) const</code>: Returns a vector that contains all the items in this vector followed by all the items in the <code>other</code> vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator+=(const QVector&lt;T&gt; &amp; other)</code>: Appends the items of the <code>other</code> vector to this vector and returns a reference to this vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator+=(const T &amp; value)</code>: This is an overloaded function. Appends <code>value</code> to the vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator&lt;&lt;(const T &amp; value)</code>: Appends <code>value</code> to the vector and returns a reference to this vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator&lt;&lt;(const QVector&lt;T&gt; &amp; other)</code>: Appends <code>other</code> to the vector and returns a reference to the vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator=(const QVector&lt;T&gt; &amp; other)</code>: Assigns <code>other</code> to this vector and returns a reference to this vector.</li>
<li><code>bool QVector::operator==(const QVector&lt;T&gt; &amp; other) const</code>: Returns <code>true</code> if <code>other</code> is equal to this vector; otherwise returns <code>false</code>. Two vectors are considered equal if they contain the same values in the same order. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>T &amp; QVector::operator[](int i)</code>: Returns the item at index position <code>i</code> as a modifiable reference. <code>i</code> must be a valid index position in the vector (i.e., <code>0 &lt;= i &lt; size()</code>). Note that using <code>non-const</code> operators can cause <code>QVector</code> to do a deep copy.</li>
<li><code>const T &amp; QVector::operator[](int i) const</code>: This is an overloaded function. Same as <code>at(i)</code>.</li>
</ul>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; out, const QVector&lt;T&gt; &amp; vector)</code>: Writes the <code>vector</code> to stream <code>out</code>. This function requires the value type to implement <code>operator&lt;&lt;()</code>.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; in, QVector&lt;T&gt; &amp; vector)</code>: Reads a vector from stream <code>in</code> into <code>vector</code>. This function requires the value type to implement <code>operator&gt;&gt;()</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/29/Qt语法详解/Qt之QTextCursor/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/29/Qt语法详解/Qt之QTextCursor/" itemprop="url">Qt之QTextCursor</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-29T11:13:18+08:00">
                2019-01-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTextCursor</code> class offers an <code>API</code> to access and modify <code>QTextDocuments</code>. The header file is <code>QTextCursor</code>. <strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextCursor()</code></td>
</tr>
<tr>
<td></td>
<td><code>QTextCursor(QTextDocument * document)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTextCursor(QTextFrame * frame)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTextCursor(const QTextBlock &amp; block)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTextCursor(const QTextCursor &amp; cursor)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QTextCursor()</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>anchor() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>atBlockEnd() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>atBlockStart() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>atEnd() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>atStart() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>beginEditBlock()</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>block() const</code></td>
</tr>
<tr>
<td><code>QTextCharFormat</code></td>
<td><code>blockCharFormat() const</code></td>
</tr>
<tr>
<td><code>QTextBlockFormat</code></td>
<td><code>blockFormat() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>blockNumber() const</code></td>
</tr>
<tr>
<td><code>QTextCharFormat</code></td>
<td><code>charFormat() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clearSelection()</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>columnNumber() const</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>createList(const QTextListFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>createList(QTextListFormat::Style style)</code></td>
</tr>
<tr>
<td><code>QTextFrame *</code></td>
<td><code>currentFrame() const</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>currentList() const</code></td>
</tr>
<tr>
<td><code>QTextTable *</code></td>
<td><code>currentTable() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>deleteChar()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>deletePreviousChar()</code></td>
</tr>
<tr>
<td><code>QTextDocument *</code></td>
<td><code>document() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>endEditBlock()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasComplexSelection() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasSelection() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertBlock()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertBlock(const QTextBlockFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertBlock(const QTextBlockFormat &amp; format, const QTextCharFormat &amp; charFormat)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertFragment(const QTextDocumentFragment &amp; fragment)</code></td>
</tr>
<tr>
<td><code>QTextFrame *</code></td>
<td><code>insertFrame(const QTextFrameFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertHtml(const QString &amp; html)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertImage(const QTextImageFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertImage(const QTextImageFormat &amp; format, QTextFrameFormat::Position alignment)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertImage(const QString &amp; name)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertImage(const QImage &amp; image, const QString &amp; name = QString())</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>insertList(const QTextListFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>insertList(QTextListFormat::Style style)</code></td>
</tr>
<tr>
<td><code>QTextTable *</code></td>
<td><code>insertTable(int rows, int columns, const QTextTableFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>QTextTable *</code></td>
<td><code>insertTable(int rows, int columns)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertText(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertText(const QString &amp; text, const QTextCharFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isCopyOf(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isNull() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>joinPreviousEditBlock()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>keepPositionOnInsert() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>mergeBlockCharFormat(const QTextCharFormat &amp; modifier)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>mergeBlockFormat(const QTextBlockFormat &amp; modifier)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>mergeCharFormat(const QTextCharFormat &amp; modifier)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>movePosition(MoveOperation operation, MoveMode mode = MoveAnchor, int n = 1)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>position() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>positionInBlock() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeSelectedText()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>select(SelectionType selection)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>selectedTableCells(int * firstRow, int * numRows, int * firstColumn, int * numColumns) const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>selectedText() const</code></td>
</tr>
<tr>
<td><code>QTextDocumentFragment</code></td>
<td><code>selection() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>selectionEnd() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>selectionStart() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBlockCharFormat(const QTextCharFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBlockFormat(const QTextBlockFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCharFormat(const QTextCharFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setKeepPositionOnInsert(bool b)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPosition(int pos, MoveMode m = MoveAnchor)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setVerticalMovementX(int x)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setVisualNavigation(bool b)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>verticalMovementX() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>visualNavigation() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&lt;(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&lt;=(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>QTextCursor &amp;</code></td>
<td><code>operator=(const QTextCursor &amp; cursor)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&gt;(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&gt;=(const QTextCursor &amp; other) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextCursor</code> class offers an <code>API</code> to access and modify <code>QTextDocuments</code>.<br>&emsp;&emsp;Text cursors are objects that are used to access and modify the contents and underlying structure of text documents via a programming interface that mimics the behavior of a cursor in a text editor. <code>QTextCursor</code> contains information about both the cursor’s position within a <code>QTextDocument</code> and any selection that it has made.<br>&emsp;&emsp;<code>QTextCursor</code> is modeled on the way a text cursor behaves in a text editor, providing a programmatic means of performing standard actions through the user interface. A document can be thought of as a single string of characters. The cursor’s current <code>position()</code> then is always either between two consecutive characters in the string, or else before the very first character or after the very last character in the string. Documents can also contain tables, lists, images, and other objects in addition to text but, from the developer’s point of view, the document can be treated as one long string. Some portions of that string can be considered to lie within particular blocks (e.g. paragraphs), or within a table’s cell, or a list’s item, or other structural elements. When we refer to <code>current character</code> we mean the character immediately before the cursor <code>position()</code> in the document. Similarly, the <code>current block</code> is the block that contains the cursor <code>position()</code>.<br>&emsp;&emsp;A <code>QTextCursor</code> also has an <code>anchor()</code> position. The text that is between the <code>anchor()</code> and the <code>position()</code> is the selection. If <code>anchor() == position()</code> there is no selection.<br>&emsp;&emsp;The cursor position can be changed programmatically using <code>setPosition()</code> and <code>movePosition()</code>; the latter can also be used to select text. For selections see <code>selectionStart()</code>, <code>selectionEnd()</code>, <code>hasSelection()</code>, <code>clearSelection()</code>, and <code>removeSelectedText()</code>.<br>&emsp;&emsp;If the <code>position()</code> is at the start of a block <code>atBlockStart()</code> returns <code>true</code>; and if it is at the end of a block <code>atBlockEnd()</code> returns <code>true</code>. The format of the current character is returned by <code>charFormat()</code>, and the format of the current block is returned by <code>blockFormat()</code>.<br>&emsp;&emsp;Formatting can be applied to the current text document using the <code>setCharFormat()</code>, <code>mergeCharFormat()</code>, <code>setBlockFormat()</code> and <code>mergeBlockFormat()</code> functions. The <code>set</code> functions will replace the cursor’s current character or block format, while the <code>merge</code> functions add the given format properties to the cursor’s current format. If the cursor has a selection the given format is applied to the current selection. Note that when only parts of a block is selected the block format is applied to the entire block. The text at the current character position can be turned into a list using <code>createList()</code>.<br>&emsp;&emsp;Deletions can be achieved using <code>deleteChar()</code>, <code>deletePreviousChar()</code>, and <code>removeSelectedText()</code>.<br>&emsp;&emsp;Text strings can be inserted into the document with the <code>insertText()</code> function, blocks (representing new paragraphs) can be inserted with <code>insertBlock()</code>.<br>&emsp;&emsp;Existing fragments of text can be inserted with <code>insertFragment()</code>, but if you want to insert pieces of text in various formats, it is usually still easier to use <code>insertText()</code> and supply a character format.<br>&emsp;&emsp;Various types of <code>higher-level</code> structure can also be inserted into the document with the cursor:</p>
<ul>
<li>Lists are ordered sequences of block elements that are decorated with bullet points or symbols. These are inserted in a specified format with <code>insertList()</code>.</li>
<li>Tables are inserted with the <code>insertTable()</code> function, and can be given an optional format. These contain an array of cells that can be traversed using the cursor.</li>
<li>Inline images are inserted with <code>insertImage()</code>. The image to be used can be specified in an image format, or by name.</li>
<li>Frames are inserted by calling <code>insertFrame()</code> with a specified format.</li>
</ul>
<p>&emsp;&emsp;Actions can be grouped (i.e. treated as a single action for undo/redo) using <code>beginEditBlock()</code> and <code>endEditBlock()</code>.<br>&emsp;&emsp;Cursor movements are limited to valid cursor positions. In <code>Latin</code> writing this is between any two consecutive characters in the text, before the first character, or after the last character. In some other writing systems cursor movements are limited to <code>clusters</code> (e.g. a syllable in Devanagari, or a base letter plus diacritics). Functions such as <code>movePosition()</code> and <code>deleteChar()</code> limit cursor movement to these valid positions.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QTextCursor::MoveMode</code>:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCursor::MoveAnchor</code></td>
<td><code>0</code></td>
<td>Moves the anchor to the same position as the cursor itself.</td>
</tr>
<tr>
<td><code>QTextCursor::KeepAnchor</code></td>
<td><code>1</code></td>
<td>Keeps the anchor where it is.</td>
</tr>
</tbody>
</table>
</div>
<p>If the <code>anchor()</code> is kept where it is and the <code>position()</code> is moved, the text in between will be selected.</p>
<ul>
<li>enum <code>QTextCursor::MoveOperation</code>:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCursor::NoMove</code></td>
<td><code>0</code></td>
<td>Keep the cursor where it is.</td>
</tr>
<tr>
<td><code>QTextCursor::Start</code></td>
<td><code>1</code></td>
<td>Move to the start of the document.</td>
</tr>
<tr>
<td><code>QTextCursor::StartOfLine</code></td>
<td><code>3</code></td>
<td>Move to the start of the current line.</td>
</tr>
<tr>
<td><code>QTextCursor::StartOfBlock</code></td>
<td><code>4</code></td>
<td>Move to the start of the current block.</td>
</tr>
<tr>
<td><code>QTextCursor::StartOfWord</code></td>
<td><code>5</code></td>
<td>Move to the start of the current word.</td>
</tr>
<tr>
<td><code>QTextCursor::PreviousBlock</code></td>
<td><code>6</code></td>
<td>Move to the start of the previous block.</td>
</tr>
<tr>
<td><code>QTextCursor::PreviousCharacter</code></td>
<td><code>7</code></td>
<td>Move to the previous character.</td>
</tr>
<tr>
<td><code>QTextCursor::PreviousWord</code></td>
<td><code>8</code></td>
<td>Move to the beginning of the previous word.</td>
</tr>
<tr>
<td><code>QTextCursor::Up</code></td>
<td><code>2</code></td>
<td>Move up one line.</td>
</tr>
<tr>
<td><code>QTextCursor::Left</code></td>
<td><code>9</code></td>
<td>Move left one character.</td>
</tr>
<tr>
<td><code>QTextCursor::WordLeft</code></td>
<td><code>10</code></td>
<td>Move left one word.</td>
</tr>
<tr>
<td><code>QTextCursor::End</code></td>
<td><code>11</code></td>
<td>Move to the end of the document.</td>
</tr>
<tr>
<td><code>QTextCursor::EndOfLine</code></td>
<td><code>13</code></td>
<td>Move to the end of the current line.</td>
</tr>
<tr>
<td><code>QTextCursor::EndOfWord</code></td>
<td><code>14</code></td>
<td>Move to the end of the current word.</td>
</tr>
<tr>
<td><code>QTextCursor::EndOfBlock</code></td>
<td><code>15</code></td>
<td>Move to the end of the current block.</td>
</tr>
<tr>
<td><code>QTextCursor::NextBlock</code></td>
<td><code>16</code></td>
<td>Move to the beginning of the next block.</td>
</tr>
<tr>
<td><code>QTextCursor::NextCharacter</code></td>
<td><code>17</code></td>
<td>Move to the next character.</td>
</tr>
<tr>
<td><code>QTextCursor::NextWord</code></td>
<td><code>18</code></td>
<td>Move to the next word.</td>
</tr>
<tr>
<td><code>QTextCursor::Down</code></td>
<td><code>12</code></td>
<td>Move down one line.</td>
</tr>
<tr>
<td><code>QTextCursor::Right</code></td>
<td><code>19</code></td>
<td>Move right one character.</td>
</tr>
<tr>
<td><code>QTextCursor::WordRight</code></td>
<td><code>20</code></td>
<td>Move right one word.</td>
</tr>
<tr>
<td><code>QTextCursor::NextCell</code></td>
<td><code>21</code></td>
<td>Move to the beginning of the next table cell inside the current table. If the current cell is the last cell in the row, the cursor will move to the first cell in the next row.</td>
</tr>
<tr>
<td><code>QTextCursor::PreviousCell</code></td>
<td><code>22</code></td>
<td>Move to the beginning of the previous table cell inside the current table. If the current cell is the first cell in the row, the cursor will move to the last cell in the previous row.</td>
</tr>
<tr>
<td><code>QTextCursor::NextRow</code></td>
<td><code>23</code></td>
<td>Move to the first new cell of the next row in the current table.</td>
</tr>
<tr>
<td><code>QTextCursor::PreviousRow</code></td>
<td><code>24</code></td>
<td>Move to the last cell of the previous row in the current table.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QTextCursor::SelectionType</code>: This enum describes the types of selection that can be applied with the <code>select()</code> function.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCursor::Document</code></td>
<td><code>3</code></td>
<td>Selects the entire document.</td>
</tr>
<tr>
<td><code>QTextCursor::BlockUnderCursor</code></td>
<td><code>2</code></td>
<td>Selects the block of text under the cursor.</td>
</tr>
<tr>
<td><code>QTextCursor::LineUnderCursor</code></td>
<td><code>1</code></td>
<td>Selects the line of text under the cursor.</td>
</tr>
<tr>
<td><code>QTextCursor::WordUnderCursor</code></td>
<td><code>0</code></td>
<td>Selects the word under the cursor. If the cursor is not positioned within a string of selectable characters, no text is selected.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextCursor::QTextCursor()</code>: Constructs a null cursor.</li>
<li><code>QTextCursor::QTextCursor(QTextDocument * document)</code>: Constructs a cursor pointing to the beginning of the <code>document</code>.</li>
<li><code>QTextCursor::QTextCursor(QTextFrame * frame)</code>: Constructs a cursor pointing to the beginning of the <code>frame</code>.</li>
<li><code>QTextCursor::QTextCursor(const QTextBlock &amp; block)</code>: Constructs a cursor pointing to the beginning of the <code>block</code>.</li>
<li><code>QTextCursor::QTextCursor(const QTextCursor &amp; cursor)</code>: Constructs a new cursor that is a copy of <code>cursor</code>.</li>
<li><code>QTextCursor::~QTextCursor()</code>: Destroys the <code>QTextCursor</code>.</li>
<li><code>int QTextCursor::anchor() const</code>: Returns the anchor position; this is the same as <code>position()</code> unless there is a selection in which case <code>position()</code> marks one end of the selection and <code>anchor()</code> marks the other end. Just like the cursor position, the anchor position is between characters.</li>
<li><code>bool QTextCursor::atBlockEnd() const</code>: Returns <code>true</code> if the cursor is at the end of a block; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::atBlockStart() const</code>: Returns <code>true</code> if the cursor is at the start of a block; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::atEnd() const</code>: Returns <code>true</code> if the cursor is at the end of the document; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::atStart() const</code>: Returns <code>true</code> if the cursor is at the start of the document; otherwise returns <code>false</code>.</li>
<li><code>void QTextCursor::beginEditBlock()</code>: Indicates the start of a block of editing operations on the document that should appear as a single operation from an undo/redo point of view. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTextCursor <span class="title">cursor</span> <span class="params">( textDocument )</span></span>;</span><br><span class="line">cursor.beginEditBlock();</span><br><span class="line">cursor.insertText ( <span class="string">"Hello"</span> );</span><br><span class="line">cursor.insertText ( <span class="string">"World"</span> );</span><br><span class="line">cursor.endEditBlock();</span><br><span class="line">​</span><br><span class="line">textDocument-&gt;undo();</span><br></pre></td></tr></table></figure>
<p>The call to <code>undo()</code> will cause both insertions to be undone, causing both <code>World</code> and <code>Hello</code> to be removed. It is possible to nest calls to <code>beginEditBlock</code> and <code>endEditBlock</code>. The <code>top-most</code> pair will determine the scope of the undo/redo operation.</p>
<ul>
<li><code>QTextBlock QTextCursor::block() const</code> — Returns the block that contains the cursor.</li>
<li><code>QTextCharFormat QTextCursor::blockCharFormat() const</code>: Returns the block character format of the block the cursor is in. The block char format is the format used when inserting text at the beginning of an empty block.</li>
<li><code>QTextBlockFormat QTextCursor::blockFormat() const</code>: Returns the block format of the block the cursor is in.</li>
<li><code>int QTextCursor::blockNumber() const</code>: Returns the number of the block the cursor is in, or <code>0</code> if the cursor is invalid. Note that this function only makes sense in documents without complex objects such as tables or frames.</li>
<li><code>QTextCharFormat QTextCursor::charFormat() const</code>: Returns the format of the character immediately before the cursor <code>position()</code>. If the cursor is positioned at the beginning of a text block that is not empty then the format of the character immediately after the cursor is returned.</li>
<li><code>void QTextCursor::clearSelection()</code>: Clears the current selection by setting the anchor to the cursor position. Note that it does not delete the text of the selection.</li>
<li><code>int QTextCursor::columnNumber() const</code>: Returns the position of the cursor within its containing line. Note that this is the column number relative to a wrapped line, not relative to the block (i.e. the paragraph). You probably want to call <code>positionInBlock()</code> instead.</li>
<li><code>QTextList * QTextCursor::createList(const QTextListFormat &amp; format)</code>: Creates and returns a new list with the given <code>format</code>, and makes the current paragraph the cursor is in the first list item.</li>
<li><code>QTextList * QTextCursor::createList(QTextListFormat::Style style)</code>: This is an overloaded function. Creates and returns a new list with the given <code>style</code>, making the cursor’s current paragraph the first list item. The <code>style</code> to be used is defined by the <code>QTextListFormat::Style</code> enum.</li>
<li><code>QTextFrame * QTextCursor::currentFrame() const</code>: Returns a pointer to the current frame. Returns <code>0</code> if the cursor is invalid.</li>
<li><code>QTextList * QTextCursor::currentList() const</code>: Returns the current list if the cursor <code>position()</code> is inside a block that is part of a list; otherwise returns <code>0</code>.</li>
<li><code>QTextTable * QTextCursor::currentTable() const</code>: Returns a pointer to the current table if the cursor <code>position()</code> is inside a block that is part of a table; otherwise returns <code>0</code>.</li>
<li><code>void QTextCursor::deleteChar()</code>: If there is no selected text, deletes the character at the current cursor position; otherwise deletes the selected text.</li>
<li><code>void QTextCursor::deletePreviousChar()</code>: If there is no selected text, deletes the character before the current cursor position; otherwise deletes the selected text.</li>
<li><code>QTextDocument * QTextCursor::document() const</code>: Returns the document this cursor is associated with.</li>
<li><code>void QTextCursor::endEditBlock()</code>: Indicates the end of a block of editing operations on the document that should appear as a single operation from an undo/redo point of view.</li>
<li><code>bool QTextCursor::hasComplexSelection() const</code>: Returns <code>true</code> if the cursor contains a selection that is not simply a range from <code>selectionStart()</code> to <code>selectionEnd()</code>; otherwise returns <code>false</code>. Complex selections are ones that span at least two cells in a table; their extent is specified by <code>selectedTableCells()</code>.</li>
<li><code>bool QTextCursor::hasSelection() const</code>: Returns <code>true</code> if the cursor contains a selection; otherwise returns <code>false</code>.</li>
<li><code>void QTextCursor::insertBlock()</code>: Inserts a new empty block at the cursor <code>position()</code> with the current <code>blockFormat()</code> and <code>charFormat()</code>.</li>
<li><code>void QTextCursor::insertBlock(const QTextBlockFormat &amp; format)</code>: This is an overloaded function. Inserts a new empty block at the cursor <code>position()</code> with block <code>format</code> and the current <code>charFormat()</code> as block char format.</li>
<li><code>void QTextCursor::insertBlock(const QTextBlockFormat &amp; format, const QTextCharFormat &amp; charFormat)</code>: This is an overloaded function. Inserts a new empty block at the cursor <code>position()</code> with block <code>format</code> and <code>charFormat</code> as block char format.</li>
<li><code>void QTextCursor::insertFragment(const QTextDocumentFragment &amp; fragment)</code>: Inserts the text <code>fragment</code> at the current <code>position()</code>.</li>
<li><code>QTextFrame * QTextCursor::insertFrame(const QTextFrameFormat &amp; format)</code>: Inserts a frame with the given <code>format</code> at the current cursor <code>position()</code>, moves the cursor <code>position()</code> inside the frame, and returns the frame. If the cursor holds a selection, the whole selection is moved inside the frame.</li>
<li><code>void QTextCursor::insertHtml(const QString &amp; html)</code>: Inserts the text <code>html</code> at the current <code>position()</code>. The text is interpreted as <code>HTML</code>. <strong>Note</strong>: When using this function with a style sheet, the style sheet will only apply to the current block in the document. In order to apply a style sheet throughout a document, use <code>QTextDocument::setDefaultStyleSheet()</code> instead.</li>
<li><code>void QTextCursor::insertImage(const QTextImageFormat &amp; format)</code>: Inserts the image defined by <code>format</code> at the current <code>position()</code>.</li>
<li><code>void QTextCursor::insertImage(const QTextImageFormat &amp; format, QTextFrameFormat::Position alignment)</code>: This is an overloaded function. Inserts the image defined by the given <code>format</code> at the cursor’s current position with the specified <code>alignment</code>.</li>
<li><code>void QTextCursor::insertImage(const QString &amp; name)</code>: This is an overloaded function. Convenience method for inserting the image with the given <code>name</code> at the current <code>position()</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QImage img = ...;</span><br><span class="line">textDocument-&gt;addResource ( QTextDocument::ImageResource, QUrl ( <span class="string">"myimage"</span> ), img );</span><br><span class="line">cursor.insertImage ( <span class="string">"myimage"</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QTextCursor::insertImage(const QImage &amp; image, const QString &amp; name = QString())</code>: This is an overloaded function. Convenience function for inserting the given <code>image</code> with an optional <code>name</code> at the current <code>position()</code>.</li>
<li><code>QTextList * QTextCursor::insertList(const QTextListFormat &amp; format)</code>: Inserts a new block at the current position and makes it the first list item of a newly created list with the given <code>format</code>. Returns the created list.</li>
<li><code>QTextList * QTextCursor::insertList(QTextListFormat::Style style)</code>: This is an overloaded function. Inserts a new block at the current position and makes it the first list item of a newly created list with the given <code>style</code>. Returns the created list.</li>
<li><code>QTextTable * QTextCursor::insertTable(int rows, int columns, const QTextTableFormat &amp; format)</code>: Creates a new table with the given number of <code>rows</code> and <code>columns</code> in the specified <code>format</code>, inserts it at the current cursor <code>position()</code> in the document, and returns the table object. The cursor is moved to the beginning of the first cell. There must be at least one row and one column in the table.</li>
<li><code>QTextTable * QTextCursor::insertTable(int rows, int columns)</code>: This is an overloaded function. Creates a new table with the given number of <code>rows</code> and <code>columns</code>, inserts it at the current cursor <code>position()</code> in the document, and returns the table object. The cursor is moved to the beginning of the first cell. There must be at least one row and one column in the table.</li>
<li><code>void QTextCursor::insertText(const QString &amp; text)</code>: Inserts <code>text</code> at the current position, using the current character format. If there is a selection, the selection is deleted and replaced by <code>text</code>, for example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cursor.clearSelection();</span><br><span class="line">cursor.movePosition ( QTextCursor::NextWord, QTextCursor::KeepAnchor );</span><br><span class="line">cursor.insertText ( <span class="string">"Hello World"</span> );</span><br></pre></td></tr></table></figure>
<p>This clears any existing selection, selects the word at the cursor (i.e. from <code>position()</code> forward), and replaces the selection with the phrase <code>Hello World</code>. Any <code>ASCII</code> linefeed characters (<code>\n</code>) in the inserted text are transformed into unicode block separators, corresponding to <code>insertBlock()</code> calls.</p>
<ul>
<li><code>void QTextCursor::insertText(const QString &amp; text, const QTextCharFormat &amp; format)</code>: This is an overloaded function. Inserts <code>text</code> at the current position with the given <code>format</code>.</li>
<li><code>bool QTextCursor::isCopyOf(const QTextCursor &amp; other) const</code>: Returns true if this cursor and <code>other</code> are copies of each <code>other</code>, i.e. one of them was created as a copy of the <code>other</code> and neither has moved since. This is much stricter than equality.</li>
<li><code>bool QTextCursor::isNull() const</code>: Returns <code>true</code> if the cursor is null; otherwise returns <code>false</code>. A null cursor is created by the default constructor.</li>
<li><code>void QTextCursor::joinPreviousEditBlock()</code>: Like <code>beginEditBlock()</code> indicates the start of a block of editing operations that should appear as a single operation for undo/redo. However unlike <code>beginEditBlock()</code> it does not start a new block but reverses the previous call to <code>endEditBlock()</code> and therefore makes following operations part of the previous edit block created. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTextCursor <span class="title">cursor</span> <span class="params">( textDocument )</span></span>;</span><br><span class="line">cursor.beginEditBlock();</span><br><span class="line">cursor.insertText ( <span class="string">"Hello"</span> );</span><br><span class="line">cursor.insertText ( <span class="string">"World"</span> );</span><br><span class="line">cursor.endEditBlock();</span><br><span class="line">...</span><br><span class="line">cursor.joinPreviousEditBlock();</span><br><span class="line">cursor.insertText ( <span class="string">"Hey"</span> );</span><br><span class="line">cursor.endEditBlock();</span><br><span class="line">​</span><br><span class="line">textDocument-&gt;undo();</span><br></pre></td></tr></table></figure>
<p>The call to <code>undo()</code> will cause all three insertions to be undone.</p>
<ul>
<li><code>bool QTextCursor::keepPositionOnInsert() const</code>: Returns whether the cursor should keep its current position when text gets inserted at the position of the cursor. The default is <code>false</code>.</li>
<li><code>void QTextCursor::mergeBlockCharFormat(const QTextCharFormat &amp; modifier)</code>: Modifies the block char format of the current block (or all blocks that are contained in the selection) with the block format specified by <code>modifier</code>.</li>
<li><code>void QTextCursor::mergeBlockFormat(const QTextBlockFormat &amp; modifier)</code>: Modifies the block format of the current block (or all blocks that are contained in the selection) with the block format specified by <code>modifier</code>.</li>
<li><code>void QTextCursor::mergeCharFormat(const QTextCharFormat &amp; modifier)</code>: Merges the cursor’s current character format with the properties described by format <code>modifier</code>. If the cursor has a selection, this function applies all the properties set in <code>modifier</code> to all the character formats that are part of the selection.</li>
<li><code>bool QTextCursor::movePosition(MoveOperation operation, MoveMode mode = MoveAnchor, int n = 1)</code>: Moves the cursor by performing the given <code>operation</code> <code>n</code> times, using the specified <code>mode</code>, and returns <code>true</code> if all operations were completed successfully; otherwise returns <code>false</code>. For example, if this function is repeatedly used to seek to the end of the next word, it will eventually fail when the end of the document is reached. By default, the move <code>operation</code> is performed once (<code>n = 1</code>). If <code>mode</code> is <code>KeepAnchor</code>, the cursor selects the text it moves over. This is the same effect that the user achieves when they hold down the <code>Shift</code> key and move the cursor with the cursor keys.</li>
<li><code>int QTextCursor::position() const</code>: Returns the absolute position of the cursor within the document. The cursor is positioned between characters.</li>
<li><code>int QTextCursor::positionInBlock() const</code>: Returns the relative position of the cursor within the block. The cursor is positioned between characters.</li>
<li><code>void QTextCursor::removeSelectedText()</code>: If there is a selection, its content is deleted; otherwise does nothing.</li>
<li><code>void QTextCursor::select(SelectionType selection)</code>: Selects text in the document according to the given <code>selection</code>.</li>
<li><code>void QTextCursor::selectedTableCells(int * firstRow, int * numRows, int * firstColumn, int * numColumns) const</code>: If the selection spans over table cells, <code>firstRow</code> is populated with the number of the first row in the selection, <code>firstColumn</code> with the number of the first column in the selection, and <code>numRows</code> and <code>numColumns</code> with the number of rows and columns in the selection. If the selection does not span any table cells the results are harmless but undefined.</li>
<li><code>QString QTextCursor::selectedText() const</code>: Returns the current selection’s text (which may be empty). This only returns the text, with no rich text formatting information. If you want a document fragment (i.e. formatted rich text) use <code>selection()</code> instead. <strong>Note</strong>: If the selection obtained from an editor spans a line break, the text will contain a <code>Unicode U+2029</code> paragraph separator character instead of a newline <code>\n</code> character. Use <code>QString::replace()</code> to replace these characters with newlines.</li>
<li><code>QTextDocumentFragment QTextCursor::selection() const</code>: Returns the current selection (which may be empty) with all its formatting information. If you just want the selected text (i.e. plain text) use <code>selectedText()</code> instead. <strong>Note</strong>: Unlike <code>QTextDocumentFragment::toPlainText()</code>, <code>selectedText()</code> may include special unicode characters such as <code>QChar::ParagraphSeparator</code>.</li>
<li><code>int QTextCursor::selectionEnd() const</code>: Returns the end of the <code>selection</code> or <code>position()</code> if the cursor doesn’t have a selection.</li>
<li><code>int QTextCursor::selectionStart() const</code>: Returns the start of the <code>selection</code> or <code>position()</code> if the cursor doesn’t have a selection.</li>
<li><code>void QTextCursor::setBlockCharFormat(const QTextCharFormat &amp; format)</code>: Sets the block char <code>format</code> of the current block (or all blocks that are contained in the selection) to <code>format</code>.</li>
<li><code>void QTextCursor::setBlockFormat(const QTextBlockFormat &amp; format)</code>: Sets the block <code>format</code> of the current block (or all blocks that are contained in the selection) to <code>format</code>.</li>
<li><code>void QTextCursor::setCharFormat(const QTextCharFormat &amp; format)</code>: Sets the cursor’s current character <code>format</code> to the given <code>format</code>. If the cursor has a selection, the given <code>format</code> is applied to the current selection.</li>
<li><code>void QTextCursor::setKeepPositionOnInsert(bool b)</code>: Defines whether the cursor should keep its current position when text gets inserted at the current position of the cursor. If <code>b</code> is <code>true</code>, the cursor keeps its current position when text gets inserted at the positing of the cursor. If <code>b</code> is <code>false</code>, the cursor moves along with the inserted text. The default is <code>false</code>. Note that a cursor always moves when text is inserted before the current position of the cursor, and it always keeps its position when text is inserted after the current position of the cursor.</li>
<li><code>void QTextCursor::setPosition(int pos, MoveMode m = MoveAnchor)</code>: Moves the cursor to the absolute position in the document specified by <code>pos</code> using a <code>MoveMode</code> specified by <code>m</code>. The cursor is positioned between characters.</li>
<li><code>void QTextCursor::setVerticalMovementX(int x)</code>: Sets the visual <code>x</code> position for vertical cursor movements to <code>x</code>. The vertical movement <code>x</code> position is cleared automatically when the cursor moves horizontally, and kept unchanged when the cursor moves vertically. The mechanism allows the cursor to move up and down on a visually straight line with proportional fonts, and to gently <code>jump</code> over short lines. A value of <code>-1</code> indicates no predefined <code>x</code> position. It will then be set automatically the next time the cursor moves up or down.</li>
<li><code>void QTextCursor::setVisualNavigation(bool b)</code>: Sets visual navigation to <code>b</code>. Visual navigation means skipping over hidden text pragraphs. The default is <code>false</code>.</li>
<li><code>int QTextCursor::verticalMovementX() const</code>: Returns the visual <code>x</code> position for vertical cursor movements. A value of <code>-1</code> indicates no predefined <code>x</code> position. It will then be set automatically the next time the cursor moves up or down.</li>
<li><code>bool QTextCursor::visualNavigation() const</code>: Returns <code>true</code> if the cursor does visual navigation; otherwise returns <code>false</code>. Visual navigation means skipping over hidden text pragraphs. The default is <code>false</code>.</li>
<li><code>bool QTextCursor::operator!=(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is at a different position in the document as this cursor; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::operator&lt;(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is positioned later in the document than this cursor; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::operator&lt;=(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is positioned later or at the same position in the document as this cursor; otherwise returns <code>false</code>.</li>
<li><code>QTextCursor &amp; QTextCursor::operator=(const QTextCursor &amp; cursor)</code>: Makes a copy of <code>cursor</code> and assigns it to this <code>QTextCursor</code>. Note that <code>QTextCursor</code> is an implicitly shared class.</li>
<li><code>bool QTextCursor::operator==(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is at the same position in the document as this cursor; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::operator&gt;(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is positioned earlier in the document than this cursor; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::operator&gt;=(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is positioned earlier or at the same position in the document as this cursor; otherwise returns <code>false</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/28/Qt语法详解/Qt之QHash/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/28/Qt语法详解/Qt之QHash/" itemprop="url">Qt之QHash</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-28T18:27:15+08:00">
                2019-01-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QHash</code> class is a template class that provides a <code>hash-table-based</code> dictionary.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QHash</code></td>
<td><code>QMultiHash</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QHash()</code></td>
</tr>
<tr>
<td></td>
<td><code>QHash(const QHash&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QHash()</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>begin()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>capacity() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constBegin() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constEnd() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constFind(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>contains(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>empty() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>end()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator pos)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>find(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>find(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insert(const Key &amp; key, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insertMulti(const Key &amp; key, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>const Key</code></td>
<td><code>key(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>const Key</code></td>
<td><code>key(const T &amp; value, const Key &amp; defaultKey) const</code></td>
</tr>
<tr>
<td><code>QList&lt;Key&gt;</code></td>
<td><code>keys() const</code></td>
</tr>
<tr>
<td><code>QList&lt;Key&gt;</code></td>
<td><code>keys(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>remove(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>reserve(int size)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>squeeze()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(QHash&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>take(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>QList&lt;Key&gt;</code></td>
<td><code>uniqueKeys() const</code></td>
</tr>
<tr>
<td><code>QHash&lt;Key, T&gt; &amp;</code></td>
<td><code>unite(const QHash&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>const T</code></td>
<td><code>value(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>const T</code></td>
<td><code>value(const Key &amp; key, const T &amp; defaultValue) const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>values() const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>values(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QHash&lt;Key, T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QHash&lt;Key, T&gt; &amp;</code></td>
<td><code>operator=(const QHash&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QHash&lt;Key, T&gt; &amp;</code></td>
<td><code>operator=(QHash&lt;Key, T&gt; &amp;&amp; other)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QHash&lt;Key, T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>operator[](const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>const T</code></td>
<td><code>operator[](const Key &amp; key) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>uint</code></td>
<td><code>qHash(const QXmlNodeModelIndex &amp; index)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(char key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(uchar key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(signed char key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(ushort key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(short key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(uint key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(int key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(ulong key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(long key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(quint64 key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(qint64 key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(QChar key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(const QByteArray &amp; key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(const QString &amp; key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(const QBitArray &amp; key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(const T * key)</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>qHash(const QPair&lt;T1, T2&gt; &amp; key)</code></td>
</tr>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&lt;&lt;(QDataStream &amp; out, const QHash&lt;Key, T&gt; &amp; hash)</code></td>
</tr>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&gt;&gt;(QDataStream &amp; in, QHash&lt;Key, T&gt; &amp; hash)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QHash</code> class is a template class that provides a <code>hash-table-based</code> dictionary.<br>&emsp;&emsp;<code>QHash&lt;Key, T&gt;</code> is one of <code>Qt&#39;s</code> generic container classes. It stores <code>(key, value)</code> pairs and provides very fast lookup of the value associated with a key.<br>&emsp;&emsp;<code>QHash</code> provides very similar functionality to <code>QMap</code>. The differences are:</p>
<ul>
<li><code>QHash</code> provides faster lookups than <code>QMap</code>.</li>
<li>When iterating over a <code>QMap</code>, the items are always sorted by key. With <code>QHash</code>, the items are arbitrarily ordered.</li>
<li>The key type of a <code>QMap</code> must provide <code>operator&lt;()</code>. The key type of a <code>QHash</code> must provide <code>operator==()</code> and a global hash function called <code>qHash()</code>.</li>
</ul>
<p>&emsp;&emsp;Here’s an example <code>QHash</code> with <code>QString</code> keys and int values:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QHash&lt;QString, <span class="keyword">int</span>&gt; hash;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;To insert a <code>(key, value)</code> pair into the hash, you can use <code>operator[]()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hash[<span class="string">"one"</span>] = <span class="number">1</span>;</span><br><span class="line">hash[<span class="string">"three"</span>] = <span class="number">3</span>;</span><br><span class="line">hash[<span class="string">"seven"</span>] = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;This inserts the following three <code>(key, value)</code> pairs into the <code>QHash</code>: <code>(&quot;one&quot;, 1)</code>, <code>(&quot;three&quot;, 3)</code>, and <code>(&quot;seven&quot;, 7)</code>. Another way to insert items into the hash is to use <code>insert()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.insert(<span class="string">"twelve"</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;To look up a value, use <code>operator[]()</code> or <code>value()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = hash[<span class="string">"thirteen"</span>];</span><br><span class="line"><span class="keyword">int</span> num2 = hash.value ( <span class="string">"thirteen"</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If there is no item with the specified key in the hash, these functions return a <code>default-constructed</code> value.<br>&emsp;&emsp;If you want to check whether the hash contains a particular key, use <code>contains()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> timeout = <span class="number">30</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( hash.contains ( <span class="string">"TIMEOUT"</span> ) ) &#123;</span><br><span class="line">    timeout = hash.value ( <span class="string">"TIMEOUT"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;There is also a <code>value()</code> overload that uses its second argument as a default value if there is no item with the specified key:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> timeout = hash.value ( <span class="string">"TIMEOUT"</span>, <span class="number">30</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;In general, we recommend that you use <code>contains()</code> and <code>value()</code> rather than <code>operator[]()</code> for looking up a key in a hash. The reason is that <code>operator[]()</code> silently inserts an item into the hash if no item exists with the same key (unless the hash is const). For example, the following code snippet will create <code>1000</code> items in memory:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line">QHash&lt;<span class="keyword">int</span>, QWidget *&gt; hash;</span><br><span class="line">...</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( hash[i] == okButton ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found button at index "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;To avoid this problem, replace <code>hash[i]</code> with <code>hash.value(i)</code> in the code above.<br>&emsp;&emsp;If you want to navigate through all the <code>(key, value)</code> pairs stored in a <code>QHash</code>, you can use an iterator. <code>QHash</code> provides both <code>Java-style</code> iterators (<code>QHashIterator</code> and <code>QMutableHashIterator</code>) and <code>STL-style</code> iterators (<code>QHash::const_iterator</code> and <code>QHash::iterator</code>). Here’s how to iterate over a <code>QHash&lt;QString, int&gt;</code> using a <code>Java-style</code> iterator:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QHashIterator&lt;QString, <span class="keyword">int</span>&gt; i ( hash );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i.hasNext() ) &#123;</span><br><span class="line">    i.next();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.key() &lt;&lt; <span class="string">": "</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Here’s the same code, but using an <code>STL-style</code> iterator:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QHash&lt;QString, <span class="keyword">int</span>&gt;::const_iterator i = hash.constBegin();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != hash.constEnd() ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.key() &lt;&lt; <span class="string">": "</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>QHash</code> is unordered, so an iterator’s sequence cannot be assumed to be predictable. If ordering by key is required, use a <code>QMap</code>.<br>&emsp;&emsp;Normally, a <code>QHash</code> allows only one value per key. If you call <code>insert()</code> with a key that already exists in the <code>QHash</code>, the previous value is erased. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash.insert ( <span class="string">"plenty"</span>, <span class="number">100</span> );</span><br><span class="line">hash.insert ( <span class="string">"plenty"</span>, <span class="number">2000</span> ); <span class="comment">/* hash.value("plenty") == 2000 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;However, you can store multiple values per key by using <code>insertMulti()</code> instead of <code>insert()</code> (or using the convenience subclass <code>QMultiHash</code>). If you want to retrieve all the values for a single key, you can use <code>values(const Key &amp;key)</code>, which returns a <code>QList&lt;T&gt;</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;<span class="keyword">int</span>&gt; values = hash.values ( <span class="string">"plenty"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.size(); ++i ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values.at ( i ) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The items that share the same key are available from most recently to least recently inserted. A more efficient approach is to call <code>find()</code> to get the iterator for the first item with a key and iterate from there:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QHash&lt;QString, <span class="keyword">int</span>&gt;::iterator i = hash.find ( <span class="string">"plenty"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != hash.end() &amp;&amp; i.key() == <span class="string">"plenty"</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If you only need to extract the values from a hash (not the keys), you can also use <code>foreach</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QHash&lt;QString, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">...</span><br><span class="line">​</span><br><span class="line">foreach ( <span class="keyword">int</span> value, hash ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Items can be removed from the hash in several ways. One way is to call <code>remove()</code>; this will remove any item with the given key. Another way is to use <code>QMutableHashIterator::remove()</code>. In addition, you can clear the entire hash using <code>clear()</code>.<br>&emsp;&emsp;<code>QHash&#39;s</code> key and value data types must be assignable data types. You cannot, for example, store a <code>QWidget</code> as a value; instead, store a <code>QWidget *</code>. In addition, <code>QHash&#39;s</code> key type must provide <code>operator==()</code>, and there must also be a global <code>qHash()</code> function that returns a hash value for an argument of the key’s type.<br>&emsp;&emsp;Here’s a list of the <code>C++</code> and <code>Qt</code> types that can serve as keys in a <code>QHash</code>: any integer type (<code>char</code>, <code>unsigned long</code>, etc.), any pointer type, <code>QChar</code>, <code>QString</code>, and <code>QByteArray</code>. For all of these, the <code>QHash</code> header defines a <code>qHash()</code> function that computes an adequate hash value. If you want to use other types as the key, make sure that you provide <code>operator==()</code> and a <code>qHash()</code> implementation.<br>&emsp;&emsp;Example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EMPLOYEE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EMPLOYEE_H</span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Employee() &#123;&#125;</span><br><span class="line">    Employee ( <span class="keyword">const</span> QString &amp;name, <span class="keyword">const</span> QDate &amp;dateOfBirth );</span><br><span class="line">    ...</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString myName;</span><br><span class="line">    QDate myDateOfBirth;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== ( <span class="keyword">const</span> Employee &amp;e1, <span class="keyword">const</span> Employee &amp;e2 ) &#123;</span><br><span class="line">    <span class="keyword">return</span> e1.name() == e2.name() &amp;&amp; e1.dateOfBirth() == e2.dateOfBirth();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">inline</span> uint <span class="title">qHash</span> <span class="params">( <span class="keyword">const</span> Employee &amp;key )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qHash ( key.name() ) ^ key.dateOfBirth().day();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// EMPLOYEE_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>qHash()</code> function computes a numeric value based on a key. It can use any algorithm imaginable, as long as it always returns the same value if given the same argument. In other words, if <code>e1 == e2</code>, then <code>qHash(e1) == qHash(e2)</code> must hold as well. However, to obtain good performance, the <code>qHash()</code> function should attempt to return different hash values for different keys to the largest extent possible.<br>&emsp;&emsp;In the example above, we’ve relied on <code>Qt&#39;s</code> global <code>qHash(const QString &amp;)</code> to give us a hash value for the employee’s name, and <code>XOR&#39;ed</code> this with the day they were born to help produce unique hashes for people with the same name.<br>&emsp;&emsp;Internally, <code>QHash</code> uses a hash table to perform lookups. Unlike <code>Qt 3&#39;s</code> <code>QDict</code> class, which needed to be initialized with a prime number, <code>QHash&#39;s</code> hash table automatically grows and shrinks to provide fast lookups without wasting too much memory. You can still control the size of the hash table by calling <code>reserve()</code> if you already know approximately how many items the <code>QHash</code> will contain, but this isn’t necessary to obtain good performance. You can also call <code>capacity()</code> to retrieve the hash table’s size.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>typedef <code>QHash::ConstIterator</code>: <code>Qt-style</code> synonym for <code>QHash::const_iterator</code>.</li>
<li>typedef <code>QHash::Iterator</code>: <code>Qt-style</code> synonym for <code>QHash::iterator</code>.</li>
<li>typedef <code>QHash::difference_type</code>: Typedef for <code>ptrdiff_t</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QHash::key_type</code>: Typedef for <code>Key</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QHash::mapped_type</code>: Typedef for <code>T</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QHash::size_type</code> — Typedef for int. Provided for STL compatibility.</li>
</ul>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QHash::QHash()</code>: Constructs an empty hash.</li>
<li><code>QHash::QHash(const QHash&lt;Key, T&gt; &amp; other)</code>: Constructs a copy of <code>other</code>. This operation occurs in constant time, because <code>QHash</code> is implicitly shared. This makes returning a <code>QHash</code> from a function very fast. If a shared instance is modified, it will be copied (<code>copy-on-write</code>), and this takes linear time.</li>
<li><code>QHash::~QHash()</code>: Destroys the hash. References to the values in the hash and all iterators of this hash become invalid.</li>
<li><code>iterator QHash::begin()</code>: Returns an <code>STL-style</code> iterator pointing to the first item in the hash.</li>
<li><code>const_iterator QHash::begin() const</code>: This is an overloaded function.</li>
<li><code>int QHash::capacity() const</code>: Returns the number of buckets in the <code>QHash&#39;s</code> internal hash table. The sole purpose of this function is to provide a means of fine tuning <code>QHash&#39;s</code> memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the hash, call <code>size()</code>.</li>
<li><code>void QHash::clear()</code>: Removes all items from the hash.</li>
<li><code>const_iterator QHash::constBegin() const</code>: Returns a const <code>STL-style</code> iterator pointing to the first item in the hash.</li>
<li><code>const_iterator QHash::constEnd() const</code>: Returns a const <code>STL-style</code> iterator pointing to the imaginary item after the last item in the hash.</li>
<li><code>const_iterator QHash::constFind(const Key &amp; key) const</code>: Returns an iterator pointing to the item with the <code>key</code> in the hash. If the hash contains no item with the <code>key</code>, the function returns <code>constEnd()</code>.</li>
<li><code>bool QHash::contains(const Key &amp; key) const</code>: Returns <code>true</code> if the hash contains an item with the <code>key</code>; otherwise returns <code>false</code>.</li>
<li><code>int QHash::count(const Key &amp; key) const</code>: Returns the number of items associated with the <code>key</code>.</li>
<li><code>int QHash::count() const</code>: This is an overloaded function. Same as <code>size()</code>.</li>
<li><code>bool QHash::empty() const</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>isEmpty()</code>, returning <code>true</code> if the hash is empty; otherwise returns <code>false</code>.</li>
<li><code>iterator QHash::end()</code>: Returns an <code>STL-style</code> iterator pointing to the imaginary item after the last item in the hash.</li>
<li><code>const_iterator QHash::end() const</code>: This is an overloaded function.</li>
<li><code>iterator QHash::erase(iterator pos)</code>: Removes the <code>(key, value)</code> pair associated with the iterator <code>pos</code> from the hash, and returns an iterator to the next item in the hash. Unlike <code>remove()</code> and <code>take()</code>, this function never causes <code>QHash</code> to rehash its internal data structure. This means that it can safely be called while iterating, and won’t affect the order of items in the hash. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QHash&lt;QObject *, <span class="keyword">int</span>&gt; objectHash;</span><br><span class="line">...</span><br><span class="line">QHash&lt;QObject *, <span class="keyword">int</span>&gt;::iterator i = objectHash.find ( obj );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != objectHash.end() &amp;&amp; i.key() == obj ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i.value() == <span class="number">0</span> ) &#123;</span><br><span class="line">        i = objectHash.erase ( i );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>iterator QHash::find(const Key &amp; key)</code>: Returns an iterator pointing to the item with the <code>key</code> in the hash. If the hash contains no item with the <code>key</code>, the function returns <code>end()</code>. If the hash contains multiple items with the <code>key</code>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here’s some code that iterates over all the items with the same <code>key</code>:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QHash&lt;QString, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">...</span><br><span class="line">QHash&lt;QString, <span class="keyword">int</span>&gt;::const_iterator i = hash.find ( <span class="string">"HDR"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != hash.end() &amp;&amp; i.key() == <span class="string">"HDR"</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>const_iterator QHash::find(const Key &amp; key) const</code>: This is an overloaded function.</li>
<li><code>iterator QHash::insert(const Key &amp; key, const T &amp; value)</code>: Inserts a new item with the <code>key</code> and a <code>value</code> of value. If there is already an item with the <code>key</code>, that item’s value is replaced with <code>value</code>. If there are multiple items with the <code>key</code>, the most recently inserted item’s value is replaced with <code>value</code>.</li>
<li><code>iterator QHash::insertMulti(const Key &amp; key, const T &amp; value)</code>: Inserts a new item with the <code>key</code> and a <code>value</code> of value. If there is already an item with the same <code>key</code> in the hash, this function will simply create a new one (This behavior is different from <code>insert()</code>, which overwrites the <code>value</code> of an existing item).</li>
<li><code>bool QHash::isEmpty() const</code>: Returns <code>true</code> if the hash contains no items; otherwise returns <code>false</code>.</li>
<li><code>const Key QHash::key(const T &amp; value) const</code>: Returns the first key mapped to <code>value</code>. If the hash contains no item with the <code>value</code>, the function returns a <code>default-constructed</code> key. This function can be slow (linear time), because <code>QHash&#39;s</code> internal data structure is optimized for fast lookup by key, not by value.</li>
<li><code>const Key QHash::key(const T &amp; value, const Key &amp; defaultKey) const</code>: This is an overloaded function. Returns the first key mapped to <code>value</code>, or <code>defaultKey</code> if the hash contains no item mapped to <code>value</code>. This function can be slow (linear time), because <code>QHash&#39;s</code> internal data structure is optimized for fast lookup by key, not by value.</li>
<li><code>QList&lt;Key&gt; QHash::keys() const</code>: Returns a list containing all the keys in the hash, in an arbitrary order. Keys that occur multiple times in the hash (because items were inserted with <code>insertMulti()</code>, or <code>unite()</code> was used) also occur multiple times in the list. To obtain a list of unique keys, where each key from the map only occurs once, use <code>uniqueKeys()</code>. The order is guaranteed to be the same as that used by <code>values()</code>.</li>
<li><code>QList&lt;Key&gt; QHash::keys(const T &amp; value) const</code>: This is an overloaded function. Returns a list containing all the keys associated with <code>value</code>, in an arbitrary order. This function can be slow (linear time), because <code>QHash&#39;s</code> internal data structure is optimized for fast lookup by key, not by value.</li>
<li><code>int QHash::remove(const Key &amp; key)</code>: Removes all the items that have the <code>key</code> from the hash. Returns the number of items removed which is usually <code>1</code> but will be <code>0</code> if the <code>key</code> isn’t in the hash, or greater than <code>1</code> if <code>insertMulti()</code> has been used with the <code>key</code>.</li>
<li><code>void QHash::reserve(int size)</code>: Ensures that the <code>QHash&#39;s</code> internal hash table consists of at least <code>size</code> buckets. This function is useful for code that needs to build a huge hash and wants to avoid repeated reallocation. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QHash&lt;QString, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">hash.reserve ( <span class="number">20000</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; ++i ) &#123;</span><br><span class="line">    hash.insert ( keys[i], values[i] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Ideally, size should be slightly more than the maximum number of items expected in the hash. size doesn’t have to be prime, because <code>QHash</code> will use a prime number internally anyway. If size is an underestimate, the worst that will happen is that the <code>QHash</code> will be a bit slower. In general, you will rarely ever need to call this function. <code>QHash&#39;s</code> internal hash table automatically shrinks or grows to provide good performance without wasting too much memory.</p>
<ul>
<li><code>int QHash::size() const</code>: Returns the number of items in the hash.</li>
<li><code>void QHash::squeeze()</code>: Reduces the size of the <code>QHash&#39;s</code> internal hash table to save memory. The sole purpose of this function is to provide a means of fine tuning <code>QHash&#39;s</code> memory usage. In general, you will rarely ever need to call this function.</li>
<li><code>void QHash::swap(QHash&lt;Key, T&gt; &amp; other)</code>: Swaps hash <code>other</code> with this hash. This operation is very fast and never fails.</li>
<li><code>T QHash::take(const Key &amp; key)</code>: Removes the item with the <code>key</code> from the hash and returns the value associated with it. If the item does not exist in the hash, the function simply returns a <code>default-constructed</code> value. If there are multiple items for key in the hash, only the most recently inserted one is removed. If you don’t use the return value, <code>remove()</code> is more efficient.</li>
<li><code>QList&lt;Key&gt; QHash::uniqueKeys() const</code>: Returns a list containing all the keys in the map. Keys that occur multiple times in the map (because items were inserted with <code>insertMulti()</code>, or <code>unite()</code> was used) occur only once in the returned list.</li>
<li><code>QHash&lt;Key, T&gt; &amp; QHash::unite(const QHash&lt;Key, T&gt; &amp; other)</code>: Inserts all the items in the <code>other</code> hash into this hash. If a key is common to both hashes, the resulting hash will contain the key multiple times.</li>
<li><code>const T QHash::value(const Key &amp; key) const</code>: Returns the value associated with the <code>key</code>. If the hash contains no item with the <code>key</code>, the function returns a <code>default-constructed</code> value. If there are multiple items for the key in the hash, the value of the most recently inserted one is returned.</li>
<li><code>const T QHash::value(const Key &amp; key, const T &amp; defaultValue) const</code>: This is an overloaded function. If the hash contains no item with the given <code>key</code>, the function returns <code>defaultValue</code>.</li>
<li><code>QList&lt;T&gt; QHash::values() const</code>: Returns a list containing all the values in the hash, in an arbitrary order. If a key is associated multiple values, all of its values will be in the list, and not just the most recently inserted one. The order is guaranteed to be the same as that used by <code>keys()</code>.</li>
<li><code>QList&lt;T&gt; QHash::values(const Key &amp; key) const</code>: This is an overloaded function. Returns a list of all the values associated with the <code>key</code>, from the most recently inserted to the least recently inserted.</li>
<li><code>bool QHash::operator!=(const QHash&lt;Key, T&gt; &amp; other) const</code>: Returns <code>true</code> if <code>other</code> is not equal to this hash; otherwise returns <code>false</code>. Two hashes are considered equal if they contain the same <code>(key, value)</code> pairs. This function requires the value type to implement <code>operator==()</code>.</li>
<li><code>QHash&lt;Key, T&gt; &amp; QHash::operator=(const QHash&lt;Key, T&gt; &amp; other)</code>: Assigns <code>other</code> to this hash and returns a reference to this hash.</li>
<li><code>bool QHash::operator==(const QHash&lt;Key, T&gt; &amp; other) const</code>: Returns <code>true</code> if <code>other</code> is equal to this hash; otherwise returns <code>false</code>. Two hashes are considered equal if they contain the same <code>(key, value)</code> pairs. This function requires the value type to implement <code>operator==()</code>.</li>
<li><code>T &amp; QHash::operator[](const Key &amp; key)</code>: Returns the value associated with the <code>key</code> as a modifiable reference. If the hash contains no item with the <code>key</code>, the function inserts a <code>default-constructed</code> value into the hash with the <code>key</code>, and returns a reference to it. If the hash contains multiple items with the <code>key</code>, this function returns a reference to the most recently inserted value.</li>
<li><code>const T QHash::operator[](const Key &amp; key) const</code>: This is an overloaded function. Same as <code>value()</code>.</li>
</ul>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>uint qHash(const QXmlNodeModelIndex &amp; index)</code>: Computes a hash key from the <code>QXmlNodeModelIndex</code> <code>index</code>, and returns it. This function would be used by <code>QHash</code> if you wanted to build a hash table for instances of <code>QXmlNodeModelIndex</code>. The hash is computed on <code>QXmlNodeModelIndex::data()</code>, <code>QXmlNodeModelIndex::additionalData()</code>, and <code>QXmlNodeModelIndex::model()</code>. This means the hash key can be used for node indexes from different node models.</li>
<li><code>uint qHash(char key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(uchar key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(signed char key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(ushort key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(short key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(uint key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(int key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(ulong key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(long key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(quint64 key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(qint64 key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(QChar key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(const QByteArray &amp; key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(const QString &amp; key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(const QBitArray &amp; key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(const T * key)</code>: Returns the hash value for the <code>key</code>.</li>
<li><code>uint qHash(const QPair&lt;T1, T2&gt; &amp; key)</code>: Returns the hash value for the <code>key</code>. Types <code>T1</code> and <code>T2</code> must be supported by <code>qHash()</code>.</li>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; out, const QHash&lt;Key, T&gt; &amp; hash)</code>: Writes the <code>hash</code> to stream <code>out</code>. This function requires the key and value types to implement <code>operator&lt;&lt;()</code>.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; in, QHash&lt;Key, T&gt; &amp; hash)</code>: Reads a hash from stream <code>in</code> into <code>hash</code>. This function requires the key and value types to implement <code>operator&gt;&gt;()</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/28/Qt语法详解/Qt之Qmap/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/28/Qt语法详解/Qt之Qmap/" itemprop="url">Qt之Qmap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-28T10:46:17+08:00">
                2019-01-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QMap</code> class is a template class that provides a <code>skip-list-based</code> dictionary.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QMap</code></td>
<td><code>QMultiMap</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QMap()</code></td>
</tr>
<tr>
<td></td>
<td><code>QMap(const QMap&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td></td>
<td><code>QMap(const std::map&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QMap()</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>begin()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constBegin() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constEnd() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constFind(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>contains(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>empty() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>end()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator pos)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>find(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>find(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insert(const Key &amp; key, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insertMulti(const Key &amp; key, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>const Key</code></td>
<td><code>key(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>const Key</code></td>
<td><code>key(const T &amp; value, const Key &amp; defaultKey) const</code></td>
</tr>
<tr>
<td><code>QList&lt;Key&gt;</code></td>
<td><code>keys() const</code></td>
</tr>
<tr>
<td><code>QList&lt;Key&gt;</code></td>
<td><code>keys(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>lowerBound(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>lowerBound(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>remove(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(QMap&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>take(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>std::map&lt;Key, T&gt;</code></td>
<td><code>toStdMap() const</code></td>
</tr>
<tr>
<td><code>QList&lt;Key&gt;</code></td>
<td><code>uniqueKeys() const</code></td>
</tr>
<tr>
<td><code>QMap&lt;Key, T&gt; &amp;</code></td>
<td><code>unite(const QMap&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>upperBound(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>upperBound(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>const T</code></td>
<td><code>value(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>const T</code></td>
<td><code>value(const Key &amp; key, const T &amp; defaultValue) const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>values() const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>values(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QMap&lt;Key, T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QMap&lt;Key, T&gt; &amp;</code></td>
<td><code>operator=(const QMap&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QMap&lt;Key, T&gt; &amp;</code></td>
<td><code>operator=(QMap&lt;Key, T&gt; &amp;&amp; other)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QMap&lt;Key, T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>operator[](const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>const T</code></td>
<td><code>operator[](const Key &amp; key) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QDataStream</code></td>
<td><code>&amp;operator&lt;&lt; ( QDataStream &amp;out, const QMap&lt;Key, T&gt; &amp;map );</code></td>
</tr>
<tr>
<td><code>QDataStream</code></td>
<td><code>&amp;operator&gt;&gt; ( QDataStream &amp;in, QMap&lt;Key, T&gt; &amp;map );</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QMap</code> class is a template class that provides a <code>skip-list-based</code> dictionary.<br>&emsp;&emsp;<code>QMap&lt;Key, T&gt;</code> is one of <code>Qt&#39;s</code> generic container classes. It stores <code>(key, value)</code> pairs and provides fast lookup of the value associated with a key.<br>&emsp;&emsp;<code>QMap</code> and <code>QHash</code> provide very similar functionality. The differences are:</p>
<ul>
<li><code>QHash</code> provides faster lookups than <code>QMap</code>.</li>
<li>When iterating over a <code>QHash</code>, the items are arbitrarily ordered. With <code>QMap</code>, the items are always sorted by key.</li>
<li>The key type of a <code>QHash</code> must provide <code>operator==()</code> and a global <code>qHash(Key)</code> function. The key type of a <code>QMap</code> must provide <code>operator&lt;()</code> specifying a total order.</li>
</ul>
<p>&emsp;&emsp;Here’s an example <code>QMap</code> with <code>QString</code> keys and int values:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br></pre></td></tr></table></figure>
<p>To insert a <code>(key, value)</code> pair into the map, you can use <code>operator[]()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>[<span class="string">"one"</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">map</span>[<span class="string">"three"</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">map</span>[<span class="string">"seven"</span>] = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;This inserts the following three <code>(key, value)</code> pairs into the <code>QMap</code>: <code>(&quot;one&quot;, 1)</code>, <code>(&quot;three&quot;, 3)</code>, and <code>(&quot;seven&quot;, 7)</code>. Another way to insert items into the map is to use <code>insert()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.insert ( <span class="string">"twelve"</span>, <span class="number">12</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;To look up a value, use <code>operator[]()</code> or <code>value()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = <span class="built_in">map</span>[<span class="string">"thirteen"</span>];</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="built_in">map</span>.value ( <span class="string">"thirteen"</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If there is no item with the specified key in the map, these functions return a <code>default-constructed</code> value.<br>&emsp;&emsp;If you want to check whether the map contains a certain key, use <code>contains()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> timeout = <span class="number">30</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">map</span>.contains ( <span class="string">"TIMEOUT"</span> ) ) &#123;</span><br><span class="line">    timeout = <span class="built_in">map</span>.value ( <span class="string">"TIMEOUT"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;There is also a <code>value()</code> overload that uses its second argument as a default value if there is no item with the specified key:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> timeout = <span class="built_in">map</span>.value ( <span class="string">"TIMEOUT"</span>, <span class="number">30</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;In general, we recommend that you use <code>contains()</code> and <code>value()</code> rather than <code>operator[]()</code> for looking up a key in a map. The reason is that <code>operator[]()</code> silently inserts an item into the map if no item exists with the same key (unless the map is const). For example, the following code snippet will create <code>1000</code> items in memory:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line">QMap&lt;<span class="keyword">int</span>, QWidget *&gt; <span class="built_in">map</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">map</span>[i] == okButton ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found button at index "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;To avoid this problem, replace <code>map[i]</code> with <code>map.value(i)</code> in the code above.<br>&emsp;&emsp;If you want to navigate through all the <code>(key, value)</code> pairs stored in a <code>QMap</code>, you can use an iterator. <code>QMap</code> provides both <code>Java-style</code> iterators (<code>QMapIterator</code> and <code>QMutableMapIterator</code>) and <code>STL-style</code> iterators (<code>QMap::const_iterator</code> and <code>QMap::iterator</code>). Here’s how to iterate over a <code>QMap&lt;QString, int&gt;</code> using a <code>Java-style</code> iterator:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QMapIterator&lt;QString, <span class="keyword">int</span>&gt; i ( <span class="built_in">map</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i.hasNext() ) &#123;</span><br><span class="line">    i.next();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.key() &lt;&lt; <span class="string">": "</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Here’s the same code, but using an <code>STL-style</code> iterator this time:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt;::const_iterator i = <span class="built_in">map</span>.constBegin();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != <span class="built_in">map</span>.constEnd() ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.key() &lt;&lt; <span class="string">": "</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The items are traversed in ascending key order.<br>&emsp;&emsp;Normally, a <code>QMap</code> allows only one value per key. If you call <code>insert()</code> with a key that already exists in the <code>QMap</code>, the previous value will be erased. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.insert ( <span class="string">"plenty"</span>, <span class="number">100</span> );</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="string">"plenty"</span>, <span class="number">2000</span> ); <span class="comment">/* map.value("plenty") == 2000 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;However, you can store multiple values per key by using <code>insertMulti()</code> instead of <code>insert()</code> (or using the convenience subclass <code>QMultiMap</code>). If you want to retrieve all the values for a single key, you can use <code>values(const Key &amp;key)</code>, which returns a <code>QList&lt;T&gt;</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;<span class="keyword">int</span>&gt; values = <span class="built_in">map</span>.values ( <span class="string">"plenty"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.size(); ++i ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values.at ( i ) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The items that share the same key are available from most recently to least recently inserted. Another approach is to call <code>find()</code> to get the <code>STL-style</code> iterator for the first item with a key and iterate from there:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt;::iterator i = <span class="built_in">map</span>.find ( <span class="string">"plenty"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != <span class="built_in">map</span>.end() &amp;&amp; i.key() == <span class="string">"plenty"</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If you only need to extract the values from a map (not the keys), you can also use <code>foreach</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">​</span><br><span class="line">foreach ( <span class="keyword">int</span> value, <span class="built_in">map</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Items can be removed from the map in several ways. One way is to call <code>remove()</code>; this will remove any item with the given key. Another way is to use <code>QMutableMapIterator::remove()</code>. In addition, you can clear the entire map using <code>clear()</code>.<br>&emsp;&emsp;<code>QMap&#39;s</code> key and value data types must be assignable data types. This covers most data types you are likely to encounter, but the compiler won’t let you, for example, store a <code>QWidget</code> as a value; instead, store a <code>QWidget *</code>. In addition, <code>QMap&#39;s</code> key type must provide <code>operator&lt;()</code>. <code>QMap</code> uses it to keep its items sorted, and assumes that two keys <code>x</code> and <code>y</code> are equal if neither <code>x &lt; y</code> nor <code>y &lt; x</code> is <code>true</code>. Example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EMPLOYEE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EMPLOYEE_H</span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Employee() &#123;&#125;</span><br><span class="line">    Employee ( <span class="keyword">const</span> QString &amp;name, <span class="keyword">const</span> QDate &amp;dateOfBirth );</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString myName;</span><br><span class="line">    QDate myDateOfBirth;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; ( <span class="keyword">const</span> Employee &amp;e1, <span class="keyword">const</span> Employee &amp;e2 ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( e1.name() != e2.name() ) &#123;</span><br><span class="line">        <span class="keyword">return</span> e1.name() &lt; e2.name();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> e1.dateOfBirth() &lt; e2.dateOfBirth();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// EMPLOYEE_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;In the example, we start by comparing the employees’ names. If they’re equal, we compare their dates of birth to break the tie.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>typedef <code>QMap::ConstIterator</code>: <code>Qt-style</code> synonym for <code>QMap::const_iterator</code>.</li>
<li>typedef <code>QMap::Iterator</code>: <code>Qt-style</code> synonym for <code>QMap::iterator</code>.</li>
<li>typedef <code>QMap::difference_type</code>: Typedef for <code>ptrdiff_t</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QMap::key_type</code>: Typedef for <code>Key</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QMap::mapped_type</code>: Typedef for <code>T</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QMap::size_type</code>: Typedef for <code>int</code>. Provided for <code>STL</code> compatibility.</li>
</ul>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QMap::QMap()</code>: Constructs an empty map.</li>
<li><code>QMap::QMap(const QMap&lt;Key, T&gt; &amp; other)</code>: Constructs a copy of <code>other</code>. This operation occurs in constant time, because <code>QMap</code> is implicitly shared. This makes returning a <code>QMap</code> from a function very fast. If a shared instance is modified, it will be copied (<code>copy-on-write</code>), and this takes linear time.</li>
<li><code>QMap::QMap(const std::map&lt;Key, T&gt; &amp; other)</code>: Constructs a copy of <code>other</code>. This function is only available if <code>Qt</code> is configured with <code>STL</code> compatibility enabled.</li>
<li><code>QMap::~QMap()</code>: Destroys the map. References to the values in the map, and all iterators over this map, become invalid.</li>
<li><code>iterator QMap::begin()</code>: Returns an <code>STL-style</code> iterator pointing to the first item in the map.</li>
<li><code>const_iterator QMap::begin() const</code>: This is an overloaded function.</li>
<li><code>void QMap::clear()</code>: Removes all items from the map.</li>
<li><code>const_iterator QMap::constBegin() const</code>: Returns a const <code>STL-style</code> iterator pointing to the first item in the map.</li>
<li><code>const_iterator QMap::constEnd() const</code>: Returns a const <code>STL-style</code> iterator pointing to the imaginary item after the last item in the map.</li>
<li><code>const_iterator QMap::constFind(const Key &amp; key) const</code>: Returns an const iterator pointing to the item with <code>key</code> in the map. If the map contains no item with <code>key</code>, the function returns <code>constEnd()</code>.</li>
<li><code>bool QMap::contains(const Key &amp; key) const</code>: Returns <code>true</code> if the map contains an item with <code>key</code>; otherwise returns <code>false</code>.</li>
<li><code>int QMap::count(const Key &amp; key) const</code>: Returns the number of items associated with <code>key</code>.</li>
<li><code>int QMap::count() const</code>: This is an overloaded function. Same as <code>size()</code>.</li>
<li><code>bool QMap::empty() const</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>isEmpty()</code>, returning <code>true</code> if the map is empty; otherwise returning <code>false</code>.</li>
<li><code>iterator QMap::end()</code>: Returns an <code>STL-style</code> iterator pointing to the imaginary item after the last item in the map.</li>
<li><code>const_iterator QMap::end() const</code>: This is an overloaded function.</li>
<li><code>iterator QMap::erase(iterator pos)</code>: Removes the <code>(key, value)</code> pair pointed to by the iterator <code>pos</code> from the map, and returns an iterator to the next item in the map.</li>
<li><code>iterator QMap::find(const Key &amp; key)</code>: Returns an iterator pointing to the item with <code>key</code> in the map. If the map contains no item with <code>key</code>, the function returns <code>end()</code>. If the map contains multiple items with <code>key</code>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here’s some code that iterates over all the items with the same <code>key</code>:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">​</span><br><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt;::const_iterator i = <span class="built_in">map</span>.find ( <span class="string">"HDR"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != <span class="built_in">map</span>.end() &amp;&amp; i.key() == <span class="string">"HDR"</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>const_iterator QMap::find(const Key &amp; key) const</code>: This is an overloaded function.</li>
<li><code>iterator QMap::insert(const Key &amp; key, const T &amp; value)</code>: Inserts a new item with the <code>key</code> and a <code>value</code> of value. If there is already an item with the <code>key</code>, that item’s value is replaced with <code>value</code>. If there are multiple items with the <code>key</code>, the most recently inserted item’s value is replaced with <code>value</code>.</li>
<li><code>iterator QMap::insertMulti(const Key &amp; key, const T &amp; value)</code>: Inserts a new item with the <code>key</code> and a <code>value</code> of value. If there is already an item with the same <code>key</code> in the map, this function will simply create a new one (This behavior is different from <code>insert()</code>, which overwrites the value of an existing item).</li>
<li><code>bool QMap::isEmpty() const</code>: Returns <code>true</code> if the map contains no items; otherwise returns <code>false</code>.</li>
<li><code>const Key QMap::key(const T &amp; value) const</code>: Returns the first key with <code>value</code>. If the map contains no item with <code>value</code>, the function returns a <code>default-constructed</code> key. This function can be slow (linear time), because <code>QMap&#39;s</code> internal data structure is optimized for fast lookup by key, not by value.</li>
<li><code>const Key QMap::key(const T &amp; value, const Key &amp; defaultKey) const</code>: This is an overloaded function. Returns the first key with <code>value</code>, or defaultKey if the map contains no item with <code>value</code>. This function can be slow (linear time), because <code>QMap&#39;s</code> internal data structure is optimized for fast lookup by key, not by value.</li>
<li><code>QList&lt;Key&gt; QMap::keys() const</code>: Returns a list containing all the keys in the map in ascending order. Keys that occur multiple times in the map (because items were inserted with <code>insertMulti()</code>, or <code>unite()</code> was used) also occur multiple times in the list. To obtain a list of unique keys, where each key from the map only occurs once, use <code>uniqueKeys()</code>. The order is guaranteed to be the same as that used by <code>values()</code>.</li>
<li><code>QList&lt;Key&gt; QMap::keys(const T &amp; value) const</code>: This is an overloaded function. Returns a list containing all the keys associated with <code>value</code> in ascending order. This function can be slow (linear time), because <code>QMap&#39;s</code> internal data structure is optimized for fast lookup by key, not by value.</li>
<li><code>iterator QMap::lowerBound(const Key &amp; key)</code>: Returns an iterator pointing to the first item with <code>key</code> in the map. If the map contains no item with <code>key</code>, the function returns an iterator to the nearest item with a greater key. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;<span class="keyword">int</span>, QString&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">1</span>, <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">5</span>, <span class="string">"five"</span> );</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">10</span>, <span class="string">"ten"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="built_in">map</span>.lowerBound ( <span class="number">0</span> ); <span class="comment">/* returns iterator to (1, "one") */</span></span><br><span class="line"><span class="built_in">map</span>.lowerBound ( <span class="number">1</span> ); <span class="comment">/* returns iterator to (1, "one") */</span></span><br><span class="line"><span class="built_in">map</span>.lowerBound ( <span class="number">2</span> ); <span class="comment">/* returns iterator to (5, "five") */</span></span><br><span class="line"><span class="built_in">map</span>.lowerBound ( <span class="number">10</span> ); <span class="comment">/* returns iterator to (10, "ten") */</span></span><br><span class="line"><span class="built_in">map</span>.lowerBound ( <span class="number">999</span> ); <span class="comment">/* returns end() */</span></span><br></pre></td></tr></table></figure>
<p>If the map contains multiple items with <code>key</code>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here’s some code that iterates over all the items with the same key:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">​</span><br><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt;::const_iterator i = <span class="built_in">map</span>.lowerBound ( <span class="string">"HDR"</span> );</span><br><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt;::const_iterator upperBound = <span class="built_in">map</span>.upperBound ( <span class="string">"HDR"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != upperBound ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>const_iterator QMap::lowerBound(const Key &amp; key) const</code>: This is an overloaded function.</li>
<li><code>int QMap::remove(const Key &amp; key)</code>: Removes all the items that have the <code>key</code> from the map. Returns the number of items removed which is usually <code>1</code> but will be <code>0</code> if the <code>key</code> isn’t in the map, or <code>&gt; 1</code> if <code>insertMulti()</code> has been used with the <code>key</code>.</li>
<li><code>int QMap::size() const</code>: Returns the number of <code>(key, value)</code> pairs in the map.</li>
<li><code>void QMap::swap(QMap&lt;Key, T&gt; &amp; other)</code>: Swaps map <code>other</code> with this map. This operation is very fast and never fails.</li>
<li><code>T QMap::take(const Key &amp; key)</code>: Removes the item with the <code>key</code> from the map and returns the value associated with it. If the item does not exist in the map, the function simply returns a <code>default-constructed</code> value. If there are multiple items for <code>key</code> in the map, only the most recently inserted one is removed and returned. If you don’t use the return value, <code>remove()</code> is more efficient.</li>
<li><code>std::map&lt;Key, T&gt; QMap::toStdMap() const</code>: Returns an <code>STL</code> map equivalent to this <code>QMap</code>. This function is only available if <code>Qt</code> is configured with <code>STL</code> compatibility enabled.</li>
<li><code>QList&lt;Key&gt; QMap::uniqueKeys() const</code>: Returns a list containing all the keys in the map in ascending order. Keys that occur multiple times in the map (because items were inserted with <code>insertMulti()</code>, or <code>unite()</code> was used) occur only once in the returned list.</li>
<li><code>QMap&lt;Key, T&gt; &amp; QMap::unite(const QMap&lt;Key, T&gt; &amp; other)</code>: Inserts all the items in the <code>other</code> map into this map. If a key is common to both maps, the resulting map will contain the key multiple times.</li>
<li><code>iterator QMap::upperBound(const Key &amp; key)</code>: Returns an iterator pointing to the item that immediately follows the last item with <code>key</code> in the map. If the map contains no item with <code>key</code>, the function returns an iterator to the nearest item with a greater key. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;<span class="keyword">int</span>, QString&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">1</span>, <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">5</span>, <span class="string">"five"</span> );</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">10</span>, <span class="string">"ten"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="built_in">map</span>.upperBound ( <span class="number">0</span> ); <span class="comment">/* returns iterator to (1, "one") */</span></span><br><span class="line"><span class="built_in">map</span>.upperBound ( <span class="number">1</span> ); <span class="comment">/* returns iterator to (5, "five") */</span></span><br><span class="line"><span class="built_in">map</span>.upperBound ( <span class="number">2</span> ); <span class="comment">/* returns iterator to (5, "five") */</span></span><br><span class="line"><span class="built_in">map</span>.upperBound ( <span class="number">10</span> ); <span class="comment">/* returns end() */</span></span><br><span class="line"><span class="built_in">map</span>.upperBound ( <span class="number">999</span> ); <span class="comment">/* returns end() */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>const_iterator QMap::upperBound(const Key &amp; key) const</code>: This is an overloaded function.</li>
<li><code>const T QMap::value(const Key &amp; key) const</code>: Returns the value associated with the <code>key</code>. If the map contains no item with <code>key</code>, the function returns a <code>default-constructed</code> value. If there are multiple items for key in the map, the value of the most recently inserted one is returned.</li>
<li><code>const T QMap::value(const Key &amp; key, const T &amp; defaultValue) const</code>: This is an overloaded function. If the map contains no item with <code>key</code>, the function returns <code>defaultValue</code>.</li>
<li><code>QList&lt;T&gt; QMap::values() const</code>: Returns a list containing all the values in the map, in ascending order of their keys. If a key is associated with multiple values, all of its values will be in the list, and not just the most recently inserted one.</li>
<li><code>QList&lt;T&gt; QMap::values(const Key &amp; key) const</code>: This is an overloaded function. Returns a list containing all the values associated with <code>key</code>, from the most recently inserted to the least recently inserted one.</li>
<li><code>bool QMap::operator!=(const QMap&lt;Key, T&gt; &amp; other) const</code>: Returns true if <code>other</code> is not equal to this map; otherwise returns false. Two maps are considered equal if they contain the same <code>(key, value)</code> pairs. This function requires the value type to implement <code>operator==()</code>.</li>
<li><code>QMap&lt;Key, T&gt; &amp; QMap::operator=(const QMap&lt;Key, T&gt; &amp; other)</code>: Assigns <code>other</code> to this map and returns a reference to this map.</li>
<li><code>QMap&lt;Key, T&gt; &amp; QMap::operator=(QMap&lt;Key, T&gt; &amp;&amp; other)</code>: bool <code>QMap::operator==(const QMap&lt;Key, T&gt; &amp; other)</code> const Returns <code>true</code> if other is equal to this map; otherwise returns <code>false</code>. Two maps are considered equal if they contain the same <code>(key, value)</code> pairs. This function requires the value type to implement <code>operator==()</code>.</li>
<li><code>T &amp; QMap::operator[](const Key &amp; key)</code>: Returns the value associated with the key key as a modifiable reference. If the map contains no item with <code>key</code>, the function inserts a <code>default-constructed</code> value into the map with <code>key</code>, and returns a reference to it. If the map contains multiple items with <code>key</code>, this function returns a reference to the most recently inserted value.</li>
<li><code>const T QMap::operator[](const Key &amp; key) const</code>: This is an overloaded function.</li>
</ul>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; out, const QMap&lt;Key, T&gt; &amp; map)</code>: Writes the <code>map</code> to stream <code>out</code>. This function requires the key and value types to implement <code>operator&lt;&lt;()</code>.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; in, QMap&lt;Key, T&gt; &amp; map)</code>: Reads a map from stream <code>in</code> into <code>map</code>. This function requires the key and value types to implement <code>operator&gt;&gt;()</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/27/Qt语法详解/Qt之QFtp/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/27/Qt语法详解/Qt之QFtp/" itemprop="url">Qt之QFtp</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T22:10:59+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>QFtp</code>类提供了一个<code>FTP</code>协议的客户端实现，该类提供了一个访问到<code>FTP</code>服务器的接口。对于新的应用程序，建议使用<code>QNetworkAccessManager</code>和<code>QNetworkReply</code>，因为这些类拥有一个更简单、更强大的<code>API</code>。<br>&emsp;&emsp;<code>QFtp</code>支持异步工作，因此没有阻塞函数。如果无法立即执行操作，函数仍将立即返回，并且该操作将被操作系统调度，供以后执行。调度操作的结果通过信号报告，这种方法依赖于事件循环操作。可以调度的操作(也被称为<code>命令</code>)有<code>connectToHost</code>、<code>login</code>、<code>close</code>、<code>list</code>、<code>cd</code>、<code>get</code>、<code>put</code>、<code>remove</code>、<code>mkdir</code>、<code>rmdir</code>、<code>rename</code>和<code>rawCommand</code>。所有这些命令都会返回一个唯一的标识符，允许程序员跟踪当前正在执行的命令。当命令的执行开始时，发出带有命令标识符的<code>commandStarted</code>信号。当命令完成时，会发出<code>commandFinished</code>信号，并带有命令标识符和一个<code>bool</code>参数，表明该命令在完成时是否出错。<br>&emsp;&emsp;在某些情况下，可能想要执行一系列命令。例如连接并登录到<code>FTP</code>服务器，简单的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QFtp *ftp = <span class="keyword">new</span> QFtp ( parent );</span><br><span class="line">ftp-&gt;connectToHost ( <span class="string">"192.168.***.***"</span>, <span class="number">21</span> );</span><br><span class="line">ftp-&gt;login ( <span class="string">"wang"</span>, <span class="string">"123456"</span> );</span><br></pre></td></tr></table></figure>
<p>在这种情况下，调度了两个<code>FTP</code>命令。当最后一个调度命令完成时，会发出<code>done</code>信号，并带有一个<code>bool</code>参数，告诉你命令序列在完成时是否出错。<br>&emsp;&emsp;如果命令序列中的某个命令的执行期间发生错误，则所有挂起的命令(即已调度，但尚未执行的命令)会被清除，并且不为它们发射信号。一些命令(例如<code>list</code>)会发出额外的信号(<code>listInfo</code>)以报告其结果。<br>&emsp;&emsp;对于文件传输，<code>QFtp</code>可以使用主动或被动模式，并且默认使用被动文件传输模式，可使用<code>setTransferMode</code>设置。函数<code>hasPendingCommands</code>和<code>clearPendingCommands</code>允许查询和清除挂起的命令列表。如果你在网络编程方面比较有经验，可以使用<code>rawCommand</code>来执行任意的<code>FTP</code>命令。注意，当前版本的<code>QFtp</code>不完全支持非<code>Unix</code>的<code>FTP</code>服务器。<br>&emsp;&emsp;如果要从<code>FTP</code>服务器下载<code>/home/wang/ftp.qdoc</code>文件，可以分为下面几步：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ftp-&gt;connectToHost ( <span class="string">"192.168.***.***"</span>, <span class="number">21</span> );</span><br><span class="line">ftp-&gt;login ( <span class="string">"wang"</span>, <span class="string">"123456"</span> );</span><br><span class="line">ftp-&gt;cd ( <span class="string">"/home/wang"</span> );</span><br><span class="line">ftp-&gt;get ( <span class="string">"ftp.qdoc"</span> );</span><br><span class="line">ftp-&gt;close();</span><br></pre></td></tr></table></figure>
<p>流程如下：</p>
<ul>
<li><code>connectToHost</code>：指定主机和端口号，连接<code>FTP</code>服务器。</li>
<li><code>login</code>：指定用户名和密码，登录到<code>FTP</code>服务器。</li>
<li><code>cd</code>：改变服务器的当前工作目录。</li>
<li><code>get</code>：从服务器上下载文件<code>ftp.qdoc</code>(绝对路径为<code>/home/wang/ftp.qdoc</code>)。</li>
<li><code>close</code>：关闭到<code>FTP</code>服务器的连接。</li>
</ul>
<p>&emsp;&emsp;对于该示例，发射以下序列的信号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">commandStarted ( <span class="number">1</span> )</span><br><span class="line">stateChanged ( HostLookup )</span><br><span class="line">stateChanged ( Connecting )</span><br><span class="line">stateChanged ( Connected )</span><br><span class="line">commandFinished ( <span class="number">1</span>, <span class="literal">false</span> )</span><br><span class="line">​</span><br><span class="line">commandStarted ( <span class="number">2</span> )</span><br><span class="line">stateChanged ( LoggedIn )</span><br><span class="line">commandFinished ( <span class="number">2</span>, <span class="literal">false</span> )</span><br><span class="line">​</span><br><span class="line">commandStarted ( <span class="number">3</span> )</span><br><span class="line">commandFinished ( <span class="number">3</span>, <span class="literal">false</span> )</span><br><span class="line">​</span><br><span class="line">commandStarted ( <span class="number">4</span> )</span><br><span class="line">dataTransferProgress ( <span class="number">0</span>, <span class="number">8710</span> )</span><br><span class="line">dataTransferProgress ( <span class="number">8192</span>, <span class="number">8710</span> )</span><br><span class="line">readyRead()</span><br><span class="line">dataTransferProgress ( <span class="number">8710</span>, <span class="number">8710</span> )</span><br><span class="line">readyRead()</span><br><span class="line">commandFinished ( <span class="number">4</span>, <span class="literal">false</span> )</span><br><span class="line">​</span><br><span class="line">commandStarted ( <span class="number">5</span> )</span><br><span class="line">stateChanged ( Closing )</span><br><span class="line">stateChanged ( Unconnected )</span><br><span class="line">commandFinished ( <span class="number">5</span>, <span class="literal">false</span> )</span><br><span class="line">​</span><br><span class="line">done ( <span class="literal">false</span> )</span><br></pre></td></tr></table></figure>
<p>如果要显示进度条以通知用户下载进度，上述示例中的<code>dataTransferProgress</code>信号就会很有用。<code>readyRead</code>信号告诉你有数据准备好被读取，然后可以使用<code>bytesAvailable</code>函数查询数据量，并且可以使用<code>read</code>或<code>readAll</code>函数读取数据量。<br>&emsp;&emsp;如果上述示例登录失败(例如用户名或密码错误)，信号将如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">commandStarted ( <span class="number">1</span> )</span><br><span class="line">stateChanged ( HostLookup )</span><br><span class="line">stateChanged ( Connecting )</span><br><span class="line">stateChanged ( Connected )</span><br><span class="line">commandFinished ( <span class="number">1</span>, <span class="literal">false</span> )</span><br><span class="line">​</span><br><span class="line">commandStarted ( <span class="number">2</span> )</span><br><span class="line">commandFinished ( <span class="number">2</span>, <span class="literal">true</span> )</span><br><span class="line">​</span><br><span class="line">done ( <span class="literal">true</span> )</span><br></pre></td></tr></table></figure>
<p>然后可以使用<code>error</code>和<code>errorString</code>函数获取有关错误的详细信息。<br>&emsp;&emsp;在进行其他命令操作之前，先一起看看<code>doc</code>的树结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/wang/doc</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── c++</span><br><span class="line">│   └── qt5_cadaques.pdf</span><br><span class="line">├── hello.sh</span><br><span class="line">├── linux</span><br><span class="line">│   └── linux-program.pdf</span><br><span class="line">└── python</span><br><span class="line">    └── hello.py</span><br><span class="line">​</span><br><span class="line">3 directories, 4 files</span><br></pre></td></tr></table></figure>
<p>里面包含<code>3</code>个目录以及<code>4</code>个文件。<br>&emsp;&emsp;要列出<code>dir</code>目录的内容，可以使用<code>list</code>。如果<code>dir</code>为空，将列出当前目录的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QFtp::<span class="built_in">list</span> ( <span class="keyword">const</span> QString &amp;dir = QString() )</span><br></pre></td></tr></table></figure>
<p>对于找到的每个目录条目，都会发出<code>listInfo</code>信号。输出文件详细信息的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">connect ( ftp, &amp;QFtp::listInfo, [ = ] ( <span class="keyword">const</span> QUrlInfo &amp;urlInfo ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; urlInfo.name() &lt;&lt; urlInfo.size() &lt;&lt; urlInfo.owner() &lt;&lt; urlInfo.group() \</span><br><span class="line">             &lt;&lt; urlInfo.lastModified().toString ( <span class="string">"MMM dd yyyy"</span> ) &lt;&lt; urlInfo.isDir();</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">ftp-&gt;<span class="built_in">list</span>();</span><br></pre></td></tr></table></figure>
<p>这里只列出文件的一部分信息，其他更多信息请参考<code>QUrlInfo</code>。输出如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"c++"</span>      <span class="number">29</span> <span class="string">"1000"</span> <span class="string">"1000"</span> <span class="string">"十一月 28 2016"</span> <span class="literal">true</span></span><br><span class="line"><span class="string">"hello.sh"</span> <span class="number">55</span> <span class="string">"1000"</span> <span class="string">"1000"</span> <span class="string">"十月 20 2016"</span>   <span class="literal">false</span></span><br><span class="line"><span class="string">"Linux"</span>    <span class="number">30</span> <span class="string">"1000"</span> <span class="string">"1000"</span> <span class="string">"十一月 28 2016"</span> <span class="literal">true</span></span><br><span class="line"><span class="string">"Python"</span>   <span class="number">21</span> <span class="string">"1000"</span> <span class="string">"1000"</span> <span class="string">"十一月 28 2016"</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>可以和服务端比对一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">总用量 4</span><br><span class="line">drwxrwxr-x. 2 wang wang 29 11月 28 10:41 c++</span><br><span class="line">-rw-rw-r--. 1 wang wang 55 10月 20 15:59 hello.sh</span><br><span class="line">drwxrwxr-x. 2 wang wang 30 11月 28 10:40 linux</span><br><span class="line">drwxrwxr-x. 2 wang wang 21 11月 28 10:39 python</span><br></pre></td></tr></table></figure>
<p>要在服务器上创建一个名为<code>dir</code>的目录，使用<code>mkdir</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp-&gt;mkdir ( <span class="string">"new_dir"</span> );</span><br></pre></td></tr></table></figure>
<p><code>remove</code>是删除文件，<code>rmdir</code>则是删除目录。要从服务器中删除文件，使用<code>remove</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp-&gt;remove( <span class="string">"hello.sh"</span> );</span><br></pre></td></tr></table></figure>
<p>要从服务器中删除目录，使用<code>rmdir</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp-&gt;rmdir ( <span class="string">"new_dir"</span> ); <span class="comment">/* 删除空目录 */</span></span><br></pre></td></tr></table></figure>
<p>注意只能删除空目录，如果目录下有文件，则不能删除。<br>&emsp;&emsp;如果要对文件进行重命名，使用<code>rename</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp-&gt;rename(<span class="string">"c++"</span>, <span class="string">"c"</span>); <span class="comment">/* c++ -&gt; c */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关于上传文件，有两个重载的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QFtp::put ( QIODevice *dev, <span class="keyword">const</span> QString &amp;file, TransferType type = Binary );</span><br></pre></td></tr></table></figure>
<p>该函数从<code>IO</code>设备<code>dev</code>读取数据，并将其写入服务器上名为<code>file</code>的文件。从<code>IO</code>设备读取数据块，因此此重载允许传输大量数据，而无需立即将所有数据读入内存。注意确保<code>dev</code>指针在操作期间有效(在发出<code>commandFinished</code>时可以安全地删除它)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m_file = <span class="keyword">new</span> QFile ( <span class="string">"E:/Qt.zip"</span> );</span><br><span class="line">ftp-&gt;put ( m_file, <span class="string">"Qt.zip"</span> );</span><br></pre></td></tr></table></figure>
<p><code>put</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QFtp::put ( <span class="keyword">const</span> QByteArray &amp;data, <span class="keyword">const</span> QString &amp;file, TransferType type = Binary );</span><br></pre></td></tr></table></figure>
<p>该函数将给定数据的副本写入服务器上名为<code>file</code>的文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp-&gt;put ( <span class="string">"Hello World!\nI'am a Qter."</span>, <span class="string">"readMe.txt"</span> );</span><br></pre></td></tr></table></figure>
<p>上传完成后，去服务端查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">c  linux  python  readMe.txt</span><br><span class="line">$ cat readMe.txt</span><br><span class="line">Hello World!</span><br><span class="line">I<span class="string">'am a Qter.</span></span><br></pre></td></tr></table></figure>
<p>如果要获取上传的进度，可以关联<code>dataTransferProgress</code>信号。<br>&emsp;&emsp;要从服务器下载文件，使用<code>get</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QFtp::get ( <span class="keyword">const</span> QString &amp;file, QIODevice *dev = <span class="number">0</span>, TransferType type = Binary );</span><br></pre></td></tr></table></figure>
<p>如果<code>dev</code>为<code>0</code>，则当有可用的数据可读时，发出<code>readyRead</code>信号，然后可以使用<code>read</code>或<code>readAll</code>函数读取数据；如果<code>dev</code>不为<code>0</code>，则将数据直接写入设备<code>dev</code>。<br>&emsp;&emsp;如果想要在有可用的数据时向用户提供数据，请连接到<code>readyRead</code>信号并立即读取数据；如果只想使用完整的数据，则可以连接到<code>commandFinished</code>信号，并在<code>get</code>命令完成后读取数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">m_file = <span class="keyword">new</span> QFile ( <span class="string">"E:/Qt.zip"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( !m_file-&gt;open ( QIODevice::WriteOnly ) ) &#123;</span><br><span class="line">    m_file-&gt;remove();</span><br><span class="line">    <span class="keyword">delete</span> m_file;</span><br><span class="line">    m_file = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    ftp-&gt;get ( <span class="string">"Qt.zip"</span>, m_file ); <span class="comment">/* 下载文件 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当前的状态<code>QFtp::State</code>由<code>state</code>返回，当状态改变时，发出<code>stateChanged</code>信号，参数是连接的新状态。该信号通常用于<code>connectToHost</code>或者<code>close</code>命令，也可以<code>自发地</code>发射，例如当服务器意外关闭连接时。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QFtp::Unconnected</code></td>
<td><code>0</code></td>
<td>没有连接到主机</td>
</tr>
<tr>
<td><code>QFtp::HostLookup</code></td>
<td><code>1</code></td>
<td>正在进行主机名查找</td>
</tr>
<tr>
<td><code>QFtp::Connecting</code></td>
<td><code>2</code></td>
<td>正在尝试连接到主机</td>
</tr>
<tr>
<td><code>QFtp::Connected</code></td>
<td><code>3</code></td>
<td>已实现与主机的连接</td>
</tr>
<tr>
<td><code>QFtp::LoggedIn</code></td>
<td><code>4</code></td>
<td>已实现连接和用户登录</td>
</tr>
<tr>
<td><code>QFtp::Closing</code></td>
<td><code>5</code></td>
<td>连接正在关闭，但尚未关闭(当连接关闭时，状态将为<code>Unconnected</code>)</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;当连接<code>TCP</code>服务器的时候，使用一个<code>QLabel</code>显示连接的状态信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FtpWindow::stateChanged ( <span class="keyword">int</span> state ) &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( state ) &#123;</span><br><span class="line">        <span class="keyword">case</span> QFtp::Unconnected: &#123;</span><br><span class="line">                stateLabel-&gt;setText ( QStringLiteral ( <span class="string">"没有连接到主机"</span> ) );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> QFtp::HostLookup: &#123;</span><br><span class="line">                stateLabel-&gt;setText ( QStringLiteral ( <span class="string">"正在进行主机名查找"</span> ) );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> QFtp::Connecting: &#123;</span><br><span class="line">                stateLabel-&gt;setText ( QStringLiteral ( <span class="string">"正在尝试连接到主机"</span> ) );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> QFtp::Connected: &#123;</span><br><span class="line">                stateLabel-&gt;setText ( QStringLiteral ( <span class="string">"已实现与主机的连接"</span> ) );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> QFtp::LoggedIn: &#123;</span><br><span class="line">                stateLabel-&gt;setText ( QStringLiteral ( <span class="string">"已实现连接和用户登录"</span> ) );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> QFtp::Closing: &#123;</span><br><span class="line">                stateLabel-&gt;setText ( QStringLiteral ( <span class="string">"连接正在关闭•"</span> ) );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>currentId</code>和<code>currentCommand</code>提供了有关当前执行命令的信息。<code>currentCommand</code>返回当前<code>FTP</code>的命令类型<code>QFtp::Command</code>，如果没有命令正在执行，则返回<code>None</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QFtp::None</code></td>
<td><code>0</code></td>
<td>未执行任何命令</td>
</tr>
<tr>
<td><code>QFtp::SetTransferMode</code></td>
<td><code>1</code></td>
<td>设置传输模式</td>
</tr>
<tr>
<td><code>QFtp::SetProxy</code></td>
<td><code>2</code></td>
<td>切换代理打开或关闭</td>
</tr>
<tr>
<td><code>QFtp::ConnectToHost</code></td>
<td><code>3</code></td>
<td>正在执行<code>connectToHost</code></td>
</tr>
<tr>
<td><code>QFtp::Login</code></td>
<td><code>4</code></td>
<td>正在执行<code>login</code></td>
</tr>
<tr>
<td><code>QFtp::Close</code></td>
<td><code>5</code></td>
<td>正在执行<code>close</code></td>
</tr>
<tr>
<td><code>QFtp::List</code></td>
<td><code>6</code></td>
<td>正在执行<code>list</code></td>
</tr>
<tr>
<td><code>QFtp::Cd</code></td>
<td><code>7</code></td>
<td>正在执行<code>cd</code></td>
</tr>
<tr>
<td><code>QFtp::Get</code></td>
<td><code>8</code></td>
<td>正在执行<code>get</code></td>
</tr>
<tr>
<td><code>QFtp::Put</code></td>
<td><code>9</code></td>
<td>正在执行<code>put</code></td>
</tr>
<tr>
<td><code>QFtp::Remove</code></td>
<td><code>10</code></td>
<td>正在执行<code>remove</code></td>
</tr>
<tr>
<td><code>QFtp::Mkdir</code></td>
<td><code>11</code></td>
<td>正在执行<code>mkdir</code></td>
</tr>
<tr>
<td><code>QFtp::Rmdir</code></td>
<td><code>12</code></td>
<td>正在执行<code>rmdir</code></td>
</tr>
<tr>
<td><code>QFtp::Rename</code></td>
<td><code>13</code></td>
<td>正在执行<code>rename</code></td>
</tr>
<tr>
<td><code>QFtp::RawCommand</code></td>
<td><code>14</code></td>
<td>正在执行<code>rawCommand</code></td>
</tr>
</tbody>
</table>
</div>
<p>这允许你对特定命令执行特定操作，例如在FTP客户端中，可能需要在启动<code>list</code>命令时清除目录视图。在这种情况下，可以简单地检查连接到<code>commandStarted</code>信号的槽函数中的<code>currentCommand</code>是否为<code>List</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FtpWindow::commandStarted ( <span class="keyword">int</span> id ) &#123;</span><br><span class="line">    QFtp::Command command = ftp-&gt;currentCommand();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( command ) &#123;</span><br><span class="line">        <span class="keyword">case</span> QFtp::List: &#123; <span class="comment">/* 正在执行list：列出目录下的文件 */</span></span><br><span class="line">                fileListTree-&gt;clear(); <span class="comment">/* 清除目录视图QTreeWidget */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"commandStarted "</span> &lt;&lt; id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过<code>error</code>和<code>errorString</code>返回最后一次发生的错误。当接收到<code>commandFinished</code>或者<code>done</code>信号时，如果标识<code>error</code>的<code>bool</code>参数为<code>true</code>，这就非常有用了。<code>error</code>返回的是一个<code>QFtp::Error</code>枚举类型，用来标识发生的错误：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QFtp::NoError</code></td>
<td><code>0</code></td>
<td>没有发生错误</td>
</tr>
<tr>
<td><code>QFtp::HostNotFound</code></td>
<td><code>2</code></td>
<td>主机名查找失败</td>
</tr>
<tr>
<td><code>QFtp::ConnectionRefused</code></td>
<td><code>3</code></td>
<td>服务器拒绝连接</td>
</tr>
<tr>
<td><code>QFtp::NotConnected</code></td>
<td><code>4</code></td>
<td>尝试发送命令，但没有到服务器的连接</td>
</tr>
<tr>
<td><code>QFtp::UnknownError</code></td>
<td><code>1</code></td>
<td>除了以上指定的错误发生</td>
</tr>
</tbody>
</table>
</div>
<p>注意，如果启动一个新命令，错误的状态会被重置为<code>NoError</code>。<br>&emsp;&emsp;<code>errorString</code>返回的是一个人类可读的字符串。通常是(但不总是)来自服务器的回复，因此并不总是可以翻译成字符串。如果消息来自<code>Qt</code>，则字符串已经通过<code>tr</code>函数的处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FtpWindow::commandFinished ( <span class="keyword">int</span> id, <span class="keyword">bool</span> error ) &#123;</span><br><span class="line">    Q_UNUSED ( id );</span><br><span class="line">    QFtp::Command command = ftp-&gt;currentCommand();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( command ) &#123;</span><br><span class="line">        <span class="keyword">case</span> QFtp::ConnectToHost: &#123; <span class="comment">/* 连接FTP服务器 */</span></span><br><span class="line">                <span class="keyword">if</span> ( error ) &#123; <span class="comment">/* 发生错误 */</span></span><br><span class="line">                    qDebug() &lt;&lt; <span class="string">"Error "</span> &lt;&lt; ftp-&gt;error() &lt;&lt; <span class="string">"ErrorString "</span> &lt;&lt; ftp-&gt;errorString();</span><br><span class="line">                    QMessageBox::information (</span><br><span class="line">                        <span class="keyword">this</span>, <span class="string">"FTP"</span>,</span><br><span class="line">                        QStringLiteral ( <span class="string">"无法连接到FTP服务器，请检查主机名是否正确！"</span> ) );</span><br><span class="line">                    ftp-&gt;<span class="built_in">abort</span>();</span><br><span class="line">                    ftp-&gt;deleteLater();</span><br><span class="line">                    ftp = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    qDebug() &lt;&lt; QStringLiteral ( <span class="string">"登录FTP服务器"</span> );</span><br><span class="line">                &#125;</span><br><span class="line">​</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;设置文件传输模式是枚举变量<code>QFtp::TransferMode</code>。<code>FTP</code>使用两个套接字连接：一个用于命令，另一个用于发送数据。虽然命令连接始终由客户端发起，但第二个连接可以由客户端或服务器发起。此枚举定义客户端(被动模式)还是服务器(活动模式)应设置数据连接。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QFtp::Passive</code></td>
<td><code>1</code></td>
<td>客户端连接到服务器以传输其数据</td>
</tr>
<tr>
<td><code>QFtp::Active</code></td>
<td><code>0</code></td>
<td>服务器连接到客户端以传输其数据</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;设置数据传输类型是使用枚举变量<code>QFtp::TransferType</code>，此枚举标识使用<code>get</code>和<code>put</code>命令进行数据传输的类型。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QFtp::Binary</code></td>
<td><code>0</code></td>
<td>数据将以二进制模式传输</td>
</tr>
<tr>
<td><code>QFtp::Ascii</code></td>
<td><code>1</code></td>
<td>数据将以<code>ASCII</code>模式传输，换行符将转换为本地格式</td>
</tr>
</tbody>
</table>
</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/27/Qt语法详解/QT信号和槽的原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/27/Qt语法详解/QT信号和槽的原理/" itemprop="url">QT信号和槽的原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T18:19:25+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;信号(<code>SIGNAL</code>)和槽(<code>SLOT</code>)是<code>Qt</code>编程的一个重要部分。这个机制可以在对象之间彼此并不了解的情况下将它们的行为联系起来。<br>&emsp;&emsp;槽和普通的<code>C++</code>成员函数很像，它可以像任何<code>C++</code>成员函数一样被调用，可以传递任何类型的参数。不同之处在于一个槽函数能和一个信号相连接，只要信号发出了，这个槽函数就会自动被调用，这个任务是由<code>connect</code>函数来实现的。<br>&emsp;&emsp;<code>connect</code>函数语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect ( sender, SIGNAL ( signal ), receiver, SLOT ( slot ) );</span><br></pre></td></tr></table></figure>
<p><code>sender</code>和<code>receiver</code>是<code>QObject</code>对象指针，<code>signal</code>和<code>slot</code>是不带参数的函数原型。宏<code>SIGNAL</code>和<code>SLOT</code>的作用是把它们转换成字符串。<br>&emsp;&emsp;信号和槽的一些使用规则如下：</p>
<ul>
<li>一个信号可以连接到多个槽，当信号发出后，槽函数都会被调用，但是调用的顺序是随机的、不确定的：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connect ( slider, SIGNAL ( valueChanged ( <span class="keyword">int</span> ) ), \</span><br><span class="line">          spinBox, SLOT ( setValue ( <span class="keyword">int</span> ) ) );</span><br><span class="line">connect ( slider, SIGNAL ( valueChanged ( <span class="keyword">int</span> ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SLOT ( updateStatusBarIndicator ( <span class="keyword">int</span> ) ) );</span><br></pre></td></tr></table></figure>
<ul>
<li>多个信号可以连接到一个槽，任何一个信号发出，槽函数都会执行：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect ( lcd, SIGNAL ( overflow() ), <span class="keyword">this</span>, SLOT ( handleMathError() ) );</span><br><span class="line">connect ( calculator, SIGNAL ( divisionByZero() ), <span class="keyword">this</span>, SLOT ( handleMathError() ) );</span><br></pre></td></tr></table></figure>
<ul>
<li>一个信号可以和另一个信号相连，第一个信号发出后，第二个信号也同时发送：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect ( lineEdit, SIGNAL ( textChanged ( <span class="keyword">const</span> QString &amp; ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SIGNAL ( updateRecord ( <span class="keyword">const</span> QString &amp; ) ) );</span><br></pre></td></tr></table></figure>
<ul>
<li>连接可以被删除，这个函数很少使用，一个对象删除后，<code>Qt</code>自动删除这个对象的所有连接：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disconnect ( lcd, SIGNAL ( overflow() ), <span class="keyword">this</span>, SLOT ( handleMathError() ) );</span><br></pre></td></tr></table></figure>
<ul>
<li>信号和槽函数必须有着相同的参数类型，这样信号和槽函数才能成功连接：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect ( ftp, SIGNAL ( rawCommandReply ( <span class="keyword">int</span>, <span class="keyword">const</span> QString &amp; ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SLOT ( processReply ( <span class="keyword">int</span>, <span class="keyword">const</span> QString &amp; ) ) );</span><br></pre></td></tr></table></figure>
<ul>
<li>如果信号里的参数个数多于槽函数的参数，多余的参数被忽略：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect ( ftp, SIGNAL ( rawCommandReply ( <span class="keyword">int</span>, <span class="keyword">const</span> QString &amp; ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SLOT ( checkErrorCode ( <span class="keyword">int</span> ) ) );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;大多数情况下使用控件的信号和槽，实际上信号和槽机制在<code>QObject</code>中就实现了，也可以实现在任何从<code>QObject</code>继承的子类中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Employee() &#123;</span><br><span class="line">        mySalary = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">salary</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mySalary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSalary</span> <span class="params">( <span class="keyword">int</span> newSalary )</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">salaryChanged</span> <span class="params">( <span class="keyword">int</span> newSalary )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mySalary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Employee::setSalary ( <span class="keyword">int</span> newSalary ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( newSalary != mySalary ) &#123;</span><br><span class="line">        mySalary = newSalary;</span><br><span class="line">        <span class="function">emit <span class="title">salaryChanged</span> <span class="params">( mySalary )</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，只有<code>newSalary != mySalary</code>时才发出<code>salaryChanged</code>信号，这样避免了死循环的出现。</p>
<hr>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;信号和槽是一种高级接口，应用于对象之间的通信，它是<code>QT</code>的核心特性。它独立于标准的<code>C/C++</code>语言，因此要正确的处理信号和槽，必须借助一个称为<code>moc(Meta Object Compiler)</code>的<code>QT</code>工具，该工具是一个<code>C++</code>预处理程序，它为高层次的事件处理自动生成所需要的附加代码。<br>&emsp;&emsp;在我们所熟知的很多<code>GUI</code>工具包中，窗口小部件(<code>widget</code>)都有一个回调函数用于响应它们能触发的每个动作，这个回调函数通常是一个指向某个函数的指针。但是<code>QT</code>的信号和槽取代了这些凌乱的函数指针，使得编写这些通信程序更为简单。<br>&emsp;&emsp;所有从<code>QObject</code>或其子类(例如<code>Qwidget</code>)派生的类都能够包含信号和槽。当对象改变其状态时，信号就由该对象发射(<code>emit</code>)出去，这就是对象所要做的全部事情，它不知道另一端是谁在接收这个信号。这就是真正的信息封装，它确保对象被当作一个真正的软件组件来使用。槽用于接收信号，但它们是普通的对象成员函数。一个槽并不知道是否有任何信号与自己相连接。，而且对象并不了解具体的通信机制。<br>&emsp;&emsp;你可以将很多信号与单个的槽进行连接，也可以将单个的信号与很多的槽进行连接，甚至于将一个信号与另外一个信号相连接也是可能的，这时无论第一个信号什么时候发射，系统都将立刻发射第二个信号。总之，信号与槽构造了一个强大的部件编程机制。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>&emsp;&emsp;当某个信号对其客户或所有者的内部状态发生改变时，信号就会被一个对象发射，只有定义过这个信号的类及其派生类才能够发射这个信号。当一个信号被发射时，与其相关联的槽将被立刻执行，就像一个正常的函数调用一样。<code>信号-槽</code>机制完全独立于任何<code>GUI</code>事件循环。只有当所有的槽返回以后，发射函数(<code>emit</code>)才返回。如果存在多个槽与某个信号相关联，那么当这个信号被发射时，这些槽将会一个接一个地执行，但是它们执行的顺序将会是随机的、不确定的。<br>&emsp;&emsp;信号的声明是在头文件中进行的，<code>QT</code>的<code>signals</code>关键字指出进入了信号声明区，随后即可声明自己的信号。例如下面定义了三个信号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignal</span> <span class="params">( <span class="keyword">int</span> x )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignalParam</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y )</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中<code>signals</code>是<code>QT</code>的关键字，<code>void mySignal()</code>定义了信号<code>mySignal</code>，这个信号没有携带参数；<code>void mySignal(int x)</code>定义了重名信号<code>mySignal</code>，但是它携带一个整型参数，有点类似于<code>C++</code>中的重载函数。从形式上，信号的声明与普通的<code>C++</code>函数是一样的，但是信号却没有函数体定义。另外，信号的返回类型都是<code>void</code>，不要指望能从信号返回什么有用信息。信号由<code>moc</code>自动产生，它们不应该在<code>.cpp</code>文件中实现。</p>
<h3 id="槽"><a href="#槽" class="headerlink" title="槽"></a>槽</h3><p>&emsp;&emsp;槽是普通的<code>C++</code>成员函数，可以被正常调用，它们唯一的特殊性就是很多信号可以与其相关联。当与其关联的信号被发射时，这个槽就会被调用。槽可以有参数，但槽的参数不能有缺省值。<br>&emsp;&emsp;既然槽是普通的成员函数，因此与其它的函数一样，它们也有权限，槽的权限决定了谁能够与其相关联。同普通的<code>C++</code>成员函数一样，槽函数也分为三种类型，即<code>public slots</code>、<code>private slots</code>和<code>protected slots</code>。</p>
<ul>
<li><code>public slots</code>：在这个区内声明的槽意味着任何对象都可将信号与之相连接。</li>
<li><code>protected slots</code>：在这个区内声明的槽意味着当前类及其子类可以将信号与之相连接。</li>
<li><code>private slots</code>：在这个区内声明的槽意味着只有类自己可以将信号与之相连接。</li>
</ul>
<p>槽也能够声明为虚函数，这也是非常有用的。槽的声明也是在头文件中进行的，例如下面声明了三个槽：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySlot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySlot</span> <span class="params">( <span class="keyword">int</span> x )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignalParam</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="信号与槽的关联"><a href="#信号与槽的关联" class="headerlink" title="信号与槽的关联"></a>信号与槽的关联</h3><p>&emsp;&emsp;通过调用<code>QObject</code>对象的<code>connect</code>函数来将某个对象的信号与另外一个对象的槽函数相关联，这样当发射者发射信号时，接收者的槽函数将被调用。该函数的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> QObject::connect ( <span class="keyword">const</span> QObject *sender, <span class="keyword">const</span> <span class="keyword">char</span> *signal, \</span><br><span class="line">                        <span class="keyword">const</span> QObject *receiver, <span class="keyword">const</span> <span class="keyword">char</span> *member ) [<span class="keyword">static</span>]</span><br></pre></td></tr></table></figure>
<p>这个函数的作用就是将发射者<code>sender</code>对象中的信号<code>signal</code>与接收者<code>receiver</code>中的<code>member</code>槽函数联系起来。指定信号<code>signal</code>时必须使用<code>QT</code>的宏<code>SIGNAL</code>，指定槽函数时必须使用宏<code>SLOT</code>。如果发射者与接收者属于同一个对象的话，那么在<code>connect</code>调用中接收者参数可以省略。例如下面定义了两个对象即标签对象<code>label</code>和滚动条对象<code>scroll</code>，并将<code>valueChanged</code>信号与标签对象的<code>setNum</code>相关联，信号还携带了一个整型参数，这样标签总是显示滚动条所处位置的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> QLabel;</span><br><span class="line">QScrollBar *scroll = <span class="keyword">new</span> QScrollBar;</span><br><span class="line">QObject::connect ( scroll, SIGNAL ( valueChanged ( <span class="keyword">int</span> ) ), label, SLOT ( setNum ( <span class="keyword">int</span> ) ) );</span><br></pre></td></tr></table></figure>
<p>一个信号甚至能够与另一个信号相关联：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> :</span> <span class="keyword">public</span> QWidget &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyWidget();</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aSignal</span><span class="params">()</span></span>;​</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPushButton *aButton;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyWidget::MyWidget() &#123;</span><br><span class="line">    aButton = <span class="keyword">new</span> QPushButton ( <span class="keyword">this</span> );</span><br><span class="line">    connect ( aButton, SIGNAL ( clicked() ), <span class="keyword">this</span>, SIGNAL ( aSignal() ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的构造函数中，<code>MyWidget</code>创建了一个私有的按钮<code>aButton</code>，按钮的单击事件产生的信号<code>clicked</code>与另外一个信号<code>aSignal</code>进行了关联。当信号<code>clicked</code>被发射时，信号<code>aSignal</code>也接着被发射。当然也可以直接将单击事件与某个私有的槽函数相关联，然后在槽中发射<code>aSignal</code>信号。<br>&emsp;&emsp;当信号与槽没有必要继续保持关联时，可以使用<code>disconnect</code>函数来断开连接：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> QObject::disconnect ( <span class="keyword">const</span> QObject *sender, <span class="keyword">const</span> <span class="keyword">char</span> *signal, \</span><br><span class="line">                           <span class="keyword">const</span> Object *receiver, <span class="keyword">const</span> <span class="keyword">char</span> *member ) [<span class="keyword">static</span>]</span><br></pre></td></tr></table></figure>
<h3 id="元对象工具"><a href="#元对象工具" class="headerlink" title="元对象工具"></a>元对象工具</h3><p>&emsp;&emsp;元对象编译器<code>moc</code>对<code>C++</code>文件中的类声明进行分析，并产生用于初始化元对象的<code>C++</code>代码，元对象包含全部信号和槽的名字以及指向这些函数的指针。<br>&emsp;&emsp;<code>moc</code>读取<code>C++</code>源文件，如果发现有<code>Q_OBJECT</code>宏声明的类，它就会生成另外一个<code>C++</code>源文件，这个新生成的文件中包含有该类的元对象代码。假设有一个头文件<code>mysignal.h</code>，在这个文件中包含有信号或槽的声明，那么在编译之前，<code>moc</code>工具就会根据该文件自动生成一个名为<code>mysignal.moc.h</code>的<code>C++</code>源文件，并将其提交给编译器；类似地，对应于<code>mysignal.cpp</code>文件，<code>moc</code>工具将自动生成一个名为<code>mysignal.moc.cpp</code>文件，并提交给编译器。</p>
<h3 id="程序样例"><a href="#程序样例" class="headerlink" title="程序样例"></a>程序样例</h3><p>&emsp;&emsp;信号和槽函数的声明一般位于头文件中，同时在类声明的开始位置必须加上<code>Q_OBJECT</code>语句。这条语句是不可缺少的，它将告诉编译器在编译之前必须先应用<code>moc</code>工具进行扩展。关键字<code>signals</code>指出随后开始信号的声明，<code>siganls</code>没有<code>public</code>、<code>private</code>、<code>protected</code>等属性，这点不同于<code>slots</code>。另外，<code>signals</code>、<code>slots</code>关键字是<code>QT</code>自己定义的，不是<code>C++</code>中的关键字。<br>&emsp;&emsp;信号的声明类似于函数的声明而非变量的声明，左边要有类型，右边要有括号。如果要向槽中传递参数的话，在括号中指定每个形参的类型，当然形参的个数可以多于一个。<br>&emsp;&emsp;关键字<code>slots</code>指出随后开始槽的声明，槽的声明与普通函数的声明一样，可以携带零或多个形参。既然信号的声明类似于普通<code>C++</code>函数的声明，那么信号也可采用<code>C++</code>中重载函数的形式进行声明。例如第一次定义的<code>void mySignal()</code>没有带参数，而第二次定义的却带有参数，从这里可以看到<code>QT</code>的信号机制是非常灵活的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* tsignal.h */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TsignalApp</span>:</span> <span class="keyword">public</span> QMainWindow &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">signals: <span class="comment">/* 信号声明区 */</span></span><br><span class="line">    <span class="comment">/* 声明信号mySignal() */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/* 声明信号mySignal(int) */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignal</span> <span class="params">( <span class="keyword">int</span> x )</span></span>;</span><br><span class="line">    <span class="comment">/* 声明信号mySignalParam(int, int) */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignalParam</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots: <span class="comment">/* 槽声明区 */</span></span><br><span class="line">    <span class="comment">/* 声明槽函数mySlot() */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySlot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/* 声明槽函数mySlot(int) */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySlot</span> <span class="params">( <span class="keyword">int</span> x )</span></span>;</span><br><span class="line">    <span class="comment">/* 声明槽函数mySignalParam (int, int) */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignalParam</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y )</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* tsignal.cpp */</span></span><br><span class="line">TsignalApp::TsignalApp() &#123;</span><br><span class="line">    <span class="comment">/* 将信号mySignal与槽mySlot相关联 */</span></span><br><span class="line">    connect ( <span class="keyword">this</span>, SIGNAL ( mySignal() ), <span class="keyword">this</span>, SLOT ( mySlot() ) );</span><br><span class="line">    <span class="comment">/* 将信号mySignal(int)与槽mySlot(int)相关联 */</span></span><br><span class="line">    connect ( <span class="keyword">this</span>, SIGNAL ( mySignal ( <span class="keyword">int</span> ) ), \</span><br><span class="line">              <span class="keyword">this</span>, SLOT ( mySlot ( <span class="keyword">int</span> ) ) );</span><br><span class="line">    <span class="comment">/* 将信号mySignalParam(int, int)与槽mySlotParam(int, int)相关联 */</span></span><br><span class="line">    connect ( <span class="keyword">this</span>, SIGNAL ( mySignalParam ( <span class="keyword">int</span>, <span class="keyword">int</span> ) ), \</span><br><span class="line">              <span class="keyword">this</span>, SLOT ( mySlotParam ( <span class="keyword">int</span>, <span class="keyword">int</span> ) ) );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> TsignalApp::mySlot() &#123; <span class="comment">/* 定义槽函数mySlot */</span></span><br><span class="line">    QMessageBox::about ( <span class="keyword">this</span>, <span class="string">"Tsignal"</span>, <span class="string">"signal/slot sample without parameter."</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> TsignalApp::mySlot ( <span class="keyword">int</span> x ) &#123; <span class="comment">/* 定义槽函数mySlot(int) */</span></span><br><span class="line">    QMessageBox::about ( <span class="keyword">this</span>, <span class="string">"Tsignal"</span>, <span class="string">"signal/slot sample with one parameter."</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> TsignalApp::mySlotParam ( <span class="keyword">int</span> x, <span class="keyword">int</span> y ) &#123; <span class="comment">/* 定义槽函数mySlotParam(int, int) */</span></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span> ( s, <span class="string">"x:%d y:%d"</span>, x, y );</span><br><span class="line">    QMessageBox::about ( <span class="keyword">this</span>, <span class="string">"Tsignal"</span>, s );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TsignalApp::slotFileNew() &#123;</span><br><span class="line">    <span class="comment">/* 发射信号mySignal */</span></span><br><span class="line">    <span class="function">emit <span class="title">mySignal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/* 发射信号mySignal(int) */</span></span><br><span class="line">    <span class="function">emit <span class="title">mySignal</span> <span class="params">( <span class="number">5</span> )</span></span>;</span><br><span class="line">    <span class="comment">/* 发射信号mySignalParam(int, int) */</span></span><br><span class="line">    <span class="function">emit <span class="title">mySignalParam</span> <span class="params">( <span class="number">5</span>, <span class="number">100</span> )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应注意的问题"><a href="#应注意的问题" class="headerlink" title="应注意的问题"></a>应注意的问题</h3><p>&emsp;&emsp;信号与槽机制是比较灵活的，但有些局限性必须要了解，这样在实际使用过程中避免产生错误。<br>&emsp;&emsp;1. 信号与槽的效率是非常高的，但是同真正的回调函数比较起来，由于增加了灵活性，因此在速度上还是有所损失。当然这种损失相对来说是比较小的，在一台<code>i586</code>的机器上测试是<code>10</code>微秒，可见这种机制所提供的简洁性、灵活性还是值得的。但如果要追求高效率的话，比如在实时系统中就要尽可能地少用这种机制。<br>&emsp;&emsp;2. 信号与槽机制与普通函数的调用一样，如果使用不当的话，在程序执行时也有可能产生死循环。因此在定义槽函数时一定要注意避免间接形成无限循环，即在槽中再次发射所接收到的同样信号。例如，如果在<code>mySlot()</code>槽函数中加上语句<code>emit mySignal()</code>即可形成死循环。<br>&emsp;&emsp;3. 如果一个信号与多个槽相联系的话，那么当这个信号被发射时，与之相关的槽被激活的顺序将是随机的。<br>&emsp;&emsp;4. 宏定义不能用在<code>signal</code>和<code>slot</code>的参数中。既然<code>moc</code>工具不扩展<code>define</code>，因此在<code>signals</code>和<code>slots</code>中携带参数的宏就不能正确地工作，如果不带参数则是可以的。例如，下面的例子中将带有参数的宏<code>SIGNEDNESS(a)</code>作为信号的参数是不合语法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ultrix</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> SIGNEDNESS(a) unsigned a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> SIGNEDNESS(a) a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Whatever</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">someSignal</span> <span class="params">( SIGNEDNESS ( a ) )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;5. 构造函数不能用在<code>signals</code>或者<code>slots</code>声明区域内。下面的用法是不符合语法要求的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    SomeClass ( QObject *parent, <span class="keyword">const</span> <span class="keyword">char</span> *name ) : QObject ( parent, name ) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;6. 函数指针不能作为信号或槽的参数。下面的例子中将<code>void (* applyFunction)(QList *, void *)</code>作为参数是不符合语法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">someClass</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span> <span class="params">( <span class="keyword">void</span> ( *applyFunction ) ( QList *, <span class="keyword">void</span> * ), <span class="keyword">char</span> * )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你可以采用下面的方法绕过这个限制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">( *ApplyFunctionType )</span> <span class="params">( QList *, <span class="keyword">void</span> * )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">someClass</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span> <span class="params">( ApplyFunctionType, <span class="keyword">char</span> * )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;7. 信号与槽不能有缺省参数。下面的用法是不合理的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">/* 将x的缺省值定义成100，在槽函数声明中使用是错误的 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">someSlot</span> <span class="params">( <span class="keyword">int</span> x = <span class="number">100</span> )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;8. 信号与槽也不能携带模板类参数。如果将信号、槽声明为模板类参数的话，即使<code>moc</code>工具不报告错误，也不可能得到预期的结果。下面的例子中，当信号发射时，槽函数不会被正确调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="keyword">void</span> MyWidget::setLocation ( pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; location );</span><br><span class="line"><span class="keyword">public</span> signals:</span><br><span class="line">    <span class="keyword">void</span> MyObject::moved ( pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; location );</span><br></pre></td></tr></table></figure>
<p>但是可以使用<code>typedef</code>语句来绕过这个限制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; IntPair;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="keyword">void</span> MyWidget::setLocation ( IntPair location );</span><br><span class="line"><span class="keyword">public</span> signals:</span><br><span class="line">    <span class="keyword">void</span> MyObject::moved ( IntPair location );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;9. 嵌套的类不能位于信号或槽区域内，也不能有信号或者槽。下面的例子中，在<code>class B</code>中声明槽<code>b</code>是不符合语法的，在信号区内声明槽<code>b</code>也是不符合语法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> slots: <span class="comment">/* 在嵌套类中声明槽不合语法 */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">​</span><br><span class="line">signals:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>; <span class="comment">/* 在信号区内声明嵌套类不合语法 */</span></span><br><span class="line">    &#125;:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;10. 友元声明不能位于信号或者槽声明区内，它们应该在普通<code>C++</code>的<code>private</code>、<code>protected</code>或者<code>public</code>区内进行声明。下面的例子是不符合语法规范的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">someClass</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">signals: <span class="comment">/* 信号定义区 */</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTemplate</span>;</span> <span class="comment">/* 此处定义不合语法 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/27/Qt语法详解/Qt之QSplashScreen/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/27/Qt语法详解/Qt之QSplashScreen/" itemprop="url">Qt之QSplashScreen</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T14:56:49+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QSplashScreen</code> widget provides a splash screen that can be shown during application startup. The header file is <code>QSplashScreen</code>.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QSplashScreen(const QPixmap &amp; pixmap = QPixmap(), Qt::WindowFlags f = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>QSplashScreen(QWidget * parent, const QPixmap &amp; pixmap = QPixmap(), Qt::WindowFlags f = 0)</code></td>
</tr>
<tr>
<td><code>virtual</code></td>
<td><code>~QSplashScreen()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>finish(QWidget * mainWin)</code></td>
</tr>
<tr>
<td><code>const QPixmap</code></td>
<td><code>pixmap() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>repaint()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPixmap(const QPixmap &amp; pixmap)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Slots"><a href="#Public-Slots" class="headerlink" title="Public Slots"></a>Public Slots</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>clearMessage()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>showMessage(const QString &amp; message, int alignment = Qt::AlignLeft, const QColor &amp; color = Qt::black)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><ul>
<li><code>void messageChanged(const QString &amp; message)</code></li>
</ul>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><ul>
<li><code>virtual void drawContents(QPainter * painter)</code></li>
</ul>
<h3 id="Reimplemented-Protected-Functions"><a href="#Reimplemented-Protected-Functions" class="headerlink" title="Reimplemented Protected Functions"></a>Reimplemented Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual bool</code></td>
<td><code>event(QEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>mousePressEvent(QMouseEvent *)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QSplashScreen</code> widget provides a splash screen that can be shown during application startup.<br>&emsp;&emsp;A splash screen is a widget that is usually displayed when an application is being started. Splash screens are often used for applications that have long start up times (e.g. database or networking applications that take time to establish connections) to provide the user with feedback that the application is loading.<br>&emsp;&emsp;The splash screen appears in the center of the screen. It may be useful to add the <code>Qt::WindowStaysOnTopHint</code> to the splash widget’s window flags if you want to keep it above all the other windows on the desktop.<br>&emsp;&emsp;Some <code>X11</code> window managers do not support the <code>stays on top</code> flag. A solution is to set up a timer that periodically calls <code>raise()</code> on the splash screen to simulate the <code>stays on top</code> effect.<br>&emsp;&emsp;The most common usage is to show a splash screen before the main widget is displayed on the screen. This is illustrated in the following code snippet in which a splash screen is displayed and some initialization tasks are performed before the application’s main window is shown:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span> <span class="params">( <span class="string">":/splash.png"</span> )</span></span>;</span><br><span class="line">    <span class="function">QSplashScreen <span class="title">splash</span> <span class="params">( pixmap )</span></span>;</span><br><span class="line">    splash.show();</span><br><span class="line">    app.processEvents();</span><br><span class="line">    ...</span><br><span class="line">    QMainWindow window;</span><br><span class="line">    window.show();</span><br><span class="line">    splash.finish ( &amp;window );</span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The user can hide the splash screen by clicking on it with the mouse. Since the splash screen is typically displayed before the event loop has started running, it is necessary to periodically call <code>QApplication::processEvents()</code> to receive the mouse clicks.<br>&emsp;&emsp;It is sometimes useful to update the splash screen with messages, for example, announcing connections established or modules loaded as the application starts up:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">pixmap</span> <span class="params">( <span class="string">":/splash.png"</span> )</span></span>;</span><br><span class="line">QSplashScreen *splash = <span class="keyword">new</span> QSplashScreen ( pixmap );</span><br><span class="line">splash-&gt;show();</span><br><span class="line">​</span><br><span class="line">... <span class="comment">/* Loading some items */</span></span><br><span class="line">splash-&gt;showMessage ( <span class="string">"Loaded modules"</span> );</span><br><span class="line">​</span><br><span class="line">qApp-&gt;processEvents();</span><br><span class="line">​</span><br><span class="line">... <span class="comment">/* Establishing connections */</span></span><br><span class="line">splash-&gt;showMessage ( <span class="string">"Established connections"</span> );</span><br><span class="line">​</span><br><span class="line">qApp-&gt;processEvents();</span><br></pre></td></tr></table></figure>
<p><code>QSplashScreen</code> supports this with the <code>showMessage()</code> function. If you wish to do your own drawing you can get a pointer to the pixmap used in the splash screen with <code>pixmap()</code>. Alternatively, you can subclass <code>QSplashScreen</code> and reimplement <code>drawContents()</code>.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QSplashScreen::QSplashScreen(const QPixmap &amp; pixmap = QPixmap(), Qt::WindowFlags f = 0)</code>: Construct a splash screen that will display the <code>pixmap</code>. There should be no need to set the widget flags, <code>f</code>, except perhaps <code>Qt::WindowStaysOnTopHint</code>.</li>
<li><code>QSplashScreen::QSplashScreen(QWidget * parent, const QPixmap &amp; pixmap = QPixmap(), Qt::WindowFlags f = 0)</code>: This is an overloaded function. This function allows you to specify a <code>parent</code> for your splashscreen. The typical use for this constructor is if you have a multiple screens and prefer to have the splash screen on a different screen than your primary one. In that case pass the proper <code>desktop()</code> as the <code>parent</code>.</li>
<li><code>QSplashScreen::~QSplashScreen() [virtual]</code>: Destructor.</li>
<li><code>void QSplashScreen::clearMessage() [slot]</code>: Removes the message being displayed on the splash screen.</li>
<li><code>void QSplashScreen::drawContents(QPainter * painter) [virtual protected]</code>: Draw the contents of the splash screen using <code>painter</code>. The default implementation draws the message passed by <code>showMessage()</code>. Reimplement this function if you want to do your own drawing on the splash screen.</li>
<li><code>bool QSplashScreen::event(QEvent * e) [virtual protected]</code>: Reimplemented from <code>QObject::event()</code>.</li>
<li><code>void QSplashScreen::finish(QWidget * mainWin)</code>: Makes the splash screen wait until the widget <code>mainWin</code> is displayed before calling <code>close()</code> on itself.</li>
<li><code>void QSplashScreen::messageChanged(const QString &amp; message) [signal]</code>: This signal is emitted when the <code>message</code> on the splash screen changes. <code>message</code> is the new message and is a <code>null-string</code> when the message has been removed.</li>
<li><code>void QSplashScreen::mousePressEvent(QMouseEvent *) [virtual protected]</code>: Reimplemented from <code>QWidget::mousePressEvent()</code>.</li>
<li><code>const QPixmap QSplashScreen::pixmap() const</code>: Returns the pixmap that is used in the splash screen. The image does not have any of the text drawn by <code>showMessage()</code> calls.</li>
<li><code>void QSplashScreen::repaint()</code>: This overrides <code>QWidget::repaint()</code>. It differs from the standard repaint function in that it also calls <code>QApplication::flush()</code> to ensure the updates are displayed, even when there is no event loop present.</li>
<li><code>void QSplashScreen::setPixmap(const QPixmap &amp; pixmap)</code>: Sets the <code>pixmap</code> that will be used as the splash screen’s image to pixmap.</li>
<li><code>void QSplashScreen::showMessage(const QString &amp; message, int alignment = Qt::AlignLeft, const QColor &amp; color = Qt::black) [slot]</code>: Draws the <code>message</code> text onto the splash screen with <code>color</code> and aligns the text according to the flags in <code>alignment</code>. To make sure the splash screen is repainted immediately, you can call <code>QCoreApplication&#39;s</code> <code>processEvents()</code> after the call to <code>showMessage()</code>. You usually want this to make sure that the <code>message</code> is kept up to date with what your application is doing (e.g., loading files).</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/27/Qt语法详解/Qt之QTreeWidgetItem/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/27/Qt语法详解/Qt之QTreeWidgetItem/" itemprop="url">Qt之QTreeWidgetItem</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T00:36:51+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTreeWidgetItem</code> class provides an item for use with the <code>QTreeWidget</code> convenience class. The header file is <code>QTreeWidgetItem</code>.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTreeWidgetItem(int type = Type)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTreeWidgetItem(const QStringList &amp; strings, int type = Type)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTreeWidgetItem(QTreeWidget * parent, int type = Type)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTreeWidgetItem(QTreeWidget * parent, const QStringList &amp; strings, int type = Type)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTreeWidgetItem(QTreeWidget * parent, QTreeWidgetItem * preceding, int type = Type)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTreeWidgetItem(QTreeWidgetItem * parent, int type = Type)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTreeWidgetItem(QTreeWidgetItem * parent, const QStringList &amp; strings, int type = Type)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTreeWidgetItem(QTreeWidgetItem * parent, QTreeWidgetItem * preceding, int type = Type)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTreeWidgetItem(const QTreeWidgetItem &amp; other)</code></td>
</tr>
<tr>
<td><code>virtual</code></td>
<td><code>~QTreeWidgetItem()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addChild(QTreeWidgetItem * child)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addChildren(const QList&lt;QTreeWidgetItem *&gt; &amp; children)</code></td>
</tr>
<tr>
<td><code>QBrush</code></td>
<td><code>background(int column) const</code></td>
</tr>
<tr>
<td><code>Qt::CheckState</code></td>
<td><code>checkState(int column) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>child(int index) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>childCount() const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem::ChildIndicatorPolicy</code></td>
<td><code>childIndicatorPolicy() const</code></td>
</tr>
<tr>
<td><code>virtual QTreeWidgetItem *</code></td>
<td><code>clone() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>columnCount() const</code></td>
</tr>
<tr>
<td><code>virtual QVariant</code></td>
<td><code>data(int column, int role) const</code></td>
</tr>
<tr>
<td><code>Qt::ItemFlags</code></td>
<td><code>flags() const</code></td>
</tr>
<tr>
<td><code>QFont</code></td>
<td><code>font(int column) const</code></td>
</tr>
<tr>
<td><code>QBrush</code></td>
<td><code>foreground(int column) const</code></td>
</tr>
<tr>
<td><code>QIcon</code></td>
<td><code>icon(int column) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>indexOfChild(QTreeWidgetItem * child) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertChild(int index, QTreeWidgetItem * child)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertChildren(int index, const QList&lt;QTreeWidgetItem *&gt; &amp; children)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isDisabled() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isExpanded() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isFirstColumnSpanned() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isHidden() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isSelected() const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>parent() const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>read(QDataStream &amp; in)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeChild(QTreeWidgetItem * child)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBackground(int column, const QBrush &amp; brush)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCheckState(int column, Qt::CheckState state)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setChildIndicatorPolicy(QTreeWidgetItem::ChildIndicatorPolicy policy)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>setData(int column, int role, const QVariant &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDisabled(bool disabled)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setExpanded(bool expand)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFirstColumnSpanned(bool span)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFlags(Qt::ItemFlags flags)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFont(int column, const QFont &amp; font)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setForeground(int column, const QBrush &amp; brush)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHidden(bool hide)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setIcon(int column, const QIcon &amp; icon)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSelected(bool select)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSizeHint(int column, const QSize &amp; size)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setStatusTip(int column, const QString &amp; statusTip)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setText(int column, const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTextAlignment(int column, int alignment)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setToolTip(int column, const QString &amp; toolTip)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setWhatsThis(int column, const QString &amp; whatsThis)</code></td>
</tr>
<tr>
<td><code>QSize</code></td>
<td><code>sizeHint(int column) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>sortChildren(int column, Qt::SortOrder order)</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>statusTip(int column) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>takeChild(int index)</code></td>
</tr>
<tr>
<td><code>QList&lt;QTreeWidgetItem *&gt;</code></td>
<td><code>takeChildren()</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>text(int column) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>textAlignment(int column) const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>toolTip(int column) const</code></td>
</tr>
<tr>
<td><code>QTreeWidget *</code></td>
<td><code>treeWidget() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>type() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>whatsThis(int column) const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>write(QDataStream &amp; out) const</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>operator&lt;(const QTreeWidgetItem &amp; other) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem &amp;</code></td>
<td><code>operator=(const QTreeWidgetItem &amp; other)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><ul>
<li><code>void emitDataChanged()</code></li>
</ul>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; out, const QTreeWidgetItem &amp; item)</code></li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; in, QTreeWidgetItem &amp; item)</code></li>
</ul>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTreeWidgetItem</code> class provides an item for use with the <code>QTreeWidget</code> convenience class.<br>&emsp;&emsp;Tree widget items are used to hold rows of information for tree widgets. Rows usually contain several columns of data, each of which can contain a text label and an icon.<br>&emsp;&emsp;The <code>QTreeWidgetItem</code> class is a convenience class that replaces the <code>QListViewItem</code> class in <code>Qt 3</code>. It provides an item for use with the <code>QTreeWidget</code> class.<br>&emsp;&emsp;Items are usually constructed with a parent that is either a <code>QTreeWidget</code> (for <code>top-level</code> items) or a <code>QTreeWidgetItem</code> (for items on lower levels of the tree). For example, the following code constructs a <code>top-level</code> item to represent cities of the world, and adds a entry for <code>Oslo</code> as a child item:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QTreeWidgetItem *cities = <span class="keyword">new</span> QTreeWidgetItem ( treeWidget );</span><br><span class="line">cities-&gt;setText ( <span class="number">0</span>, tr ( <span class="string">"Cities"</span> ) );</span><br><span class="line">QTreeWidgetItem *osloItem = <span class="keyword">new</span> QTreeWidgetItem ( cities );</span><br><span class="line">osloItem-&gt;setText ( <span class="number">0</span>, tr ( <span class="string">"Oslo"</span> ) );</span><br><span class="line">osloItem-&gt;setText ( <span class="number">1</span>, tr ( <span class="string">"Yes"</span> ) );</span><br></pre></td></tr></table></figure>
<p>Items can be added in a particular order by specifying the item they follow when they are constructed:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QTreeWidgetItem *planets = <span class="keyword">new</span> QTreeWidgetItem ( treeWidget, cities );</span><br><span class="line">planets-&gt;setText ( <span class="number">0</span>, tr ( <span class="string">"Planets"</span> ) );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Each column in an item can have its own background brush which is set with the <code>setBackground()</code> function. The current background brush can be found with <code>background()</code>. The text label for each column can be rendered with its own font and brush. These are specified with the <code>setFont()</code> and <code>setForeground()</code> functions, and read with <code>font()</code> and <code>foreground()</code>.<br>&emsp;&emsp;The main difference between <code>top-level</code> items and those in lower levels of the tree is that a <code>top-level</code> item has no <code>parent()</code>. This information can be used to tell the difference between items, and is useful to know when inserting and removing items from the tree. Children of an item can be removed with <code>takeChild()</code> and inserted at a given index in the list of children with the <code>insertChild()</code> function.<br>&emsp;&emsp;By default, items are enabled, selectable, checkable, and can be the source of a drag and drop operation. Each item’s flags can be changed by calling <code>setFlags()</code> with the appropriate value. Checkable items can be checked and unchecked with the <code>setCheckState()</code> function. The corresponding <code>checkState()</code> function indicates whether the item is currently checked.</p>
<h3 id="Subclassing"><a href="#Subclassing" class="headerlink" title="Subclassing"></a>Subclassing</h3><p>&emsp;&emsp;When subclassing <code>QTreeWidgetItem</code> to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than <code>UserType</code>.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QTreeWidgetItem::ChildIndicatorPolicy</code>:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTreeWidgetItem::ShowIndicator</code></td>
<td><code>0</code></td>
<td>The controls for expanding and collapsing will be shown for this item even if there are no children.</td>
</tr>
<tr>
<td><code>QTreeWidgetItem::DontShowIndicator</code></td>
<td><code>1</code></td>
<td>The controls for expanding and collapsing will never be shown even if there are children. If the node is forced open the user will not be able to expand or collapse the item.</td>
</tr>
<tr>
<td><code>QTreeWidgetItem::DontShowIndicatorWhenChildless</code></td>
<td><code>2</code></td>
<td>The controls for expanding and collapsing will be shown if the item contains children.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QTreeWidgetItem::ItemType</code>: This enum describes the types that are used to describe tree widget items.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTreeWidgetItem::Type</code></td>
<td><code>0</code></td>
<td>The default type for tree widget items.</td>
</tr>
<tr>
<td><code>QTreeWidgetItem::UserType</code></td>
<td><code>1000</code></td>
<td>The minimum value for custom types. Values below <code>UserType</code> are reserved by <code>Qt</code>.</td>
</tr>
</tbody>
</table>
</div>
<p>You can define new user types in <code>QTreeWidgetItem</code> subclasses to ensure that custom items are treated specially; for example, when items are sorted.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTreeWidgetItem::QTreeWidgetItem(int type = Type)</code>: Constructs a tree widget item of the specified <code>type</code>. The item must be inserted into a tree widget.</li>
<li><code>QTreeWidgetItem::QTreeWidgetItem(const QStringList &amp; strings, int type = Type)</code>: Constructs a tree widget item of the specified <code>type</code>. The item must be inserted into a tree widget. The given list of <code>strings</code> will be set as the item text for each column in the item.</li>
<li><code>QTreeWidgetItem::QTreeWidgetItem(QTreeWidget * parent, int type = Type)</code>: Constructs a tree widget item of the specified <code>type</code> and appends it to the items in the given <code>parent</code>.</li>
<li><code>QTreeWidgetItem::QTreeWidgetItem(QTreeWidget * parent, const QStringList &amp; strings, int type = Type)</code>: Constructs a tree widget item of the specified <code>type</code> and appends it to the items in the given <code>parent</code>. The given list of <code>strings</code> will be set as the item text for each column in the item.</li>
<li><code>QTreeWidgetItem::QTreeWidgetItem(QTreeWidget * parent, QTreeWidgetItem * preceding, int type = Type)</code>: Constructs a tree widget item of the specified <code>type</code> and inserts it into the given <code>parent</code> after the <code>preceding</code> item.</li>
<li><code>QTreeWidgetItem::QTreeWidgetItem(QTreeWidgetItem * parent, int type = Type)</code>: Constructs a tree widget item and append it to the given <code>parent</code>.</li>
<li><code>QTreeWidgetItem::QTreeWidgetItem(QTreeWidgetItem * parent, const QStringList &amp; strings, int type = Type)</code>: Constructs a tree widget item and append it to the given <code>parent</code>. The given list of <code>strings</code> will be set as the item text for each column in the item.</li>
<li><code>QTreeWidgetItem::QTreeWidgetItem(QTreeWidgetItem * parent, QTreeWidgetItem * preceding, int type = Type)</code>: Constructs a tree widget item of the specified <code>type</code> that is inserted into the <code>parent</code> after the <code>preceding</code> child item.</li>
<li><code>QTreeWidgetItem::QTreeWidgetItem(const QTreeWidgetItem &amp; other)</code>: Constructs a copy of <code>other</code>. Note that <code>type()</code> and <code>treeWidget()</code> are not copied. This function is useful when reimplementing <code>clone()</code>.</li>
<li><code>QTreeWidgetItem::~QTreeWidgetItem() [virtual]</code>: Destroys this tree widget item. The item will be removed from <code>QTreeWidgets</code> to which it has been added. This makes it safe to delete an item at any time.</li>
<li><code>void QTreeWidgetItem::addChild(QTreeWidgetItem * child)</code>: Appends the <code>child</code> item to the list of children.</li>
<li><code>void QTreeWidgetItem::addChildren(const QList&lt;QTreeWidgetItem *&gt; &amp; children)</code>: Appends the given list of <code>children</code> to the item.</li>
<li><code>QBrush QTreeWidgetItem::background(int column) const</code>: Returns the brush used to render the background of the specified <code>column</code>.</li>
<li><code>Qt::CheckState QTreeWidgetItem::checkState(int column) const</code>: Returns the check state of the label in the given <code>column</code>.</li>
<li><code>QTreeWidgetItem * QTreeWidgetItem::child(int index) const</code>: Returns the item at the given <code>index</code> in the list of the item’s children.</li>
<li><code>int QTreeWidgetItem::childCount() const</code>: Returns the number of child items.</li>
<li><code>QTreeWidgetItem::ChildIndicatorPolicy QTreeWidgetItem::childIndicatorPolicy() const</code>: Returns the item indicator policy. This policy decides when the tree branch <code>expand/collapse</code> indicator is shown.</li>
<li><code>QTreeWidgetItem * QTreeWidgetItem::clone() const [virtual]</code>: Creates a deep copy of the item and of its children.</li>
<li><code>int QTreeWidgetItem::columnCount() const</code>: Returns the number of columns in the item.</li>
<li><code>QVariant QTreeWidgetItem::data(int column, int role) const [virtual]</code>: Returns the value for the item’s <code>column</code> and <code>role</code>.</li>
<li><code>void QTreeWidgetItem::emitDataChanged() [protected]</code>: Causes the model associated with this item to emit a <code>dataChanged()</code> signal for this item. You normally only need to call this function if you have subclassed <code>QTreeWidgetItem</code> and reimplemented <code>data()</code> and/or <code>setData()</code>.</li>
<li><code>Qt::ItemFlags QTreeWidgetItem::flags() const</code>: Returns the flags used to describe the item. These determine whether the item can be checked, edited, and selected. The default value for flags is <code>Qt::ItemIsSelectable | Qt::ItemIsUserCheckable | Qt::ItemIsEnabled | Qt::ItemIsDragEnabled</code>. If the item was constructed with a parent, flags will in addition contain <code>Qt::ItemIsDropEnabled</code>.</li>
<li><code>QFont QTreeWidgetItem::font(int column) const</code>: Returns the font used to render the text in the specified <code>column</code>.</li>
<li><code>QBrush QTreeWidgetItem::foreground(int column) const</code>: Returns the brush used to render the foreground (e.g. <code>text</code>) of the specified <code>column</code>.</li>
<li><code>QIcon QTreeWidgetItem::icon(int column) const</code>: Returns the icon that is displayed in the specified <code>column</code>.</li>
<li><code>int QTreeWidgetItem::indexOfChild(QTreeWidgetItem * child) const</code>: Returns the index of the given <code>child</code> in the item’s list of children.</li>
<li><code>void QTreeWidgetItem::insertChild(int index, QTreeWidgetItem * child)</code>: Inserts the <code>child</code> item at <code>index</code> in the list of children. If the <code>child</code> has already been inserted somewhere else it wont be inserted again.</li>
<li><code>void QTreeWidgetItem::insertChildren(int index, const QList&lt;QTreeWidgetItem *&gt; &amp; children)</code>: Inserts the given list of <code>children</code> into the list of the item <code>children</code> at <code>index</code>. Children that have already been inserted somewhere else wont be inserted.</li>
<li><code>bool QTreeWidgetItem::isDisabled() const</code>: Returns <code>true</code> if the item is disabled; otherwise returns <code>false</code>.</li>
<li><code>bool QTreeWidgetItem::isExpanded() const</code>: Returns <code>true</code> if the item is expanded, otherwise returns <code>false</code>.</li>
<li><code>bool QTreeWidgetItem::isFirstColumnSpanned() const</code>: Returns <code>true</code> if the item is spanning all the columns in a row; otherwise returns <code>false</code>.</li>
<li><code>bool QTreeWidgetItem::isHidden() const</code>: Returns <code>true</code> if the item is hidden, otherwise returns <code>false</code>.</li>
<li><code>bool QTreeWidgetItem::isSelected() const</code>: Returns <code>true</code> if the item is selected, otherwise returns <code>false</code>.</li>
<li><code>QTreeWidgetItem * QTreeWidgetItem::parent() const</code>: Returns the item’s parent.</li>
<li><code>void QTreeWidgetItem::read(QDataStream &amp; in) [virtual]</code>: Reads the item from stream <code>in</code>. This only reads data into a single item.</li>
<li><code>void QTreeWidgetItem::removeChild(QTreeWidgetItem * child)</code>: Removes the given item indicated by <code>child</code>. The removed item will not be deleted.</li>
<li><code>void QTreeWidgetItem::setBackground(int column, const QBrush &amp; brush)</code>: Sets the background <code>brush</code> of the label in the given <code>column</code> to the specified <code>brush</code>.</li>
<li><code>void QTreeWidgetItem::setCheckState(int column, Qt::CheckState state)</code>: Sets the item in the given column check <code>state</code> to be <code>state</code>.</li>
<li><code>void QTreeWidgetItem::setChildIndicatorPolicy(QTreeWidgetItem::ChildIndicatorPolicy policy)</code>: Sets the item indicator <code>policy</code>. This <code>policy</code> decides when the tree branch <code>expand/collapse</code> indicator is shown. The default value is <code>ShowForChildren</code>.</li>
<li><code>void QTreeWidgetItem::setData(int column, int role, const QVariant &amp; value) [virtual]</code>: Sets the <code>value</code> for the item’s <code>column</code> and <code>role</code> to the given <code>value</code>. The <code>role</code> describes the type of data specified by <code>value</code>, and is defined by the <code>Qt::ItemDataRole</code> enum.</li>
<li><code>void QTreeWidgetItem::setDisabled(bool disabled)</code>: Disables the item if <code>disabled</code> is <code>true</code>; otherwise enables the item.</li>
<li><code>void QTreeWidgetItem::setExpanded(bool expand)</code>: Expands the item if <code>expand</code> is true, otherwise collapses the item. <strong>Warning</strong>: The <code>QTreeWidgetItem</code> must be added to the <code>QTreeWidget</code> before calling this function.</li>
<li><code>void QTreeWidgetItem::setFirstColumnSpanned(bool span)</code>: Sets the first section to <code>span</code> all columns if <code>span</code> is <code>true</code>; otherwise all item sections are shown.</li>
<li><code>void QTreeWidgetItem::setFlags(Qt::ItemFlags flags)</code>: Sets the <code>flags</code> for the item to the given <code>flags</code>. These determine whether the item can be selected or modified. This is often used to disable an item.</li>
<li><code>void QTreeWidgetItem::setFont(int column, const QFont &amp; font)</code>: Sets the <code>font</code> used to display the text in the given <code>column</code> to the given <code>font</code>.</li>
<li><code>void QTreeWidgetItem::setForeground(int column, const QBrush &amp; brush)</code>: Sets the foreground <code>brush</code> of the label in the given <code>column</code> to the specified <code>brush</code>.</li>
<li><code>void QTreeWidgetItem::setHidden(bool hide)</code>: Hides the item if <code>hide</code> is <code>true</code>, otherwise shows the item.</li>
<li><code>void QTreeWidgetItem::setIcon(int column, const QIcon &amp; icon)</code>: Sets the <code>icon</code> to be displayed in the given <code>column</code> to <code>icon</code>.</li>
<li><code>void QTreeWidgetItem::setSelected(bool select)</code>: Sets the selected state of the item to <code>select</code>.</li>
<li><code>void QTreeWidgetItem::setSizeHint(int column, const QSize &amp; size)</code>: Sets the <code>size</code> hint for the tree item in the given <code>column</code> to be <code>size</code>. If no <code>size</code> hint is set, the item delegate will compute the <code>size</code> hint based on the item data.</li>
<li><code>void QTreeWidgetItem::setStatusTip(int column, const QString &amp; statusTip)</code>: Sets the status tip for the given <code>column</code> to the given <code>statusTip</code>. <code>QTreeWidget</code> mouse tracking needs to be enabled for this feature to work.</li>
<li><code>void QTreeWidgetItem::setText(int column, const QString &amp; text)</code>: Sets the <code>text</code> to be displayed in the given <code>column</code> to the given <code>text</code>.</li>
<li><code>void QTreeWidgetItem::setTextAlignment(int column, int alignment)</code>: Sets the text <code>alignment</code> for the label in the given <code>column</code> to the <code>alignment</code> specified.</li>
<li><code>void QTreeWidgetItem::setToolTip(int column, const QString &amp; toolTip)</code>: Sets the tooltip for the given <code>column</code> to <code>toolTip</code>.</li>
<li><code>void QTreeWidgetItem::setWhatsThis(int column, const QString &amp; whatsThis)</code>: Sets the <code>What&#39;s This?</code> help for the given <code>column</code> to <code>whatsThis</code>.</li>
<li><code>QSize QTreeWidgetItem::sizeHint(int column) const</code>: Returns the size hint set for the tree item in the given <code>column</code>.</li>
<li><code>void QTreeWidgetItem::sortChildren(int column, Qt::SortOrder order)</code>: Sorts the children of the item using the given <code>order</code>, by the values in the given <code>column</code>. <strong>Note</strong>: This function does nothing if the item is not associated with a <code>QTreeWidget</code>.</li>
<li><code>QString QTreeWidgetItem::statusTip(int column) const</code>: Returns the status tip for the contents of the given <code>column</code>.</li>
<li><code>QTreeWidgetItem * QTreeWidgetItem::takeChild(int index)</code>: Removes the item at <code>index</code> and returns it, otherwise return <code>0</code>.</li>
<li><code>QList&lt;QTreeWidgetItem *&gt; QTreeWidgetItem::takeChildren()</code>: Removes the list of children and returns it, otherwise returns an empty list.</li>
<li><code>QString QTreeWidgetItem::text(int column) const</code>: Returns the text in the specified <code>column</code>.</li>
<li><code>int QTreeWidgetItem::textAlignment(int column) const</code>: Returns the text alignment for the label in the given <code>column</code>.</li>
<li><code>QString QTreeWidgetItem::toolTip(int column) const</code>: Returns the tool tip for the given <code>column</code>.</li>
<li><code>QTreeWidget * QTreeWidgetItem::treeWidget() const</code>: Returns the tree widget that contains the item.</li>
<li><code>int QTreeWidgetItem::type() const</code>: Returns the type passed to the <code>QTreeWidgetItem</code> constructor.</li>
<li><code>QString QTreeWidgetItem::whatsThis(int column) const</code>: Returns the <code>What&#39;s This?</code> help for the contents of the given <code>column</code>.</li>
<li><code>void QTreeWidgetItem::write(QDataStream &amp; out) const [virtual]</code>: Writes the item to stream <code>out</code>. This only writes data from one single item.</li>
<li><code>bool QTreeWidgetItem::operator&lt;(const QTreeWidgetItem &amp; other) const [virtual]</code>: Returns <code>true</code> if the text in the item is less than the text in the <code>other</code> item, otherwise returns <code>false</code>.</li>
<li><code>QTreeWidgetItem &amp; QTreeWidgetItem::operator=(const QTreeWidgetItem &amp; other)</code>: Assigns <code>other&#39;s</code> data and flags to this item. Note that <code>type()</code> and <code>treeWidget()</code> are not copied. This function is useful when reimplementing <code>clone()</code>.</li>
</ul>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; out, const QTreeWidgetItem &amp; item)</code>: Writes the tree widget item item to stream out. This operator uses <code>QTreeWidgetItem::write()</code>.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; in, QTreeWidgetItem &amp; item)</code>: Reads a tree widget item from stream in into item. This operator uses <code>QTreeWidgetItem::read()</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/26/Qt语法详解/Qt之QNetwork系列/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/26/Qt语法详解/Qt之QNetwork系列/" itemprop="url">Qt之QNetwork系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-26T21:42:05+08:00">
                2019-01-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="QNetworkAccessManager"><a href="#QNetworkAccessManager" class="headerlink" title="QNetworkAccessManager"></a>QNetworkAccessManager</h3><p>&emsp;&emsp;这个类的所有函数都是可重入的，它是从<code>Qt 4.4</code>引入的。</p>
<h4 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h4><p>&emsp;&emsp;<code>QNetworkAccessManager</code>类允许应用程序发送网络请求和接收网络应答。<code>Network Access API</code>都是围绕着一个<code>QNetworkAccessManager</code>对象构造的，这个对象包含着发送请求的一些通用配置和设置。它包含着代理和缓存的配置，以及和这些事物相关的一些信号，并且应答信号可以作为我们检测一个网络操作的进度。一个<code>QNetworkAccessManager</code>对于一整个<code>Qt</code>应用程序来说已经足够了！<br>&emsp;&emsp;一旦一个<code>QNetworkAccessManager</code>对象被创建了，那么应用程序就可以使用它在网络上发送请求。它提供了一组标准的函数，可以承载网络请求和一些可选的数据，并且每一个请求返回一个<code>QNetworkReply</code>对象。该返回的对象包含着返回的请求应带的所有数据。<br>&emsp;&emsp;一个简单的从网络下载的例子可如下完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QNetworkAccessManager *manager = <span class="keyword">new</span> QNetworkAccessManager ( <span class="keyword">this</span> );</span><br><span class="line">connect ( manager, SIGNAL ( finished ( QNetworkReply * ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SLOT ( replyFinished ( QNetworkReply * ) ) );</span><br><span class="line">manager-&gt;get ( QNetworkRequest ( QUrl ( <span class="string">"http://qt.nokia.com"</span> ) ) );</span><br></pre></td></tr></table></figure>
<p><code>QNetworkAccessManager</code>有一个异步的<code>API</code>。当上面的<code>replyFinished</code>槽被调用的时候，它带的参数就是包含有下载的数据的<code>QNetworkReply</code>对象。注意，当请求完成的时候，程序员需要在适当的时候删除<code>QNetworkReply</code>对象。不要在连接到信号<code>finished</code>的槽函数中直接删除掉，你可以使用<code>deleteLater</code>函数。<br>&emsp;&emsp;注意，<code>QNetworkAccessManager</code>将会把它收到的请求排队，并行执行的请求数量是依赖于协议的。目前对于桌面平台的<code>HTTP</code>协议，对于一个<code>主机/端口</code>的组合，可并行执行<code>6</code>个请求。<br>&emsp;&emsp;一个更加复杂的例子如下所示，假设<code>manager</code>已经存在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QNetworkRequest request;</span><br><span class="line">request.setUrl ( QUrl ( <span class="string">"http://qt.nokia.com"</span> ) );</span><br><span class="line">request.setRawHeader ( <span class="string">"User-Agent"</span>, <span class="string">"MyOwnBrowser 1.0"</span> );</span><br><span class="line">QNetworkReply *reply = manager-&gt;get ( request );</span><br><span class="line">connect ( reply, SIGNAL ( readyRead() ), <span class="keyword">this</span>, SLOT ( slotReadyRead() ) );</span><br><span class="line">connect ( reply, SIGNAL ( error ( QNetworkReply::NetworkError ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SLOT ( slotError ( QNetworkReply::NetworkError ) ) );</span><br><span class="line">connect ( reply, SIGNAL ( sslErrors ( QList&lt;QSslError&gt; ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SLOT ( slotSslErrors ( QList&lt;QSslError&gt; ) ) );</span><br></pre></td></tr></table></figure>
<h4 id="网络和漫游支持"><a href="#网络和漫游支持" class="headerlink" title="网络和漫游支持"></a>网络和漫游支持</h4><p>&emsp;&emsp;在<code>Qt 4.7</code>版本中，<code>QNetworkAccessManager</code>有了额外的<code>Bearer Management API</code>支持，使得<code>QNetworkAccessManager</code>具有了管理管理网络连接的能力。<code>QNetworkAccessManager</code>可以在设备离线的时候启用网络接口，并且如果当前进程是最后一个使用网络时，<code>QNetworkAccessManager</code>可以停止网络接口。每一个入队/挂起的网络请求可以自动地传输到一个新的接入点。客户希望不作出任何改变就可以利用这个特性。实际上它就像把与特定平台相关的网络连接的代码从应用程序中删除。</p>
<h4 id="成员类型文档"><a href="#成员类型文档" class="headerlink" title="成员类型文档"></a>成员类型文档</h4><ul>
<li><code>enum QNetworkAccessManager::NetworkAccessibility</code>：表明是否可以通过网络管理接入网络。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QNetworkAccessManager::UnknownAccessibility</code></td>
<td><code>-1</code></td>
<td>The network accessibility cannot be determined.</td>
</tr>
<tr>
<td><code>QNetworkAccessManager::NotAccessible</code></td>
<td><code>0</code></td>
<td>The network is not currently accessible, either because there is currently no network coverage or network access has been explicitly disabled by a call to <code>setNetworkAccessible()</code>.</td>
</tr>
<tr>
<td><code>QNetworkAccessManager::Accessible</code></td>
<td><code>1</code></td>
<td>The network is accessible.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>enum QNetworkAccessManager::Operation</code>表明这个对于一个应答的处理过程。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QNetworkAccessManager::HeadOperation</code></td>
<td><code>1</code></td>
<td>retrieve headers operation (created with <code>head()</code>)</td>
</tr>
<tr>
<td><code>QNetworkAccessManager::GetOperation</code></td>
<td><code>2</code></td>
<td>retrieve headers and download contents (created with <code>get()</code>)</td>
</tr>
<tr>
<td><code>QNetworkAccessManager::PutOperation</code></td>
<td><code>3</code></td>
<td>upload contents operation (created with <code>put()</code>)</td>
</tr>
<tr>
<td><code>QNetworkAccessManager::PostOperation</code></td>
<td><code>4</code></td>
<td>send the contents of an <code>HTML</code> form for processing via <code>HTTP</code> <code>POST</code> (created with <code>post()</code>)</td>
</tr>
<tr>
<td><code>QNetworkAccessManager::DeleteOperation</code></td>
<td><code>5</code></td>
<td>delete contents operation (created with <code>deleteResource()</code>)</td>
</tr>
<tr>
<td><code>QNetworkAccessManager::CustomOperation</code></td>
<td><code>6</code></td>
<td>custom operation (created with <code>sendCustomRequest()</code>)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="属性文档"><a href="#属性文档" class="headerlink" title="属性文档"></a>属性文档</h4><p>&emsp;&emsp;<code>NetworkAccessibility</code>这个属性表明当前是否可以通过网络管理接入网络。如果网络不可接入，那么<code>network access manager</code>将不会处理任何新的网络请求，所有这些请求都会发生错误而失败。那些以<code>file://scheme</code>作为<code>URLs</code>的请求仍然会被处理。这个属性的默认值反应了设备的物理状态。应用程序可以通过如下操作来覆盖它的值以禁止任何网络请求：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networkAccessManager-&gt;setNetworkAccessible ( QNetworkAccessManager::NotAccessible );</span><br></pre></td></tr></table></figure>
<p>可以通过如下调用来再次使能网络：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networkAccessManager-&gt;setNetworkAccessible ( QNetworkAccessManager::Accessible );</span><br></pre></td></tr></table></figure>
<p>调用<code>setNetworkAccessible</code>并不会改变网络状态。<br>&emsp;&emsp;Access functions:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NetworkAccessibility <span class="title">networkAccessible</span> <span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNetworkAccessible</span> <span class="params">( NetworkAccessibility accessible )</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Notifier signal:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">networkAccessibleChanged</span> <span class="params">( QNetworkAccessManager::NetworkAccessibility accessible )</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="QNetworkRequest"><a href="#QNetworkRequest" class="headerlink" title="QNetworkRequest"></a>QNetworkRequest</h3><p>&emsp;&emsp;这个类是从<code>Qt 4.4</code>开始引入进来的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QNetworkRequest ( const QUrl &amp;url = QUrl() )</code></td>
</tr>
<tr>
<td></td>
<td><code>QNetworkRequest ( const QNetworkRequest &amp;other )</code></td>
</tr>
<tr>
<td></td>
<td><code>~QNetworkRequest ()</code></td>
</tr>
<tr>
<td><code>QVariant</code></td>
<td><code>attribute ( Attribute code, const QVariant &amp;defaultValue = QVariant() ) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasRawHeader ( const QByteArray &amp;headerName ) const</code></td>
</tr>
<tr>
<td><code>QVariant</code></td>
<td><code>header ( KnownHeaders header ) const</code></td>
</tr>
<tr>
<td><code>QObject *</code></td>
<td><code>originatingObject () const</code></td>
</tr>
<tr>
<td><code>Priority</code></td>
<td><code>priority () const</code></td>
</tr>
<tr>
<td><code>QByteArray</code></td>
<td><code>rawHeader ( const QByteArray &amp;headerName ) const</code></td>
</tr>
<tr>
<td><code>QList&lt;QByteArray&gt;</code></td>
<td><code>rawHeaderList () const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setAttribute ( Attribute code, const QVariant &amp;value )</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHeader ( KnownHeaders header, const QVariant &amp;value )</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setOriginatingObject ( QObject *object )</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPriority ( Priority priority )</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setRawHeader ( const QByteArray &amp;headerName, const QByteArray &amp;headerValue )</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSslConfiguration ( const QSslConfiguration &amp;config )</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUrl ( const QUrl &amp;url )</code></td>
</tr>
<tr>
<td><code>QSslConfiguration</code></td>
<td><code>sslConfiguration () const</code></td>
</tr>
<tr>
<td><code>QUrl</code></td>
<td><code>url () const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!= ( const QNetworkRequest &amp;other ) const</code></td>
</tr>
<tr>
<td><code>QNetworkRequest &amp;</code></td>
<td><code>operator= ( const QNetworkRequest &amp;other )</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator== ( const QNetworkRequest &amp;other ) const</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="详细描述-1"><a href="#详细描述-1" class="headerlink" title="详细描述"></a>详细描述</h4><p>&emsp;&emsp;<code>QNetworkRequest</code>类包含一个和<code>QNetworkAccessManager</code>一起发送的请求。<code>QNetworkRequest</code>是<code>Network Access API</code>的一部分，并且这个类包含着在网络上发送请求的必要信息。它包含了一个<code>URL</code>和一些可以用来修改请求的附加信息。</p>
<h4 id="成员类型文档-1"><a href="#成员类型文档-1" class="headerlink" title="成员类型文档"></a>成员类型文档</h4><ul>
<li>enum <code>QNetworkRequest::Attribute</code>：<code>QNetworkRequest</code>和<code>QNetworkReply</code>的属性编码。属性是额外的<code>meta</code>数据，可以用来控制请求的行为，并且可以通过应答传递更多的信息到应用程序中。属性都是可扩展的，允许自定义实现来传递自定义的值。下面的表格说明默认属性值，都是和<code>QVariant</code>类型相关，指明属性的默认值是否丢失，是否在请求和应答中使用。</li>
<li>enum <code>QNetworkRequest::CacheLoadControl</code>：控制了<code>QNetworkAccessManager</code>的缓冲机制。</li>
<li>enum <code>QNetworkRequest::KnownHeaders</code>：列出了<code>QNetworkRequest</code>解析的已知的首部。每一个已知的首部都用完整的<code>HTTP</code>名字以原始类型的形式呈现。</li>
<li>enum <code>QNetworkRequest::LoadControl</code>：表明请求的缓存机制的一个方面是否被人为的覆盖了，例如被<code>QtWebKit</code>。</li>
<li>enum <code>QNetworkRequest::Priority</code>：这个表枚举了可能的网络请求的优先级。</li>
</ul>
<hr>
<h3 id="QNetworkReply"><a href="#QNetworkReply" class="headerlink" title="QNetworkReply"></a>QNetworkReply</h3><p>&emsp;&emsp;这个类是从<code>Qt 4.4</code>引入的，其中的所有函数都是可重入的。</p>
<h4 id="详细描述-2"><a href="#详细描述-2" class="headerlink" title="详细描述"></a>详细描述</h4><p>&emsp;&emsp;<code>QNetworkReply</code>类包含了发送给<code>QNetworkManager</code>的数据和首部。<code>QNetworkReply</code>类包含了发送给<code>QNetworkAccessManager</code>请求的所有应答数据。和<code>QNetworkRequest</code>类似，这些数据包含了一个<code>URL</code>和一些首部信息(同时包含解析后的和原始形式的)，以及一些和应答状态相关的信息，再加上应答信息自身的内容。<br>&emsp;&emsp;<code>QNetworkReply</code>是一个顺序访问的<code>QIODevice</code>，这也意味着一旦数据从该对象中读取出来，那么该对象就不再持有这些数据。因此当需要保存数据时，这个工作应该由应用程序完成。无论什么时候从网络中获得数据，<code>readyRead</code>信号都会被触发。<code>downloadProgress</code>信号在接收到数据时也会被发送，但是它所持有的数据量不一定就是真实接收到的数据量。<code>QNetworkReply</code>是一个与应答信息关联的<code>QIODevice</code>，它同样触发<code>uploadProgress</code>信号，这表明<code>upload</code>操作拥有这些数据。注意，不要在连接到<code>error</code>或者<code>finished</code>的槽函数里删除该对象，应该使用<code>deleteLater</code>。</p>
<h4 id="成员类型"><a href="#成员类型" class="headerlink" title="成员类型"></a>成员类型</h4><ul>
<li><code>enum QNetworkReply::NetworkError</code>：表明在处理请求的过程中所有可能的错误情况。</li>
<li><code>typedef QNetworkReply::RawHeaderPair</code>：<code>RawHeaderPair</code>是一个<code>QPair&lt;QByteArray, QByteArray&gt;</code>，第一个<code>QByteArray</code>代表头部的名字，第二个代表头部信息。</li>
<li><code>void QNetworkReply::finished () [signal]</code>：当应答信息被处理完毕时，这个信号就会被触发。当这个信号被触发后，就不会再对应答数据或者元数据进行更新。除非<code>close</code>被调用，否则应答信息会一直被打开等待读取，可以通过<code>read</code>或者<code>readAll</code>方法读取数据。特别地，在<code>readyRead</code>后如果没有调用<code>read</code>，那么调用<code>readAll</code>就会将所有的内容都存储在一个<code>QByteArray</code>中。这个信号和<code>QNetworkAccessManager::finished</code>是串联触发的。注意，不要在与这个信号关联的槽函数中直接删除掉<code>QNetworkReply</code>对象，应该使用<code>deleteLater</code>。你可以在收到<code>finished</code>信号之前使用<code>isFinished</code>函数检查一个<code>QNetworkReply</code>是否已经结束。</li>
</ul>
<p>&emsp;&emsp;另外一些重要的函数就是对应答信息的读取函数了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">qint64 <span class="title">read</span> <span class="params">( <span class="keyword">char</span> *, qint64 )</span></span></span><br><span class="line"><span class="function">QByteArray <span class="title">read</span> <span class="params">( qint64 )</span></span></span><br><span class="line"><span class="function">QByteArray <span class="title">readAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">qint64 <span class="title">readBufferSize</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readChannelFinished</span><span class="params">()</span></span></span><br><span class="line"><span class="function">qint64 <span class="title">readData</span> <span class="params">( <span class="keyword">char</span> *, qint64 )</span></span></span><br><span class="line"><span class="function">qint64 <span class="title">readLine</span> <span class="params">( <span class="keyword">char</span> *, qint64 )</span></span></span><br><span class="line"><span class="function">QByteArray <span class="title">readLine</span> <span class="params">( qint64 )</span></span></span><br><span class="line"><span class="function">qint64 <span class="title">readLineData</span> <span class="params">( <span class="keyword">char</span> *, qint64 )</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readyRead</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QNetworkReply::downloadProgress ( qint64 bytesReceived, qint64 bytesTotal ) [signal]</code>：这个信号被触发，用来表明该网络请求的下载部分的进度。如果该网络请求没有相关联的下载部分，这个信号在参数<code>bytesReceived</code>和<code>bytesTotal</code>的值都为<code>0</code>时，会被触发一次。参数<code>bytesReceived</code>表明已经接收到的数据量，而<code>bytesTotal</code>则表明总共期望下载的数据量。如果期望下载的数据量未知，那么<code>bytesTotal</code>就为<code>-1</code>。当<code>bytesReceived</code>和<code>bytesTotal</code>相等时，就表明下载完毕，此时<code>bytesTotal</code>就不等于<code>-1</code>了。注意，<code>bytesReceived</code>和<code>bytesTotal</code>的值也许都和<code>size</code>不同，它是通过<code>read</code>或者<code>readAll</code>获得的总的数据量，或者表明数据量的头部的值<code>ContentLengthHeader</code>。造成这种情况的原因是：协议头部或者是数据在下载的过程总可能被压缩。</li>
<li><code>void QNetworkReply::uploadProgress ( qint64 bytesSent, qint64 bytesTotal ) [signal]</code>：该信号表示的是网络请求中上传的部分，其它都和上面的<code>downloadProgress</code>类似。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/47/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><span class="page-number current">48</span><a class="page-number" href="/page/49/">49</a><span class="space">&hellip;</span><a class="page-number" href="/page/96/">96</a><a class="extend next" rel="next" href="/page/49/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">955</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
