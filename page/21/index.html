<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="泥腿子出身">
<meta property="og:url" content="http://fukangwei.gitee.io/page/21/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="泥腿子出身">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/21/">





  <title>泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/19/Qt语法详解/Qt之QInputDialog/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/Qt语法详解/Qt之QInputDialog/" itemprop="url">Qt之QInputDialog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T14:24:05+08:00">
                2019-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>QInputDialog</code>类提供了从用户那里得到一个单一值的简单方便的对话框，输入值可以是字符串、数字或者列表中的一项，必须设置标签来告诉用户应该输入什么。其头文件为<code>qinputdialog.h</code>，它继承了<code>QDialog</code>。</p>
<h3 id="getDouble"><a href="#getDouble" class="headerlink" title="getDouble"></a>getDouble</h3><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> QInputDialog::getDouble (</span><br><span class="line">    <span class="keyword">const</span> QString &amp;caption, <span class="keyword">const</span> QString &amp;label, <span class="keyword">double</span> num = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">double</span> from = <span class="number">-2147483647</span>, <span class="keyword">double</span> to = <span class="number">2147483647</span>, <span class="keyword">int</span> decimals = <span class="number">1</span>,</span><br><span class="line">    <span class="keyword">bool</span> *ok = <span class="number">0</span>, QWidget *parent = <span class="number">0</span>, <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p>这是从用户那里得到浮点数的函数。</p>
<ul>
<li><code>caption</code>：这个对话框在标题栏显示的文本。</li>
<li><code>label</code>：显示给用户的文本(它应该告诉用户应该输入什么)。</li>
<li><code>num</code>：这个行编辑中所要设置的默认的浮点数值。</li>
<li><code>from</code>和<code>to</code>：最小值和最大值，用户应该在这个范围内进行选择。</li>
<li><code>decimals</code>：小数点后面小数的最大位数；</li>
<li><code>parent</code>和<code>name</code>：对话框的父对象为<code>parent</code>，名称为<code>name</code>。</li>
<li><code>ok</code>：如果<code>ok</code>参数为非零，则用户点击<code>OK</code>，<code>*ok</code>被设置为<code>True</code>，并且如果用户点击<code>Cancel</code>，就被设置为<code>False</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok = FALSE;</span><br><span class="line"><span class="keyword">double</span> res = QInputDialog::getDouble (</span><br><span class="line">                tr ( <span class="string">"Application name"</span> ),</span><br><span class="line">                tr ( <span class="string">"Please enter a decimal number"</span> ),</span><br><span class="line">                <span class="number">33.7</span>, <span class="number">0</span>, <span class="number">1000</span>, <span class="number">2</span>, &amp;ok, <span class="keyword">this</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ok ) &#123;</span><br><span class="line">    <span class="comment">/* 用户输入一些东西并且按下OK */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 用户按下Cancel */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getInteger"><a href="#getInteger" class="headerlink" title="getInteger"></a>getInteger</h3><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QInputDialog::getInteger (</span><br><span class="line">    <span class="keyword">const</span> QString &amp;caption, <span class="keyword">const</span> QString &amp;label, <span class="keyword">int</span> num = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">int</span> from = <span class="number">-2147483647</span>, <span class="keyword">int</span> to = <span class="number">2147483647</span>, <span class="keyword">int</span> step = <span class="number">1</span>,</span><br><span class="line">    <span class="keyword">bool</span> *ok = <span class="number">0</span>, QWidget *parent = <span class="number">0</span>, <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p>从用户那里得到整数的函数。</p>
<ul>
<li><code>caption</code>：这个对话框在标题栏显示的文本；</li>
<li><code>label</code>：显示给用户的文本(它应该告诉用户应该输入什么)。</li>
<li><code>num</code>：微调框中所要设置的默认整数。</li>
<li><code>from</code>和<code>to</code>：最小值和最大值，用户应该在这个范围内进行选择。</li>
<li><code>step</code>：用户通过点击上下箭头增加或者减少的数值。</li>
<li><code>parent</code>和<code>name</code>：对话框的父对象为<code>parent</code>，名称为<code>name</code>。</li>
<li><code>ok</code>：如果<code>ok</code>参数为非零，则用户点击<code>OK</code>，<code>*ok</code>被设置为<code>True</code>，并且如果用户点击<code>Cancel</code>，就被设置为<code>False</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok = FALSE;</span><br><span class="line"><span class="keyword">int</span> res = QInputDialog::getInteger (</span><br><span class="line">            tr ( <span class="string">"Application name"</span> ),</span><br><span class="line">            tr ( <span class="string">"Please enter a number"</span> ),</span><br><span class="line">            <span class="number">22</span>, <span class="number">0</span>, <span class="number">1000</span>, <span class="number">2</span>, &amp;ok, <span class="keyword">this</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ok ) &#123;</span><br><span class="line">    <span class="comment">/* 用户输入一些东西并且按下OK  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 用户按下Cancel */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getItem"><a href="#getItem" class="headerlink" title="getItem"></a>getItem</h3><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString QInputDialog::getItem (</span><br><span class="line">    <span class="keyword">const</span> QString &amp;caption, <span class="keyword">const</span> QString &amp;label, <span class="keyword">const</span> QStringList &amp;<span class="built_in">list</span>, <span class="keyword">int</span> current = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">bool</span> editable = TRUE, <span class="keyword">bool</span> *ok = <span class="number">0</span>, QWidget *parent = <span class="number">0</span>, <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p>让用户从一个字符串列表中选择一项的函数。</p>
<ul>
<li><code>caption</code>：这个对话框在标题栏显示的文本。</li>
<li><code>label</code>：显示给用户的文本(它应该告诉用户应该输入什么)。</li>
<li><code>list</code>：插入到组合框中的字符串列表。</li>
<li><code>current</code>：哪一项为当前项。</li>
<li><code>editable</code>：如果<code>editable</code>为<code>True</code>，则用户可以输入自己的文本；如果<code>editable</code>为<code>False</code>，则用户只能选择已有的项中的一项。</li>
<li><code>parent</code>和<code>name</code>：对话框的父对象为<code>parent</code>，名称为<code>name</code>。</li>
<li><code>ok</code>：如果<code>ok</code>参数为非零，则用户点击<code>OK</code>，<code>*ok</code>被设置为<code>True</code>，并且如果用户点击<code>Cancel</code>，就被设置为<code>False</code>。</li>
</ul>
<p>这个函数返回当前项的文本，或者如果<code>editable</code>为真，就是组合框的当前文本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">QStringList lst;</span><br><span class="line">lst &lt;&lt; <span class="string">"First"</span> &lt;&lt; <span class="string">"Second"</span> &lt;&lt; <span class="string">"Third"</span> &lt;&lt; <span class="string">"Fourth"</span> &lt;&lt; <span class="string">"Fifth"</span>;</span><br><span class="line"><span class="keyword">bool</span> ok = FALSE;</span><br><span class="line">QString res = QInputDialog::getItem (</span><br><span class="line">                tr ( <span class="string">"Application name"</span> ),</span><br><span class="line">                tr ( <span class="string">"Please select an item"</span> ),</span><br><span class="line">                lst, <span class="number">1</span>, TRUE, &amp;ok, <span class="keyword">this</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ok ) &#123;</span><br><span class="line">    <span class="comment">/* 用户选择一项并且按下OK */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 用户按下Cancel */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getText"><a href="#getText" class="headerlink" title="getText"></a>getText</h3><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString QInputDialog::getText (</span><br><span class="line">    <span class="keyword">const</span> QString &amp;caption, <span class="keyword">const</span> QString &amp;label, QLineEdit::EchoMode mode = QLineEdit::Normal,</span><br><span class="line">    <span class="keyword">const</span> QString &amp;text = QString::null, <span class="keyword">bool</span> *ok = <span class="number">0</span>, QWidget *parent = <span class="number">0</span>, <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p>从用户那里得到一个字符串的函数。</p>
<ul>
<li><code>caption</code>：这个对话框在标题栏显示的文本。</li>
<li><code>label</code>：显示给用户的文本(它应该告诉用户应该输入什么)。</li>
<li><code>text</code>：放置在行编辑中的默认文本。</li>
<li><code>mode</code>：行编辑的回显模式。</li>
<li><code>parent</code>和<code>name</code>：对话框的父对象为<code>parent</code>，名称为<code>name</code>。</li>
<li><code>ok</code>：如果<code>ok</code>参数为非零，则用户点击<code>OK</code>，<code>*ok</code>被设置为<code>True</code>，并且如果用户点击<code>Cancel</code>，就被设置为<code>False</code>。</li>
</ul>
<p>这个函数返回用户在行编辑中输入的文本，如果没有输入，就返回空字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok = FALSE;</span><br><span class="line">QString text = QInputDialog::getText (</span><br><span class="line">                   tr ( <span class="string">"Application name"</span> ),</span><br><span class="line">                   tr ( <span class="string">"Please enter your name"</span> ),</span><br><span class="line">                   QLineEdit::Normal, QString::null, &amp;ok, <span class="keyword">this</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ok &amp;&amp; !text.isEmpty() ) &#123;</span><br><span class="line">    <span class="comment">/* 用户输入一些东西并且按下OK */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 用户不输入任何东西或者按下Cancel */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Qt语法详解/Qt之QInputDialog/1.png" height="188" width="547"></p>
<p>&emsp;&emsp;实际用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok;</span><br><span class="line"><span class="comment">/* 获取字符串(参数：指定父窗口、标题栏、设置对话框中的标签的显示文本、设置输入的</span></span><br><span class="line"><span class="comment">   字符串的显示模式、设置输入框中的默认字符串、设置获取按下按钮信息的bool变量) */</span></span><br><span class="line">QString <span class="built_in">string</span> = QInputDialog::getText (</span><br><span class="line">    <span class="keyword">this</span>, tr ( <span class="string">"输入字符串对话框"</span> ), tr ( <span class="string">"请输入用户名："</span> ),</span><br><span class="line">    QLineEdit::Normal, tr ( <span class="string">"admin"</span> ), &amp;ok );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ok ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"string:"</span> &lt;&lt; <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 获取整数 */</span></span><br><span class="line"><span class="keyword">int</span> value1 = QInputDialog::getInt (</span><br><span class="line">    <span class="keyword">this</span>, tr ( <span class="string">"输入整数对话框"</span> ), tr ( <span class="string">"请输入-1000到1000之间的数值"</span> ),</span><br><span class="line">    <span class="number">100</span>, <span class="number">-1000</span>, <span class="number">1000</span>, <span class="number">10</span>, &amp;ok ); <span class="comment">/* 默认值100，最小值“-1000”，最大值1000，数值每次变化10 */</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ok ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"value1:"</span> &lt;&lt; value1;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 获取浮点数 */</span></span><br><span class="line"><span class="keyword">double</span> value2 = QInputDialog::getDouble (</span><br><span class="line">    <span class="keyword">this</span>, tr ( <span class="string">"输入浮点数对话框"</span> ), tr ( <span class="string">"请输入-1000到1000之间的数值"</span> ),</span><br><span class="line">    <span class="number">0.00</span>, <span class="number">-1000</span>, <span class="number">1000</span>, <span class="number">2</span>, &amp;ok ); <span class="comment">/* 2表示小数的位数为2 */</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ok ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"value2:"</span> &lt;&lt; value2;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 获取条目 */</span></span><br><span class="line">QStringList items;</span><br><span class="line">items &lt;&lt; tr ( <span class="string">"条目1"</span> ) &lt;&lt; tr ( <span class="string">"条目2"</span> );</span><br><span class="line">QString item = QInputDialog::getItem (</span><br><span class="line">    <span class="keyword">this</span>, tr ( <span class="string">"输入条目对话框"</span> ), tr ( <span class="string">"请选择一个条目"</span> ),</span><br><span class="line">    items, <span class="number">0</span>, <span class="literal">true</span>, &amp;ok ); <span class="comment">/* 0表示默认显示列表中的第0个条目，true表示条目可以被更改 */</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ok ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"item:"</span> &lt;&lt; item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/19/Python语法/skimage模块/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/Python语法/skimage模块/" itemprop="url">skimage模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T11:51:39+08:00">
                2019-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Python语法/" itemprop="url" rel="index">
                    <span itemprop="name">Python语法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>scikit-image</code>是基于<code>scipy</code>的一款图像处理包，它将图片作为<code>numpy</code>数组进行处理。可以使用<code>pip</code>进行安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scikit-image</span><br></pre></td></tr></table></figure>
<h3 id="skimage库子模块"><a href="#skimage库子模块" class="headerlink" title="skimage库子模块"></a>skimage库子模块</h3><p>&emsp;&emsp;<code>skimage</code>包含了很多子模块，各个子模块具有不同的功能：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>子模块名称</th>
<th>实现功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>io</code></td>
<td>读取、保存以及显示图片和视频</td>
</tr>
<tr>
<td><code>color</code></td>
<td>颜色空间变换</td>
</tr>
<tr>
<td><code>data</code></td>
<td>提供一些测试图片和样本数据</td>
</tr>
<tr>
<td><code>filters</code></td>
<td>图像增强的模块，例如边缘检测、自动阈值</td>
</tr>
<tr>
<td><code>draw</code></td>
<td>操作于<code>numpy</code>数组上的基本图形绘制，包括线条、矩阵、圆和文本等</td>
</tr>
<tr>
<td><code>transform</code></td>
<td>几何变换和其他变换，例如旋转、拉伸和<code>Radon</code>变换</td>
</tr>
<tr>
<td><code>exposure</code></td>
<td>图像强度调整，例如直方图均衡化</td>
</tr>
<tr>
<td><code>feature</code></td>
<td>特征检测和提取，例如纹理分析</td>
</tr>
<tr>
<td><code>graph</code></td>
<td>图论操作，例如最短路径</td>
</tr>
<tr>
<td><code>measure</code></td>
<td>图像属性测量，例如相似度和轮廓</td>
</tr>
<tr>
<td><code>morphology</code></td>
<td>形态学操作，例如开闭运算、骨架提取</td>
</tr>
<tr>
<td><code>novice</code></td>
<td>简化的用于教学目的的接口</td>
</tr>
<tr>
<td><code>restoration</code></td>
<td>修复算法，例如去卷积算法、去噪</td>
</tr>
<tr>
<td><code>segmentation</code></td>
<td>图像分割为多个区域</td>
</tr>
<tr>
<td><code>util</code></td>
<td>通用工具</td>
</tr>
<tr>
<td><code>viewer</code></td>
<td>简单图形用户界面，用于可视化结果</td>
</tr>
</tbody>
</table>
</div>
<h3 id="skimage操作"><a href="#skimage操作" class="headerlink" title="skimage操作"></a>skimage操作</h3><h4 id="图像读取与显示"><a href="#图像读取与显示" class="headerlink" title="图像读取与显示"></a>图像读取与显示</h4><p>&emsp;&emsp;<code>skimage</code>的<code>io</code>模块提供了图像读取、保存与显示等功能，<code>data</code>模块包含了一些示例图片。从外部读取图片并显示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">skimage.io.imread(fname)  <span class="comment"># 读取fname指定的图片</span></span><br><span class="line">skimage.io.imshow(arr)  <span class="comment"># 显示arr数组表示的图片</span></span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">img = io.imread(<span class="string">'cat.png'</span>)</span><br><span class="line">io.imshow(img)</span><br><span class="line">io.show()  <span class="comment"># 不要忘记这一句</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/1.png" height="182" width="267"></p>
<p>以灰度图的形式读取时，使用函数<code>skimage.io.imread(fname, as_grey=True)</code>，参数<code>fname</code>表示要显示的图片路径：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">img = io.imread(<span class="string">'./cat.png'</span>, as_grey=<span class="keyword">True</span>)</span><br><span class="line">io.imshow(img)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/2.png" height="180" width="268"></p>
<h4 id="skimage自带图片"><a href="#skimage自带图片" class="headerlink" title="skimage自带图片"></a>skimage自带图片</h4><p>&emsp;&emsp;自带图片如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>图片名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>astronaut</code></td>
<td>宇航员</td>
</tr>
<tr>
<td><code>binary_blobs</code></td>
<td>二元斑点</td>
</tr>
<tr>
<td><code>camera</code></td>
<td>相机</td>
</tr>
<tr>
<td><code>checkerboard</code></td>
<td>棋盘</td>
</tr>
<tr>
<td><code>chelsea</code></td>
<td>猫</td>
</tr>
<tr>
<td><code>clock</code></td>
<td>时钟</td>
</tr>
<tr>
<td><code>coffee</code></td>
<td>一杯咖啡</td>
</tr>
<tr>
<td><code>coins</code></td>
<td>硬币</td>
</tr>
<tr>
<td><code>horse</code></td>
<td>马</td>
</tr>
<tr>
<td><code>hubble_deep_field</code></td>
<td>星空</td>
</tr>
<tr>
<td><code>immunohistochemistry</code></td>
<td>结肠图片</td>
</tr>
<tr>
<td><code>logo</code></td>
<td>商标</td>
</tr>
<tr>
<td><code>moon</code></td>
<td>月球表面</td>
</tr>
<tr>
<td><code>page</code></td>
<td>书页内容</td>
</tr>
<tr>
<td><code>rocket</code></td>
<td>火箭</td>
</tr>
<tr>
<td><code>text</code></td>
<td>文字图片</td>
</tr>
</tbody>
</table>
</div>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line">img = data.hubble_deep_field()</span><br><span class="line">io.imshow(img)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/3.jpg" height="226" width="272"></p>
<p>图片名就是对应的函数名，如<code>camera</code>图片对应的函数名为<code>data.camera()</code>。这些图片存储在<code>skimage</code>的安装目录下，可以通过<code>data_dir</code>把路径打印出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data_dir</span><br><span class="line">print(data_dir)</span><br></pre></td></tr></table></figure>
<h4 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h4><p>&emsp;&emsp;使用<code>io.imsave(fname, arr)</code>函数对图片进行保存，参数<code>fname</code>表示保存的路径和名称，参数<code>arr</code>表示需要保存的数组变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line"></span><br><span class="line">img = data.checkerboard()</span><br><span class="line">io.imshow(img)</span><br><span class="line">io.imsave(<span class="string">'checkerboard_copy.jpg'</span>, img)</span><br></pre></td></tr></table></figure>
<p>这样就在当前的工作目录下增加了一个<code>checkerboard_copy.jpg</code>文件。保存图片同时也起到了转换格式的作用，若读取的是<code>png</code>格式图片，当保存为<code>jpg</code>时，则图片从<code>png</code>格式转换为<code>jpg</code>格式。</p>
<h4 id="获取图片信息"><a href="#获取图片信息" class="headerlink" title="获取图片信息"></a>获取图片信息</h4><p>&emsp;&emsp;代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line"></span><br><span class="line">img = data.chelsea()</span><br><span class="line">io.imshow(img)</span><br><span class="line">io.show()</span><br><span class="line">print(type(img))  <span class="comment"># 类型</span></span><br><span class="line">print(img.shape)  <span class="comment"># 形状</span></span><br><span class="line">print(img.shape[<span class="number">0</span>])  <span class="comment"># 图片宽度</span></span><br><span class="line">print(img.shape[<span class="number">1</span>])  <span class="comment"># 图片高度</span></span><br><span class="line">print(img.shape[<span class="number">2</span>])  <span class="comment"># 图片通道数</span></span><br><span class="line">print(img.size)  <span class="comment"># 显示总像素个数</span></span><br><span class="line">print(img.max())  <span class="comment"># 最大像素值</span></span><br><span class="line">print(img.min())  <span class="comment"># 最小像素值</span></span><br><span class="line">print(img.mean())  <span class="comment"># 像素平均值</span></span><br></pre></td></tr></table></figure>
<h4 id="图像像素访问与裁剪"><a href="#图像像素访问与裁剪" class="headerlink" title="图像像素访问与裁剪"></a>图像像素访问与裁剪</h4><p>&emsp;&emsp;图片读入程序后，以<code>numpy</code>数组方式存储，因此对<code>numpy</code>数组的操作，都可以用于图片数组。对数组元素的访问，实际上就是对图片像素点的访问。对彩色图片的像素点访问方式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img[i, j, c]</span><br></pre></td></tr></table></figure>
<p><code>i</code>表示图片的行数，<code>j</code>表示图片的列数，<code>c</code>表示图片的通道数(<code>RGB</code>三通道分别对应<code>0</code>、<code>1</code>和<code>2</code>)，坐标从左上角开始。<br>&emsp;&emsp;对灰度图片的像素点访问方式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gray[i, j]</span><br></pre></td></tr></table></figure>
<p>例如输出<code>data</code>中宇航员图片第<code>20</code>行第<code>10</code>列的<code>B</code>通道数值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data</span><br><span class="line"></span><br><span class="line">img = data.astronaut()</span><br><span class="line">pixel = img[<span class="number">20</span>, <span class="number">10</span>, <span class="number">2</span>]</span><br><span class="line">print(pixel)  <span class="comment"># 输出“69”</span></span><br></pre></td></tr></table></figure>
<p>显示图片的红色单通道如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line"></span><br><span class="line">img = data.astronaut()</span><br><span class="line">R = img[:, :, <span class="number">0</span>]</span><br><span class="line">io.imshow(R)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/4.jpg" height="226" width="233"></p>
<h4 id="像素修改"><a href="#像素修改" class="headerlink" title="像素修改"></a>像素修改</h4><p>&emsp;&emsp;例如对宇航员图片随机添加椒盐噪声：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = data.astronaut()</span><br><span class="line">rows, cols, dims = img.shape</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5000</span>):  <span class="comment"># 随机生成5000个椒盐点</span></span><br><span class="line">    x = np.random.randint(<span class="number">0</span>, rows)</span><br><span class="line">    y = np.random.randint(<span class="number">0</span>, cols)</span><br><span class="line">    img[x, y, :] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">io.imshow(img)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/5.jpg" height="225" width="235"></p>
<h4 id="图片裁剪"><a href="#图片裁剪" class="headerlink" title="图片裁剪"></a>图片裁剪</h4><p>&emsp;&emsp;由于图片是以<code>numpy</code>数组进行存储，因此对于数组的裁剪，就是对图片的裁剪。例如对宇航员图片进行裁剪：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line"></span><br><span class="line">img = data.astronaut()</span><br><span class="line">partial_img = img[<span class="number">50</span>:<span class="number">150</span>, <span class="number">170</span>:<span class="number">270</span>, :]</span><br><span class="line">io.imshow(partial_img)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/6.png" height="227" width="228"></p>
<p>对多个像素点进行操作时，使用数组切片方式进行访问：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img[i, :] = im[j, :]  <span class="comment"># 将第j行的数值赋值给第i行</span></span><br><span class="line">img[:, i] = <span class="number">100</span>  <span class="comment"># 将第i列的所有数值设为100</span></span><br><span class="line">img[:<span class="number">100</span>, :<span class="number">50</span>].sum()  <span class="comment"># 计算前100行、前50列所有数值的和</span></span><br><span class="line">img[<span class="number">50</span>:<span class="number">100</span>, <span class="number">50</span>:<span class="number">100</span>]  <span class="comment"># 第50至100行，第50至100列(不包括第100行和第100列)</span></span><br><span class="line">img[i].mean()  <span class="comment"># 第i行所有数值的平均值</span></span><br><span class="line">img[:, <span class="number">-1</span>]  <span class="comment"># 最后一列</span></span><br><span class="line">img[<span class="number">-2</span>, :] (<span class="keyword">or</span> im[<span class="number">-2</span>])  <span class="comment"># 倒数第二行</span></span><br></pre></td></tr></table></figure>
<p>将宇航员图片进行二值化，像素值大于<code>128</code>的变为<code>1</code>，否则变为<code>0</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data, color</span><br><span class="line"></span><br><span class="line">img = data.astronaut()</span><br><span class="line">img_gray = color.rgb2gray(img)</span><br><span class="line">rows, cols = img_gray.shape</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">        <span class="keyword">if</span> (img_gray[i, j] &lt;= <span class="number">0.5</span>):</span><br><span class="line">            img_gray[i, j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            img_gray[i, j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">io.imshow(img_gray)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/7.png" height="226" width="234"></p>
<p>使用<code>color</code>模块的<code>rgb2gray</code>函数，将彩色三通道图片转换为灰度图片，转换结果为<code>float64</code>类型的数组，范围在<code>[0, 1]</code>之间。<br>&emsp;&emsp;对<code>R</code>通道的数值进行修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line"></span><br><span class="line">img = data.astronaut()</span><br><span class="line">img_idx_modified = img[:, :, <span class="number">0</span>] &gt; <span class="number">170</span></span><br><span class="line">print(img_idx_modified)</span><br><span class="line">img[img_idx_modified] = [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>]</span><br><span class="line">io.imshow(img)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/8.jpg" height="226" width="233"></p>
<p>这个例子先对<code>R</code>通道的所有像素值进行判断，如果大于<code>170</code>，则将这个地方的像素值变为<code>[0, 255, 0]</code>，即<code>G</code>通道值为<code>255</code>，<code>R</code>和<code>B</code>通道值为<code>0</code>。</p>
<h3 id="图像数据类型以及颜色空间转换"><a href="#图像数据类型以及颜色空间转换" class="headerlink" title="图像数据类型以及颜色空间转换"></a>图像数据类型以及颜色空间转换</h3><h4 id="图像数据类型"><a href="#图像数据类型" class="headerlink" title="图像数据类型"></a>图像数据类型</h4><p>&emsp;&emsp;在<code>skimage</code>中，一张图片以<code>numpy</code>数组形式存储，数组的数据类型有很多中，相互之间可以转换。数据类型以及取值范围如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>uint8</code></td>
<td><code>0</code> to <code>255</code></td>
</tr>
<tr>
<td><code>uint16</code></td>
<td><code>0</code> to <code>65535</code></td>
</tr>
<tr>
<td><code>uint32</code></td>
<td><code>0</code> to <code>2^32 - 1</code></td>
</tr>
<tr>
<td><code>float16</code></td>
<td>半精度浮点数：<code>16</code>位，正负号<code>1</code>位，指数<code>5</code>位，精度<code>10</code>位</td>
</tr>
<tr>
<td><code>float32</code></td>
<td>单精度浮点数：<code>32</code>位，正负号<code>1</code>位，指数<code>8</code>位，精度<code>23</code>位</td>
</tr>
<tr>
<td><code>float64</code></td>
<td>双精度浮点数：<code>64</code>位，正负号<code>1</code>位，指数<code>11</code>位，精度<code>52</code>位</td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>-1</code> to <code>1</code> or <code>0</code> to <code>1</code></td>
</tr>
<tr>
<td><code>int8</code></td>
<td><code>-128</code> to <code>127</code></td>
</tr>
<tr>
<td><code>int16</code></td>
<td><code>-32768</code> to <code>32767</code></td>
</tr>
<tr>
<td><code>int32</code></td>
<td><code>-2^31</code> to <code>2^32 - 1</code></td>
</tr>
</tbody>
</table>
</div>
<p>一张图片的像素值范围是<code>[0, 255]</code>，因此默认类型是<code>unit8</code>，可用如下代码查看数据类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data</span><br><span class="line"></span><br><span class="line">img = data.astronaut()</span><br><span class="line">print(img.dtype.name)  <span class="comment"># 输出“uint8”</span></span><br></pre></td></tr></table></figure>
<p>在上面的表中，特别注意的是<code>float</code>类型，它的范围是<code>[-1, 1]</code>或<code>[0, 1]</code>之间。一张彩色图片转换为灰度图后，它的类型就由<code>unit8</code>变成了<code>float</code>。<br>&emsp;&emsp;<code>uint8</code>转为<code>float</code>如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data, img_as_float</span><br><span class="line"></span><br><span class="line">img = data.astronaut()</span><br><span class="line">print(img.dtype.name)  <span class="comment"># 输出“uint8”</span></span><br><span class="line">dst = img_as_float(img)</span><br><span class="line">print(dst.dtype.name)  <span class="comment"># 输出“float64”</span></span><br></pre></td></tr></table></figure>
<p><code>float</code>转为<code>uint8</code>如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> img_as_ubyte</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = np.array([<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>], dtype=float)</span><br><span class="line">print(img.dtype.name)  <span class="comment"># 输出“float64”</span></span><br><span class="line">dst = img_as_ubyte(img)</span><br><span class="line">print(dst.dtype.name)  <span class="comment"># 输出“uint8”</span></span><br></pre></td></tr></table></figure>
<p><code>float</code>转为<code>uint8</code>可能会造成数据损失，因此会有警告。除了如上两种转换以外，还有其他的一些类型转换：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>img_as_float</code></td>
<td>Convert to <code>64-bit</code> floating point</td>
</tr>
<tr>
<td><code>img_as_ubyte</code></td>
<td>Convert to <code>8-bit</code> uint</td>
</tr>
<tr>
<td><code>img_as_uint</code></td>
<td>Convert to <code>16-bit</code> uint</td>
</tr>
<tr>
<td><code>img_as_int</code></td>
<td>Convert to <code>16-bit</code> int</td>
</tr>
</tbody>
</table>
</div>
<h4 id="颜色空间及转换"><a href="#颜色空间及转换" class="headerlink" title="颜色空间及转换"></a>颜色空间及转换</h4><p>&emsp;&emsp;除了直接转换可以改变数据类型外，还可以通过图像的颜色空间转换来改变数据类型。常用的颜色空间有灰度空间、<code>rgb</code>空间、<code>hsv</code>空间和<code>cmyk</code>空间。颜色空间转换以后，图片类型都变成了<code>float</code>型。<br>&emsp;&emsp;所有的颜色空间转换函数都放在<code>skimage</code>的<code>color</code>模块内。例如<code>RGB</code>转为灰度图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data, color</span><br><span class="line"></span><br><span class="line">img = data.camera()</span><br><span class="line">gray = color.rgb2gray(img)</span><br><span class="line">io.imshow(gray)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/9.jpg" height="226" width="233"></p>
<p>其它转换的用法都是一样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">skimage.color.rgb2grey(rgb)</span><br><span class="line">skimage.color.rgb2hsv(rgb)</span><br><span class="line">skimage.color.rgb2lab(rgb)</span><br><span class="line">skimage.color.gray2rgb(image)</span><br><span class="line">skimage.color.hsv2rgb(hsv)</span><br><span class="line">skimage.color.lab2rgb(lab)</span><br></pre></td></tr></table></figure>
<p>实际上，上面的所有转换函数都可以用一个函数来代替：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.color.convert_colorspace(arr, fromspace, tospace)</span><br></pre></td></tr></table></figure>
<p>表示将<code>arr</code>从<code>fromspace</code>颜色空间转换到<code>tospace</code>颜色空间。<br>&emsp;&emsp;<code>RGB</code>转为<code>HSV</code>如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data, color</span><br><span class="line"></span><br><span class="line">img = data.coffee()</span><br><span class="line">hsv = color.convert_colorspace(img, <span class="string">'RGB'</span>, <span class="string">'HSV'</span>)</span><br><span class="line">io.imshow(hsv)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/10.jpg" height="269" width="410"></p>
<p>在<code>color</code>模块的颜色空间转换函数中，还有一个比较有用的函数是<code>skimage.color.label2rgb(arr)</code>，可以根据标签值对图片进行着色。以后的图片分类后着色就可以用这个函数。例如将<code>coffee</code>图片分成三类，然后用默认颜色对三类进行着色：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, data, color</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = data.coffee()</span><br><span class="line">gray = color.rgb2gray(img)</span><br><span class="line">rows, cols = gray.shape</span><br><span class="line">labels = np.zeros([rows, cols])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">        <span class="keyword">if</span> (gray[i, j] &lt; <span class="number">0.4</span>):</span><br><span class="line">            labels[i, j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> (gray[i, j] &lt; <span class="number">0.75</span>):</span><br><span class="line">            labels[i, j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            labels[i, j] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">dst = color.label2rgb(labels)</span><br><span class="line">io.imshow(dst)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/11.png" height="274" width="410"></p>
<h3 id="图像的批量处理"><a href="#图像的批量处理" class="headerlink" title="图像的批量处理"></a>图像的批量处理</h3><p>&emsp;&emsp;有时我们不仅要对一张图片进行处理，可能还会对一批图片处理。这时我们可以通过循环来执行处理，也可以调用程序自带的图片集合来处理。图片集合函数为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.io.ImageCollection(load_pattern, load_func=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<p>该函数的第一个参数<code>load_pattern</code>表示图片组的路径，可以是一个<code>str</code>字符串；第二个参数<code>load_func</code>是一个回调函数，我们对图片进行批量处理就可以通过这个回调函数实现。回调函数默认为<code>imread</code>，即默认这个函数是批量读取图片。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> skimage.io <span class="keyword">as</span> io</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data_dir</span><br><span class="line"></span><br><span class="line">str = data_dir + <span class="string">'/*.png'</span></span><br><span class="line">coll = io.ImageCollection(str)</span><br><span class="line">print(len(coll))</span><br></pre></td></tr></table></figure>
<p>显示结果为<code>28</code>，说明系统自带了<code>25</code>张<code>png</code>的示例图片。这些图片都读取了出来，放在图片集合<code>coll</code>里。如果我们想显示其中一张图片，则可以在后面加上代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io.imshow(coll[<span class="number">10</span>])</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/12.jpg" height="269" width="410"></p>
<p>&emsp;&emsp;如果一个文件夹里，我们既存放了一些<code>jpg</code>格式的图片，又存放了一些<code>png</code>格式的图片。现在想把它们全部读取出来，可以采用如下方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> skimage.io <span class="keyword">as</span> io</span><br><span class="line"></span><br><span class="line">str = <span class="string">'d:/pic/*.jpg:d:/pic/*.png'</span></span><br><span class="line">coll = io.ImageCollection(str)</span><br><span class="line">print(len(coll))</span><br></pre></td></tr></table></figure>
<p>注意字符串<code>d:/pic/*.jpg:d:/pic/*.png</code>，它是两个字符串合在一起，第一个是<code>d:/pic/*.jpg</code>，第二个是<code>d:/pic/*.png</code>，合在一起后，中间用冒号来隔开，这样就可以把<code>d:/pic/</code>文件夹下的<code>jpg</code>和<code>png</code>格式的图片都读取出来。如果还想读取存放在其它地方的图片，也可以一并加进去，只是中间同样用冒号来隔开。<br>&emsp;&emsp;<code>io.ImageCollection</code>默认的第二个参数就是批量读取。如果我们不是想批量读取，而是其它批量操作(如批量转换为灰度图)，又该怎么做呢？那就需要先定义一个函数，然后将这个函数作为第二个参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data_dir, io, color</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_gray</span><span class="params">(f)</span>:</span></span><br><span class="line">    rgb = io.imread(f)</span><br><span class="line">    <span class="keyword">return</span> color.rgb2gray(rgb)</span><br><span class="line"></span><br><span class="line">str = data_dir + <span class="string">'/*.png'</span></span><br><span class="line">coll = io.ImageCollection(str, load_func=convert_gray)</span><br><span class="line">io.imshow(coll[<span class="number">10</span>])</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/13.jpg" height="270" width="409"></p>
<p>得到图片集合以后，我们还可以将这些图片连接起来，构成一个维度更高的数组。连接图片的函数为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.io.concatenate_images(ic)</span><br></pre></td></tr></table></figure>
<p>该函数的参数就是以上的图片集合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">coll = io.ImageCollection(<span class="string">'d:/pic/*.jpg'</span>)</span><br><span class="line">mat = io.concatenate_images(coll)</span><br></pre></td></tr></table></figure>
<p>使用<code>concatenate_images(ic)</code>函数的前提是读取的这些图片尺寸必须一致，否则会出错。我们看看图片连接前后的维度变化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">coll = io.ImageCollection(<span class="string">'d:/pic/*.jpg'</span>)</span><br><span class="line">print(len(coll))  <span class="comment"># 连接的图片数量</span></span><br><span class="line">print(coll[<span class="number">0</span>].shape)  <span class="comment"># 连接前的图片尺寸，所有的都一样</span></span><br><span class="line">mat = io.concatenate_images(coll)</span><br><span class="line">print(mat.shape)  <span class="comment"># 连接后的数组尺寸</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">(<span class="number">870</span>, <span class="number">580</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">870</span>, <span class="number">580</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，将<code>2</code>个<code>3</code>维数组连接成了一个<code>4</code>维数组。如果我们对图片进行批量操作后，想把操作后的结果保存起来，也是可以办到的。<br>&emsp;&emsp;把系统自带的所有<code>png</code>示例图片全部转换成<code>256 * 256</code>的<code>jpg</code>格式灰度图，保存在<code>d:/data/</code>文件夹下。改变图片的大小可以使用<code>tranform</code>模块的<code>resize</code>函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data_dir, io, transform, color</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_gray</span><span class="params">(f)</span>:</span></span><br><span class="line">    rgb = io.imread(f)  <span class="comment"># 依次读取rgb图片</span></span><br><span class="line">    gray = color.rgb2gray(rgb)  <span class="comment"># 将rgb图片转换成灰度图</span></span><br><span class="line">    dst = transform.resize(gray, (<span class="number">256</span>, <span class="number">256</span>))  <span class="comment"># 将灰度图片大小转换为“256*256”</span></span><br><span class="line">    <span class="keyword">return</span> dst</span><br><span class="line"></span><br><span class="line">image_list = data_dir + <span class="string">'/*.png'</span></span><br><span class="line">coll = io.ImageCollection(image_list, load_func=convert_gray)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(coll)):</span><br><span class="line">    io.imsave(<span class="string">'d:/data/'</span> + str(i) + <span class="string">'.jpg'</span>, coll[i])  <span class="comment"># 循环保存图片</span></span><br></pre></td></tr></table></figure>
<h3 id="图像的形变与缩放"><a href="#图像的形变与缩放" class="headerlink" title="图像的形变与缩放"></a>图像的形变与缩放</h3><p>&emsp;&emsp;图像的形变与缩放使用的是<code>skimage</code>的<code>transform</code>模块。</p>
<h4 id="改变图片尺寸resize"><a href="#改变图片尺寸resize" class="headerlink" title="改变图片尺寸resize"></a>改变图片尺寸resize</h4><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.transform.resize(image, output_shape)</span><br></pre></td></tr></table></figure>
<p>参数<code>image</code>是需要改变尺寸的图片，<code>output_shape</code>是新的图片尺寸。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> transform, data</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = data.camera()</span><br><span class="line">dst = transform.resize(img, (<span class="number">80</span>, <span class="number">60</span>))</span><br><span class="line">plt.figure(<span class="string">'resize'</span>)</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.title(<span class="string">'before resize'</span>)</span><br><span class="line">plt.imshow(img, plt.cm.gray)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.title(<span class="string">'before resize'</span>)</span><br><span class="line">plt.imshow(dst, plt.cm.gray)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>将<code>camera</code>图片由原来的<code>512 * 512</code>变成了<code>80 * 60</code>大小，从下图中的坐标尺就能够看出来：</p>
<p><img src="/2019/02/19/Python语法/skimage模块/14.jpg" height="230" width="360"></p>
<h4 id="按比例缩放rescale"><a href="#按比例缩放rescale" class="headerlink" title="按比例缩放rescale"></a>按比例缩放rescale</h4><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.transform.rescale(image, scale[, ...])</span><br></pre></td></tr></table></figure>
<p>参数<code>scale</code>可以是单个<code>float</code>数，表示长和宽缩放的倍数；也可以是一个<code>float</code>型的<code>tuple</code>(例如<code>[0.2, 0.5]</code>)，将行列分别进行缩放：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> transform, data</span><br><span class="line"></span><br><span class="line">img = data.camera()</span><br><span class="line">print(img.shape)  <span class="comment"># 图片原始大小</span></span><br><span class="line">print(transform.rescale(img, <span class="number">0.1</span>).shape)  <span class="comment"># 长和宽缩小为原来图片大小的0.1</span></span><br><span class="line">print(transform.rescale(img, [<span class="number">0.5</span>, <span class="number">0.25</span>]).shape)  <span class="comment"># 行缩小为原来图片的一半，列为四分之一</span></span><br><span class="line">print(transform.rescale(img, <span class="number">2</span>).shape)  <span class="comment"># 长和宽放大为原来图片大小的2倍</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">51</span>, <span class="number">51</span>)</span><br><span class="line">(<span class="number">256</span>, <span class="number">128</span>)</span><br><span class="line">(<span class="number">1024</span>, <span class="number">1024</span>)</span><br></pre></td></tr></table></figure>
<h4 id="旋转rotate"><a href="#旋转rotate" class="headerlink" title="旋转rotate"></a>旋转rotate</h4><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.transform.rotate(image, angle[, ...], resize = <span class="keyword">False</span>)</span><br></pre></td></tr></table></figure>
<p>参数<code>angle</code>是一个<code>float</code>类型数，表示旋转的度数；参数<code>resize</code>用于控制在旋转时是否改变大小。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> transform, data</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = data.camera()</span><br><span class="line">print(img.shape)  <span class="comment"># 图片原始大小</span></span><br><span class="line">img1 = transform.rotate(img, <span class="number">60</span>)  <span class="comment"># 旋转90度，不改变大小</span></span><br><span class="line">print(img1.shape)</span><br><span class="line">img2 = transform.rotate(img, <span class="number">30</span>, resize=<span class="keyword">True</span>)  <span class="comment"># 旋转30度，同时改变大小</span></span><br><span class="line">print(img2.shape)</span><br><span class="line">plt.figure(<span class="string">'resize'</span>)</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.title(<span class="string">'rotate 60'</span>)</span><br><span class="line">plt.imshow(img1, plt.cm.gray)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.title(<span class="string">'rotate 30'</span>)</span><br><span class="line">plt.imshow(img2, plt.cm.gray)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">700</span>, <span class="number">700</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/15.jpg" height="230" width="360"></p>
<h3 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h3><p>&emsp;&emsp;以多分辨率来解释图像的一种有效但概念简单的结构就是图像金字塔。图像金字塔最初用于机器视觉和图像压缩，一幅图像的金字塔是一系列以金字塔形状排列的分辨率逐步降低的图像集合。金字塔的底部是待处理图像的高分辨率表示，而顶部是低分辨率的近似。当向金字塔的上层移动时，尺寸和分辨率就降低。<br>&emsp;&emsp;在此我们举一个高斯金字塔的应用实例，函数原型为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.transform.pyramid_gaussian(image, downscale=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><code>downscale</code>控制着金字塔的缩放比例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data, transform</span><br><span class="line"></span><br><span class="line">image = data.astronaut()  <span class="comment"># 载入宇航员图片</span></span><br><span class="line">rows, cols, dim = image.shape  <span class="comment"># 获取图片的行数、列数和通道数</span></span><br><span class="line"><span class="comment"># 产生高斯金字塔图像，共生成了“log(512) = 9”幅金字塔图像，加上原始图像共10幅</span></span><br><span class="line">pyramid = tuple(transform.pyramid_gaussian(image, downscale=<span class="number">2</span>))</span><br><span class="line">composite_image = np.ones((rows, cols + cols // <span class="number">2</span>, <span class="number">3</span>), dtype=np.float)  <span class="comment"># 生成背景</span></span><br><span class="line">composite_image[:rows, :cols, :] = pyramid[<span class="number">0</span>]  <span class="comment"># 融合原始图像</span></span><br><span class="line">i_row = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> pyramid[<span class="number">1</span>:]:</span><br><span class="line">    n_rows, n_cols = p.shape[:<span class="number">2</span>]</span><br><span class="line">    composite_image[i_row:i_row + n_rows, cols:cols + n_cols] = p  <span class="comment"># 循环融合9幅金字塔图像</span></span><br><span class="line">    i_row += n_rows</span><br><span class="line"></span><br><span class="line">plt.imshow(composite_image)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/16.jpg" height="241" width="359"></p>
<p>上图就是<code>10</code>张金字塔图像，下标为<code>0</code>的表示原始图像，后面每层的图像行和列变为上一层的一半，直至变为<code>1</code>。</p>
<h3 id="对比度与亮度调整"><a href="#对比度与亮度调整" class="headerlink" title="对比度与亮度调整"></a>对比度与亮度调整</h3><p>&emsp;&emsp;图像亮度与对比度的调整是放在<code>skimage</code>的<code>exposure</code>模块里面。</p>
<h4 id="gamma调整"><a href="#gamma调整" class="headerlink" title="gamma调整"></a>gamma调整</h4><p>&emsp;&emsp;原理是<code>I = I * g</code>，对原图像的像素进行幂运算，得到新的像素值，公式中的<code>g</code>就是<code>gamma</code>值。如果<code>gamma &gt; 1</code>，新图像比原图像暗；如果<code>gamma &lt; 1</code>，新图像比原图像亮。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.exposure.adjust_gamma(image, gamma=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>参数<code>gamma</code>默认为<code>1</code>，即原图像不发生变化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data, exposure, img_as_float</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">image = img_as_float(data.moon())</span><br><span class="line">gam1 = exposure.adjust_gamma(image, <span class="number">2</span>)  <span class="comment"># 调暗</span></span><br><span class="line">gam2 = exposure.adjust_gamma(image, <span class="number">0.5</span>)  <span class="comment"># 调亮</span></span><br><span class="line">plt.figure(<span class="string">'adjust_gamma'</span>, figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">plt.subplot(<span class="number">131</span>)</span><br><span class="line">plt.title(<span class="string">'origin image'</span>)</span><br><span class="line">plt.imshow(image, plt.cm.gray)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">132</span>)</span><br><span class="line">plt.title(<span class="string">'gamma = 2'</span>)</span><br><span class="line">plt.imshow(gam1, plt.cm.gray)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">133</span>)</span><br><span class="line">plt.title(<span class="string">'gamma = 0.5'</span>)</span><br><span class="line">plt.imshow(gam2, plt.cm.gray)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/17.jpg" height="139" width="418"></p>
<h4 id="log对数调整"><a href="#log对数调整" class="headerlink" title="log对数调整"></a>log对数调整</h4><p>&emsp;&emsp;这个函数刚好和<code>gamma</code>相反，原理是<code>I = log(I)</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data, exposure, img_as_float</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">image = img_as_float(data.moon())</span><br><span class="line">gam1 = exposure.adjust_log(image)  <span class="comment"># 对数调整</span></span><br><span class="line">plt.figure(<span class="string">'adjust_gamma'</span>, figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.title(<span class="string">'origin image'</span>)</span><br><span class="line">plt.imshow(image, plt.cm.gray)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.title(<span class="string">'log'</span>)</span><br><span class="line">plt.imshow(gam1, plt.cm.gray)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/18.jpg" height="206" width="419"></p>
<h4 id="判断图像对比度是否偏低"><a href="#判断图像对比度是否偏低" class="headerlink" title="判断图像对比度是否偏低"></a>判断图像对比度是否偏低</h4><p>&emsp;&emsp;函数是<code>is_low_contrast(img)</code>，返回一个<code>bool</code>型值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data, exposure</span><br><span class="line">image = data.moon()</span><br><span class="line">result = exposure.is_low_contrast(image)</span><br><span class="line">print(result)  <span class="comment"># 输出“False”</span></span><br></pre></td></tr></table></figure>
<h4 id="调整强度"><a href="#调整强度" class="headerlink" title="调整强度"></a>调整强度</h4><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.exposure.rescale_intensity(image, in_range=<span class="string">'image'</span>, out_range=<span class="string">'dtype'</span>)</span><br></pre></td></tr></table></figure>
<p>参数<code>in_range</code>表示输入图片的强度范围，默认为<code>image</code>，表示用图像的最大和最小像素值作为范围；参数<code>out_range</code>表示输出图片的强度范围，默认为<code>dtype</code>，表示用图像的类型的最大和最小值作为范围。默认情况下，输入图片的<code>[min, max]</code>范围被拉伸到<code>[dtype.min, dtype.max]</code>，如果<code>dtype=uint8</code>，那么<code>dtype.min</code>为<code>0</code>，<code>dtype.max</code>为<code>255</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> exposure</span><br><span class="line"></span><br><span class="line">image = np.array([<span class="number">51</span>, <span class="number">102</span>, <span class="number">153</span>], dtype=np.uint8)</span><br><span class="line">mat = exposure.rescale_intensity(image)</span><br><span class="line">print(mat)  <span class="comment"># 输出“[0 127 255]”</span></span><br></pre></td></tr></table></figure>
<p>即像素最小值由<code>51</code>变为<code>0</code>，最大值由<code>153</code>变为<code>255</code>，整体进行了拉伸，但是数据类型没有变，还是<code>uint8</code>。<br>&emsp;&emsp;前面我们讲过，可以通过<code>img_as_float</code>函数将<code>unit8</code>类型转换为<code>float</code>型，实际上还有更简单的方法，就是乘以<code>1.0</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">image = np.array([<span class="number">51</span>, <span class="number">102</span>, <span class="number">153</span>], dtype=np.uint8)</span><br><span class="line">print(image * <span class="number">1.0</span>)  <span class="comment"># 输出“[ 51. 102. 153.]”</span></span><br></pre></td></tr></table></figure>
<p>而<code>float</code>类型的范围是<code>[0, 1]</code>，因此对<code>float</code>进行<code>rescale_intensity</code>调整后，范围变为<code>[0, 1]</code>，而不是<code>[0, 255]</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> exposure</span><br><span class="line"></span><br><span class="line">image = np.array([<span class="number">51</span>, <span class="number">102</span>, <span class="number">153</span>], dtype=np.uint8)</span><br><span class="line">tmp = image * <span class="number">1.0</span></span><br><span class="line">mat = exposure.rescale_intensity(tmp)</span><br><span class="line">print(mat)  <span class="comment"># 输出“[0.  0.5 1. ]”</span></span><br></pre></td></tr></table></figure>
<p>如果原始像素值不想被拉伸，只是等比例缩小，就使用<code>in_range</code>参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> exposure</span><br><span class="line"></span><br><span class="line">image = np.array([<span class="number">51</span>, <span class="number">102</span>, <span class="number">153</span>], dtype=np.uint8)</span><br><span class="line">tmp = image * <span class="number">1.0</span></span><br><span class="line">mat = exposure.rescale_intensity(tmp, in_range=(<span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">print(mat)  <span class="comment"># 输出“[0.2 0.4 0.6]”，即原像素值除以255</span></span><br></pre></td></tr></table></figure>
<p>如果参数<code>in_range</code>的范围要比原始像素值的范围<code>[min, max]</code>大或者小，那就进行裁剪：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mat = exposure.rescale_intensity(tmp, in_range=(<span class="number">0</span>, <span class="number">102</span>))</span><br><span class="line">print(mat)  <span class="comment"># 输出“[0.5 1.  1. ]”，即原像素值除以102，超出1的变为1</span></span><br></pre></td></tr></table></figure>
<p>如果一个数组里面有负数，现在想调整到正数，就使用<code>out_range</code>参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> exposure</span><br><span class="line"></span><br><span class="line">image = np.array([<span class="number">-10</span>, <span class="number">0</span>, <span class="number">10</span>], dtype=np.int8)</span><br><span class="line">mat = exposure.rescale_intensity(image, out_range=(<span class="number">0</span>, <span class="number">127</span>))</span><br><span class="line">print(mat)  <span class="comment"># 输出“[  0  63 127]”</span></span><br></pre></td></tr></table></figure>
<h3 id="直方图与均衡化"><a href="#直方图与均衡化" class="headerlink" title="直方图与均衡化"></a>直方图与均衡化</h3><p>&emsp;&emsp;在<code>skimage</code>中，对直方图的处理是放在<code>exposure</code>模块中。</p>
<h4 id="计算直方图"><a href="#计算直方图" class="headerlink" title="计算直方图"></a>计算直方图</h4><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skimage.exposure.histogram(image, nbins=<span class="number">256</span>)</span><br></pre></td></tr></table></figure>
<p><code>numpy</code>也提供了一个计算直方图的函数<code>histogram</code>，两者大同小义。该函数返回一个<code>tuple(hist, bins_center)</code>，前一个数组是直方图的统计量，后一个数组是每个<code>bin</code>的中间值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> exposure, data</span><br><span class="line"></span><br><span class="line">image = data.camera() * <span class="number">1.0</span></span><br><span class="line">hist1 = np.histogram(image, bins=<span class="number">2</span>)  <span class="comment"># 用numpy计算直方图</span></span><br><span class="line">hist2 = exposure.histogram(image, nbins=<span class="number">2</span>)  <span class="comment"># 用skimage计算直方图</span></span><br><span class="line">print(hist1)</span><br><span class="line">print(hist2)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(array([<span class="number">107432</span>, <span class="number">154712</span>], dtype=int64), array([  <span class="number">0.</span> , <span class="number">127.5</span>, <span class="number">255.</span> ]))</span><br><span class="line">(array([<span class="number">107432</span>, <span class="number">154712</span>], dtype=int64), array([ <span class="number">63.75</span>, <span class="number">191.25</span>]))</span><br></pre></td></tr></table></figure>
<p>每个<code>bin</code>的统计量是一样的，但<code>numpy</code>返回的是每个<code>bin</code>的两端的范围值，而<code>skimage</code>返回的是每个<code>bin</code>的中间值。</p>
<h4 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h4><p>&emsp;&emsp;绘图可以调用<code>matplotlib.pyplot</code>库来进行，其中的<code>hist</code>函数可以直接绘制直方图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n, bins, patches = plt.hist(</span><br><span class="line">    arr, bins=<span class="number">10</span>, normed=<span class="number">0</span>, facecolor=<span class="string">'black'</span>,</span><br><span class="line">    edgecolor=<span class="string">'black'</span>, alpha=<span class="number">1</span>, histtype=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>arr</code>: 显示直方图的一维数组。</li>
<li><code>bins</code>: 直方图的柱数。</li>
<li><code>normed</code>: 是否将得到的直方图向量归一化。</li>
<li><code>facecolor</code>: 直方图颜色。</li>
<li><code>edgecolor</code>: 直方图边框颜色。</li>
<li><code>alpha</code>: 透明度。</li>
<li><code>histtype</code>: 直方图类型，例如<code>bar</code>、<code>barstacked</code>、<code>step</code>和<code>stepfilled</code>。</li>
</ul>
<p>返回值如下：</p>
<ul>
<li><code>n</code>: 直方图向量，是否归一化由参数<code>normed</code>设定。</li>
<li><code>bins</code>: 返回各个<code>bin</code>的区间范围。</li>
<li><code>patches</code>: 返回每个<code>bin</code>里面包含的数据，是一个<code>list</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = data.camera()</span><br><span class="line">plt.figure(<span class="string">"hist"</span>)</span><br><span class="line">arr = img.flatten()</span><br><span class="line">n, bins, patches = plt.hist(arr, bins=<span class="number">256</span>, normed=<span class="number">1</span>, edgecolor=<span class="string">'None'</span>, facecolor=<span class="string">'red'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/19.png" height="268" width="370"></p>
<p>其中的<code>flatten</code>是<code>numpy</code>中的函数，用于将多维数组序列化成一维数组。</p>
<h4 id="彩色图片三通道直方图"><a href="#彩色图片三通道直方图" class="headerlink" title="彩色图片三通道直方图"></a>彩色图片三通道直方图</h4><p>&emsp;&emsp;一般来说直方图都是针对灰度图的，如果要画<code>rgb</code>图像的三通道直方图，实际上就是三个直方图的叠加：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = data.coffee()</span><br><span class="line">ar = img[:, :, <span class="number">0</span>].flatten()</span><br><span class="line">plt.hist(ar, bins=<span class="number">256</span>, normed=<span class="number">1</span>, facecolor=<span class="string">'r'</span>, edgecolor=<span class="string">'r'</span>, hold=<span class="number">1</span>)</span><br><span class="line">ag = img[:, :, <span class="number">1</span>].flatten()</span><br><span class="line">plt.hist(ag, bins=<span class="number">256</span>, normed=<span class="number">1</span>, facecolor=<span class="string">'g'</span>, edgecolor=<span class="string">'g'</span>, hold=<span class="number">1</span>)</span><br><span class="line">ab = img[:, :, <span class="number">2</span>].flatten()</span><br><span class="line">plt.hist(ab, bins=<span class="number">256</span>, normed=<span class="number">1</span>, facecolor=<span class="string">'b'</span>, edgecolor=<span class="string">'b'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>其中加一个参数<code>hold = 1</code>，表示可以叠加：</p>
<p><img src="/2019/02/19/Python语法/skimage模块/20.png" height="266" width="366"></p>
<h4 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h4><p>&emsp;&emsp;如果一幅图像的像素占有很多的灰度级而且分布均匀，那么这样的图像往往有高对比度和多变的灰度色调。直方图均衡化就是一种能仅靠输入图像直方图信息自动达到这种效果的变换函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data, exposure</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = data.moon()</span><br><span class="line">plt.figure(<span class="string">"hist"</span>, figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">arr = img.flatten()</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.imshow(img, plt.cm.gray)  <span class="comment"># 原始图像</span></span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.hist(arr, bins=<span class="number">256</span>, normed=<span class="number">1</span>, edgecolor=<span class="string">'None'</span>, facecolor=<span class="string">'red'</span>)  <span class="comment"># 原始图像直方图</span></span><br><span class="line">img1 = exposure.equalize_hist(img)</span><br><span class="line">arr1 = img1.flatten()</span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.imshow(img1, plt.cm.gray)  <span class="comment"># 均衡化图像</span></span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.hist(arr1, bins=<span class="number">256</span>, normed=<span class="number">1</span>, edgecolor=<span class="string">'None'</span>, facecolor=<span class="string">'red'</span>)  <span class="comment"># 均衡化直方图</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/21.jpg" height="324" width="332"></p>
<h3 id="HOG特征"><a href="#HOG特征" class="headerlink" title="HOG特征"></a>HOG特征</h3><p>&emsp;&emsp;该函数返回一维<code>hog</code>特征和<code>hog</code>特征的可视化图像：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">skimage.feature.hog(</span><br><span class="line">    image, orientations=<span class="number">9</span>, pixels_per_cell=(<span class="number">8</span>, <span class="number">8</span>), cells_per_block=(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    visualise=<span class="keyword">False</span>, transform_sqrt=<span class="keyword">False</span>, feature_vector=<span class="keyword">True</span>, normalise=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>image</code>：传入要进行<code>hog</code>特征计算的灰度图。</li>
<li><code>orientations</code>：设置方向梯度直方图的箱子个数。</li>
<li><code>pixels_per_cell</code>：设置每个单元的像素。</li>
<li><code>cells_per_block</code>：设置每个区块的单元数。</li>
<li><code>visualise</code>：设置是否返回可视化的<code>hog</code>特征。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data, color, exposure</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog</span><br><span class="line"></span><br><span class="line">image = color.rgb2gray(data.astronaut())</span><br><span class="line">fd, hog_image = hog(image, orientations=<span class="number">8</span>, pixels_per_cell=(<span class="number">16</span>, <span class="number">16</span>), cells_per_block=(<span class="number">1</span>, <span class="number">1</span>), visualize=<span class="keyword">True</span>)</span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), sharex=<span class="keyword">True</span>, sharey=<span class="keyword">True</span>)</span><br><span class="line">ax1.axis(<span class="string">'off'</span>)</span><br><span class="line">ax1.imshow(image, cmap=plt.cm.gray)</span><br><span class="line">ax1.set_title(<span class="string">'Input image'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rescale histogram for better display</span></span><br><span class="line">hog_image_rescaled = exposure.rescale_intensity(hog_image, in_range=(<span class="number">0</span>, <span class="number">0.02</span>))</span><br><span class="line">ax2.axis(<span class="string">'off'</span>)</span><br><span class="line">ax2.imshow(hog_image_rescaled, cmap=plt.cm.gray)</span><br><span class="line">ax2.set_title(<span class="string">'Histogram of Oriented Gradients'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/19/Python语法/skimage模块/22.jpg" height="257" width="523"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/18/Qt语法详解/Qt之QMenu/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/Qt语法详解/Qt之QMenu/" itemprop="url">Qt之QMenu</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T19:51:39+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QMenu</code> class provides a menu widget for use in menu bars, context menus, and other popup menus.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QMenu</code></td>
<td><code>QWidget</code></td>
<td><code>Q3PopupMenu</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QMenu(QWidget * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>QMenu(const QString &amp; title, QWidget * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QMenu()</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>actionAt(const QPoint &amp; pt) const</code></td>
</tr>
<tr>
<td><code>QRect</code></td>
<td><code>actionGeometry(QAction * act) const</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>activeAction() const</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>addAction(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>addAction(const QIcon &amp; icon, const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>addAction(const QString &amp; text, const QObject * receiver, const char * member, const QKeySequence &amp; shortcut = 0)</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>addAction(const QIcon &amp; icon, const QString &amp; text, const QObject * receiver, const char * member, const QKeySequence &amp; shortcut = 0)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addAction(QAction * action)</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>addMenu(QMenu * menu)</code></td>
</tr>
<tr>
<td><code>QMenu *</code></td>
<td><code>addMenu(const QString &amp; title)</code></td>
</tr>
<tr>
<td><code>QMenu *</code></td>
<td><code>addMenu(const QIcon &amp; icon, const QString &amp; title)</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>addSeparator()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>defaultAction() const</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>exec()</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>exec(const QPoint &amp; p, QAction * action = 0)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>hideTearOffMenu()</code></td>
</tr>
<tr>
<td><code>QIcon</code></td>
<td><code>icon() const</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>insertMenu(QAction * before, QMenu * menu)</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>insertSeparator(QAction * before)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isTearOffEnabled() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isTearOffMenuVisible() const</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>menuAction() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>popup(const QPoint &amp; p, QAction * atAction = 0)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>separatorsCollapsible() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setActiveAction(QAction * act)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDefaultAction(QAction * act)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setIcon(const QIcon &amp; icon)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSeparatorsCollapsible(bool collapse)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTearOffEnabled(bool)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTitle(const QString &amp; title)</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>title() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Public-Functions"><a href="#Reimplemented-Public-Functions" class="headerlink" title="Reimplemented Public Functions"></a>Reimplemented Public Functions</h3><ul>
<li><code>virtual QSize sizeHint() const;</code></li>
</ul>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>aboutToHide();</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>aboutToShow();</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>hovered ( QAction *action );</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>triggered ( QAction *action );</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Static-Public-Members"><a href="#Static-Public-Members" class="headerlink" title="Static Public Members"></a>Static Public Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QAction *</code></td>
<td><code>exec ( QList&lt;QAction *&gt; actions, const QPoint &amp;pos, QAction *at, QWidget *parent );</code></td>
</tr>
<tr>
<td><code>QAction *</code></td>
<td><code>exec ( QList&lt;QAction *&gt; actions, const QPoint &amp;pos, QAction *at = 0 );</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td><code>columnCount() const;</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>initStyleOption ( QStyleOptionMenuItem *option, const QAction *action ) const;</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Protected-Functions"><a href="#Reimplemented-Protected-Functions" class="headerlink" title="Reimplemented Protected Functions"></a>Reimplemented Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual void</code></td>
<td><code>actionEvent ( QActionEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>changeEvent ( QEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>enterEvent ( QEvent * );</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>event ( QEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>focusNextPrevChild ( bool next );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>hideEvent ( QHideEvent * );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>keyPressEvent ( QKeyEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>leaveEvent ( QEvent * );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>mouseMoveEvent ( QMouseEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>mousePressEvent ( QMouseEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>mouseReleaseEvent ( QMouseEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>paintEvent ( QPaintEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>timerEvent ( QTimerEvent *e );</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>wheelEvent ( QWheelEvent *e );</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QMenu</code> class provides a menu widget for use in menu bars, context menus, and other popup menus.<br>&emsp;&emsp;A menu widget is a selection menu. It can be either a <code>pull-down</code> menu in a menu bar or a standalone context menu. <code>Pull-down</code> menus are shown by the menu bar when the user clicks on the respective item or presses the specified shortcut key. Use <code>QMenuBar::addMenu()</code> to insert a menu into a menu bar. Context menus are usually invoked by some special keyboard key or by <code>right-clicking</code>. They can be executed either asynchronously with <code>popup()</code> or synchronously with <code>exec()</code>. Menus can also be invoked in response to button presses; these are just like context menus except for how they are invoked.</p>
<p><img src="/2019/02/18/Qt语法详解/Qt之QMenu/1.png"></p>
<p align="center" style="color:green">Fig. A menu shown in Plastique widget style, Windows XP widget style, and Macintosh widget style.</p>

<h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>&emsp;&emsp;A menu consists of a list of action items. Actions are added with the <code>addAction()</code>, <code>addActions()</code> and <code>insertAction()</code> functions. An action is represented vertically and rendered by <code>QStyle</code>. In addition, actions can have a text label, an optional icon drawn on the very left side, and shortcut key sequence such as <code>Ctrl + X</code>.<br>&emsp;&emsp;The existing actions held by a menu can be found with <code>actions()</code>.<br>&emsp;&emsp;There are four kinds of action items: separators, actions that show a submenu, widgets, and actions that perform an action. Separators are inserted with <code>addSeparator()</code>, submenus with <code>addMenu()</code>, and all other items are considered action items.<br>&emsp;&emsp;When inserting action items you usually specify a receiver and a slot. The receiver will be notifed whenever the item is <code>triggered()</code>. In addition, <code>QMenu</code> provides two signals, <code>activated()</code> and <code>highlighted()</code>, which signal the <code>QAction</code> that was triggered from the menu.<br>&emsp;&emsp;You clear a menu with <code>clear()</code> and remove individual action items with <code>removeAction()</code>.<br>&emsp;&emsp;A QMenu can also provide a tear-off menu. A <code>tear-off</code> menu is a <code>top-level</code> window that contains a copy of the menu. This makes it possible for the user to <code>tear off</code> frequently used menus and position them in a convenient place on the screen. If you want this functionality for a particular menu, insert a <code>tear-off</code> handle with <code>setTearOffEnabled()</code>. When using <code>tear-off</code> menus, bear in mind that the concept isn’t typically used on <code>Microsoft Windows</code> so some users may not be familiar with it. Consider using a <code>QToolBar</code> instead.<br>&emsp;&emsp;Widgets can be inserted into menus with the <code>QWidgetAction</code> class. Instances of this class are used to hold widgets, and are inserted into menus with the <code>addAction()</code> overload that takes a <code>QAction</code>.<br>&emsp;&emsp;Conversely, actions can be added to widgets with the <code>addAction()</code>, <code>addActions()</code> and <code>insertAction()</code> functions.<br>&emsp;&emsp;<strong>Warning</strong>: To make <code>QMenu</code> visible on the screen, <code>exec()</code> or <code>popup()</code> should be used instead of <code>show()</code>.</p>
<h3 id="Property-Documentation"><a href="#Property-Documentation" class="headerlink" title="Property Documentation"></a>Property Documentation</h3><ul>
<li><code>icon : QIcon</code>: This property holds the icon of the menu. This is equivalent to the <code>QAction::icon</code> property of the <code>menuAction()</code>. By default, if no icon is explicitly set, this property contains a null icon. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QIcon <span class="title">icon</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">setIcon</span> <span class="params">( <span class="keyword">const</span> QIcon &amp;icon )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>separatorsCollapsible : bool</code>: This property holds whether consecutive separators should be collapsed. This property specifies whether consecutive separators in the menu should be visually collapsed to a single one. Separators at the beginning or the end of the menu are also hidden. By default, this property is <code>true</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">separatorsCollapsible</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSeparatorsCollapsible</span> <span class="params">( <span class="keyword">bool</span> collapse )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tearOffEnabled : bool</code>: This property holds whether the menu supports being torn off. When <code>true</code>, the menu contains a special <code>tear-off</code> item (often shown as a dashed line at the top of the menu) that creates a copy of the menu when it is triggered. This <code>torn-off</code> copy lives in a separate window. It contains the same menu items as the original menu, with the exception of the <code>tear-off</code> handle. By default, this property is <code>false</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTearOffEnabled</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTearOffEnabled</span> <span class="params">( <span class="keyword">bool</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>title : QString</code>: This property holds the title of the menu. This is equivalent to the <code>QAction::text</code> property of the <code>menuAction()</code>. By default, this property contains an empty string. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">title</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTitle</span> <span class="params">( <span class="keyword">const</span> QString &amp;title )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QMenu::QMenu(QWidget * parent = 0)</code>: Constructs a menu with <code>parent</code>. Although a popup menu is always a <code>top-level</code> widget, if a parent is passed, the popup menu will be deleted when that parent is destroyed (as with any other <code>QObject</code>).</li>
<li><code>QMenu::QMenu(const QString &amp; title, QWidget * parent = 0)</code>: Constructs a menu with a <code>title</code> and a <code>parent</code>. Although a popup menu is always a <code>top-level</code> widget, if a parent is passed, the popup menu will be deleted when that parent is destroyed (as with any other <code>QObject</code>).</li>
<li><code>QMenu::~QMenu()</code>: Destroys the menu.</li>
<li><code>void QMenu::aboutToHide() [signal]</code>: This signal is emitted just before the menu is hidden from the user.</li>
<li><code>void QMenu::aboutToShow() [signal]</code>: This signal is emitted just before the menu is shown to the user.</li>
<li><code>QAction * QMenu::actionAt(const QPoint &amp; pt) const</code>: Returns the item at <code>pt</code>; returns <code>0</code> if there is no item there.</li>
<li><code>void QMenu::actionEvent(QActionEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::actionEvent()</code>.</li>
<li><code>QRect QMenu::actionGeometry(QAction * act) const</code>: Returns the geometry of action <code>act</code>.</li>
<li><code>QAction * QMenu::activeAction() const</code>: Returns the currently highlighted action, or <code>0</code> if no action is currently highlighted.</li>
<li><code>QAction * QMenu::addAction(const QString &amp; text)</code>: This is an overloaded function. This convenience function creates a new action with <code>text</code>. The function adds the newly created action to the menu’s list of actions, and returns it.</li>
<li><code>QAction * QMenu::addAction(const QIcon &amp; icon, const QString &amp; text)</code>: This is an overloaded function. This convenience function creates a new action with an <code>icon</code> and some <code>text</code>. The function adds the newly created action to the menu’s list of actions, and returns it.</li>
<li><code>QAction * QMenu::addAction(const QString &amp; text, const QObject * receiver, const char * member, const QKeySequence &amp; shortcut = 0)</code>: This is an overloaded function. This convenience function creates a new action with the <code>text</code> and an optional <code>shortcut</code>. The action’s <code>triggered()</code> signal is connected to the <code>receiver&#39;s</code> <code>member</code> slot. The function adds the newly created action to the menu’s list of actions and returns it.</li>
<li><code>QAction * QMenu::addAction(const QIcon &amp; icon, const QString &amp; text, const QObject * receiver, const char * member, const QKeySequence &amp; shortcut = 0)</code>: This is an overloaded function. This convenience function creates a new action with an <code>icon</code> and some <code>text</code> and an optional <code>shortcut</code>. The action’s <code>triggered()</code> signal is connected to the <code>member</code> slot of the <code>receiver</code> object. The function adds the newly created action to the menu’s list of actions, and returns it.</li>
<li><code>void QMenu::addAction(QAction * action)</code>: This is an overloaded function. Appends the <code>action</code> to the menu’s list of actions.</li>
<li><code>QAction * QMenu::addMenu(QMenu * menu)</code>: This convenience function adds <code>menu</code> as a submenu to this menu. It returns menu’s <code>menuAction()</code>. This <code>menu</code> does not take ownership of menu.</li>
<li><code>QMenu * QMenu::addMenu(const QString &amp; title)</code>: Appends a new <code>QMenu</code> with <code>title</code> to the menu. The <code>menu</code> takes ownership of the menu. Returns the new menu.</li>
<li><code>QMenu * QMenu::addMenu(const QIcon &amp; icon, const QString &amp; title)</code>: Appends a new <code>QMenu</code> with <code>icon</code> and <code>title</code> to the menu. The <code>menu</code> takes ownership of the menu. Returns the new menu.</li>
<li><code>QAction * QMenu::addSeparator()</code>: This convenience function creates a new separator action, i.e. an action with <code>QAction::isSeparator()</code> returning <code>true</code>, and adds the new action to this menu’s list of actions. It returns the newly created action.</li>
<li><code>void QMenu::changeEvent(QEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::changeEvent()</code>.</li>
<li><code>void QMenu::clear()</code>: Removes all the menu’s actions. Actions owned by the menu and not shown in any other widget are deleted.</li>
<li><code>int QMenu::columnCount() const [protected]</code>: If a menu does not fit on the screen it lays itself out so that it does fit. It is style dependent what layout means (for example, on <code>Windows</code> it will use multiple columns). This functions returns the number of columns necessary.</li>
<li><code>QAction * QMenu::defaultAction() const</code>: Returns the current default action.</li>
<li><code>void QMenu::enterEvent(QEvent *) [virtual protected]</code>: Reimplemented from <code>QWidget::enterEvent()</code>.</li>
<li><code>bool QMenu::event(QEvent * e) [virtual protected]</code>: Reimplemented from <code>QObject::event()</code>.</li>
<li><code>QAction * QMenu::exec()</code>: Executes this menu synchronously. This is equivalent to <code>exec(pos())</code>. This returns the triggered <code>QAction</code> in either the popup menu or one of its submenus, or <code>0</code> if no item was triggered (normally because the user pressed <code>Esc</code>). In most situations you’ll want to specify the position yourself, for example, the current mouse position:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec ( QCursor::pos() );</span><br></pre></td></tr></table></figure>
<p>or aligned to a <code>widget</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec ( somewidget.mapToGlobal ( QPoint ( <span class="number">0</span>, <span class="number">0</span> ) ) );</span><br></pre></td></tr></table></figure>
<p>or in reaction to a <code>QMouseEvent *e</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec ( e-&gt;globalPos() );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QAction * QMenu::exec(const QPoint &amp; p, QAction * action = 0)</code>: This is an overloaded function. Executes this menu synchronously. Pops up the menu so that the <code>action</code> will be at the specified global position <code>p</code>. To translate a widget’s local coordinates into global coordinates, use <code>QWidget::mapToGlobal()</code>. This returns the triggered <code>QAction</code> in either the popup menu or one of its submenus, or <code>0</code> if no item was triggered (normally because the user pressed <code>Esc</code>). Note that all signals are emitted as usual. If you connect a <code>QAction</code> to a slot and call the menu’s <code>exec()</code>, you get the result both via the <code>signal-slot</code> connection and in the return value of <code>exec()</code>. Common usage is to position the menu at the current mouse position:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec ( QCursor::pos() );</span><br></pre></td></tr></table></figure>
<p>or aligned to a <code>widget</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec ( somewidget.mapToGlobal ( QPoint ( <span class="number">0</span>, <span class="number">0</span> ) ) );</span><br></pre></td></tr></table></figure>
<p>or in reaction to a <code>QMouseEvent *e</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec ( e-&gt;globalPos() );</span><br></pre></td></tr></table></figure>
<p>When positioning a menu with <code>exec()</code> or <code>popup()</code>, bear in mind that you cannot rely on the menu’s current <code>size()</code>. For performance reasons, the menu adapts its size only when necessary. So in many cases, the size before and after the show is different. Instead, use <code>sizeHint()</code> which calculates the proper size depending on the menu’s current contents.</p>
<ul>
<li><code>QAction * QMenu::exec(QList&lt;QAction *&gt; actions, const QPoint &amp; pos, QAction * at, QWidget * parent) [static]</code>: This is an overloaded function. Executes a menu synchronously. The menu’s actions are specified by the list of <code>actions</code>. The menu will pop up so that the specified <code>action</code>, <code>at</code>, appears at global position <code>pos</code>. If <code>at</code> is not specified then the menu appears at position <code>pos</code>. <code>parent</code> is the menu’s parent widget; specifying the <code>parent</code> will provide context when <code>pos</code> alone is not enough to decide where the menu should go (e.g., with multiple desktops or when the parent is embedded in <code>QGraphicsView</code>). The function returns the triggered <code>QAction</code> in either the popup menu or one of its submenus, or <code>0</code> if no item was triggered (normally because the user pressed <code>Esc</code>). This is equivalent to:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QMenu menu;</span><br><span class="line">QAction *at = actions[<span class="number">0</span>]; <span class="comment">/* Assumes actions is not empty */</span></span><br><span class="line">​</span><br><span class="line">foreach ( QAction *a, actions ) &#123;</span><br><span class="line">    menu.addAction ( a );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">menu.exec ( pos, at );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QAction * QMenu::exec(QList&lt;QAction *&gt; actions, const QPoint &amp; pos, QAction * at = 0) [static]</code>: This is an overloaded function. Executes a menu synchronously. The menu’s actions are specified by the list of <code>actions</code>. The menu will pop up so that the specified <code>action</code>, <code>at</code>, appears at global position <code>pos</code>. If <code>at</code> is not specified then the menu appears at position <code>pos</code>. The function returns the triggered <code>QAction</code> in either the popup menu or one of its submenus, or <code>0</code> if no item was triggered (normally because the user pressed <code>Esc</code>). This is equivalent to:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QMenu menu;</span><br><span class="line">QAction *at = actions[<span class="number">0</span>]; <span class="comment">/* Assumes actions is not empty */</span></span><br><span class="line">​</span><br><span class="line">foreach ( QAction *a, actions ) &#123;</span><br><span class="line">    menu.addAction ( a );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">menu.exec ( pos, at );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>bool QMenu::focusNextPrevChild(bool next) [virtual protected]</code>: Reimplemented from <code>QWidget::focusNextPrevChild()</code>.</li>
<li><code>void QMenu::hideEvent(QHideEvent *) [virtual protected]</code>: Reimplemented from <code>QWidget::hideEvent()</code>.</li>
<li><code>void QMenu::hideTearOffMenu()</code>: This function will forcibly hide the torn off menu making it disappear from the users desktop.</li>
<li><code>void QMenu::hovered(QAction * action) [signal]</code>: This signal is emitted when a menu action is highlighted; <code>action</code> is the action that caused the signal to be emitted. Often this is used to update status information.</li>
<li><code>void QMenu::initStyleOption(QStyleOptionMenuItem * option, const QAction * action) const [protected]</code>: Initialize <code>option</code> with the values from this menu and information from <code>action</code>. This method is useful for subclasses when they need a <code>QStyleOptionMenuItem</code>, but don’t want to fill in all the information themselves.</li>
<li><code>QAction * QMenu::insertMenu(QAction * before, QMenu * menu)</code>: This convenience function inserts <code>menu</code> before action <code>before</code> and returns the menus <code>menuAction()</code>.</li>
<li><code>QAction * QMenu::insertSeparator(QAction * before)</code>: This convenience function creates a new separator action, i.e. an action with <code>QAction::isSeparator()</code> returning <code>true</code>. The function inserts the newly created action into this menu’s list of actions before action <code>before</code> and returns it.</li>
<li><code>bool QMenu::isEmpty() const</code>: Returns <code>true</code> if there are no visible actions inserted into the menu, <code>false</code> otherwise.</li>
<li><code>bool QMenu::isTearOffMenuVisible() const</code>: When a menu is torn off a second menu is shown to display the menu contents in a new window. When the menu is in this mode and the menu is visible returns <code>true</code>; otherwise <code>false</code>.</li>
<li><code>void QMenu::keyPressEvent(QKeyEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::keyPressEvent()</code>.</li>
<li><code>void QMenu::leaveEvent(QEvent *) [virtual protected]</code>: Reimplemented from <code>QWidget::leaveEvent()</code>.</li>
<li><code>QAction * QMenu::menuAction() const</code>: Returns the action associated with this menu.</li>
<li><code>void QMenu::mouseMoveEvent(QMouseEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::mouseMoveEvent()</code>.</li>
<li><code>void QMenu::mousePressEvent(QMouseEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::mousePressEvent()</code>.</li>
<li><code>void QMenu::mouseReleaseEvent(QMouseEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::mouseReleaseEvent()</code>.</li>
<li><code>void QMenu::paintEvent(QPaintEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::paintEvent()</code>.</li>
<li><code>void QMenu::popup(const QPoint &amp; p, QAction * atAction = 0)</code>: Displays the menu so that the action <code>atAction</code> will be at the specified global position <code>p</code>. To translate a widget’s local coordinates into global coordinates, use <code>QWidget::mapToGlobal()</code>. When positioning a menu with <code>exec()</code> or <code>popup()</code>, bear in mind that you cannot rely on the menu’s current <code>size()</code>. For performance reasons, the menu adapts its size only when necessary, so in many cases, the size before and after the show is different. Instead, use <code>sizeHint()</code> which calculates the proper size depending on the menu’s current contents.</li>
<li><code>void QMenu::setActiveAction(QAction * act)</code>: Sets the currently highlighted action to <code>act</code>.</li>
<li><code>void QMenu::setDefaultAction(QAction * act)</code>: This sets the default action to <code>act</code>. The default action may have a visual cue, depending on the current <code>QStyle</code>. A default action usually indicates what will happen by default when a drop occurs.</li>
<li><code>QSize QMenu::sizeHint() const [virtual]</code>: Reimplemented from <code>QWidget::sizeHint()</code>.</li>
<li><code>void QMenu::timerEvent(QTimerEvent * e) [virtual protected]</code>: Reimplemented from <code>QObject::timerEvent()</code>.</li>
<li><code>void QMenu::triggered(QAction * action) [signal]</code>: This signal is emitted when an action in this menu is triggered. <code>action</code> is the action that caused the signal to be emitted. Normally, you connect each menu action’s <code>triggered()</code> signal to its own custom slot, but sometimes you will want to connect several actions to a single slot, for example, when you have a group of closely related actions, such as <code>left justify</code>, <code>center</code>, <code>right justify</code>. <strong>Note</strong>: This signal is emitted for the main parent menu in a hierarchy. Hence, only the parent menu needs to be connected to a slot; <code>sub-menus</code> need not be connected.</li>
<li><code>void QMenu::wheelEvent(QWheelEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::wheelEvent()</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/18/Qt语法详解/Qt之QToolButton/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/Qt语法详解/Qt之QToolButton/" itemprop="url">Qt之QToolButton</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T19:29:18+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>QToolButton</code>类提供了用于命令或选项可以快速访问的按钮，通常可以用在<code>QToolBar</code>里面。工具按钮和普通的命令按钮不同，通常不显示文本，而显示图标。</p>
<h3 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h3><p>&emsp;&emsp;当使用<code>QToolBar::addAction</code>添加一个新的(或已存在的)<code>QAction</code>至工具栏时，工具按钮通常被创建。也可以用同样的方式构建工具按钮和其它部件，并设置它们的布局。<br>&emsp;&emsp;<code>QToolButton</code>支持自动浮起，在自动浮起模式中，只有在鼠标指向它的时候才绘制三维框架。当按钮被用在<code>QToolBar</code>里时，这个特征会被自动启用，可以使用<code>setAutoRaise</code>来改变。<br>&emsp;&emsp;按钮的外观和尺寸可通过<code>setToolButtonStyle</code>和<code>setIconSize</code>来调节。当在<code>QMainWindow</code>的<code>QToolBar</code>里使用时，按钮会自动地调节来适合<code>QMainWindow</code>的设置(参考<code>QMainWindow::setToolButtonStyle</code>和<code>QMainWindow::setIconSize</code>)。<br>&emsp;&emsp;工具按钮可以提供一个弹出菜单，使用<code>setMenu</code>来进行设置。通过<code>setPopupMode</code>来设置菜单的弹出模式，缺省模式是<code>DelayedPopupMode</code>，这个特征有时对于网页浏览器中的<code>后退</code>按钮有用，在按下按钮一段时间后，会弹出一个显示所有可以后退浏览的可能页面的菜单列表，默认延迟<code>600</code>毫秒，可以用<code>setPopupDelay</code>进行调整。</p>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><ul>
<li><code>void setMenu(QMenu * menu)</code>：设置按钮的弹出菜单，和<code>QPushButton</code>用法类似。</li>
<li><code>void setPopupMode(ToolButtonPopupMode mode)</code>：设置弹出菜单的方式，默认情况下，设置为<code>DelayedPopup</code>(延迟弹出)。枚举<code>QToolButton::ToolButtonPopupMode</code>如下：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QToolButton::DelayedPopup</code></td>
<td><code>0</code></td>
<td>按下按钮一定时间后(超时风格依赖，参考<code>QStyle::SH_ToolButton_PopupDelay</code>)，显示菜单</td>
</tr>
<tr>
<td><code>QToolButton::MenuButtonPopup</code></td>
<td><code>1</code></td>
<td>这种模式下，工具按钮显示一个特殊的箭头以指示菜单是否存在，按下按钮的箭头部分时显示菜单</td>
</tr>
<tr>
<td><code>QToolButton::InstantPopup</code></td>
<td><code>2</code></td>
<td>按下工具按钮时菜单显示，无延迟。这种模式下，按钮自身的动作不触发</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>void setToolButtonStyle(Qt::ToolButtonStyle style)</code>：设置按钮风格，只显示一个图标，文本或文本位于图标旁边、下方。默认值是<code>Qt::ToolButtonIconOnly</code>。枚举<code>Qt::ToolButtonStyle</code>如下：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Qt::ToolButtonIconOnly</code></td>
<td><code>0</code></td>
<td>只显示图标</td>
</tr>
<tr>
<td><code>Qt::ToolButtonTextOnly</code></td>
<td><code>1</code></td>
<td>只显示文本</td>
</tr>
<tr>
<td><code>Qt::ToolButtonTextBesideIcon</code></td>
<td><code>2</code></td>
<td>文本显示在图标旁边</td>
</tr>
<tr>
<td><code>Qt::ToolButtonTextUnderIcon</code></td>
<td><code>3</code></td>
<td>文本显示在图标下边</td>
</tr>
<tr>
<td><code>Qt::ToolButtonFollowStyle</code></td>
<td><code>4</code></td>
<td>遵循<code>QStyle::StyleHint</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>void setArrowType(Qt::ArrowType type)</code>：设置按钮是否显示一个箭头，而不是一个正常的图标。这将显示一个箭头作为<code>QToolButton</code>的图标。默认情况下，这个属性被设置为<code>Qt::NoArrow</code>。枚举<code>Qt::ArrowType</code>如下：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Qt::NoArrow</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>Qt::UpArrow</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>Qt::DownArrow</code></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>Qt::LeftArrow</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td><code>Qt::RightArrow</code></td>
<td><code>4</code></td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;效果如下：</p>
<p><img src="/2019/02/18/Qt语法详解/Qt之QToolButton/1.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QToolButton *pButton = <span class="keyword">new</span> QToolButton ( <span class="keyword">this</span> );</span><br><span class="line">pButton-&gt;setArrowType ( Qt::LeftArrow );</span><br><span class="line">pButton-&gt;setText ( <span class="string">"Left Arrow"</span> );</span><br><span class="line"><span class="comment">/* 文本位于图标之下 */</span></span><br><span class="line">pButton-&gt;setToolButtonStyle ( Qt::ToolButtonTextUnderIcon );</span><br><span class="line">pButton-&gt;setStyleSheet ( <span class="string">"QToolButton&#123;border: none; background: rgb(68, 69, 73); color: rgb(0, 160, 230);&#125;"</span> );</span><br></pre></td></tr></table></figure>
<p>这里可以通过样式表<code>color</code>来设置图标的颜色及文本色。</p>
<ul>
<li><code>void setDefaultAction(QAction * action)</code>：设置<code>QAction</code>，该<code>action</code>则会定义<code>QToolButton</code>的文本、图标、<code>TooTip</code>等按钮的属性。</li>
</ul>
<p>&emsp;&emsp;效果如下：</p>
<p><img src="/2019/02/18/Qt语法详解/Qt之QToolButton/2.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QAction *pAction = <span class="keyword">new</span> QAction ( <span class="keyword">this</span> );</span><br><span class="line">pAction-&gt;setText ( QString::fromLocal8Bit ( <span class="string">"一去丶二三里"</span> ) );</span><br><span class="line">pAction-&gt;setIcon ( QIcon ( <span class="string">":/Images/logo"</span> ) );</span><br><span class="line">pButton-&gt;setIconSize ( QSize ( <span class="number">48</span>, <span class="number">48</span> ) );</span><br><span class="line">pAction-&gt;setToolTip ( QString::fromLocal8Bit ( <span class="string">"青春不老，奋斗不止！"</span> ) );</span><br><span class="line">pButton-&gt;setDefaultAction ( pAction );</span><br><span class="line">pButton-&gt;setToolButtonStyle ( Qt::ToolButtonTextUnderIcon );</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/18/Qt语法详解/Qt之pushButton/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/Qt语法详解/Qt之pushButton/" itemprop="url">Qt之pushButton</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T19:16:34+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><code>setEnabled(true/false)</code>：设置按键使能与否的函数(即可不可以被按下)。</li>
<li><code>boolisEnabled() const</code>：判断按键是否使能，使能返回<code>true</code>，否则为<code>false</code>。</li>
<li><code>setText(string)</code>：设置按钮显示的内容。</li>
<li><code>setIcon(QIcon(图片路径))</code>：使按钮显示为一个图片。</li>
<li><code>setFont(font)</code>：设置按钮上的字体。</li>
</ul>
<hr>
<h3 id="单击导致信号与槽连接"><a href="#单击导致信号与槽连接" class="headerlink" title="单击导致信号与槽连接"></a>单击导致信号与槽连接</h3><p>&emsp;&emsp;代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    QPushButton *button = <span class="keyword">new</span> QPushButton ( <span class="string">"Quit"</span> );</span><br><span class="line">    QObject::connect ( button, SIGNAL ( clicked() ), &amp;app, SLOT ( quit() ) );</span><br><span class="line">    button-&gt;show();</span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/18/Qt语法详解/Qt之pushButton/1.png"></p>
<hr>
<h3 id="QPushButton设置响应按钮为回车键"><a href="#QPushButton设置响应按钮为回车键" class="headerlink" title="QPushButton设置响应按钮为回车键"></a>QPushButton设置响应按钮为回车键</h3><p>&emsp;&emsp;代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;pushButton-&gt;setFocus(); <span class="comment">/* 设置默认焦点 */</span></span><br><span class="line">ui-&gt;pushButton-&gt;setShortcut ( QKeySequence::InsertParagraphSeparator ); <span class="comment">/* 设置快捷键为键盘的“回车”键 */</span></span><br><span class="line">ui-&gt;pushButton-&gt;setShortcut ( Qt::Key_Enter ); <span class="comment">/* 设置快捷键为enter键 */</span></span><br><span class="line">ui-&gt;pushButton-&gt;setShortcut ( Qt::Key_Return ); <span class="comment">/* 设置快捷键为小键盘上的enter键 */</span></span><br></pre></td></tr></table></figure>
<p>或者如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;pushButton-&gt;setFocus(); <span class="comment">/* 设置默认焦点 */</span></span><br><span class="line">ui-&gt;pushButton-&gt;setDefault ( <span class="literal">true</span> ); <span class="comment">/* 设置默认按钮，设置了这个属性，当用户按下回车的时候，就会按下该按钮 */</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="QPushbutton用于发送toggled-bool-的checkable属性"><a href="#QPushbutton用于发送toggled-bool-的checkable属性" class="headerlink" title="QPushbutton用于发送toggled(bool)的checkable属性"></a>QPushbutton用于发送toggled(bool)的checkable属性</h3><p>&emsp;&emsp;默认情况下<code>checkable</code>是不选中的，<code>Button</code>默认为触发按钮(<code>trigger button</code>)，按下去马上弹起来。选中<code>checkable</code>后，<code>Button</code>变成切换按钮(<code>toggle button</code>)，可以有两种状态，即按下和弹起。此时该按钮可以发射<code>toggled(bool)</code>信号，与槽函数<code>setVisible(bool)</code>结合，即可用于控件交替显示。<br>&emsp;&emsp;下图中两个<code>more</code>按钮，上边是弹起状态，下边是按下状态：</p>
<p><img src="/2019/02/18/Qt语法详解/Qt之pushButton/2.png"></p>
<p>&emsp;&emsp;问题：I have the follwing code where moreButton is a <code>QPushButton</code>. When I toggle the button, nothing happens. Shouldn’t it show or hide <code>secondaryGroupBox</code> and <code>tertiaryGroupBox</code>?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect ( moreButton, SIGNAL ( toggled ( <span class="keyword">bool</span> ) ), secondaryGroupBox, SLOT ( setVisible ( <span class="keyword">bool</span> ) ) );</span><br><span class="line">QObject::connect ( moreButton, SIGNAL ( toggled ( <span class="keyword">bool</span> ) ), tertiaryGroupBox, SLOT ( setVisible ( <span class="keyword">bool</span> ) ) );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;回答：Most likely, your pushbutton is not checkable. Try <code>moreButton-&gt;setCheckable(true)</code>, a <code>non-checkable</code> button never emits the <code>toggled(bool)</code> signal.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/18/Qt语法详解/Qt之QSlider/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/Qt语法详解/Qt之QSlider/" itemprop="url">Qt之QSlider</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T19:01:21+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>QSlider</code>部件提供了一个垂直或水平滑动条。它允许用户沿水平或垂直方向移动滑块，并将滑块所在的位置转换成一个合法范围内的值。</p>
<h3 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h3><p>&emsp;&emsp;<code>QSlider</code>很少有自己的函数，大部分功能在<code>QAbstractSlider</code>中。最有用的函数是<code>setValue</code>，用来设置滑块的当前值；<code>triggerAction</code>来模拟点击的效果(对快捷键有用)，<code>setSingleStep</code>和<code>setPageStep</code>用来设置步长，<code>setMinimum</code>和<code>setMaximum</code>用于定义滚动条的范围。<br>&emsp;&emsp;<code>QSlider</code>提供了一些方法来控制刻度标记，可以使用<code>setTickPosition</code>来表示刻度标记的位置，使用<code>setTickInterval</code>来指定刻度的间隔；当前设置的刻度位置和间隔可以分别使用<code>tickPosition</code>和<code>tickInterval</code>函数来查询。<br>&emsp;&emsp;<code>QSlider</code>继承了一组全面的信号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>信号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>valueChanged</code></td>
<td>当滑块的值发生了改变，发射此信号。<code>tracking</code>确定在用户交互时，是否发出此信号</td>
</tr>
<tr>
<td><code>sliderPressed</code></td>
<td>当用户按下滑块，发射此信号</td>
</tr>
<tr>
<td><code>sliderMoved</code></td>
<td>当用户拖动滑块，发射此信号</td>
</tr>
<tr>
<td><code>sliderReleased</code></td>
<td>当用户释放滑块，发射此信号</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;<code>QSlider</code>只提供整数范围。滑块接受<code>Tab</code>键的焦点，并同时提供了一个鼠标滚轮和键盘接口。键盘接口如下：</p>
<ul>
<li><code>Left/Right</code>：移动水平滑块一个步长。</li>
<li><code>Up/Down</code>：移动垂直滑块一个步长。</li>
<li><code>PageUp</code>：上移一页。</li>
<li><code>PageDown</code>：下移一页。</li>
<li><code>Home</code>：移动至起始位置(最小值)。</li>
<li><code>End</code>：移动至结束位置(最大值)。</li>
</ul>
<h3 id="刻度位置"><a href="#刻度位置" class="headerlink" title="刻度位置"></a>刻度位置</h3><p>&emsp;&emsp;枚举量为<code>QSlider::TickPosition</code>，这个枚举指定刻度线相对于滑块和用户操作的位置。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QSlider::NoTicks</code></td>
<td>不绘制任何刻度线</td>
</tr>
<tr>
<td><code>QSlider::TicksBothSides</code></td>
<td>在滑块的两侧绘制刻度线</td>
</tr>
<tr>
<td><code>QSlider::TicksAbove</code></td>
<td>在(水平)滑块上方绘制刻度线</td>
</tr>
<tr>
<td><code>QSlider::TicksBelow</code></td>
<td>在(水平)滑块下方绘制刻度线</td>
</tr>
<tr>
<td><code>QSlider::TicksLeft</code></td>
<td>在(垂直)滑块左侧绘制刻度线</td>
</tr>
<tr>
<td><code>QSlider::TicksRight</code></td>
<td>在(垂直)滑块右侧绘制刻度线</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>&emsp;&emsp;下面来看一个示例，结合<code>QSlider</code>与<code>QSpinBox</code>，让它们彼此之间相互更新：</p>
<p><img src="/2019/02/18/Qt语法详解/Qt之QSlider/1.png" height="130" width="196"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nMin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> nMax = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> nSingleStep = <span class="number">10</span>;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 微调框 */</span></span><br><span class="line">QSpinBox *pSpinBox = <span class="keyword">new</span> QSpinBox ( <span class="keyword">this</span> );</span><br><span class="line">pSpinBox-&gt;setMinimum ( nMin ); <span class="comment">/* 最小值 */</span></span><br><span class="line">pSpinBox-&gt;setMaximum ( nMax ); <span class="comment">/* 最大值 */</span></span><br><span class="line">pSpinBox-&gt;setSingleStep ( nSingleStep ); <span class="comment">/* 步长 */</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 滑动条 */</span></span><br><span class="line">QSlider *pSlider = <span class="keyword">new</span> QSlider ( <span class="keyword">this</span> );</span><br><span class="line">pSlider-&gt;setOrientation ( Qt::Horizontal ); <span class="comment">/* 水平方向 */</span></span><br><span class="line">pSlider-&gt;setMinimum ( nMin ); <span class="comment">/* 最小值 */</span></span><br><span class="line">pSlider-&gt;setMaximum ( nMax ); <span class="comment">/* 最大值 */</span></span><br><span class="line">pSlider-&gt;setSingleStep ( nSingleStep ); <span class="comment">/* 步长 */</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 连接信号槽(相互改变) */</span></span><br><span class="line">connect ( pSpinBox, SIGNAL ( valueChanged ( <span class="keyword">int</span> ) ), pSlider, SLOT ( setValue ( <span class="keyword">int</span> ) ) );</span><br><span class="line">connect ( pSlider, SIGNAL ( valueChanged ( <span class="keyword">int</span> ) ), pSpinBox, SLOT ( setValue ( <span class="keyword">int</span> ) ) );</span><br><span class="line">​</span><br><span class="line">pSpinBox-&gt;setValue ( <span class="number">10</span> );</span><br></pre></td></tr></table></figure>
<p>通过<code>setMinimum</code>与<code>setMaximum</code>函数，将进度条固定到一个合适的范围(<code>0</code>至<code>200</code>)。连接信号槽后，当<code>QSpinBox</code>的值发生改变时，<code>QSlider</code>的值也会发生相应变化；反之亦然。最后使用<code>setValue</code>将<code>QSpinBox</code>的值设置为<code>10</code>，由于信号槽已经连接，所以这时<code>QSlider</code>的值也会发生改变。</p>
<h3 id="刻度位置及间隔"><a href="#刻度位置及间隔" class="headerlink" title="刻度位置及间隔"></a>刻度位置及间隔</h3><p>&emsp;&emsp;源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QSlider *pSlider = <span class="keyword">new</span> QSlider ( <span class="keyword">this</span> );</span><br><span class="line">pSlider-&gt;setOrientation ( Qt::Horizontal ); <span class="comment">/* 水平方向 */</span></span><br><span class="line">pSlider-&gt;setMinimum ( nMin ); <span class="comment">/* 最小值 */</span></span><br><span class="line">pSlider-&gt;setMaximum ( nMax ); <span class="comment">/* 最大值 */</span></span><br><span class="line">pSlider-&gt;setSingleStep ( nSingleStep ); <span class="comment">/* 步长 */</span></span><br><span class="line"><span class="comment">// pSlider-&gt;setTickInterval(40); /* 设置刻度间隔 */</span></span><br><span class="line">pSlider-&gt;setTickPosition ( QSlider::TicksAbove ); <span class="comment">/* 刻度在上方 */</span></span><br></pre></td></tr></table></figure>
<p>当使用<code>setTickInterval(40)</code>设置刻度间隔后，在绘制刻度时，就会有<code>6</code>个刻度点(从<code>0</code>开始，每隔步长<code>40</code>绘制一个点，到<code>200</code>处结束)。也就是说，刻度点的个数等于<code>最大值 / 刻度间隔 + 1</code>。</p>
<p><img src="/2019/02/18/Qt语法详解/Qt之QSlider/2.png" height="130" width="198"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/18/Qt语法详解/Qt之QMapIterator/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/Qt语法详解/Qt之QMapIterator/" itemprop="url">Qt之QMapIterator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T18:27:49+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QMapIterator</code> class provides a <code>Java-style</code> const iterator for <code>QMap</code> and <code>QMultiMap</code>. The header file is <code>QMapIterator</code>.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QMapIterator(const QMap&lt;Key, T&gt; &amp; map)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>findNext(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>findPrevious(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasNext() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasPrevious() const</code></td>
</tr>
<tr>
<td><code>const Key &amp;</code></td>
<td><code>key() const</code></td>
</tr>
<tr>
<td><code>Item</code></td>
<td><code>next()</code></td>
</tr>
<tr>
<td><code>Item</code></td>
<td><code>peekNext() const</code></td>
</tr>
<tr>
<td><code>Item</code></td>
<td><code>peekPrevious() const</code></td>
</tr>
<tr>
<td><code>Item</code></td>
<td><code>previous()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>toBack()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>toFront()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>value() const</code></td>
</tr>
<tr>
<td><code>QMapIterator &amp;</code></td>
<td><code>operator=(const QMap&lt;Key, T&gt; &amp; map)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QMapIterator</code> class provides a <code>Java-style</code> const iterator for <code>QMap</code> and <code>QMultiMap</code>.<br>&emsp;&emsp;<code>QMap</code> has both <code>Java-style</code> iterators and <code>STL-style</code> iterators. The <code>Java-style</code> iterators are more <code>high-level</code> and easier to use than the <code>STL-style</code> iterators; on the other hand, they are slightly less efficient.<br>&emsp;&emsp;<code>QMapIterator&lt;Key, T&gt;</code> allows you to iterate over a <code>QMap</code> (or a <code>QMultiMap</code>). If you want to modify the map as you iterate over it, use <code>QMutableMapIterator</code> instead.<br>&emsp;&emsp;The <code>QMapIterator</code> constructor takes a <code>QMap</code> as argument. After construction, the iterator is located at the very beginning of the map (before the first item). Here’s how to iterate over all the elements sequentially:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;<span class="keyword">int</span>, QWidget *&gt; <span class="built_in">map</span>;</span><br><span class="line">​</span><br><span class="line">QMapIterator&lt;<span class="keyword">int</span>, QWidget *&gt; i ( <span class="built_in">map</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i.hasNext() ) &#123;</span><br><span class="line">    i.next();</span><br><span class="line">    qDebug() &lt;&lt; i.key() &lt;&lt; <span class="string">": "</span> &lt;&lt; i.value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>next()</code> function returns the next item in the map and advances the iterator. The <code>key()</code> and <code>value()</code> functions return the key and value of the last item that was jumped over.<br>&emsp;&emsp;Unlike <code>STL-style</code> iterators, <code>Java-style</code> iterators point between items rather than directly at items. The first call to <code>next()</code> advances the iterator to the position between the first and second item, and returns the first item; the second call to <code>next()</code> advances the iterator to the position between the second and third item; and so on.</p>
<p><img src="/2019/02/18/Qt语法详解/Qt之QMapIterator/1.png"></p>
<p>&emsp;&emsp;Here’s how to iterate over the elements in reverse order:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QMapIterator&lt;<span class="keyword">int</span>, QWidget *&gt; i ( <span class="built_in">map</span> );</span><br><span class="line">i.toBack();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i.hasPrevious() ) &#123;</span><br><span class="line">    i.previous();</span><br><span class="line">    qDebug() &lt;&lt; i.key() &lt;&lt; <span class="string">": "</span> &lt;&lt; i.value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If you want to find all occurrences of a particular value, use <code>findNext()</code> or <code>findPrevious()</code> in a loop. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QMapIterator&lt;<span class="keyword">int</span>, QWidget *&gt; i ( <span class="built_in">map</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i.findNext ( widget ) ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"Found widget "</span> &lt;&lt; widget &lt;&lt; <span class="string">" under key "</span></span><br><span class="line">             &lt;&lt; i.key();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Multiple iterators can be used on the same map. If the map is modified while a <code>QMapIterator</code> is active, the <code>QMapIterator</code> will continue iterating over the original map, ignoring the modified copy.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QMapIterator::QMapIterator(const QMap&lt;Key, T&gt; &amp; map)</code>：Constructs an iterator for traversing <code>map</code>. The iterator is set to be at the front of the <code>map</code> (before the first item).</li>
<li><code>bool QMapIterator::findNext(const T &amp; value)</code>：Searches for <code>value</code> starting from the current iterator position forward. Returns <code>true</code> if a <code>(key, value)</code> pair with <code>value</code> is found; otherwise returns <code>false</code>. After the call, if <code>value</code> was found, the iterator is positioned just after the matching item; otherwise, the iterator is positioned at the back of the container.</li>
<li><code>bool QMapIterator::findPrevious(const T &amp; value)</code>：Searches for <code>value</code> starting from the current iterator position backward. Returns <code>true</code> if a <code>(key, value)</code> pair with <code>value</code> is found; otherwise returns <code>false</code>. After the call, if <code>value</code> was found, the iterator is positioned just before the matching item; otherwise, the iterator is positioned at the front of the container.</li>
<li><code>bool QMapIterator::hasNext() const</code>：Returns <code>true</code> if there is at least one item ahead of the iterator, i.e. the iterator is not at the back of the container; otherwise returns <code>false</code>.</li>
<li><code>bool QMapIterator::hasPrevious() const</code>：Returns <code>true</code> if there is at least one item behind the iterator, i.e. the iterator is not at the front of the container; otherwise returns <code>false</code>.</li>
<li><code>const Key &amp; QMapIterator::key() const</code>：Returns the key of the last item that was jumped over using one of the traversal functions (<code>next()</code>, <code>previous()</code>, <code>findNext()</code>, <code>findPrevious()</code>). After a call to <code>next()</code> or <code>findNext()</code>, <code>key()</code> is equivalent to <code>peekPrevious().key()</code>. After a call to <code>previous()</code> or <code>findPrevious()</code>, <code>key()</code> is equivalent to <code>peekNext().key()</code>.</li>
<li><code>Item QMapIterator::next()</code>：Returns the next item and advances the iterator by one position. Call <code>key()</code> on the return value to obtain the item’s key, and <code>value()</code> to obtain the value. Calling this function on an iterator located at the back of the container leads to undefined results.</li>
<li><code>Item QMapIterator::peekNext() const</code>：Returns the next item without moving the iterator. Call <code>key()</code> on the return value to obtain the item’s key, and <code>value()</code> to obtain the value. Calling this function on an iterator located at the back of the container leads to undefined results.</li>
<li><code>Item QMapIterator::peekPrevious() const</code>：Returns the previous item without moving the iterator. Call <code>key()</code> on the return value to obtain the item’s key, and <code>value()</code> to obtain the value. Calling this function on an iterator located at the front of the container leads to undefined results.</li>
<li><code>Item QMapIterator::previous()</code>：Returns the previous item and moves the iterator back by one position. Call <code>key()</code> on the return value to obtain the item’s key, and <code>value()</code> to obtain the value. Calling this function on an iterator located at the front of the container leads to undefined results.</li>
<li><code>void QMapIterator::toBack()</code>：Moves the iterator to the back of the container (after the last item).</li>
<li><code>void QMapIterator::toFront()</code>：Moves the iterator to the front of the container (before the first item).</li>
<li><code>const T &amp; QMapIterator::value() const</code>：Returns the value of the last item that was jumped over using one of the traversal functions (<code>next()</code>, <code>previous()</code>, <code>findNext()</code>, <code>findPrevious()</code>). After a call to <code>next()</code> or <code>findNext()</code>, <code>value()</code> is equivalent to <code>peekPrevious().value()</code>. After a call to <code>previous()</code> or <code>findPrevious()</code>, <code>value()</code> is equivalent to <code>peekNext().value()</code>.</li>
<li><code>QMapIterator &amp; QMapIterator::operator=(const QMap&lt;Key, T&gt; &amp; map)</code>：Makes the iterator operate on <code>map</code>. The iterator is set to be at the front of the <code>map</code> (before the first item).</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/18/Qt语法详解/Qt之QFrame/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/Qt语法详解/Qt之QFrame/" itemprop="url">Qt之QFrame</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T15:53:34+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>QFrame</code>类是有框架的窗口部件的基类，其头文件是<code>qframe.h</code>。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>QRect contentsRect</code>：框架内的矩形。</li>
<li><code>QRect frameRect</code>：框架矩形。</li>
<li><code>Shadow frameShadow</code>：来自框架风格的框架阴影值。</li>
<li><code>Shape frameShape</code>：来自框架风格的框架外形值。</li>
<li><code>int frameWidth</code>：被绘制的框架的宽度。</li>
<li><code>int lineWidth</code>：线宽。</li>
<li><code>int margin</code>：边白的宽度。</li>
<li><code>int midLineWidth</code>：中间的线的宽度。</li>
</ul>
<h3 id="保护成员"><a href="#保护成员" class="headerlink" title="保护成员"></a>保护成员</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">paintEvent</span> <span class="params">( QPaintEvent *event )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">resizeEvent</span> <span class="params">( QResizeEvent *e )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">drawFrame</span> <span class="params">( QPainter *p )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">drawContents</span> <span class="params">( QPainter * )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">frameChanged</span> <span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h3><p>&emsp;&emsp;<code>QFrame</code>类是有框架的窗口部件的基类。它绘制框架，并且调用一个虚函数<code>drawContents</code>来填充这个框架，这个函数是被子类重新实现的。这里至少还有两个有用的函数：<code>drawFrame</code>和<code>frameChanged</code>。<br>&emsp;&emsp;<code>QPopupMenu</code>用于把菜单<code>升高</code>，高于周围屏幕；<code>QProgressBar</code>有<code>凹陷</code>的外观；<code>QLabel</code>有平坦的外观。这些有框架的窗口部件可以被改变：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QLabel <span class="title">label</span> <span class="params">( ... )</span></span>;</span><br><span class="line">label.setFrameStyle ( QFrame::Panel | QFrame::Raised );</span><br><span class="line">label.setLineWidth ( <span class="number">2</span> );</span><br><span class="line">​</span><br><span class="line"><span class="function">QProgressBar <span class="title">pbar</span> <span class="params">( ... )</span></span>;</span><br><span class="line">label.setFrameStyle ( QFrame::NoFrame );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>QFrame</code>类也能够直接被用来创建没有任何内容的简单框架，通常情况下你要用到<code>QHBox</code>或<code>QVBox</code>，因为它们可以自动地布置你放到框架中的窗口部件。<br>&emsp;&emsp;框架窗口部件有四个属性：<code>frameStyle</code>、<code>lineWidth</code>、<code>midLineWidth</code>和<code>margin</code>。框架风格由框架外形和阴影风格决定，框架外形有<code>NoFrame</code>、<code>Box</code>、<code>Panel</code>、<code>StyledPanel</code>、<code>PopupPanel</code>、<code>WinPanel</code>、<code>ToolBarPanel</code>、<code>MenuBarPanel</code>、<code>HLine</code>和<code>VLine</code>，阴影风格有<code>Plain</code>、<code>Raised</code>和<code>Sunken</code>。<br>&emsp;&emsp;线宽就是框架边界的宽度。中间线宽指定的是在框架中间的另外一条线的宽度，它使用第三种颜色来得到一个三维的效果。注意，中间线只有在<code>Box</code>、<code>HLine</code>和<code>VLine</code>这些凸起和凹陷的框架中才被绘制。边白就是框架和框架内容之间的间隙。下面的表格显示的是风格和宽度的绝大多数有用的组合：</p>
<p><img src="/2019/02/18/Qt语法详解/Qt之QFrame/1.png" height="276" width="342"></p>
<h3 id="成员类型文档"><a href="#成员类型文档" class="headerlink" title="成员类型文档"></a>成员类型文档</h3><p>&emsp;&emsp;<code>QFrame::Shadow</code>这个枚举类型定义了<code>QFrame</code>的框架所使用的三维效果。当前定义的效果有：</p>
<ul>
<li><code>QFrame::Plain</code>：框架和内容看来和周围一样高。</li>
<li><code>QFrame::Raised</code>：框架和内容看起来凸起。</li>
<li><code>QFrame::Sunken</code>：框架和内容看起来凹陷。</li>
<li><code>QFrame::MShadow</code>：内部的，对于阴影的掩码。</li>
</ul>
<p>&emsp;&emsp;<code>Shadow</code>和<code>QFrame::Shape</code>、<code>lineWidth</code>和<code>midLineWidth</code>相互作用。类文档中的框架的图片描绘的比这些词语更好。<br>&emsp;&emsp;<code>QFrame::Shape</code>这个枚举类型定义了<code>QFrame</code>的框架所使用的外形。当前定义的效果有：</p>
<ul>
<li><code>NoFrame</code>：<code>QFrame</code>不画任何东西。</li>
<li><code>Box</code>：<code>QFrame</code>在它的内容周围画一个框。</li>
<li><code>Panel</code>：<code>QFrame</code>画一个平板使内容看起来凸起或者凹陷。</li>
<li><code>WinPanel</code>：类似于<code>Panel</code>，但<code>QFrame</code>绘制三维效果的方式和<code>Microsoft Windows 95</code>的一样。</li>
<li><code>ToolBarPanel</code>：<code>QFrame</code>调用<code>QStyle::drawToolBarPanel</code>。</li>
<li><code>MenuBarPanel</code>：<code>QFrame</code>调用<code>QStyle::drawMenuBarPanel</code>。</li>
<li><code>HLine</code>：<code>QFrame</code>绘制一个水平线，但没有框任何东西(作为分隔是有用的)。</li>
<li><code>VLine</code>：<code>QFrame</code>绘制一个竖直线，但没有框任何东西(作为分隔是有用的)。</li>
<li><code>StyledPanel</code>：<code>QFrame</code>调用<code>QStyle::drawPanel</code>。</li>
<li><code>PopupPanel</code>：<code>QFrame</code>调用<code>QStyle::drawPopupPanel</code>。</li>
</ul>
<p>&emsp;&emsp;当它不调用<code>QStyle</code>时，<code>Shape</code>和<code>QFrame::Shadow</code>、<code>lineWidth</code>和<code>midLineWidth</code>相互作用来创建整个结果。</p>
<h3 id="成员函数文档"><a href="#成员函数文档" class="headerlink" title="成员函数文档"></a>成员函数文档</h3><ul>
<li><code>QFrame::QFrame ( QWidget * parent = 0, const char * name = 0, WFlags f = 0 )</code>：构造一个框架风格为<code>NoFrame</code>并且<code>1</code>像素框架宽度的框架窗口部件。<code>parent</code>、<code>name</code>和<code>f</code>参数被传递给<code>QWidget</code>的构造函数。</li>
<li><code>QRect QFrame::contentsRect () const</code>：返回框架内的矩形。</li>
<li><code>void QFrame::drawContents ( QPainter * ) [虚 保护]</code>：绘制框架内容的虚函数。当你得到<code>QPainter</code>时，它已经被打开，并且在你离开时，它也必须是打开的。绘制工具的转换在真个过程中是被关闭的。如果你转换绘制工具，记得考虑框架并且在返回前重置转换。这个函数在子类中被重新实现用来绘制框架中的一些东西。它只能在<code>contentsRect</code>内绘制，默认函数什么都不做。</li>
<li><code>void QFrame::drawFrame ( QPainter * p ) [虚 保护]</code>：使用绘制工具<code>p</code>和当前框架属性和颜色组绘制框架。框架内的矩形不受影响。这个函数是虚函数，但通常情况下你不需要重新实现它。如果你要做，注意<code>QPainter</code>已经被打开并且必须保持打开的状态。</li>
<li><code>void QFrame::frameChanged () [虚 保护]</code>：当框架风格、线宽和中间线宽发生改变时，这个虚函数被调用。这个函数在子类中可以被重新实现，它需要知道什么时候框架属性发生变化。默认实现是调用<code>update</code>。</li>
<li><code>QRect QFrame::frameRect () const</code>：返回框架矩形。</li>
<li><code>Shadow QFrame::frameShadow () const</code>：返回来自框架风格的框架阴影值。</li>
<li><code>Shape QFrame::frameShape () const</code>：返回来自框架风格的框架外形值。</li>
<li><code>int QFrame::frameStyle () const</code>：返回框架风格，默认值是<code>QFrame::NoFrame</code>。</li>
<li><code>int QFrame::frameWidth () const</code>：返回所绘制的框架的宽度。</li>
<li><code>int QFrame::lineWidth () const</code>：返回线宽。</li>
<li><code>int QFrame::margin () const</code>：返回边白的宽度。</li>
<li><code>int QFrame::midLineWidth () const</code>：返回中间线的宽度。</li>
<li><code>void QFrame::paintEvent ( QPaintEvent * event ) [虚、保护]</code>：处理绘制事件<code>event</code>，绘制框架和内容。打开框架上的绘制工具并且调用<code>drawFrame</code>，然后是<code>drawContents</code>。</li>
<li><code>void QFrame::resizeEvent ( QResizeEvent * e ) [虚、保护]</code>：处理重定义大小事件<code>e</code>。对于被重新定义大小的窗口部件，调整框架矩形。框架矩形是弹性的，并且周围的区域是固定的。结果框架矩形也许是零或者无效，你可以使用<code>setMinimumSize</code>来避免这种可能。如果框架矩形已经是一个零矩形，那么将不会做任何事。</li>
<li><code>void QFrame::setFrameRect ( const QRect &amp; ) [虚]</code>：设置框架矩形。</li>
<li><code>void QFrame::setFrameShadow ( Shadow )</code>：设置来自框架风格的框架阴影值。</li>
<li><code>void QFrame::setFrameShape ( Shape )</code>：设置来自框架风格的框架外形值。</li>
<li><code>void QFrame::setFrameStyle ( int style ) [虚]</code>：设置框架风格为<code>style</code>。<code>style</code>是框架外形和框架阴影风格的位或操作：</li>
</ul>
<ol>
<li><code>NoFrame</code>：不绘制任何东西。</li>
<li><code>Box</code>：绘制矩形框。内容看起来和周围的屏幕一样高，但是边界本身也许凸起或凹陷。</li>
<li><code>Panel</code>：绘制矩形凸起或凹陷的平板。</li>
<li><code>StyledPanel</code>：绘制一个依赖于当前<code>GUI</code>风格的矩形平板。它可能是凸起的，也可能是凹陷的。</li>
<li><code>PopupPanel</code>：绘制用于弹出窗口的框架。它的外观也依赖于当前<code>GUI</code>风格，通常和<code>StyledPanel</code>一样。</li>
<li><code>ToolBarPanel</code>：绘制用于工具条的框架。它的外观也依赖于当前<code>GUI</code>风格。</li>
<li><code>MenuBarPanel</code>：绘制用于菜单条的框架。它的外观也依赖于当前<code>GUI</code>风格。</li>
<li><code>LineEditPanel</code>：绘制用于行编辑的框架。它的外观也依赖于当前<code>GUI</code>风格。</li>
<li><code>TabWidgetPanel</code>：绘制用于<code>Tab</code>窗口部件的框架。它的外观也依赖于当前<code>GUI</code>风格。</li>
<li><code>WinPanel</code>：绘制一个和<code>Windows 95</code>一样的凸起或凹陷的矩形平板。指定这个外形设置线宽为<code>2</code>像素。<code>WinPanel</code>的提供是为了兼容性。为了使<code>GUI</code>风格独立，我们建议使用<code>StyledPanel</code>替换它。</li>
<li><code>HLine</code>：绘制一条水平线(垂直中央)。</li>
<li><code>VLine</code>：绘制一条垂直线(水平中央)。</li>
</ol>
<p>&emsp;&emsp;阴影风格有：</p>
<ol>
<li><code>Plain</code>：使用调色板的前景颜色绘制(没有任何三维效果)。</li>
<li><code>Raised</code>：使用当前颜色组的亮和暗颜色绘制三维的凸起线。</li>
<li><code>Sunken</code>：使用当前颜色组的亮和暗颜色绘制三维的凹陷线。</li>
</ol>
<p>如果被指定的中间线宽大于<code>0</code>，在<code>Raised</code>或<code>Sunken</code>、<code>HLine</code>和<code>VLine</code>框架中会被绘制一条另外的线。当前颜色组的中间颜色被用于绘制中间线。</p>
<ul>
<li><code>void QFrame::setLineWidth ( int ) [虚]</code>：设置线宽。</li>
<li><code>void QFrame::setMargin ( int ) [虚]</code>：设置边白的宽度。</li>
<li><code>void QFrame::setMidLineWidth ( int ) [虚]</code>：设置中间线的宽度。</li>
</ul>
<h3 id="属性文档"><a href="#属性文档" class="headerlink" title="属性文档"></a>属性文档</h3><ul>
<li><code>QRect contentsRect</code>：这个属性保存的是框架内的矩形。使用<code>contentsRect</code>来得到这个属性值。</li>
<li><code>QRect frameRect</code>：这个属性保存的是框架矩形，框架矩形是被画的框架所在的矩形，默认情况下是整个窗口部件。设置这个属性不会导致窗口部件更新。如果这个属性被设置为零矩形(比如<code>QRect(0, 0, 0, 0)</code>)，那么框架矩形将会等于窗口部件矩形。使用<code>setFrameRect</code>来设置这个属性值，并且使用<code>frameRect</code>来得到这个属性值。</li>
<li><code>Shadow frameShadow</code>：这个属性保存的是来自框架风格的框架阴影值。使用<code>setFrameShadow</code>来设置这个属性值，并且使用<code>frameShadow</code>来得到这个属性值。</li>
<li><code>Shape frameShape</code>：这个属性用来操存的是来自框架风格的框架外形值。使用<code>setFrameShape</code>来设置这个属性值，并且使用<code>frameShape</code>来得到这个属性值。</li>
<li><code>int frameWidth</code>：这个属性保存的是被绘制的框架的宽度。注意框架宽度依赖于框架风格、线宽和中间线宽。比如在<code>NoFrame</code>风格下，框架宽度为<code>0</code>；而在<code>Panel</code>风格下，框架宽度和线宽相同。框架宽度也包括边白。使用<code>frameWidth</code>来得到这个属性值。</li>
<li><code>int lineWidth</code>：这个属性保存的是线宽。注意<code>HLine</code>和<code>VLine</code>的总线宽由<code>frameWidth</code>给定，而不是<code>lineWidth</code>，默认值为<code>1</code>。使用<code>setLineWidth</code>来设置这个属性值并且使用<code>lineWidth</code>来得到这个属性值。</li>
<li><code>int margin</code>：这个属性保存的是边白的宽度。边白是框架最里面的像素和<code>contentsRect</code>最外面的像素之间的区域。它被包含在<code>frameWidth</code>中。边白是根据<code>backgroundMode</code>被填充的，默认值为<code>0</code>。使用<code>setMargin</code>来设置这个属性值，并且使用<code>margin</code>来得到这个属性值。</li>
<li><code>int midLineWidth</code>：这个属性保存的是中间线的宽度，默认值为<code>0</code>。使用<code>setMidLineWidth</code>来设置这个属性值，并且使用<code>midLineWidth</code>来得到这个属性值。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/18/Qt语法详解/Qt之QListIterator/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/Qt语法详解/Qt之QListIterator/" itemprop="url">Qt之QListIterator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T15:24:17+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QListIterator</code> class provides a <code>Java-style</code> const iterator for <code>QList</code> and <code>QQueue</code>. The header file is <code>QListIterator</code>.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QListIterator(const QList&lt;T&gt; &amp; list)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>findNext(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>findPrevious(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasNext() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasPrevious() const</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>next()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>peekNext() const</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>peekPrevious() const</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>previous()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>toBack()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>toFront()</code></td>
</tr>
<tr>
<td><code>QListIterator &amp;</code></td>
<td><code>operator=(const QList&lt;T&gt; &amp; list)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QListIterator</code> class provides a <code>Java-style</code> const iterator for <code>QList</code> and <code>QQueue</code>.<br>&emsp;&emsp;<code>QList</code> has both <code>Java-style</code> iterators and <code>STL-style</code> iterators. The <code>Java-style</code> iterators are more <code>high-level</code> and easier to use than the <code>STL-style</code> iterators; on the other hand, they are slightly less efficient.<br>&emsp;&emsp;An alternative to using iterators is to use index positions. Most <code>QList</code> member functions take an index as their first parameter, making it possible to access, modify, and remove items without using iterators.<br>&emsp;&emsp;<code>QListIterator&lt;T&gt;</code> allows you to iterate over a <code>QList&lt;T&gt;</code> (or a <code>QQueue&lt;T&gt;</code>). If you want to modify the list as you iterate over it, use <code>QMutableListIterator&lt;T&gt;</code> instead.<br>&emsp;&emsp;The <code>QListIterator</code> constructor takes a <code>QList</code> as argument. After construction, the iterator is located at the very beginning of the list (before the first item). Here’s how to iterate over all the elements sequentially:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;<span class="keyword">float</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">​</span><br><span class="line">QListIterator&lt;<span class="keyword">float</span>&gt; i ( <span class="built_in">list</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i.hasNext() ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; i.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>next()</code> function returns the next item in the list and advances the iterator. Unlike <code>STL-style</code> iterators, <code>Java-style</code> iterators point between items rather than directly at items. The first call to <code>next()</code> advances the iterator to the position between the first and second item, and returns the first item; the second call to <code>next()</code> advances the iterator to the position between the second and third item, and returns the second item; and so on.</p>
<p><img src="/2019/02/18/Qt语法详解/Qt之QListIterator/1.png"></p>
<p>&emsp;&emsp;Here’s how to iterate over the elements in reverse order:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QListIterator&lt;<span class="keyword">float</span>&gt; i ( <span class="built_in">list</span> );</span><br><span class="line">i.toBack();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i.hasPrevious() ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; i.previous();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If you want to find all occurrences of a particular value, use <code>findNext()</code> or <code>findPrevious()</code> in a loop.<br>&emsp;&emsp;Multiple iterators can be used on the same list. If the list is modified while a <code>QListIterator</code> is active, the <code>QListIterator</code> will continue iterating over the original list, ignoring the modified copy.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QListIterator::QListIterator(const QList&lt;T&gt; &amp; list)</code>: Constructs an iterator for traversing <code>list</code>. The iterator is set to be at the front of the <code>list</code> (before the first item).</li>
<li><code>bool QListIterator::findNext(const T &amp; value)</code>: Searches for <code>value</code> starting from the current iterator position forward. Returns <code>true</code> if <code>value</code> is found; otherwise returns <code>false</code>. After the call, if <code>value</code> was found, the iterator is positioned just after the matching item; otherwise, the iterator is positioned at the back of the container.</li>
<li><code>bool QListIterator::findPrevious(const T &amp; value)</code>: Searches for <code>value</code> starting from the current iterator position backward. Returns <code>true</code> if <code>value</code> is found; otherwise returns <code>false</code>. After the call, if <code>value</code> was found, the iterator is positioned just before the matching item; otherwise, the iterator is positioned at the front of the container.</li>
<li><code>bool QListIterator::hasNext() const</code>: Returns <code>true</code> if there is at least one item ahead of the iterator, i.e. the iterator is not at the back of the container; otherwise returns <code>false</code>.</li>
<li><code>bool QListIterator::hasPrevious() const</code>: Returns <code>true</code> if there is at least one item behind the iterator, i.e. the iterator is not at the front of the container; otherwise returns <code>false</code>.</li>
<li><code>const T &amp; QListIterator::next()</code>: Returns the next item and advances the iterator by one position. Calling this function on an iterator located at the back of the container leads to undefined results.</li>
<li><code>const T &amp; QListIterator::peekNext() const</code>: Returns the next item without moving the iterator. Calling this function on an iterator located at the back of the container leads to undefined results.</li>
<li><code>const T &amp; QListIterator::peekPrevious() const</code>: Returns the previous item without moving the iterator. Calling this function on an iterator located at the front of the container leads to undefined results.</li>
<li><code>const T &amp; QListIterator::previous()</code>: Returns the previous item and moves the iterator back by one position. Calling this function on an iterator located at the front of the container leads to undefined results.</li>
<li><code>void QListIterator::toBack()</code>: Moves the iterator to the back of the container (after the last item).</li>
<li><code>void QListIterator::toFront()</code>: Moves the iterator to the front of the container (before the first item).</li>
<li><code>QListIterator &amp; QListIterator::operator=(const QList&lt;T&gt; &amp; list)</code>: Makes the iterator operate on <code>list</code>. The iterator is set to be at the front of the <code>list</code> (before the first item).</li>
</ul>
<p>&emsp;&emsp;<strong>补充说明</strong>：<code>JAVA</code>风格的迭代器是指向项目之间的，而不是直接指向项目。迭代器或者指向容器的最前面，或者指向两个项目之间，或者指向容器的最后面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/18/Qt语法详解/Qt之QPrinter/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/Qt语法详解/Qt之QPrinter/" itemprop="url">Qt之QPrinter</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T11:15:19+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QPrinter</code> class is a paint device that paints on a printer.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter</code></td>
<td><code>QPaintDevice</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QPrinter(PrinterMode mode = ScreenResolution)</code></td>
</tr>
<tr>
<td></td>
<td><code>QPrinter(const QPrinterInfo &amp; printer, PrinterMode mode = ScreenResolution)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QPrinter()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>abort()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>collateCopies() const</code></td>
</tr>
<tr>
<td><code>ColorMode</code></td>
<td><code>colorMode() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>copyCount() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>creator() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>docName() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>doubleSidedPrinting() const</code></td>
</tr>
<tr>
<td><code>DuplexMode</code></td>
<td><code>duplex() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>fontEmbeddingEnabled() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>fromPage() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>fullPage() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>getPageMargins(qreal * left, qreal * top, qreal * right, qreal * bottom, Unit unit) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isValid() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>newPage()</code></td>
</tr>
<tr>
<td><code>Orientation</code></td>
<td><code>orientation() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>outputFileName() const</code></td>
</tr>
<tr>
<td><code>OutputFormat</code></td>
<td><code>outputFormat() const</code></td>
</tr>
<tr>
<td><code>PageOrder</code></td>
<td><code>pageOrder() const</code></td>
</tr>
<tr>
<td><code>QRect</code></td>
<td><code>pageRect() const</code></td>
</tr>
<tr>
<td><code>QRectF</code></td>
<td><code>pageRect(Unit unit) const</code></td>
</tr>
<tr>
<td><code>QRect</code></td>
<td><code>paperRect() const</code></td>
</tr>
<tr>
<td><code>QRectF</code></td>
<td><code>paperRect(Unit unit) const</code></td>
</tr>
<tr>
<td><code>PaperSize</code></td>
<td><code>paperSize() const</code></td>
</tr>
<tr>
<td><code>QSizeF</code></td>
<td><code>paperSize(Unit unit) const</code></td>
</tr>
<tr>
<td><code>PaperSource</code></td>
<td><code>paperSource() const</code></td>
</tr>
<tr>
<td><code>QPrintEngine *</code></td>
<td><code>printEngine() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>printProgram() const</code></td>
</tr>
<tr>
<td><code>PrintRange</code></td>
<td><code>printRange() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>printerName() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>printerSelectionOption() const</code></td>
</tr>
<tr>
<td><code>PrinterState</code></td>
<td><code>printerState() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>resolution() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCollateCopies(bool collate)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setColorMode(ColorMode newColorMode)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCopyCount(int count)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCreator(const QString &amp; creator)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDocName(const QString &amp; name)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDoubleSidedPrinting(bool doubleSided)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDuplex(DuplexMode duplex)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontEmbeddingEnabled(bool enable)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFromTo(int from, int to)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFullPage(bool fp)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setOrientation(Orientation orientation)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setOutputFileName(const QString &amp; fileName)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setOutputFormat(OutputFormat format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPageMargins(qreal left, qreal top, qreal right, qreal bottom, Unit unit)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPageOrder(PageOrder pageOrder)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPaperSize(PaperSize newPaperSize)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPaperSize(const QSizeF &amp; paperSize, Unit unit)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPaperSource(PaperSource source)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPrintProgram(const QString &amp; printProg)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPrintRange(PrintRange range)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPrinterName(const QString &amp; name)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPrinterSelectionOption(const QString &amp; option)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setResolution(int dpi)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setWinPageSize(int pageSize)</code></td>
</tr>
<tr>
<td><code>QList&lt;PaperSource&gt;</code></td>
<td><code>supportedPaperSources() const</code></td>
</tr>
<tr>
<td><code>QList&lt;int&gt;</code></td>
<td><code>supportedResolutions() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>supportsMultipleCopies() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>toPage() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>winPageSize() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Public-Functions"><a href="#Reimplemented-Public-Functions" class="headerlink" title="Reimplemented Public Functions"></a>Reimplemented Public Functions</h3><ul>
<li><code>virtual QPaintEngine * paintEngine() const;</code></li>
</ul>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><ul>
<li><code>void setEngines(QPrintEngine * printEngine, QPaintEngine * paintEngine);</code></li>
</ul>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QPrinter</code> class is a paint device that paints on a printer.<br>&emsp;&emsp;This device represents a series of pages of printed output, and is used in almost exactly the same way as other paint devices such as <code>QWidget</code> and <code>QPixmap</code>. A set of additional functions are provided to manage <code>device-specific</code> features, such as orientation and resolution, and to step through the pages in a document as it is generated.<br>&emsp;&emsp;When printing directly to a printer on <code>Windows</code> or <code>Mac OS X</code>, <code>QPrinter</code> uses the <code>built-in</code> printer drivers. On <code>X11</code>, <code>QPrinter</code> uses the <code>Common Unix Printing System</code> (<code>CUPS</code>) or the standard <code>Unix</code> lpr utility to send <code>PostScript</code> or <code>PDF</code> output to the printer. As an alternative, the <code>printProgram()</code> function can be used to specify the command or utility to use instead of the system default.<br>&emsp;&emsp;Note that setting parameters like paper size and resolution on an invalid printer is undefined. You can use <code>QPrinter::isValid()</code> to verify this before changing any parameters.<br>&emsp;&emsp;<code>QPrinter</code> supports a number of parameters, most of which can be changed by the end user through a print dialog. In general, <code>QPrinter</code> passes these functions onto the underlying <code>QPrintEngine</code>.<br>&emsp;&emsp;The most important parameters are:</p>
<ul>
<li><code>setOrientation()</code> tells <code>QPrinter</code> which page orientation to use.</li>
<li><code>setPaperSize()</code> tells <code>QPrinter</code> what paper size to expect from the printer.</li>
<li><code>setResolution()</code> tells <code>QPrinter</code> what resolution you wish the printer to provide, in dots per inch (<code>DPI</code>).</li>
<li><code>setFullPage()</code> tells <code>QPrinter</code> whether you want to deal with the full page or just with the part the printer can draw on.</li>
<li><code>setCopyCount()</code> tells <code>QPrinter</code> how many copies of the document it should print.</li>
</ul>
<p>&emsp;&emsp;Many of these functions can only be called before the actual printing begins (i.e., before <code>QPainter::begin()</code> is called). This usually makes sense because, for example, it’s not possible to change the number of copies when you are halfway through printing. There are also some settings that the user sets (through the printer dialog) and that applications are expected to obey.<br>&emsp;&emsp;When <code>QPainter::begin()</code> is called, the <code>QPrinter</code> it operates on is prepared for a new page, enabling the <code>QPainter</code> to be used immediately to paint the first page in a document. Once the first page has been painted, <code>newPage()</code> can be called to request a new blank page to paint on, or <code>QPainter::end()</code> can be called to finish printing. The second page and all following pages are prepared using a call to <code>newPage()</code> before they are painted.<br>&emsp;&emsp;The first page in a document does not need to be preceded by a call to <code>newPage()</code>. You only need to calling <code>newPage()</code> after <code>QPainter::begin()</code> if you need to insert a blank page at the beginning of a printed document. Similarly, calling <code>newPage()</code> after the last page in a document is painted will result in a trailing blank page appended to the end of the printed document.<br>&emsp;&emsp;If you want to abort the print job, <code>abort()</code> will try its best to stop printing. It may cancel the entire job or just part of it.<br>&emsp;&emsp;Since <code>QPrinter</code> can print to any <code>QPrintEngine</code> subclass, it is possible to extend printing support to cover new types of printing subsystem by subclassing <code>QPrintEngine</code> and reimplementing its interface.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QPrinter::ColorMode</code>: This enum type is used to indicate whether <code>QPrinter</code> should print in color or not.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::Color</code></td>
<td><code>1</code></td>
<td>print in color if available, otherwise in grayscale.</td>
</tr>
<tr>
<td><code>QPrinter::GrayScale</code></td>
<td><code>0</code></td>
<td>print in grayscale, even on color printers.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QPrinter::DuplexMode</code>: This enum is used to indicate whether printing will occur on one or both sides of each sheet of paper (simplex or duplex printing).</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::DuplexNone</code></td>
<td><code>0</code></td>
<td>Single sided (simplex) printing only.</td>
</tr>
<tr>
<td><code>QPrinter::DuplexAuto</code></td>
<td><code>1</code></td>
<td>The printer’s default setting is used to determine whether duplex printing is used.</td>
</tr>
<tr>
<td><code>QPrinter::DuplexLongSide</code></td>
<td><code>2</code></td>
<td>Both sides of each sheet of paper are used for printing. The paper is turned over its longest edge before the second side is printed</td>
</tr>
<tr>
<td><code>QPrinter::DuplexShortSide</code></td>
<td><code>3</code></td>
<td>Both sides of each sheet of paper are used for printing. The paper is turned over its shortest edge before the second side is printed</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QPrinter::Orientation</code>: This enum type (not to be confused with <code>Orientation</code>) is used to specify each page’s orientation.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::Portrait</code></td>
<td><code>0</code></td>
<td>the page’s height is greater than its width.</td>
</tr>
<tr>
<td><code>QPrinter::Landscape</code></td>
<td><code>1</code></td>
<td>the page’s width is greater than its height.</td>
</tr>
</tbody>
</table>
</div>
<p>This type interacts with <code>QPrinter::PaperSize</code> and <code>QPrinter::setFullPage()</code> to determine the final size of the page available to the application.</p>
<ul>
<li>enum <code>QPrinter::OutputFormat</code>: The <code>OutputFormat</code> enum is used to describe the format <code>QPrinter</code> should use for printing.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::NativeFormat</code></td>
<td><code>0</code></td>
<td><code>QPrinter</code> will print output using a method defined by the platform it is running on. This mode is the default when printing directly to a printer.</td>
</tr>
<tr>
<td><code>QPrinter::PdfFormat</code></td>
<td><code>1</code></td>
<td><code>QPrinter</code> will generate its output as a searchable <code>PDF</code> file. This mode is the default when printing to a file.</td>
</tr>
<tr>
<td><code>QPrinter::PostScriptFormat</code></td>
<td><code>2</code></td>
<td><code>QPrinter</code> will generate its output as in the <code>PostScript</code> format.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QPrinter::PageOrder</code>: This enum type is used by <code>QPrinter</code> to tell the application program how to print.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::FirstPageFirst</code></td>
<td><code>0</code></td>
<td>the <code>lowest-numbered</code> page should be printed first.</td>
</tr>
<tr>
<td><code>QPrinter::LastPageFirst</code></td>
<td><code>1</code></td>
<td>the <code>highest-numbered</code> page should be printed first.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QPrinter::PaperSize</code>: This enum type specifies what paper size <code>QPrinter</code> should use. <code>QPrinter</code> does not check that the paper size is available; it just uses this information, together with <code>QPrinter::Orientation</code> and <code>QPrinter::setFullPage()</code>, to determine the printable area.</li>
</ul>
<p>&emsp;&emsp;The defined sizes (with <code>setFullPage(true)</code>) are:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::A0</code></td>
<td><code>5</code></td>
<td><code>841 x 1189</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::A1</code></td>
<td><code>6</code></td>
<td><code>594 x 841</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::A2</code></td>
<td><code>7</code></td>
<td><code>420 x 594</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::A3</code></td>
<td><code>8</code></td>
<td><code>297 x 420</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::A4</code></td>
<td><code>0</code></td>
<td><code>210 x 297</code> mm, <code>8.26 x 11.69</code> inches</td>
</tr>
<tr>
<td><code>QPrinter::A5</code></td>
<td><code>9</code></td>
<td><code>148 x 210</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::A6</code></td>
<td><code>10</code></td>
<td><code>105 x 148</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::A7</code></td>
<td><code>11</code></td>
<td><code>74 x 105</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::A8</code></td>
<td><code>12</code></td>
<td><code>52 x 74</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::A9</code></td>
<td><code>13</code></td>
<td><code>37 x 52</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B0</code></td>
<td><code>14</code></td>
<td><code>1000 x 1414</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B1</code></td>
<td><code>15</code></td>
<td><code>707 x 1000</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B2</code></td>
<td><code>17</code></td>
<td><code>500 x 707</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B3</code></td>
<td><code>18</code></td>
<td><code>353 x 500</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B4</code></td>
<td><code>19</code></td>
<td><code>250 x 353</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B5</code></td>
<td><code>1</code></td>
<td><code>176 x 250</code> mm, <code>6.93 x 9.84</code> inches</td>
</tr>
<tr>
<td><code>QPrinter::B6</code></td>
<td><code>20</code></td>
<td><code>125 x 176</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B7</code></td>
<td><code>21</code></td>
<td><code>88 x 125</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B8</code></td>
<td><code>22</code></td>
<td><code>62 x 88</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B9</code></td>
<td><code>23</code></td>
<td><code>33 x 62</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::B10</code></td>
<td><code>16</code></td>
<td><code>31 x 44</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::C5E</code></td>
<td><code>24</code></td>
<td><code>163 x 229</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::Comm10E</code></td>
<td><code>25</code></td>
<td><code>105 x 241</code> mm, U.S. Common <code>10</code> Envelope</td>
</tr>
<tr>
<td><code>QPrinter::DLE</code></td>
<td><code>26</code></td>
<td><code>110 x 220</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::Executive</code></td>
<td><code>4</code></td>
<td><code>7.5 x 10</code> inches, <code>190.5 x 254</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::Folio</code></td>
<td><code>27</code></td>
<td><code>210 x 330</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::Ledger</code></td>
<td><code>28</code></td>
<td><code>431.8 x 279.4</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::Legal</code></td>
<td><code>3</code></td>
<td><code>8.5 x 14</code> inches, <code>215.9 x 355.6</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::Letter</code></td>
<td><code>2</code></td>
<td><code>8.5 x 11</code> inches, <code>215.9 x 279.4</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::Tabloid</code></td>
<td><code>29</code></td>
<td><code>279.4 x 431.8</code> mm</td>
</tr>
<tr>
<td><code>QPrinter::Custom</code></td>
<td><code>30</code></td>
<td>Unknown, or a user defined size.</td>
</tr>
</tbody>
</table>
</div>
<p>With <code>setFullPage(false)</code> (the default), the metrics will be a bit smaller; how much depends on the printer in use.</p>
<ul>
<li>enum <code>QPrinter::PaperSource</code>: This enum type specifies what paper source <code>QPrinter</code> is to use. <code>QPrinter</code> does not check that the paper source is available; it just uses this information to try and set the paper source. Whether it will set the paper source depends on whether the printer has that particular source. <strong>Warning</strong>: This is currently only implemented for <code>Windows</code>.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::Auto</code></td>
<td><code>6</code></td>
</tr>
<tr>
<td><code>QPrinter::Cassette</code></td>
<td><code>11</code></td>
</tr>
<tr>
<td><code>QPrinter::Envelope</code></td>
<td><code>4</code></td>
</tr>
<tr>
<td><code>QPrinter::EnvelopeManual</code></td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>QPrinter::FormSource</code></td>
<td><code>12</code></td>
</tr>
<tr>
<td><code>QPrinter::LargeCapacity</code></td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>QPrinter::LargeFormat</code></td>
<td><code>9</code></td>
</tr>
<tr>
<td><code>QPrinter::Lower</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>QPrinter::MaxPageSource</code></td>
<td><code>13</code></td>
</tr>
<tr>
<td><code>QPrinter::Middle</code></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>QPrinter::Manual</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td><code>QPrinter::OnlyOne</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>QPrinter::Tractor</code></td>
<td><code>7</code></td>
</tr>
<tr>
<td><code>QPrinter::SmallFormat</code></td>
<td><code>8</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QPrinter::PrintRange</code>: Used to specify the print range selection option.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::AllPages</code></td>
<td><code>0</code></td>
<td>All pages should be printed.</td>
</tr>
<tr>
<td><code>QPrinter::Selection</code></td>
<td><code>1</code></td>
<td>Only the selection should be printed.</td>
</tr>
<tr>
<td><code>QPrinter::PageRange</code></td>
<td><code>2</code></td>
<td>The specified page range should be printed.</td>
</tr>
<tr>
<td><code>QPrinter::CurrentPage</code></td>
<td><code>3</code></td>
<td>Only the current page should be printed.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QPrinter::PrinterMode</code>: This enum describes the mode the printer should work in. It basically presets a certain resolution and working mode.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::ScreenResolution</code></td>
<td><code>0</code></td>
<td>Sets the resolution of the print device to the screen resolution. This has the big advantage that the results obtained when painting on the printer will match more or less exactly the visible output on the screen. It is the easiest to use, as font metrics on the screen and on the printer are the same. This is the default value. <code>ScreenResolution</code> will produce a lower quality output than <code>HighResolution</code> and should only be used for drafts.</td>
</tr>
<tr>
<td><code>QPrinter::PrinterResolution</code></td>
<td><code>1</code></td>
<td>This value is deprecated. Is is equivalent to <code>ScreenResolution</code> on <code>Unix</code> and <code>HighResolution</code> on <code>Windows</code> and <code>Mac</code>. Due do the difference between <code>ScreenResolution</code> and <code>HighResolution</code>, use of this value may lead to <code>non-portable</code> printer code.</td>
</tr>
<tr>
<td><code>QPrinter::HighResolution</code></td>
<td><code>2</code></td>
<td>On <code>Windows</code>, sets the printer resolution to that defined for the printer in use. For <code>PostScript</code> printing, sets the resolution of the <code>PostScript</code> driver to <code>1200</code> dpi.</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: When rendering text on a <code>QPrinter</code> device, it is important to realize that the size of text, when specified in points, is independent of the resolution specified for the device itself. Therefore, it may be useful to specify the font size in pixels when combining text with graphics to ensure that their relative sizes are what you expect.</p>
<ul>
<li>enum <code>QPrinter::PrinterState</code>:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::Idle</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>QPrinter::Active</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>QPrinter::Aborted</code></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>QPrinter::Error</code></td>
<td><code>3</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QPrinter::Unit</code>: This enum type is used to specify the measurement unit for page and paper sizes.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPrinter::Millimeter</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>QPrinter::Point</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>QPrinter::Inch</code></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>QPrinter::Pica</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td><code>QPrinter::Didot</code></td>
<td><code>4</code></td>
</tr>
<tr>
<td><code>QPrinter::Cicero</code></td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>QPrinter::DevicePixel</code></td>
<td><code>6</code></td>
</tr>
</tbody>
</table>
</div>
<p>Note the difference between <code>Point</code> and <code>DevicePixel</code>. The <code>Point</code> unit is defined to be <code>1/72th</code> of an inch, while the <code>DevicePixel</code> unit is resolution dependant and is based on the actual pixels, or dots, on the printer.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QPrinter::QPrinter(PrinterMode mode = ScreenResolution)</code>: Creates a new printer object with the given <code>mode</code>.</li>
<li><code>QPrinter::QPrinter(const QPrinterInfo &amp; printer, PrinterMode mode = ScreenResolution)</code>: Creates a new printer object with the given <code>printer</code> and <code>mode</code>.</li>
<li><code>QPrinter::~QPrinter()</code>: Destroys the printer object and frees any allocated resources. If the printer is destroyed while a print job is in progress this may or may not affect the print job.</li>
<li><code>bool QPrinter::abort()</code>: Aborts the current print run. Returns <code>true</code> if the print run was successfully aborted and <code>printerState()</code> will return <code>QPrinter::Aborted</code>; otherwise returns <code>false</code>. It is not always possible to abort a print job. For example, all the data has gone to the printer but the printer cannot or will not cancel the job when asked to.</li>
<li><code>bool QPrinter::collateCopies() const</code>: Returns <code>true</code> if collation is turned on when multiple copies is selected. Returns <code>false</code> if it is turned off when multiple copies is selected. When collating is turned off the printing of each individual page will be repeated the <code>numCopies()</code> amount before the next page is started. With collating turned on all pages are printed before the next copy of those pages is started.</li>
<li><code>ColorMode QPrinter::colorMode() const</code>: Returns the current color mode.</li>
<li>int <code>QPrinter::copyCount() const</code>: Returns the number of copies that will be printed. The default value is <code>1</code>.</li>
<li><code>QString QPrinter::creator() const</code>: Returns the name of the application that created the document.</li>
<li><code>QString QPrinter::docName() const</code>: Returns the document name.</li>
<li><code>bool QPrinter::doubleSidedPrinting() const</code>: Returns <code>true</code> if double side printing is enabled. Currently this option is only supported on <code>X11</code>.</li>
<li><code>DuplexMode QPrinter::duplex() const</code>: Returns the current duplex mode. Currently this option is only supported on <code>X11</code>.</li>
<li><code>bool QPrinter::fontEmbeddingEnabled() const</code>: Returns <code>true</code> if font embedding is enabled. Currently this option is only supported on <code>X11</code>.</li>
<li><code>int QPrinter::fromPage() const</code>: Returns the number of the first page in a range of pages to be printed (the <code>from page</code> setting). Pages in a document are numbered according to the convention that the first page is page <code>1</code>. By default, this function returns a special value of <code>0</code>, meaning that the <code>from page</code> setting is unset. <strong>Note</strong>: If <code>fromPage()</code> and <code>toPage()</code> both return <code>0</code>, this indicates that the whole document will be printed.</li>
<li><code>bool QPrinter::fullPage() const</code>: Returns <code>true</code> if the origin of the printer’s coordinate system is at the corner of the page and <code>false</code> if it is at the edge of the printable area.</li>
<li><code>void QPrinter::getPageMargins(qreal * left, qreal * top, qreal * right, qreal * bottom, Unit unit) const</code>: Returns the page margins for this printer in <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>. The <code>unit</code> of the returned margins are specified with the <code>unit</code> parameter.</li>
<li><code>bool QPrinter::isValid() const</code>: Returns <code>true</code> if the printer currently selected is a valid printer in the system, or a pure <code>PDF/PostScript</code> printer; otherwise returns <code>false</code>. To detect other failures check the output of <code>QPainter::begin()</code> or <code>QPrinter::newPage()</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">QPrinter printer;</span><br><span class="line">printer.setOutputFormat ( QPrinter::PdfFormat );</span><br><span class="line">printer.setOutputFileName ( <span class="string">"/foobar/nonwritable.pdf"</span> );</span><br><span class="line">QPainter painter;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ! painter.begin ( &amp;printer ) ) &#123; <span class="comment">/* failed to open file */</span></span><br><span class="line">    qWarning ( <span class="string">"failed to open file, is it writable?"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">painter.drawText ( <span class="number">10</span>, <span class="number">10</span>, <span class="string">"Test"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ! printer.newPage() ) &#123;</span><br><span class="line">    qWarning ( <span class="string">"failed in flushing page to disk, disk full?"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">painter.drawText ( <span class="number">10</span>, <span class="number">10</span>, <span class="string">"Test 2"</span> );</span><br><span class="line">painter.end();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>bool QPrinter::newPage()</code>: Tells the printer to eject the current page and to continue printing on a new page. Returns <code>true</code> if this was successful; otherwise returns <code>false</code>. Calling <code>newPage()</code> on an inactive <code>QPrinter</code> object will always fail.</li>
<li><code>Orientation QPrinter::orientation() const</code>: Returns the orientation setting. This is <code>driver-dependent</code>, but is usually <code>QPrinter::Portrait</code>.</li>
<li><code>QString QPrinter::outputFileName() const</code>: Returns the name of the output file. By default, this is an empty string (indicating that the printer shouldn’t print to file).</li>
<li><code>OutputFormat QPrinter::outputFormat() const</code>: Returns the output format for this printer.</li>
<li><code>PageOrder QPrinter::pageOrder() const</code>: Returns the current page order. The default page order is <code>FirstPageFirst</code>.</li>
<li><code>QRect QPrinter::pageRect() const</code>: Returns the page’s rectangle; this is usually smaller than the <code>paperRect()</code> since the page normally has margins between its borders and the paper. The unit of the returned rectangle is <code>DevicePixel</code>.</li>
<li><code>QRectF QPrinter::pageRect(Unit unit) const</code>: Returns the page’s rectangle in <code>unit</code>; this is usually smaller than the <code>paperRect()</code> since the page normally has margins between its borders and the paper.</li>
<li><code>QPaintEngine * QPrinter::paintEngine() const [virtual]</code>: Reimplemented from <code>QPaintDevice::paintEngine()</code>. Returns the paint engine used by the printer.</li>
<li><code>QRect QPrinter::paperRect() const</code>: Returns the paper’s rectangle; this is usually larger than the <code>pageRect()</code>. The unit of the returned rectangle is <code>DevicePixel</code>.</li>
<li><code>QRectF QPrinter::paperRect(Unit unit) const</code>: Returns the paper’s rectangle in <code>unit</code>; this is usually larger than the <code>pageRect()</code>.</li>
<li><code>PaperSize QPrinter::paperSize() const</code>: Returns the printer paper size. The default value is <code>driver-dependent</code>.</li>
<li><code>QSizeF QPrinter::paperSize(Unit unit) const</code>: Returns the paper size in <code>unit</code>.</li>
<li><code>PaperSource QPrinter::paperSource() const</code>: Returns the printer’s paper source. This is <code>Manual</code> or a printer tray or paper cassette.</li>
<li><code>QPrintEngine * QPrinter::printEngine() const</code>: Returns the print engine used by the printer.</li>
<li><code>QString QPrinter::printProgram() const</code>: Returns the name of the program that sends the print output to the printer. The default is to return an empty string; meaning that <code>QPrinter</code> will try to be smart in a <code>system-dependent</code> way. On <code>X11</code> only, you can set it to something different to use a specific print program. On the other platforms, this returns an empty string.</li>
<li><code>PrintRange QPrinter::printRange() const</code>: Returns the page range of the <code>QPrinter</code>. After the print setup dialog has been opened, this function returns the value selected by the user.</li>
<li><code>QString QPrinter::printerName() const</code>: Returns the printer name. This value is initially set to the name of the default printer.</li>
<li><code>QString QPrinter::printerSelectionOption() const</code>: Returns the printer options selection string. This is useful only if the print command has been explicitly set. The default value (an empty string) implies that the printer should be selected in a <code>system-dependent</code> manner. Any other value implies that the given value should be used. <strong>Warning</strong>: This function is not available on <code>Windows</code>.</li>
<li><code>PrinterState QPrinter::printerState() const</code>: Returns the current state of the printer. This may not always be accurate (for example if the printer doesn’t have the capability of reporting its state to the operating system).</li>
<li><code>int QPrinter::resolution() const</code>: Returns the current assumed resolution of the printer, as set by <code>setResolution()</code> or by the printer driver.</li>
<li><code>void QPrinter::setCollateCopies(bool collate)</code>: Sets the default value for collation checkbox when the print dialog appears. If <code>collate</code> is <code>true</code>, it will enable <code>setCollateCopiesEnabled()</code>. The default value is <code>false</code>. This value will be changed by what the user presses in the print dialog.</li>
<li><code>void QPrinter::setColorMode(ColorMode newColorMode)</code>: Sets the printer’s color mode to <code>newColorMode</code>, which can be either <code>Color</code> or <code>GrayScale</code>.</li>
<li><code>void QPrinter::setCopyCount(int count)</code>: Sets the number of copies to be printed to <code>count</code>. The printer driver reads this setting and prints the specified number of copies.</li>
<li><code>void QPrinter::setCreator(const QString &amp; creator)</code>: Sets the name of the application that created the document to <code>creator</code>. This function is only applicable to the <code>X11</code> version of <code>Qt</code>. If no <code>creator</code> name is specified, the <code>creator</code> will be set to <code>Qt</code> followed by some version number.</li>
<li><code>void QPrinter::setDocName(const QString &amp; name)</code>: Sets the document name to <code>name</code>. On <code>X11</code>, the document name is for example used as the default output filename in <code>QPrintDialog</code>. Note that the document name does not affect the file name if the printer is printing to a file. Use the <code>setOutputFile()</code> function for this.</li>
<li><code>void QPrinter::setDoubleSidedPrinting(bool doubleSided)</code>: Enables double sided printing if <code>doubleSided</code> is <code>true</code>; otherwise disables it. Currently this option is only supported on <code>X11</code>.</li>
<li><code>void QPrinter::setDuplex(DuplexMode duplex)</code>: Enables double sided printing based on the <code>duplex</code> mode. Currently this option is only supported on <code>X11</code>.</li>
<li><code>void QPrinter::setEngines(QPrintEngine * printEngine, QPaintEngine * paintEngine) [protected]</code>: This function is used by subclasses of <code>QPrinter</code> to specify custom print and paint engines (<code>printEngine</code> and <code>paintEngine</code>, respectively). <code>QPrinter</code> does not take ownership of the engines, so you need to manage these engine instances yourself. Note that changing the engines will reset the printer state and all its properties.</li>
<li><code>void QPrinter::setFontEmbeddingEnabled(bool enable)</code>: Enabled or disables font embedding depending on <code>enable</code>. Currently this option is only supported on <code>X11</code>.</li>
<li><code>void QPrinter::setFromTo(int from, int to)</code>: Sets the range of pages to be printed to cover the pages with numbers specified by <code>from</code> and <code>to</code>, where <code>from</code> corresponds to the first page in the range and <code>to</code> corresponds to the last. <strong>Note</strong>: Pages in a document are numbered according to the convention that the first page is page <code>1</code>. However, if <code>from</code> and <code>to</code> are both set to <code>0</code>, the whole document will be printed. This function is mostly used to set a default value that the user can override in the print dialog when you call <code>setup()</code>.</li>
<li><code>void QPrinter::setFullPage(bool fp)</code>: If <code>fp</code> is <code>true</code>, enables support for painting over the entire page; otherwise restricts painting to the printable area reported by the device. By default, full page printing is disabled. In this case, the origin of the <code>QPrinter&#39;s</code> coordinate system coincides with the <code>top-left</code> corner of the printable area. If full page printing is enabled, the origin of the <code>QPrinter&#39;s</code> coordinate system coincides with the <code>top-left</code> corner of the paper itself. In this case, the device metrics will report the exact same dimensions as indicated by <code>PaperSize</code>. It may not be possible to print on the entire physical page because of the printer’s margins, so the application must account for the margins itself.</li>
<li><code>void QPrinter::setOrientation(Orientation orientation)</code>: Sets the print orientation to <code>orientation</code>. The <code>orientation</code> can be either <code>QPrinter::Portrait</code> or <code>QPrinter::Landscape</code>. The printer driver reads this setting and prints using the specified orientation. On <code>Windows</code>, this option can be changed while printing and will take effect from the next call to <code>newPage()</code>. On <code>Mac OS X</code>, changing the orientation during a print job has no effect.</li>
<li><code>void QPrinter::setOutputFileName(const QString &amp; fileName)</code>: Sets the name of the output file to <code>fileName</code>. Setting a null or empty name (<code>0</code> or <code>&quot;&quot;</code>) disables printing to a file. Setting a <code>non-empty</code> name enables printing to a file. This can change the value of <code>outputFormat()</code>. If the file name has the suffix <code>.ps</code> then <code>PostScript</code> is automatically selected as output format. If the file name has the <code>.pdf</code> suffix <code>PDF</code> is generated. If the file name has a suffix other than <code>.ps</code> and <code>.pdf</code>, the output format used is the one set with <code>setOutputFormat()</code>. <code>QPrinter</code> uses <code>Qt&#39;s</code> <code>cross-platform</code> <code>PostScript</code> or <code>PDF</code> print engines respectively. If you can produce this format natively, for example <code>Mac OS X</code> can generate <code>PDF&#39;s</code> from its print engine, set the output format back to <code>NativeFormat</code>.</li>
<li><code>void QPrinter::setOutputFormat(OutputFormat format)</code>: Sets the output format for this printer to <code>format</code>.</li>
<li><code>void QPrinter::setPageMargins(qreal left, qreal top, qreal right, qreal bottom, Unit unit)</code>: This function sets the <code>left</code>, <code>top</code>, <code>right</code> and <code>bottom</code> page margins for this printer. The unit of the margins are specified with the <code>unit</code> parameter.</li>
<li><code>void QPrinter::setPageOrder(PageOrder pageOrder)</code>: Sets the page order to <code>pageOrder</code>. The page order can be <code>QPrinter::FirstPageFirst</code> or <code>QPrinter::LastPageFirst</code>. The application is responsible for reading the page order and printing accordingly. This function is mostly useful for setting a default value that the user can override in the print dialog. This function is only supported under <code>X11</code>.</li>
<li><code>void QPrinter::setPaperSize(PaperSize newPaperSize)</code>: Sets the printer paper size to <code>newPaperSize</code> if that size is supported. The result is undefined if <code>newPaperSize</code> is not supported. The default paper size is <code>driver-dependent</code>. This function is useful mostly for setting a default value that the user can override in the print dialog.</li>
<li><code>void QPrinter::setPaperSize(const QSizeF &amp; paperSize, Unit unit)</code>: Sets the paper size based on <code>paperSize</code> in <code>unit</code>.</li>
<li><code>void QPrinter::setPaperSource(PaperSource source)</code>: Sets the paper source setting to <code>source</code>. <code>Windows</code> only: This option can be changed while printing and will take effect from the next call to <code>newPage()</code>.</li>
<li><code>void QPrinter::setPrintProgram(const QString &amp; printProg)</code>: Sets the name of the program that should do the print job to <code>printProg</code>. On <code>X11</code>, this function sets the program to call with the <code>PostScript</code> output. On other platforms, it has no effect.</li>
<li><code>void QPrinter::setPrintRange(PrintRange range)</code>: Sets the print range option in to be <code>range</code>.</li>
<li><code>void QPrinter::setPrinterName(const QString &amp; name)</code>: Sets the printer name to <code>name</code>.</li>
<li><code>void QPrinter::setPrinterSelectionOption(const QString &amp; option)</code>: Sets the printer to use <code>option</code> to select the printer. <code>option</code> is null by default (which implies that <code>Qt</code> should be smart enough to guess correctly), but it can be set to other values to use a specific printer selection option. If the printer selection option is changed while the printer is active, the current print job may or may not be affected. Warning: This function is not available on <code>Windows</code>.</li>
<li><code>void QPrinter::setResolution(int dpi)</code>: Requests that the printer prints at <code>dpi</code> or as near to <code>dpi</code> as possible. This setting affects the coordinate system as returned by, for example <code>QPainter::viewport()</code>. This function must be called before <code>QPainter::begin()</code> to have an effect on all platforms.</li>
<li><code>void QPrinter::setWinPageSize(int pageSize)</code>: Sets the page size to be used by the printer under Windows to <code>pageSize</code>. <strong>Warning</strong>: This function is not portable so you may prefer to use <code>setPaperSize()</code> instead.</li>
<li><code>QList&lt;PaperSource&gt; QPrinter::supportedPaperSources() const</code>: Returns the supported paper sizes for this printer. The values will be either a value that matches an entry in the <code>QPrinter::PaperSource</code> enum or a driver spesific value. The driver spesific values are greater than the constant <code>DMBIN_USER</code> declared in <code>wingdi.h</code>. <strong>Warning</strong>: This function is only available in <code>Windows</code>.</li>
<li><code>QList&lt;int&gt; QPrinter::supportedResolutions() const</code>: Returns a list of the resolutions (a list of <code>dots-per-inch</code> integers) that the printer says it supports. For <code>X11</code> where all printing is directly to postscript, this function will always return a one item list containing only the postscript resolution.</li>
<li><code>bool QPrinter::supportsMultipleCopies() const</code>: Returns <code>true</code> if the printer supports printing multiple copies of the same document in one job; otherwise <code>false</code> is returned. On most systems this function will return <code>true</code>. However, on <code>X11</code> systems that do not support <code>CUPS</code>, this function will return <code>false</code>. That means the application has to handle the number of copies by printing the same document the required number of times.</li>
<li><code>int QPrinter::toPage() const</code>: Returns the number of the last page in a range of pages to be printed (the <code>to page</code> setting). Pages in a document are numbered according to the convention that the first page is page <code>1</code>. By default, this function returns a special value of <code>0</code>, meaning that the <code>to page</code> setting is unset. <strong>Note</strong>: If <code>fromPage()</code> and <code>toPage()</code> both return <code>0</code>, this indicates that the whole document will be printed. The programmer is responsible for reading this setting and printing accordingly.</li>
<li><code>int QPrinter::winPageSize() const</code>: Returns the page size used by the printer under <code>Windows</code>. <strong>Warning</strong>: This function is not portable so you may prefer to use <code>paperSize()</code> instead.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/96/">96</a><a class="extend next" rel="next" href="/page/22/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">958</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
