<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="暴徒">
<meta property="og:url" content="http://fukangwei.gitee.io/page/5/index.html">
<meta property="og:site_name" content="暴徒">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="暴徒">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/5/">





  <title>暴徒</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">暴徒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/16/Linux系统编程/fork和vfork函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/16/Linux系统编程/fork和vfork函数/" itemprop="url">fork和vfork函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T15:40:43+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>&emsp;&emsp;<code>fork</code>函数的功能是创建子进程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork ( <span class="keyword">void</span> );</span><br></pre></td></tr></table></figure>
<p><code>fork</code>的奇妙之处在于它被调用一次，却返回两次，它可能有三种不同的返回值：</p>
<ul>
<li>在父进程中，<code>fork</code>返回新创建的子进程的<code>PID</code>。</li>
<li>在子进程中，<code>fork</code>返回<code>0</code>。</li>
<li>如果出现错误，<code>fork</code>返回一个负值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"This is father process\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"This is child process\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在<code>pid = fork();</code>之前，只有一个进程在执行，但在这条语句执行之后，就变成两个进程在执行了，这两个进程的共享代码段，将要执行的下一条语句都是<code>if(pid == 0)</code>。两个进程中，原来就存在的那个进程被称作<code>父进程</code>，新出现的那个进程被称作<code>子进程</code>，父子进程的区别在于进程标识符(<code>PID</code>)不同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    pid = fork();</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"count is %d\n"</span>, count );</span><br><span class="line">    <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">1</span></span><br><span class="line">count = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对<code>fork</code>函数，子进程的数据空间、堆栈空间都会从父进程得到一个拷贝，而不是共享。在子进程中对<code>count</code>进行加<code>1</code>的操作，并没有影响到父进程中的<code>count</code>值，父进程中的<code>count</code>值仍然为<code>0</code>。</p>
<h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><p>&emsp;&emsp;<code>vfork</code>函数的功能是创建子进程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> vfork ( <span class="keyword">void</span> );</span><br></pre></td></tr></table></figure>
<p><code>vfork</code>和<code>fork</code>的区别如下：</p>
<ul>
<li><code>fork</code>：子进程拷贝父进程的数据段，父、子进程的执行次序不确定。</li>
<li><code>vfork</code>：子进程与父进程共享数据段，子进程先运行，父进程后运行。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    pid = vfork();</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"count is %d\n"</span>, count );</span><br><span class="line">    <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="vfork挂掉的一个问题"><a href="#vfork挂掉的一个问题" class="headerlink" title="vfork挂掉的一个问题"></a>vfork挂掉的一个问题</h3><p>&emsp;&emsp;有个人问了这样的一个问题：为什么<code>vfork</code>的子进程里用<code>return</code>，整个程序会挂掉，而且<code>exit</code>不会？但如果把子进程的<code>return</code>改成<code>exit(0)</code>就没事。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    var = <span class="number">88</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( pid = vfork() ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"vfork error"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123; <span class="comment">/* 子进程 */</span></span><br><span class="line">        var++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"pid = %d, glob = %d, var = %d\n"</span>, getpid(), glob, var );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>&emsp;&emsp;首先说一下<code>fork</code>和<code>vfork</code>的差别：</p>
<ul>
<li><code>fork</code>是创建一个子进程，并把父进程的内存数据<code>copy</code>到子进程中。</li>
<li><code>vfork</code>是创建一个子进程，并和父进程的内存数据<code>share</code>一起用。</li>
</ul>
<p>这两个的差别是，一个是<code>copy</code>，一个是<code>share</code>。<code>vfork</code>是这样的工作的：保证子进程先执行；当子进程调用<code>exit</code>或<code>exec</code>后，父进程往下执行。</p>
<h4 id="为什么return会挂掉，exit不会？"><a href="#为什么return会挂掉，exit不会？" class="headerlink" title="为什么return会挂掉，exit不会？"></a>为什么return会挂掉，exit不会？</h4><p>&emsp;&emsp;从上面可以知道，结束子进程的调用是<code>exit</code>而不是<code>return</code>，如果你在<code>vfork</code>中<code>return</code>了，那么这就意味<code>main</code>函数<code>return</code>了，注意因为函数栈父子进程共享，所以整个程序的栈就跪了。如果你在子进程中<code>return</code>，那么基本是下面的过程：</p>
<ol>
<li>子进程的<code>main</code>函数<code>return</code>了，于是程序的函数栈发生了变化。</li>
<li>而<code>main</code>函数<code>return</code>后，通常会调用<code>exit</code>或相似的函数，如<code>_exit</code>、<code>_exitgroup</code>。</li>
<li>这时父进程收到子进程<code>exit</code>，开始从<code>vfork</code>返回。但是父进程的栈都被子进程的<code>return</code>给废掉了，于是代码崩溃了(对于某些内核版本，直接报<code>栈错误</code>就给跪了。然而对于其他内核版本，有可能会再次调用<code>main</code>，于是进入了一个无限循环的结果，直到<code>vfork</code>调用返回<code>error</code>)。</li>
</ol>
<p>&emsp;&emsp;现在再回到<code>return</code>和<code>exit</code>，<code>return</code>会释放局部变量并弹栈，回到上级函数执行；<code>exit</code>直接退掉。如果用过<code>C++</code>就会知道，<code>return</code>会调用局部对象的析构函数，<code>exit</code>不会(<code>exit</code>不是系统调用，是<code>glibc</code>对系统调用<code>_exit</code>或<code>_exitgroup</code>的封装)。可见，子进程调用<code>exit</code>没有修改函数栈，所以父进程得以顺利执行。</p>
<h4 id="关于fork的优化"><a href="#关于fork的优化" class="headerlink" title="关于fork的优化"></a>关于fork的优化</h4><p>&emsp;&emsp;<code>fork</code>太耗费资源，而<code>vfork</code>又太危险，所以就有人开始优化<code>fork</code>。优化的技术用到了著名的写时拷贝(<code>COW</code>)，也就是说对于<code>fork</code>后并不是马上拷贝内存，而是只有你在需要改变的时候，才会从父进程中拷贝到子进程中，这样<code>fork</code>后立马执行<code>exec</code>的成本就非常小了。所以<code>Linux</code>的<code>Man Page</code>中并不鼓励使用<code>vfork</code>。</p>
<hr>
<h3 id="Linux下fork的运行机制"><a href="#Linux下fork的运行机制" class="headerlink" title="Linux下fork的运行机制"></a>Linux下fork的运行机制</h3><p>&emsp;&emsp;面试题代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid1;</span><br><span class="line">    <span class="keyword">pid_t</span> pid2;</span><br><span class="line">    pid1 = fork();</span><br><span class="line">    pid2 = fork();</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"pid1:%d, pid2:%d\n"</span>, pid1, pid2 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>条件为：已知从这个程序执行到这个程序的所有进程结束这个时间段内，没有其它新进程执行。</p>
<ul>
<li>请说出执行这个程序后，将一共运行几个进程。</li>
<li>如果其中一个进程的输出结果是<code>pid1:1001, pid2:1002</code>，写出其他进程的输出结果(不考虑进程执行顺序)。</li>
</ul>
<h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><ul>
<li>进程可以看做程序的一次执行过程。<code>Linux</code>下的每个进程有唯一的<code>PID</code>标识进程。<code>PID</code>是一个从<code>1</code>到<code>32768</code>的正整数，其中<code>1</code>一般是特殊进程<code>init</code>，其它进程从<code>2</code>开始依次编号。当用完<code>32768</code>后，从<code>2</code>重新开始。</li>
<li><code>Linux</code>中有一个叫进程表的结构，用来存储当前正在运行的进程。可以使用<code>ps -aux</code>命令查看所有正在运行的进程。</li>
<li>进程在<code>Linux</code>中呈树状结构，<code>init</code>为根节点，其它进程均有父进程，某进程的父进程就是启动这个进程的进程，这个进程叫做父进程的子进程。</li>
<li><code>fork</code>的作用是复制一个与当前进程一样的进程。新进程的所有数据(变量、环境变量、程序计数器等)数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</li>
</ul>
<h4 id="解题的关键"><a href="#解题的关键" class="headerlink" title="解题的关键"></a>解题的关键</h4><p>&emsp;&emsp;我认为解题的关键就是要认识到<code>fork</code>将程序切成两段：</p>
<p><img src="/2019/03/16/Linux系统编程/fork和vfork函数/1.png"></p>
<p>&emsp;&emsp;上图表示一个含有<code>fork</code>的程序，而<code>fork</code>语句可以看成将程序切为<code>A</code>、<code>B</code>两个部分。然后整个程序会如下运行：</p>
<ol>
<li>设由<code>shell</code>直接执行程序，生成了进程<code>P</code>。<code>P</code>执行完<code>Part.A</code>的所有代码。</li>
<li>当执行到<code>pid = fork();</code>时，<code>P</code>启动一个进程<code>Q</code>，<code>Q</code>是<code>P</code>的子进程，和<code>P</code>是同一个程序的进程。<code>Q</code>继承<code>P</code>的所有变量、环境变量、程序计数器的当前值。</li>
<li>在<code>P</code>进程中，<code>fork()</code>将<code>Q</code>的<code>PID</code>返回给变量<code>pid</code>，并继续执行<code>Part.B</code>的代码。</li>
<li>在进程<code>Q</code>中，将<code>0</code>赋给<code>pid</code>，并继续执行<code>Part.B</code>的代码。</li>
</ol>
<p>&emsp;&emsp;这里有三个点非常关键：</p>
<ul>
<li><code>P</code>执行了所有程序，而<code>Q</code>只执行了<code>Part.B</code>，即<code>fork</code>后面的程序，这是因为<code>Q</code>继承了<code>P</code>的<code>PC</code>，即程序计数器。</li>
<li><code>Q</code>继承了<code>fork</code>语句执行时当前的环境，而不是程序的初始环境。</li>
<li><code>P</code>中<code>fork</code>语句启动子进程<code>Q</code>，并将<code>Q</code>的<code>PID</code>返回，而<code>Q</code>中的<code>fork</code>语句不启动新进程，仅将<code>0</code>返回。</li>
</ul>
<h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><p>&emsp;&emsp;下面利用上文阐述的知识进行解题。这里我把两个问题放在一起进行分析。</p>
<ol>
<li>从<code>shell</code>中执行此程序，启动了一个进程，我们设这个进程为<code>P0</code>，设其<code>PID</code>为<code>XXX</code>(解题过程不需知道其<code>PID</code>)。</li>
<li>当执行到<code>pid1 = fork();</code>时，<code>P0</code>启动一个子进程<code>P1</code>，由题目知<code>P1</code>的<code>PID</code>为<code>1001</code>。我们暂且不管<code>P1</code>。</li>
<li><code>P0</code>中的<code>fork</code>返回<code>1001</code>给<code>pid1</code>，继续执行到<code>pid2 = fork();</code>，此时启动另一个新进程，设为<code>P2</code>，由题目知<code>P2</code>的<code>PID</code>为<code>1002</code>。同样暂且不管<code>P2</code>。</li>
<li><code>P0</code>中的第二个<code>fork</code>返回<code>1002</code>给<code>pid2</code>，继续执行完后续程序，结束。所以<code>P0</code>的结果为<code>pid1:1001, pid2:1002</code>。</li>
<li>再看<code>P2</code>，<code>P2</code>生成时，<code>P0</code>中<code>pid1</code>为<code>1001</code>，所以<code>P2</code>中<code>pid1</code>继承<code>P0</code>的<code>1001</code>，而作为子进程<code>pid2</code>为<code>0</code>。<code>P2</code>从第二个<code>fork</code>后开始执行，结束后输出<code>pid1:1001, pid2:0</code>。</li>
<li>接着看<code>P1</code>，<code>P1</code>中第一条<code>fork</code>返回<code>0</code>给<code>pid1</code>，然后接着执行后面的语句。而后面接着的语句是<code>pid2 = fork();</code>。执行到这里，<code>P1</code>又产生了一个新进程，设为<code>P3</code>。先不管<code>P3</code>。</li>
<li><code>P1</code>中第二条<code>fork</code>将<code>P3</code>的<code>PID</code>返回给<code>pid2</code>，由预备知识知<code>P3</code>的<code>PID</code>为<code>1003</code>，所以<code>P1</code>的<code>pid2</code>为<code>1003</code>。<code>P1</code>继续执行后续程序，结束，输出<code>pid1:0, pid2:1003</code>。</li>
<li><code>P3</code>作为<code>P1</code>的子进程，继承<code>P1</code>中<code>pid1</code>为<code>0</code>，并且第二条<code>fork</code>将<code>0</code>返回给<code>pid2</code>，所以<code>P3</code>最后输出<code>pid1:0, pid2:0</code>。至此，整个执行过程完毕。</li>
</ol>
<p>&emsp;&emsp;所得答案如下：</p>
<ul>
<li>一共执行了四个进程(<code>P0</code>、<code>P1</code>、<code>P2</code>和<code>P3</code>)。</li>
<li>另外几个进程的输出分别为：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid1:<span class="number">1001</span>, pid2:<span class="number">0</span></span><br><span class="line">pid1:<span class="number">0</span>, pid2:<span class="number">1003</span></span><br><span class="line">pid1:<span class="number">0</span>, pid2:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以给出一个以<code>P0</code>为根的进程树：</p>
<p><img src="/2019/03/16/Linux系统编程/fork和vfork函数/2.png" height="270" width="355"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/16/Linux系统编程/孤儿进程与僵尸进程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/16/Linux系统编程/孤儿进程与僵尸进程/" itemprop="url">孤儿进程与僵尸进程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T12:20:37+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>&emsp;&emsp;我们知道在<code>unix/linux</code>中，正常情况下子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。当一个进程完成它的工作终止之后，它的父进程需要调用<code>wait</code>或者<code>waitpid</code>系统调用取得子进程的终止状态。</p>
<ul>
<li>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被<code>init</code>进程(进程号为<code>1</code>)所收养，并由<code>init</code>进程对它们完成状态收集工作。</li>
<li>僵尸进程：一个进程使用<code>fork</code>创建子进程，如果子进程退出，而父进程并没有调用<code>wait</code>或<code>waitpid</code>获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</li>
</ul>
<h3 id="问题及危害"><a href="#问题及危害" class="headerlink" title="问题及危害"></a>问题及危害</h3><p>&emsp;&emsp;<code>unix</code>提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息就可以得到。这种机制就是：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件、占用的内存等。但是仍然为其保留一定的信息(包括进程号<code>the process ID</code>、退出状态<code>the termination status of the process</code>、运行时间<code>the amount of CPU time taken by the process</code>等)，直到父进程通过<code>wait/waitpid</code>来取时才释放。但这样就导致了问题，如果父进程不调用<code>wait/waitpid</code>的话，那么保留的那段信息就不会释放，其进程号就会一直被占用。但是系统所能使用的进程号是有限的，如果大量地产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，这就是僵尸进程的危害。<br>&emsp;&emsp;孤儿进程是没有父进程的进程，孤儿进程的处理这个重任就落到了<code>init</code>进程身上。<code>init</code>进程就好像是一个收容所，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为<code>init</code>，而<code>init</code>进程会循环地<code>wait</code>它的已经退出的子进程。这样当一个孤儿进程结束了其生命周期的时候，<code>init</code>进程就会处理它的一切善后工作，因此孤儿进程并不会有什么危害。<br>&emsp;&emsp;任何一个子进程(<code>init</code>除外)在<code>exit</code>之后，并非马上就消失掉，而是留下一个称为僵尸进程(<code>Zombie</code>)的数据结构，等待父进程处理，这是每个子进程在结束时都要经过的阶段。如果子进程在<code>exit</code>之后，父进程没有来得及处理，这时用<code>ps</code>命令就能看到子进程的状态是<code>Z</code>。如果父进程能及时处理，可能用<code>ps</code>命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。如果父进程在子进程结束之前退出，则子进程将由<code>init</code>接管。<code>init</code>将会以父进程的身份对僵尸状态的子进程进行处理。<br>&emsp;&emsp;僵尸进程危害场景：例如有个进程，它定期地产生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短。但是父进程只管生成新的子进程，至于子进程退出之后的事情，则一概不闻不问。这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，如果用ps命令查看的话，就会看到很多状态为<code>Z</code>的进程。严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大量僵死进程的那个元凶枪毙掉(也就是通过<code>kill</code>发送<code>SIGTERM</code>或者<code>SIGKILL</code>信号了)。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被<code>init</code>进程接管，<code>init</code>进程会<code>wait</code>这些孤儿进程，释放它们占用的系统进程表中的资源。这样，这些已经僵死的孤儿进程就能瞑目而去了。</p>
<h3 id="孤儿进程和僵尸进程测试"><a href="#孤儿进程和僵尸进程测试" class="headerlink" title="孤儿进程和僵尸进程测试"></a>孤儿进程和僵尸进程测试</h3><p>&emsp;&emsp;孤儿进程测试程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork(); <span class="comment">/* 创建一个进程 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123; <span class="comment">/* 创建失败 */</span></span><br><span class="line">        perror ( <span class="string">"fork error:"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123; <span class="comment">/* 子进程 */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I am the child process.\n"</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"pid: %d\tppid:%d\n"</span>, getpid(), getppid() ); <span class="comment">/* 输出进程ID和父进程ID */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I will sleep five seconds.\n"</span> );</span><br><span class="line">        sleep ( <span class="number">5</span> ); <span class="comment">/* 睡眠5s，保证父进程先退出 */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"pid: %d\tppid:%d\n"</span>, getpid(), getppid() );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"child process is exited.\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* 父进程 */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I am father process.\n"</span> );</span><br><span class="line">        sleep ( <span class="number">1</span> ); <span class="comment">/* 父进程睡眠1s，保证子进程输出进程id */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"father process is  exited.\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/16/Linux系统编程/孤儿进程与僵尸进程/1.png"></p>
<p>&emsp;&emsp;僵尸进程测试程序<code>1</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fork error:"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I am child process.I am exiting.\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"I am father process.I will sleep two seconds\n"</span> );</span><br><span class="line">    sleep ( <span class="number">2</span> ); <span class="comment">/* 等待子进程先退出 */</span></span><br><span class="line">    system ( <span class="string">"ps -o pid,ppid,state,tty,command"</span> ); <span class="comment">/* 输出进程信息 */</span></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"father process is exiting.\n"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/16/Linux系统编程/孤儿进程与僵尸进程/2.png"></p>
<p>&emsp;&emsp;僵尸进程测试程序<code>2</code>：父进程循环创建子进程，子进程退出，造成多个僵尸进程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span>  pid;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123; <span class="comment">/* 循环创建子进程 */</span></span><br><span class="line">        pid = fork();</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">            perror ( <span class="string">"fork error:"</span> );</span><br><span class="line">            <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"I am a child process.\nI am exiting.\n"</span> );</span><br><span class="line">            <span class="built_in">exit</span> ( <span class="number">0</span> ); <span class="comment">/* 子进程退出，成为僵尸进程 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sleep ( <span class="number">20</span> ); <span class="comment">/* 父进程休眠20s继续创建子进程 */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/16/Linux系统编程/孤儿进程与僵尸进程/3.png" height="278" width="310"></p>
<h3 id="僵尸进程解决办法"><a href="#僵尸进程解决办法" class="headerlink" title="僵尸进程解决办法"></a>僵尸进程解决办法</h3><p>&emsp;&emsp;1. 通过信号机制：子进程退出时向父进程发送<code>SIGCHLD</code>信号，父进程处理<code>SIGCHLD</code>信号，在信号处理函数中调用<code>wait</code>进行处理僵尸进程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_child</span> <span class="params">( <span class="keyword">int</span> signo )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    signal ( SIGCHLD, sig_child ); <span class="comment">/* 创建捕捉子进程退出信号 */</span></span><br><span class="line">    pid = fork();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fork error:"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I am child process,pid id %d.I am exiting.\n"</span>, getpid() );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"I am father process.I will sleep two seconds\n"</span> );</span><br><span class="line">    sleep ( <span class="number">2</span> ); <span class="comment">/* 等待子进程先退出 */</span></span><br><span class="line">    system ( <span class="string">"ps -o pid,ppid,state,tty,command"</span> ); <span class="comment">/* 输出进程信息 */</span></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"father process is exiting.\n"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_child</span> <span class="params">( <span class="keyword">int</span> signo )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> stat;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( ( pid = waitpid ( <span class="number">-1</span>, &amp;stat, WNOHANG ) ) &gt; <span class="number">0</span> ) &#123; <span class="comment">/* 处理僵尸进程 */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"child %d terminated.\n"</span>, pid );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. <code>fork</code>两次：<code>Unix环境高级编程</code>的<code>8.6</code>节说的非常详细，原理是将子进程成为孤儿进程，从而其父进程变为<code>init</code>进程，通过<code>init</code>进程可以处理僵尸进程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span>  pid;</span><br><span class="line">    pid = fork(); <span class="comment">/* 创建第一个子进程 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fork error:"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123; <span class="comment">/* 第一个子进程 */</span></span><br><span class="line">        <span class="comment">/* 子进程再创建子进程 */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I am the first child process.pid:%d\tppid:%d\n"</span>, getpid(), getppid() );</span><br><span class="line">        pid = fork();</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">            perror ( <span class="string">"fork error:"</span> );</span><br><span class="line">            <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( pid &gt; <span class="number">0</span> ) &#123; <span class="comment">/* 第一个子进程退出 */</span></span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"first procee is exited.\n"</span> );</span><br><span class="line">            <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">/* 第二个子进程睡眠3s保证第一个子进程退出，这样第二个子进程的父亲就是init进程 */</span></span><br><span class="line">        sleep ( <span class="number">3</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I am the second child process.pid: %d\tppid:%d\n"</span>, getpid(), getppid() );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( waitpid ( pid, <span class="literal">NULL</span>, <span class="number">0</span> ) != pid ) &#123; <span class="comment">/* 父进程处理第一个子进程退出 */</span></span><br><span class="line">        perror ( <span class="string">"waitepid error:"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/16/Linux系统编程/孤儿进程与僵尸进程/4.png"></p>
<hr>
<h3 id="僵尸进程概念"><a href="#僵尸进程概念" class="headerlink" title="僵尸进程概念"></a>僵尸进程概念</h3><p>&emsp;&emsp;僵尸进程(<code>Zombie Process</code>)：就是已经结束了的进程，但是没有从进程表中删除。太多了会导致进程表里面条目满了，进而导致系统崩溃，倒是不占用其他系统资源。<br>&emsp;&emsp;在<code>Linux</code>进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集。除此之外，僵尸进程不再占有任何内存空间。它需要它的父进程来为它收尸，如果他的父进程没安装<code>SIGCHLD</code>信号处理函数调用<code>wait</code>或<code>waitpid</code>等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态。如果这时父进程结束了，那么<code>init</code>进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。</p>
<h3 id="僵尸进程产生的原因"><a href="#僵尸进程产生的原因" class="headerlink" title="僵尸进程产生的原因"></a>僵尸进程产生的原因</h3><p>&emsp;&emsp;每个<code>Linux</code>进程在进程表里都有一个进入点(<code>entry</code>)，核心程序执行该进程时使用到的一切信息都存储在进入点。当用<code>ps</code>命令察看系统中的进程信息时，看到的就是进程表中的相关数据。当用<code>fork</code>系统调用建立一个新的进程后，核心进程就会在进程表中给这个新进程分配一个进入点，然后将相关信息存储在该进入点所对应的进程表内。这些信息中有一项是其父进程的识别码。当这个进程走完了自己的生命周期后，它会执行<code>exit</code>系统调用，此时原来进程表中的数据会被该进程的退出码(<code>exit code</code>)、执行时所用的<code>CPU</code>时间等数据所取代，这些数据会一直保留到系统将它传递给它的父进程为止。由此可见，僵尸进程的出现时间是在子进程终止后，但是父进程尚未读取这些数据之前。</p>
<h3 id="僵尸进程的解决方法"><a href="#僵尸进程的解决方法" class="headerlink" title="僵尸进程的解决方法"></a>僵尸进程的解决方法</h3><ul>
<li>父进程通过<code>wait</code>和<code>waitpid</code>等函数等待子进程结束，这会导致父进程挂起。执行<code>wait</code>或<code>waitpid</code>系统调用，则子进程在终止后会立即把它在进程表中的数据返回给父进程，此时系统会立即删除该进入点。在这种情形下就不会产生僵尸进程。</li>
<li>如果父进程很忙，那么可以用<code>signal</code>函数为<code>SIGCHLD</code>安装<code>handler</code>。在子进程结束后，父进程会收到该信号，可以在<code>handler</code>中调用<code>wait</code>回收。</li>
<li>如果父进程不关心子进程什么时候结束，那么可以用<code>signal(SIGCLD, SIG_IGN)</code>或<code>signal(SIGCHLD, SIG_IGN)</code>通知内核，自己对子进程的结束不感兴趣。那么子进程结束后，内核会回收子进程的资源，并不再给父进程发送信号。</li>
<li><code>fork</code>两次，父进程<code>fork</code>一个子进程，然后继续工作。子进程<code>fork</code>一个孙进程后退出，那么孙进程会被<code>init</code>接管，孙进程结束后，<code>init</code>会回收它的资源。不过子进程的回收还要自己来做。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/14/数学和物理/数学符号/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/数学和物理/数学符号/" itemprop="url">数学符号</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:57:21+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="运算符号"><a href="#运算符号" class="headerlink" title="运算符号"></a>运算符号</h3><p>&emsp;&emsp;加号($+$)，减号($-$)，乘号($\times$或$\cdot$)，除号($\div$或$/$)，两个集合的并集($\bigcup$)，交集($\bigcap$)，根号($\sqrt{x}$)，对数($\log$、$\lg$、$\ln$)，比($:$)，绝对值符号($\left| x \right|$)，微分($\mathrm{d}$)，积分($\int$)，闭合曲面(曲线)积分($\int$)。</p>
<h3 id="关系符号"><a href="#关系符号" class="headerlink" title="关系符号"></a>关系符号</h3><p>&emsp;&emsp;等号($=$)，近似符号($\approx$)，不等号($\neq$)，大于符号($&gt;$)，小于符号($&lt;$)，大于或等于符号($\geq$)，小于或等于符号($\leq$)，变量变化的趋势($\to$)，相似符号($\sim$)，全等号($\cong$)，平行符号($\parallel$)，不平行符号($\nparallel$)，垂直符号($\perp$)，正比例符号($\propto$)，属于符号($\in$)，不属于符号($\notin$)，包含于符号($\subseteq$)，包含符号($\supseteq$)，$a|b$表示<code>a</code>能整除<code>b</code>)。</p>
<h3 id="结合符号"><a href="#结合符号" class="headerlink" title="结合符号"></a>结合符号</h3><p>&emsp;&emsp;小括号($()$)，中括号($[]$)，大括号(${}$)。</p>
<h3 id="性质符号"><a href="#性质符号" class="headerlink" title="性质符号"></a>性质符号</h3><p>&emsp;&emsp;正号($+$)，负号($-$)，正负号($\pm$)。</p>
<h3 id="省略符号"><a href="#省略符号" class="headerlink" title="省略符号"></a>省略符号</h3><p>&emsp;&emsp;三角形($\bigtriangleup$)，正弦($\sin$)，双曲正弦函数($\sinh$)，<code>x</code>的函数($f(x)$)，极限($\lim$)，角($\angle$)，因为($\because$)，所以($\therefore$)，连续加($\sum$)，连续乘($\prod$)，幂($a^x$)，阶乘($!$)。</p>
<h3 id="离散数学符号"><a href="#离散数学符号" class="headerlink" title="离散数学符号"></a>离散数学符号</h3><p>&emsp;&emsp;全称量词($\forall$)，存在量词($\exists$)，命题的<code>非</code>运算($\neg$)，命题的<code>与</code>运算($\wedge$)，命题的<code>或</code>运算($\vee$)，命题的<code>条件</code>运算($\to$)，命题的<code>双条件</code>运算($\leftrightarrow$)，命题<code>p</code>与<code>q</code>的等价关系($p \Leftrightarrow q$)；$p \Rightarrow q$是命题<code>p</code>与<code>q</code>的蕴涵关系(<code>p</code>是<code>q</code>的充分条件，<code>q</code>是<code>p</code>的必要条件)，空集($\emptyset$)，真包含($\subset$)；集合的并运算($\cup$)，集合的交运算($\cap$)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/14/办公/Markdown中写数学公式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/办公/Markdown中写数学公式/" itemprop="url">Markdown中写数学公式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T10:09:21+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;一些扩展的<code>Markdown</code>语法支持采用<code>LaTex</code>语法写数学公式，而在网页中使用<code>Mathjax</code>插件来显示数学公式。在<code>Markdown</code>中插入数学公式的语法是<code>$数学公式$</code>和<code>$$数学公式$$</code>。<br>&emsp;&emsp;行内公式是可以让公式在文中与文字或其他东西混编，不独占一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">质能方程$E = mc^2$</span><br></pre></td></tr></table></figure>
<p>质能方程$E = mc^2$。<br>&emsp;&emsp;独立公式使公式单独占一行，不与文中其他文字等混编：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$E = mc^2$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">E = mc^2</script><h3 id="普通公式"><a href="#普通公式" class="headerlink" title="普通公式"></a>普通公式</h3><p>&emsp;&emsp;普通的加减乘除数学公式的输入方法与平常的书写一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$x = 100 * y + z - 10 / 33 + 10 % 3$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">x = 100 * y + z - 10 / 33 + 10 % 3</script><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>&emsp;&emsp;使用<code>^</code>来表示上标，<code>_</code>来表示下标，同时如果上下标的内容多于一个字符，可以使用<code>{}</code>来将这些内容括起来当做一个整体。实际上，上下标是可以嵌套的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$x = a_&#123;1&#125;^n + a_&#123;2&#125;^n + a_&#123;3&#125;^n$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">x = a_{1}^n + a_{2}^n + a_{3}^n</script><p>如果希望左右两边都能有上下标，可以使用<code>\sideset</code>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\sideset&#123;^1_2&#125;&#123;^3_4&#125;A$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\sideset{^1_2}{^3_4}A</script><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p>&emsp;&emsp;<code>()</code>、<code>[]</code>和<code>|</code>都表示它们自己，但是<code>{}</code>因为有特殊作用，因此当需要显示大括号时，一般使用<code>\lbrace \rbrace</code>来表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace</script><h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><p>&emsp;&emsp;分数使用<code>\frac{分母}{分子}</code>这样的语法，不过推荐使用<code>\cfrac</code>来代替<code>\frac</code>，显示公式不会太挤。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\frac&#123;1&#125;&#123;3&#125; 与 \cfrac&#123;1&#125;&#123;3&#125;$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\frac{1}{3} 与 \cfrac{1}{3}</script><h3 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h3><p>&emsp;&emsp;开方使用<code>\sqrt[次数]{被开方数}</code>这样的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$$\sqrt[3]&#123;X&#125;$$</span><br><span class="line">$$\sqrt&#123;5 - x&#125;$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\sqrt[3]{X}</script><script type="math/tex; mode=display">\sqrt{5 - x}</script><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>显示</th>
<th>代码</th>
<th>显示</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$A$</code></td>
<td>$A$</td>
<td><code>$\alpha$</code></td>
<td>$\alpha$</td>
</tr>
<tr>
<td><code>$B$</code></td>
<td>$B$</td>
<td><code>$\beta$</code></td>
<td>$\beta$</td>
</tr>
<tr>
<td><code>$\Gamma$</code></td>
<td>$\Gamma$</td>
<td><code>$\gamma$</code></td>
<td>$\gamma$</td>
</tr>
<tr>
<td><code>$\Delta$</code></td>
<td>$\Delta$</td>
<td><code>$\delta$</code></td>
<td>$\delta$</td>
</tr>
<tr>
<td><code>$E$</code></td>
<td>$E$</td>
<td><code>$\epsilon$</code></td>
<td>$\epsilon$</td>
</tr>
<tr>
<td><code>$Z$</code></td>
<td>$Z$</td>
<td><code>$\zeta$</code></td>
<td>$\zeta$</td>
</tr>
<tr>
<td><code>$H$</code></td>
<td>$H$</td>
<td><code>$\eta$</code></td>
<td>$\eta$</td>
</tr>
<tr>
<td><code>$\Theta$</code></td>
<td>$\Theta$</td>
<td><code>$\theta$</code></td>
<td>$\theta$</td>
</tr>
<tr>
<td><code>$I$</code></td>
<td>$I$</td>
<td><code>$\iota$</code></td>
<td>$\iota$</td>
</tr>
<tr>
<td><code>$K$</code></td>
<td>$K$</td>
<td><code>$\kappa$</code></td>
<td>$\kappa$</td>
</tr>
<tr>
<td><code>$\Lambda$</code></td>
<td>$\Lambda$</td>
<td><code>$\lambda$</code></td>
<td>$\lambda$</td>
</tr>
<tr>
<td><code>$M$</code></td>
<td>$M$</td>
<td><code>$\mu$</code></td>
<td>$\mu$</td>
</tr>
<tr>
<td><code>$N$</code></td>
<td>$N$</td>
<td><code>$\nu$</code></td>
<td>$\nu$</td>
</tr>
<tr>
<td><code>$\Xi$</code></td>
<td>$\Xi$</td>
<td><code>$\xi$</code></td>
<td>$\xi$</td>
</tr>
<tr>
<td><code>$O$</code></td>
<td>$O$</td>
<td><code>$\omicron$</code></td>
<td>$\omicron$</td>
</tr>
<tr>
<td><code>$\Pi$</code></td>
<td>$\Pi$</td>
<td><code>$\pi$</code></td>
<td>$\pi$</td>
</tr>
<tr>
<td><code>$P$</code></td>
<td>$P$</td>
<td><code>$\rho$</code></td>
<td>$\rho$</td>
</tr>
<tr>
<td><code>$\Sigma$</code></td>
<td>$\Sigma$</td>
<td><code>$\sigma$</code></td>
<td>$\sigma$</td>
</tr>
<tr>
<td><code>$T$</code></td>
<td>$T$</td>
<td><code>$\tau$</code></td>
<td>$\tau$</td>
</tr>
<tr>
<td><code>$\Upsilon$</code></td>
<td>$\Upsilon$</td>
<td><code>$\upsilon$</code></td>
<td>$\upsilon$</td>
</tr>
<tr>
<td><code>$\Phi$</code></td>
<td>$\Phi$</td>
<td><code>$\phi$</code></td>
<td>$\phi$</td>
</tr>
<tr>
<td><code>$X$</code></td>
<td>$X$</td>
<td><code>$\chi$</code></td>
<td>$\chi$</td>
</tr>
<tr>
<td><code>$\Psi$</code></td>
<td>$\Psi$</td>
<td><code>$\psi$</code></td>
<td>$\psi$</td>
</tr>
<tr>
<td><code>$\Omega$</code></td>
<td>$\Omega$</td>
<td><code>$\omega$</code></td>
<td>$\omega$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\emptyset$</code></td>
<td>$\emptyset$</td>
<td><code>$\in$</code></td>
<td>$\in$</td>
</tr>
<tr>
<td><code>$\notin$</code></td>
<td>$\notin$</td>
<td><code>$\subset$</code></td>
<td>$\subset$</td>
</tr>
<tr>
<td><code>$\supset$</code></td>
<td>$\supset$</td>
<td><code>$\subseteq$</code></td>
<td>$\subseteq$</td>
</tr>
<tr>
<td><code>$\supseteq$</code></td>
<td>$\supseteq$</td>
<td><code>$\bigcap$</code></td>
<td>$\bigcap$</td>
</tr>
<tr>
<td><code>$\bigcup$</code></td>
<td>$\bigcup$</td>
<td><code>$\bigvee$</code></td>
<td>$\bigvee$</td>
</tr>
<tr>
<td><code>$\bigwedge$</code></td>
<td>$\bigwedge$</td>
<td><code>$\biguplus$</code></td>
<td>$\biguplus$</td>
</tr>
<tr>
<td><code>$\bigsqcup$</code></td>
<td>$\bigsqcup$</td>
<td><code>$\ni$</code></td>
<td>$\ni$</td>
</tr>
<tr>
<td><code>$\forall$</code></td>
<td>$\forall$</td>
<td><code>$\exists$</code></td>
<td>$\exists$</td>
</tr>
<tr>
<td><code>$\neg$</code></td>
<td>$\neg$</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="对数运算符"><a href="#对数运算符" class="headerlink" title="对数运算符"></a>对数运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\log$</code></td>
<td>$\log$</td>
<td><code>$\lg$</code></td>
<td>$\lg$</td>
</tr>
<tr>
<td><code>$\ln$</code></td>
<td>$\ln$</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="三角运算符"><a href="#三角运算符" class="headerlink" title="三角运算符"></a>三角运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\bot$</code></td>
<td>$\bot$</td>
<td><code>$\angle$</code></td>
<td>$\angle$</td>
</tr>
<tr>
<td><code>$\sin$</code></td>
<td>$\sin$</td>
<td><code>$\cos$</code></td>
<td>$\cos$</td>
</tr>
<tr>
<td><code>$\tan$</code></td>
<td>$\tan$</td>
<td><code>$\cot$</code></td>
<td>$\cot$</td>
</tr>
<tr>
<td><code>$\sec</code></td>
<td>$\sec$</td>
<td><code>$\csc$</code></td>
<td>$\csc$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="微积分运算符"><a href="#微积分运算符" class="headerlink" title="微积分运算符"></a>微积分运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\prime$</code></td>
<td>$\prime$</td>
<td><code>$\int$</code></td>
<td>$\int$</td>
</tr>
<tr>
<td><code>$\iint$</code></td>
<td>$\iint$</td>
<td><code>$\iiint$</code></td>
<td>$\iiint$</td>
</tr>
<tr>
<td><code>$\oint$</code></td>
<td>$\oint$</td>
<td><code>$\lim$</code></td>
<td>$\lim$</td>
</tr>
<tr>
<td><code>$\infty$</code></td>
<td>$\infty$</td>
<td><code>$\nabla$</code></td>
<td>$\nabla$</td>
</tr>
<tr>
<td><code>$\mathrm{d}$</code></td>
<td>$\mathrm{d}$</td>
<td><code>$\partial$</code></td>
<td>$\partial$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a>绝对值</h3><p>&emsp;&emsp;代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\left| x \right|$</span><br></pre></td></tr></table></figure>
<p>$\left| x \right|$</p>
<h3 id="箭头符号"><a href="#箭头符号" class="headerlink" title="箭头符号"></a>箭头符号</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\gets$</code></td>
<td>$\gets$</td>
<td><code>$\to$</code></td>
<td>$\to$</td>
</tr>
<tr>
<td><code>$\leftarrow$</code></td>
<td>$\leftarrow$</td>
<td><code>$\Leftarrow$</code></td>
<td>$\Leftarrow$</td>
</tr>
<tr>
<td><code>$\rightarrow$</code></td>
<td>$\rightarrow$</td>
<td><code>$\Rightarrow$</code></td>
<td>$\Rightarrow$</td>
</tr>
<tr>
<td><code>$\leftrightarrow$</code></td>
<td>$\leftrightarrow$</td>
<td><code>$\Leftrightarrow$</code></td>
<td>$\Leftrightarrow$</td>
</tr>
<tr>
<td><code>$\mapsto$</code></td>
<td>$\mapsto$</td>
<td><code>$\hookleftarrow$</code></td>
<td>$\hookleftarrow$</td>
</tr>
<tr>
<td><code>$\leftharpoonup$</code></td>
<td>$\leftharpoonup$</td>
<td><code>$\leftharpoondown$</code></td>
<td>$\leftharpoondown$</td>
</tr>
<tr>
<td><code>$\rightleftharpoons$</code></td>
<td>$\rightleftharpoons$</td>
<td><code>$\longleftarrow$</code></td>
<td>$\longleftarrow$</td>
</tr>
<tr>
<td><code>$\Longleftarrow$</code></td>
<td>$\Longleftarrow$</td>
<td><code>$\longrightarrow$</code></td>
<td>$\longrightarrow$</td>
</tr>
<tr>
<td><code>$\Longrightarrow$</code></td>
<td>$\Longrightarrow$</td>
<td><code>$\longleftrightarrow$</code></td>
<td>$\longleftrightarrow$</td>
</tr>
<tr>
<td><code>$\Longleftrightarrow$</code></td>
<td>$\Longleftrightarrow$</td>
<td><code>$\longmapsto$</code></td>
<td>$\longmapsto$</td>
</tr>
<tr>
<td><code>$\hookrightarrow$</code></td>
<td>$\hookrightarrow$</td>
<td><code>$\rightharpoonup$</code></td>
<td>$\rightharpoonup$</td>
</tr>
<tr>
<td><code>$\rightharpoondown$</code></td>
<td>$\rightharpoondown$</td>
<td><code>$\leadsto$</code></td>
<td>$\leadsto$</td>
</tr>
<tr>
<td><code>$\uparrow$</code></td>
<td>$\uparrow$</td>
<td><code>$\Uparrow$</code></td>
<td>$\Uparrow$</td>
</tr>
<tr>
<td><code>$\downarrow$</code></td>
<td>$\downarrow$</td>
<td><code>$\Downarrow$</code></td>
<td>$\Downarrow$</td>
</tr>
<tr>
<td><code>$\updownarrow$</code></td>
<td>$\updownarrow$</td>
<td><code>$\Updownarrow$</code></td>
<td>$\Updownarrow$</td>
</tr>
<tr>
<td><code>$\nearrow$</code></td>
<td>$\nearrow$</td>
<td><code>$\searrow$</code></td>
<td>$\searrow$</td>
</tr>
<tr>
<td><code>$\swarrow$</code></td>
<td>$\swarrow$</td>
<td><code>$\nwarrow$</code></td>
<td>$\nwarrow$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\pm$</code></td>
<td>$\pm$</td>
<td><code>$\mp$</code></td>
<td>$\mp$</td>
<td><code>$\times$</code></td>
<td>$\times$</td>
</tr>
<tr>
<td><code>$\div$</code></td>
<td>$\div$</td>
<td><code>$\cdot$</code></td>
<td>$\cdot$</td>
<td><code>$\ast$</code></td>
<td>$\ast$</td>
</tr>
<tr>
<td><code>$\star$</code></td>
<td>$\star$</td>
<td><code>$\dagger$</code></td>
<td>$\dagger$</td>
<td><code>$\ddagger$</code></td>
<td>$\ddagger$</td>
</tr>
<tr>
<td><code>$\amalg$</code></td>
<td>$\amalg$</td>
<td><code>$\cap$</code></td>
<td>$\cap$</td>
<td><code>$\cup$</code></td>
<td>$\cup$</td>
</tr>
<tr>
<td><code>$\uplus$</code></td>
<td>$\uplus$</td>
<td><code>$\sqcap$</code></td>
<td>$\sqcap$</td>
<td><code>$\sqcup$</code></td>
<td>$\sqcup$</td>
</tr>
<tr>
<td><code>$\vee$</code></td>
<td>$\vee$</td>
<td><code>$\wedge$</code></td>
<td>$\wedge$</td>
<td><code>$\oplus$</code></td>
<td>$\oplus$</td>
</tr>
<tr>
<td><code>$\ominus$</code></td>
<td>$\ominus$</td>
<td><code>$\otimes$</code></td>
<td>$\otimes$</td>
<td><code>$\circ$</code></td>
<td>$\circ$</td>
</tr>
<tr>
<td><code>$\bullet$</code></td>
<td>$\bullet$</td>
<td><code>$\diamond$</code></td>
<td>$\diamond$</td>
<td><code>$\lhd$</code></td>
<td>$\lhd$</td>
</tr>
<tr>
<td><code>$\rhd$</code></td>
<td>$\rhd$</td>
<td><code>$\unlhd$</code></td>
<td>$\unlhd$</td>
<td><code>$\unrhd$</code></td>
<td>$\unrhd$</td>
</tr>
<tr>
<td><code>$\oslash$</code></td>
<td>$\oslash$</td>
<td><code>$\odot$</code></td>
<td>$\odot$</td>
<td><code>$\bigcirc$</code></td>
<td>$\bigcirc$</td>
</tr>
<tr>
<td><code>$\triangleleft$</code></td>
<td>$\triangleleft$</td>
<td><code>$\Diamond$</code></td>
<td>$\Diamond$</td>
<td><code>$\bigtriangleup$</code></td>
<td>$\bigtriangleup$</td>
</tr>
<tr>
<td><code>$\bigtriangledown$</code></td>
<td>$\bigtriangledown$</td>
<td><code>$\Box$</code></td>
<td>$\Box$</td>
<td><code>$\triangleright$</code></td>
<td>$\triangleright$</td>
</tr>
<tr>
<td><code>$\setminus$</code></td>
<td>$\setminus$</td>
<td><code>$\wr$</code></td>
<td>$\wr$</td>
<td><code>$\sqrt{x}$</code></td>
<td>$\sqrt{x}$</td>
</tr>
<tr>
<td><code>$x^{\circ}$</code></td>
<td>$x^{\circ}$</td>
<td><code>$\triangledown$</code></td>
<td>$\triangledown$</td>
<td><code>$\sqrt[n]{x}$</code></td>
<td>$\sqrt[n]{x}$</td>
</tr>
<tr>
<td><code>$a^x$</code></td>
<td>$a^x$</td>
<td><code>$a^{xyz}$</code></td>
<td>$a^{xyz}$</td>
<td><code>$\sum$</code></td>
<td>$\sum$</td>
</tr>
<tr>
<td><code>$\prod$</code></td>
<td>$\prod$</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\le$</code></td>
<td>$\le$</td>
<td><code>$\ge$</code></td>
<td>$\ge$</td>
<td><code>$\neq$</code></td>
<td>$\neq$</td>
</tr>
<tr>
<td><code>$\sim$</code></td>
<td>$\sim$</td>
<td><code>$\ll$</code></td>
<td>$\ll$</td>
<td><code>$\gg$</code></td>
<td>$\gg$</td>
</tr>
<tr>
<td><code>$\doteq$</code></td>
<td>$\doteq$</td>
<td><code>$\simeq$</code></td>
<td>$\simeq$</td>
<td><code>$\lneqq$</code></td>
<td>$\lneqq$</td>
</tr>
<tr>
<td><code>$\gneqq$</code></td>
<td>$\gneqq$</td>
<td><code>$\approx$</code></td>
<td>$\approx$</td>
<td><code>$\asymp$</code></td>
<td>$\asymp$</td>
</tr>
<tr>
<td><code>$\lnsim$</code></td>
<td>$\lnsim$</td>
<td><code>$\gneq$</code></td>
<td>$\gneq$</td>
<td><code>$\cong$</code></td>
<td>$\cong$</td>
</tr>
<tr>
<td><code>$\smile$</code></td>
<td>$\smile$</td>
<td><code>$\sqsubset$</code></td>
<td>$\sqsubset$</td>
<td><code>$\sqsupset$</code></td>
<td>$\sqsupset$</td>
</tr>
<tr>
<td><code>$\equiv$</code></td>
<td>$\equiv$</td>
<td><code>$\frown$</code></td>
<td>$\frown$</td>
<td><code>$\sqsubseteq$</code></td>
<td>$\sqsubseteq$</td>
</tr>
<tr>
<td><code>$\sqsupseteq$</code></td>
<td>$\sqsupseteq$</td>
<td><code>$\propto$</code></td>
<td>$\propto$</td>
<td><code>$\bowtie$</code></td>
<td>$\bowtie$</td>
</tr>
<tr>
<td><code>$\lneq$</code></td>
<td>$\lneq$</td>
<td><code>$\ngtr$</code></td>
<td>$\ngtr$</td>
<td><code>$\prec$</code></td>
<td>$\prec$</td>
</tr>
<tr>
<td><code>$\succ$</code></td>
<td>$\succ$</td>
<td><code>$\vdash$</code></td>
<td>$\vdash$</td>
<td><code>$\dashv$</code></td>
<td>$\dashv$</td>
</tr>
<tr>
<td><code>$\preceq$</code></td>
<td>$\preceq$</td>
<td><code>$\succeq$</code></td>
<td>$\succeq$</td>
<td><code>$\models$</code></td>
<td>$\models$</td>
</tr>
<tr>
<td><code>$\perp$</code></td>
<td>$\perp$</td>
<td><code>$\parallel$</code></td>
<td>$\parallel$</td>
<td><code>$\mid$</code></td>
<td>$\mid$</td>
</tr>
<tr>
<td><code>$\bumpeq$</code></td>
<td>$\bumpeq$</td>
<td><code>$\nmid$</code></td>
<td>$\nmid$</td>
<td><code>$\nleq$</code></td>
<td>$\nleq$</td>
</tr>
<tr>
<td><code>$\ngeq$</code></td>
<td>$\ngeq$</td>
<td><code>$\nsim$</code></td>
<td>$\nsim$</td>
<td><code>$\ncong$</code></td>
<td>$\ncong$</td>
</tr>
<tr>
<td><code>$\nparallel$</code></td>
<td>$\nparallel$</td>
<td><code>$\not&lt;$</code></td>
<td>$\not&lt;$</td>
<td><code>$\not&gt;$</code></td>
<td>$\not&gt;$</td>
</tr>
<tr>
<td><code>$\not=$</code></td>
<td>$\not=$</td>
<td><code>$\not\le$</code></td>
<td>$\not\le$</td>
<td><code>$\not\ge$</code></td>
<td>$\not\ge$</td>
</tr>
<tr>
<td><code>$\not\sim$</code></td>
<td>$\not\sim$</td>
<td><code>$\not \approx$</code></td>
<td>$\not\approx$</td>
<td><code>$\not\cong$</code></td>
<td>$\not\cong$</td>
</tr>
<tr>
<td><code>$\not\equiv$</code></td>
<td>$\not\equiv$</td>
<td><code>$\not\parallel$</code></td>
<td>$\not\parallel$</td>
<td><code>$\nless$</code></td>
<td>$\nless$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Accents符号"><a href="#Accents符号" class="headerlink" title="Accents符号"></a>Accents符号</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\hat{x}$</code></td>
<td>$\hat{x}$</td>
<td><code>$\check{x}$</code></td>
<td>$\check{x}$</td>
<td><code>$\dot{x}$</code></td>
<td>$\dot{x}$</td>
</tr>
<tr>
<td><code>$\breve{x}$</code></td>
<td>$\breve{x}$</td>
<td><code>$\acute{x}$</code></td>
<td>$\acute{x}$</td>
<td><code>$\ddot{x}$</code></td>
<td>$\ddot{x}$</td>
</tr>
<tr>
<td><code>$\grave{x}$</code></td>
<td>$\grave{x}$</td>
<td><code>$\tilde{x}$</code></td>
<td>$\tilde{x}$</td>
<td><code>$\mathring{x}$</code></td>
<td>$\mathring{x}$</td>
</tr>
<tr>
<td><code>$\bar{x}$</code></td>
<td>$\bar{x}$</td>
<td><code>$\vec{x}$</code></td>
<td>$\vec{x}$</td>
<td><code>$\vec{\jmath}$</code></td>
<td>$\vec{\jmath}$</td>
</tr>
<tr>
<td><code>$\tilde{\imath}$</code></td>
<td>$\tilde{\imath}$</td>
<td><code>$\widehat{7+x}$</code></td>
<td>$\widehat{7+x}$</td>
<td><code>$\widetilde{abc}$</code></td>
<td>$\widetilde{abc}$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Bracketing符号"><a href="#Bracketing符号" class="headerlink" title="Bracketing符号"></a>Bracketing符号</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\{$</code></td>
<td>$\{$</td>
<td><code>$\}$</code></td>
<td>$\}$</td>
<td><code>$\rangle$</code></td>
<td>$\rangle$</td>
</tr>
<tr>
<td><code>$\backslash$</code></td>
<td>$\backslash$</td>
<td><code>$\lfloor$</code></td>
<td>$\lfloor$</td>
<td><code>$\rfloor$</code></td>
<td>$\rfloor$</td>
</tr>
<tr>
<td><code>$\lceil$</code></td>
<td>$\lceil$</td>
<td><code>$\rceil$</code></td>
<td>$\rceil$</td>
<td><code>$\langle$</code></td>
<td>$\langle$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="点符号"><a href="#点符号" class="headerlink" title="点符号"></a>点符号</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\cdot$</code></td>
<td>$\cdot$</td>
<td><code>$\vdots$</code></td>
<td>$\vdots$</td>
</tr>
<tr>
<td><code>$\dots$</code></td>
<td>$\dots$</td>
<td><code>$\ddots$</code></td>
<td>$\ddots$</td>
</tr>
<tr>
<td><code>$\cdots$</code></td>
<td>$\cdots$</td>
<td><code>$\because$</code></td>
<td>$\because$</td>
</tr>
<tr>
<td><code>$\therefore$</code></td>
<td>$\therefore$</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>&emsp;&emsp;You might notice that if you use any of these to typeset an expression that is vertically large, like</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\frac&#123;a&#125;&#123;x&#125;)^2</span><br></pre></td></tr></table></figure>
<p>the parentheses don’t come out the right size:</p>
<p>$(\frac{a}{x})^2$</p>
<p>If we put <code>\left</code> and <code>\right</code> before the relevant parentheses, we get a prettier expression:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\left(\frac&#123;a&#125;&#123;x&#125; \right)^2</span><br></pre></td></tr></table></figure>
<p>$\left(\frac{a}{x} \right)^2$</p>
<p>&emsp;&emsp;if you type this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\underbrace&#123;a_0+a_1+a_2+\cdots+a_n&#125;_&#123;x&#125;</span><br></pre></td></tr></table></figure>
<p>Gives</p>
<p>$\underbrace{a_0+a_1+a_2+\cdots+a_n}_{x}$</p>
<p>Or</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\overbrace&#123;a_0+a_1+a_2+\cdots+a_n&#125;^&#123;x&#125;</span><br></pre></td></tr></table></figure>
<p>Gives</p>
<p>$\overbrace{a_0+a_1+a_2+\cdots+a_n}^{x}$</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/14/Linux系统编程/多进程编程之信号量/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/Linux系统编程/多进程编程之信号量/" itemprop="url">多进程编程之信号量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T08:33:40+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="semget系统调用"><a href="#semget系统调用" class="headerlink" title="semget系统调用"></a>semget系统调用</h3><p>&emsp;&emsp;<code>semget</code>系统调用创建一个新的信号量集，或者获取一个已经存在的信号量集。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span> <span class="params">( <span class="keyword">key_t</span> key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>key</code>：一个键值，用来标识一个全局唯一的信号量集，就像文件名全局唯一的标识一个文件一样。要通过信号量通信的进程需要使用相同的键值来创建或获取该信号量。</li>
<li><code>num_sems</code>：指定要创建或获取的信号量集中信号量的数目。如果是创建信号量，则该值必须指定；如果是获取已存在的信号量，则可以设置为<code>0</code>。</li>
<li><code>sem_flags</code>：指定一组标志。它低端的<code>9</code>个比特是该信号量的权限，其格式和含义都与系统调用<code>open</code>的<code>mode</code>参数相同。我们可以和<code>IPC_CREAT</code>标志做按位<code>或</code>运算，此时即使信号量存大，<code>semget</code>也不会报错。我们还可以用<code>IPC_CREAT</code>和<code>IPC_EXCL</code>标志来确保创建一组新的、唯一的信号量集，此时若信号量存在，<code>semget</code>返回错误并设置<code>errno</code>为<code>EEXIST</code>。</li>
</ul>
<p>&emsp;&emsp;<code>semget</code>调用成功时返回一个正整数，它是信号量集的标识符；失败时返回<code>-1</code>，并设置<code>errno</code>。</p>
<h3 id="semop系统调用"><a href="#semop系统调用" class="headerlink" title="semop系统调用"></a>semop系统调用</h3><p>&emsp;&emsp;<code>semop</code>系统调用改变信号量的值，即执行<code>P</code>和<code>V</code>操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span> <span class="params">( <span class="keyword">int</span> sem_id, struct sembuf *sem_ops, <span class="keyword">size_t</span> num_sem_ops )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sem_id</code>：由<code>semget</code>调用返回的信号量集标识符，用以指定被操作的目标信号量集。</li>
<li><code>num_sem_ops</code>：指定要执行的操作个数，即<code>sem_ops</code>数组中无素的个数。<code>semop</code>对数组中的每个成员按数组顺序依次执行，该过程是原子操作。</li>
<li><code>sem_ops</code>：指向一个sembuf结构体的数组：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sem_num;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sem_op;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sem_flg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体成员说明如下：</p>
<ol>
<li><code>sem_num</code>是信号量集中信号量的编号，像数组一样，从<code>0</code>开始。</li>
<li><code>sem_op</code>指定操作类型，可选值为正整数、<code>0</code>和负整数。每种类型的操作行为又受到<code>sem_flg</code>的影响。</li>
<li><code>sem_flg</code>的可选值是<code>IPC_NOWAIT</code>、<code>SEM_UNDO</code>。<code>IPC_NOWAIT</code>指无论信号量操作是否成功，<code>semop</code>调用都将立即返回，类似于非阻塞；<code>SEM_UNDO</code>指当进程退出时取消正在进行的<code>semop</code>操作。</li>
</ol>
<p>&emsp;&emsp;<code>semop</code>成功时返回<code>0</code>，失败时返回<code>-1</code>并设置<code>errno</code>。</p>
<h3 id="semctl系统调用"><a href="#semctl系统调用" class="headerlink" title="semctl系统调用"></a>semctl系统调用</h3><p>&emsp;&emsp;<code>semctl</code>系统调用允许调用者对信号量进行直接控制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span> <span class="params">( <span class="keyword">int</span> sem_id, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> command, ... )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sem_id</code>：由<code>semget</code>调用返回的信号量集标识符，用以指定被操作的信号量集。</li>
<li><code>sem_num</code>：指定被操作的信号量在信号量集中的编号。</li>
<li><code>command</code>：指定要执行的命令。</li>
</ul>
<p>&emsp;&emsp;有的命令需要第<code>4</code>个参数。第<code>4</code>个参数由用户自己定义，但<code>sys/sem.h</code>给出了推荐格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">    <span class="keyword">int</span> val; <span class="comment">/* 用于SETVAL命令 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span> <span class="comment">/* 用于IPC_STAT和IPC_SET命令 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>; <span class="comment">/* 用于GETALL和SETALL命令 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span> <span class="comment">/* 用于IPC_INFO命令 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sem_ctl</code>成功时的返回值取决于<code>command</code>参数，失败时返回<code>-1</code>并设置<code>errno</code>。</p>
<h3 id="特殊键值IPC-PRIVATE"><a href="#特殊键值IPC-PRIVATE" class="headerlink" title="特殊键值IPC_PRIVATE"></a>特殊键值IPC_PRIVATE</h3><p>&emsp;&emsp;<code>semget</code>的调用可以给其<code>key</code>参数传递一个特殊的键值<code>IPC_PRIVATE</code>，其值为<code>0</code>，这样无论该信号量是否存在，<code>semget</code>都将创建一个新的信号量。使用该值创建的信号量并非像它的名字声称的那样是进程私有的。</p>
<h3 id="使用IPC-PRIVATE创建信号量"><a href="#使用IPC-PRIVATE创建信号量" class="headerlink" title="使用IPC_PRIVATE创建信号量"></a>使用IPC_PRIVATE创建信号量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* op为“-1”时执行P操作，op为1时执行V操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pv</span> <span class="params">( <span class="keyword">int</span> sem_id, <span class="keyword">int</span> op )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = op;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    semop ( sem_id, &amp;sem_b, <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sem_id = semget ( IPC_PRIVATE, <span class="number">1</span>, <span class="number">0666</span> );</span><br><span class="line">    <span class="keyword">union</span> semun sem_un;</span><br><span class="line">    sem_un.val = <span class="number">1</span>;</span><br><span class="line">    semctl ( sem_id, <span class="number">0</span>, SETVAL, sem_un );</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( id &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"fork failed.\n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( id == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"child try to get binary sem\n"</span> );</span><br><span class="line">        pv ( sem_id, <span class="number">-1</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"child get the sem and would release it after 5 seconds\n"</span> );</span><br><span class="line">        sleep ( <span class="number">5</span> );</span><br><span class="line">        pv ( sem_id, <span class="number">1</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"parent try to get binary sem\n"</span> );</span><br><span class="line">        pv ( sem_id, <span class="number">-1</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"parent get the sem and would release it after 3 seconds\n"</span> );</span><br><span class="line">        sleep ( <span class="number">3</span> );</span><br><span class="line">        pv ( sem_id, <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    waitpid ( id, <span class="literal">NULL</span>, <span class="number">0</span> );</span><br><span class="line">    semctl ( sem_id, <span class="number">0</span>, IPC_RMID, sem_un ); <span class="comment">/* 删除信号量 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="linux的信号灯"><a href="#linux的信号灯" class="headerlink" title="linux的信号灯"></a>linux的信号灯</h3><h4 id="信号灯概述"><a href="#信号灯概述" class="headerlink" title="信号灯概述"></a>信号灯概述</h4><p>&emsp;&emsp;信号灯与其他进程间通信方式不大相同，它主要提供对进程间共享资源访问控制机制。相当于内存中的标志，进程可以根据它判定是否能够访问某些共享资源，同时进程也可以修改该标志。除了用于访问控制外，还可用于进程同步。信号灯有以下两种类型：</p>
<ul>
<li>二值信号灯：最简单的信号灯形式，信号灯的值只能取<code>0</code>或<code>1</code>，类似于互斥锁。</li>
<li>计算信号灯：信号灯的值可以取任意非负值(当然受内核本身的约束)。</li>
</ul>
<p>&emsp;&emsp;二值信号灯能够实现互斥锁的功能，但两者的关注内容不同。信号灯强调共享资源，只要共享资源可用，其他进程同样可以修改信号灯的值；互斥锁更强调进程，占用资源的进程使用完资源后，必须由进程本身来解锁。</p>
<h4 id="Linux信号灯"><a href="#Linux信号灯" class="headerlink" title="Linux信号灯"></a>Linux信号灯</h4><p>&emsp;&emsp;<code>Linux</code>对信号灯的支持状况与消息队列一样，在<code>Red hat 8.0</code>发行版本中支持的是系统<code>V</code>的信号灯，因此本文将主要介绍系统<code>V</code>信号灯及其相应<code>API</code>。在没有声明的情况下，以下讨论中指的都是系统<code>V</code>信号灯。注意，通常所说的系统<code>V</code>信号灯指的是计数信号灯集。</p>
<h4 id="信号灯与内核"><a href="#信号灯与内核" class="headerlink" title="信号灯与内核"></a>信号灯与内核</h4><p>&emsp;&emsp;系统<code>V</code>信号灯是随内核持续的，只有在内核重起或者显示删除一个信号灯集时，该信号灯集才会真正被删除。因此系统中记录信号灯的数据结构<code>struct ipc_ids sem_ids</code>位于内核中，系统中的所有信号灯都可以在结构<code>sem_ids</code>中找到访问入口。<br>&emsp;&emsp;下图说明了内核与信号灯是怎样建立起联系的，其中<code>struct ipc_ids sem_ids</code>是内核中记录信号灯的全局数据结构，描述一个具体的信号灯及其相关信息。</p>
<p><img src="/2019/03/14/Linux系统编程/多进程编程之信号量/1.png"></p>
<p>&emsp;&emsp;<code>struct sem</code>结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> semval; <span class="comment">/* current value */</span></span><br><span class="line">    <span class="keyword">int</span> sempid <span class="comment">/* pid of last operation */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上图可以看出，全局数据结构<code>struct ipc_ids sem_ids</code>可以访问到<code>struct kern_ipc_perm</code>的第一个成员，即<code>struct kern_ipc_perm</code>；而每个<code>struct kern_ipc_perm</code>能够与具体的信号灯对应起来是因为在该结构中，有一个<code>key_t</code>类型成员<code>key</code>，而<code>key</code>则唯一确定一个信号灯集；同时，结构<code>struct kern_ipc_perm</code>的最后一个成员<code>sem_nsems</code>确定了该信号灯在信号灯集中的顺序，这样内核就能够记录每个信号灯的信息了。</p>
<h4 id="操作信号灯"><a href="#操作信号灯" class="headerlink" title="操作信号灯"></a>操作信号灯</h4><p>&emsp;&emsp;对消息队列的操作无非有下面三种类型：</p>
<ul>
<li>打开或创建信号灯：与消息队列的创建及打开基本相同，不再详述。</li>
<li>信号灯值操作：<code>linux</code>可以增加或减小信号灯的值，相应于对共享资源的释放和占有。具体参见后面的<code>semop</code>系统调用。</li>
<li>获得或设置信号灯属性：系统中的每一个信号灯集都对应一个<code>struct sem_array</code>结构，该结构记录了信号灯集的各种信息，存在于系统空间。为了设置、获得该信号灯集的各种信息及属性，在用户空间有一个重要的联合结构与之对应，即<code>union semun</code>。</li>
</ul>
<p><img src="/2019/03/14/Linux系统编程/多进程编程之信号量/2.png"></p>
<h4 id="信号灯API"><a href="#信号灯API" class="headerlink" title="信号灯API"></a>信号灯API</h4><p>&emsp;&emsp;1. 文件名到键值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="keyword">key_t</span> ftok ( <span class="keyword">char</span> *pathname, <span class="keyword">char</span> proj );</span><br></pre></td></tr></table></figure>
<p>它返回与路径<code>pathname</code>相对应的一个键值，具体用法请参考消息队列。<br>&emsp;&emsp;2. <code>linux</code>特有的<code>ipc</code>调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipc</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> call, <span class="keyword">int</span> first, <span class="keyword">int</span> second, <span class="keyword">int</span> third, <span class="keyword">void</span> *ptr, <span class="keyword">long</span> fifth )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>call</code>取不同值时，对应信号灯的三个系统调用：</p>
<ul>
<li>当<code>call</code>为<code>SEMOP</code>时，对应<code>int semop(int semid, struct sembuf *sops, unsigned nsops)</code>调用。</li>
<li>当<code>call</code>为<code>SEMGET</code>时，对应<code>int semget(key_t key, int nsems, int semflg)</code>调用。</li>
<li>当<code>call</code>为<code>SEMCTL</code>时，对应<code>int semctl(int semid, int semnum, int cmd, union semun arg)</code>调用。</li>
</ul>
<p>本人不主张采用系统调用<code>ipc</code>，而更倾向于采用系统<code>V</code>或者<code>POSIX</code>进程间通信<code>API</code>。<br>&emsp;&emsp;3. 系统<code>V</code>信号灯<code>API</code>：系统<code>V</code>消息队列<code>API</code>只有三个，使用时需要包括几个头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>semget</code>函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span> <span class="params">( <span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg )</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>key</code>：一个键值，由<code>ftok</code>获得，唯一标识一个信号灯集，用法与<code>msgget</code>中的<code>key</code>相同。</li>
<li><code>nsems</code>：指定打开或者新创建的信号灯集中将包含信号灯的数目。</li>
<li><code>semflg</code>：一些标志位。</li>
</ol>
<p>参数<code>key</code>和<code>semflg</code>的取值，以及何时打开已有信号灯集或者创建一个新的信号灯集与<code>msgget</code>中的对应部分相同，不再祥述。该调用返回与健值<code>key</code>相对应的信号灯集描述字。函数执行成功返回信号灯集描述字，否则返回<code>-1</code>。<br>&emsp;&emsp;如果<code>key</code>所代表的信号灯已经存在，且<code>semget</code>指定了<code>IPC_CREAT | IPC_EXCL</code>标志，那么即使参数<code>nsems</code>与原来信号灯的数目不等，返回的也是<code>EEXIST</code>错误；如果<code>semget</code>只指定了<code>IPC_CREAT</code>标志。</p>
<ul>
<li><code>semop</code>函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span> <span class="params">( <span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">unsigned</span> nsops )</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>semid</code>是信号灯集<code>ID</code>，<code>sops</code>指向数组的每一个<code>sembuf</code>结构都刻画一个在特定信号灯上的操作；<code>nsops</code>为<code>sops</code>指向数组的大小。<code>sembuf</code>结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sem_num; <span class="comment">/* semaphore index in array */</span></span><br><span class="line">    <span class="keyword">short</span> sem_op; <span class="comment">/* semaphore operation */</span></span><br><span class="line">    <span class="keyword">short</span> sem_flg; <span class="comment">/* operation flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>sem_num</code>对应信号集中的信号灯，<code>0</code>对应第一个信号灯。<code>sem_flg</code>可取<code>IPC_NOWAIT</code>以及<code>SEM_UNDO</code>两个标志。如果设置了<code>SEM_UNDO</code>标志，那么在进程结束时，相应的操作将被取消，这是比较重要的一个标志位。如果设置了该标志位，那么在进程没有释放共享资源就退出时，内核将代为释放。如果为一个信号灯设置了该标志，内核都要分配一个<code>sem_undo</code>结构来记录它，为的是确保以后资源能够安全释放。事实上，如果进程退出了，那么它所占用就释放了，但信号灯值却没有改变，此时，信号灯值反映的已经不是资源占有的实际情况，在这种情况下，问题的解决就靠内核来完成。这有点像僵尸进程，进程虽然退出了，资源也都释放了，但内核进程表中仍然有它的记录，此时就需要父进程调用<code>waitpid</code>来解决问题了。<br>&emsp;&emsp;<code>sem_op</code>的值大于<code>0</code>，等于<code>0</code>以及小于<code>0</code>确定了对<code>sem_num</code>指定的信号灯进行的三种操作。<br>&emsp;&emsp;这里需要强调的是<code>semop</code>同时操作多个信号灯，在实际应用中，对应多种资源的申请或释放。<code>semop</code>保证操作的原子性，这一点尤为重要。尤其对于多种资源的申请来说，要么一次性获得所有资源，要么放弃申请，要么在不占有任何资源情况下继续等待，这样，一方面避免了资源的浪费；另一方面，避免了进程之间由于申请共享资源造成死锁。<br>&emsp;&emsp;也许从实际含义上更好理解这些操作：信号灯的当前值记录相应资源目前可用数目；<code>sem_op &gt; 0</code>对应相应进程要释放<code>sem_op</code>数目的共享资源；<code>sem_op = 0</code>可以用于对共享资源是否已用完的测试；<code>sem_op &lt; 0</code>相当于进程要申请<code>-sem_op</code>个共享资源。再联想操作的原子性，更不难理解该系统调用何时正常返回，何时睡眠等待。<br>&emsp;&emsp;调用返回：成功返回<code>0</code>，否则返回<code>-1</code>。</p>
<ul>
<li><code>semctl</code>函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span> <span class="params">( <span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, <span class="keyword">union</span> semun arg )</span></span>;</span><br></pre></td></tr></table></figure>
<p>该系统调用实现对信号灯的各种控制操作，参数<code>semid</code>指定信号灯集；参数<code>cmd</code>指定具体的操作类型；参数<code>semnum</code>指定对哪个信号灯操作，只对几个特殊的<code>cmd</code>操作有意义；<code>arg</code>用于设置或返回信号灯信息。该系统调用详细信息请参见其手册页，这里只给出参数<code>cmd</code>所能指定的操作：</p>
<ol>
<li><code>IPC_STAT</code>：获取信号灯信息，信息由<code>arg.buf</code>返回。</li>
<li><code>IPC_SET</code>：设置信号灯信息，待设置信息保存在<code>arg.buf</code>中。</li>
<li><code>GETALL</code>：返回所有信号灯的值，结果保存在<code>arg.array</code>中，参数<code>sennum</code>被忽略。</li>
<li><code>GETNCNT</code>：返回等待<code>semnum</code>所代表信号灯的值增加的进程数，相当于目前有多少进程在等待<code>semnum</code>代表的信号灯所代表的共享资源。</li>
<li><code>GETPID</code>：返回最后一个对<code>semnum</code>所代表信号灯执行<code>semop</code>操作的进程<code>ID</code>。</li>
<li><code>GETVAL</code>：返回<code>semnum</code>所代表信号灯的值。</li>
<li><code>GETZCNT</code>：返回等待<code>semnum</code>所代表信号灯的值变成<code>0</code>的进程数。</li>
<li><code>SETALL</code>：通过<code>arg.array</code>更新所有信号灯的值，并且更新与本信号集相关的<code>semid_ds</code>结构的<code>sem_ctime</code>成员。</li>
<li><code>SETVAL</code>：设置<code>semnum</code>所代表信号灯的值为<code>arg.val</code>。</li>
</ol>
<p>&emsp;&emsp;调用返回：调用失败返回<code>-1</code>，成功返回与<code>cmd</code>相关：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Cmd</th>
<th>return value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GETNCNT</code></td>
<td><code>Semncnt</code></td>
</tr>
<tr>
<td><code>GETPID</code></td>
<td><code>Sempid</code></td>
</tr>
<tr>
<td><code>GETVAL</code></td>
<td><code>Semval</code></td>
</tr>
<tr>
<td><code>GETZCNT</code></td>
<td><code>Semzcnt</code></td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;4. 信号灯的限制：</p>
<ul>
<li>一次系统调用<code>semop</code>可同时操作的信号灯数目<code>SEMOPM</code>，<code>semop</code>中的参数<code>nsops</code>如果超过了这个数目，将返回<code>E2BIG</code>错误。<code>SEMOPM</code>的大小特定于系统，<code>red hat 8.0</code>为<code>32</code>。</li>
<li>信号灯的最大数目<code>SEMVMX</code>，当设置信号灯值超过这个限制时，会返回<code>ERANGE</code>错误。在<code>red hat 8.0</code>中该值为<code>32767</code>。</li>
<li>系统范围内信号灯集的最大数目<code>SEMMNI</code>以及系统范围内信号灯的最大数目<code>SEMMNS</code>。超过这两个限制将返回<code>ENOSPC</code>错误。<code>red hat 8.0</code>中该值为<code>32000</code>。</li>
<li>每个信号灯集中的最大信号灯数目<code>SEMMSL</code>，<code>red hat 8.0</code>中为<code>250</code>。<code>SEMOPM</code>以及<code>SEMVMX</code>是使用<code>semop</code>调用时应该注意的；<code>SEMMNI</code>以及<code>SEMMNS</code>是调用<code>semget</code>时应该注意的。<code>SEMVMX</code>同时也是<code>semctl</code>调用应该注意的。</li>
</ul>
<p>&emsp;&emsp;5. 竞争问题<br>&emsp;&emsp;第一个创建信号灯的进程同时也初始化信号灯，这样系统调用<code>semget</code>包含了两个步骤：创建信号灯；初始化信号灯。由此可能导致一种竞争状态：第一个创建信号灯的进程在初始化信号灯时，第二个进程又调用<code>semget</code>，并且发现信号灯已经存在，此时第二个进程必须具有判断是否有进程正在对信号灯进行初始化的能力。这里给出了绕过这种竞争状态的方法：当<code>semget</code>创建一个新的信号灯时，信号灯结构<code>semid_ds</code>的<code>sem_otime</code>成员初始化后的值为<code>0</code>。因此，第二个进程在成功调用<code>semget</code>后，可再次以<code>IPC_STAT</code>命令调用<code>semctl</code>，等待<code>sem_otime</code>变为非<code>0</code>值，此时可判断该信号灯已经初始化完毕。下图描述了竞争状态产生及解决方法：</p>
<p><img src="/2019/03/14/Linux系统编程/多进程编程之信号量/3.png"></p>
<p>&emsp;&emsp;实际上，这种解决方法也是基于这样一个假定：第一个创建信号灯的进程必须调用<code>semop</code>，这样<code>sem_otime</code>才能变为非零值。另外，因为第一个进程可能不调用<code>semop</code>，或者<code>semop</code>操作需要很长时间，第二个进程可能无限期等待下去，或者等待很长时间。<br>&emsp;&emsp;信号灯与其它进程间通信方式有所不同，它主要用于进程间同步。通常所说的系统V信号灯实际上是一个信号灯的集合，可用于多种共享资源的进程间同步。每个信号灯都有一个值，可以用来表示当前该信号灯代表的共享资源可用(<code>available</code>)数量，如果一个进程要申请共享资源，那么就从信号灯值中减去要申请的数目，如果当前没有足够的可用资源，进程可以睡眠等待，也可以立即返回。当进程要申请多种共享资源时，<code>linux</code>可以保证操作的原子性，即要么申请到所有的共享资源，要么放弃所有资源，这样能够保证多个进程不会造成互锁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/13/网络编程/IP数据报格式详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/网络编程/IP数据报格式详解/" itemprop="url">IP数据报格式详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T20:14:07+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>TCP/IP</code>协议定义了一个在因特网上传输的包，称为<code>IP</code>数据报(<code>IP Datagram</code>)。这是一个与硬件无关的虚拟包，由首部和数据两部分组成。首部的前一部分是固定长度，共<code>20</code>字节，是所有<code>IP</code>数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。首都中的源地址和目的地址都是<code>IP</code>协议地址。</p>
<p><img src="/2019/03/13/网络编程/IP数据报格式详解/1.jpg" height="235" width="370"></p>
<p>&emsp;&emsp;<code>IP</code>数据报首部的固定部分中的各字段：</p>
<ul>
<li>版本：占<code>4</code>位，指<code>IP</code>协议的版本，通信双方使用的<code>IP</code>协议版本必须一致。日前广泛使用的<code>IP</code>协议版本号为<code>4</code>(即<code>IPv4</code>)。</li>
<li>首部长度：占<code>4</code>位，可表示的最大十进制数值是<code>15</code>。请注意，这个字段所表示数的单位是<code>32</code>位字(<code>1</code>个<code>32</code>位字长是<code>4</code>字节)，因此当<code>IP</code>的首部长度为<code>1111</code>时(即十进制的<code>15</code>)，首部长度就达到<code>60</code>字节。当<code>IP</code>分组的首部长度不是<code>4</code>字节的整数倍时，必须利用最后的填充字段加以填充，因此数据部分永远在<code>4</code>字节的整数倍开始，这样在实现<code>IP</code>协议时较为方便。首部长度限制为<code>60</code>字节的缺点是有时可能不够用，这样做的目的是希望用户尽量减少开销。最常用的首部长度就是<code>20</code>字节(即首部长度为<code>0101</code>)，这时不使用任何选项。</li>
<li>服务：占<code>8</code>位，用来获得更好的服务，一般不使用。服务类型字段实际上被划分为<code>2</code>个部分，一部分为优先权，一部分为<code>TOS</code>。优先权用来设定报文的优先级，就像邮包分为挂号和平信一样。<code>TOS</code>允许按照吞吐量、时延、可靠性和费用方式选择传输服务，在早期的时候，<code>TOS</code>还被用来进行路由选择。在<code>QOS</code>中有时也会使用优先权，常见的优先权队列。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。<code>1998</code>年<code>IETF</code>把这个字段改名为区分服务<code>DS</code>(<code>Differentiated Services</code>)，只有在使用区分服务时，这个字段才起作用。</li>
<li>总长度：总长度指首都及数据之和的长度，单位为字节。因为总长度字段为<code>16</code>位，所以数据报的最大长度为<code>65535</code>字节。在<code>IP</code>层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，即最大传送单元<code>MTU</code>(<code>Maximum Transfer Unit</code>)。当一个数据报封装成链路层的帧时，此数据报的总长度(即首部加上数据部分)一定不能超过下面的数据链路层的<code>MTU</code>值。如果报文总长度大于数据链路可传输的最大传输单元，那么就会对报文进行分片。</li>
<li>标识(<code>Identification</code>)：占<code>16</code>位。<code>IP</code>软件在存储器中维持一个计数器，每产生一个数据报，计数器就加<code>1</code>，并将此值赋给标识字段。但这个<code>标识</code>并不是序号，因为<code>IP</code>是无连接的服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的<code>MTU</code>而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</li>
<li>标志(<code>Flag</code>)：占<code>3</code>位，但目前只有<code>2</code>位有意义，其中第一位没有被使用。第二位是不分片位，当<code>DF</code>位被置<code>1</code>，表示路由器不能对数据报文进行分片处理，如果报文由于不能被分片而不能被转发，那么路由器将丢弃这个数据包，并向源地址发送错误报告。这一功能可以用来测试线路的最大传输单元，只有当<code>DF = 0</code>时才允许分片。第三位为<code>MF</code>，当路由器对数据进行分片时，除了最后一个分片的<code>MF</code>位为<code>0</code>外，其他所有的<code>MF</code>全部为<code>1</code>，表示其后面还有其他的分片。<code>MF = 1</code>表示后面<code>还有分片</code>的数据报；<code>MF = 0</code>表示这已是若干数据报片中的最后一个。</li>
<li>片偏移：占<code>13</code>位。较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以<code>8</code>个字节为偏移单位。这就是说，每个分片的长度一定是<code>8</code>字节(<code>64</code>位)的整数倍。</li>
<li>生存时间：占<code>8</code>位，生存时间字段常用的英文缩写是<code>TTL</code>(<code>Time To Live</code>)，其表明数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子，因而白白消耗网络资源。每经过一个路由器时，就将<code>TTL</code>减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于<code>1</code>秒，就把<code>TTL</code>值减<code>1</code>。当<code>TTL</code>值为<code>0</code>时，就丢弃这个数据报，同时向源地址发送错误报告，促使重新发送。</li>
<li>协议：占<code>8</code>位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的<code>IP</code>层知道应将数据部分上交给哪个处理过程，常用的有<code>ICMP</code>(<code>1</code>)、<code>IGMP</code>(<code>2</code>)、<code>TCP</code>(<code>6</code>)、<code>UDP</code>(<code>17</code>)、<code>IPv6</code>(<code>41</code>)。</li>
<li>首部检验和：占<code>16</code>位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，都要重新计算一下首都检验和(一些字段，如生存时间、标志、片偏移等都可能发生变化)。不检验数据部分可减少计算的工作量。</li>
<li>源地址：发送方<code>IP</code>地址。</li>
<li>目的地址：接收方<code>IP</code>地址。</li>
</ul>
<p><img src="/2019/03/13/网络编程/IP数据报格式详解/2.jpg" height="207" width="359"></p>
<p>&emsp;&emsp;<code>IP</code>数据报首部的可变部分：<code>IP</code>首都的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从<code>1</code>个字节到<code>40</code>个字节不等，取决于所选择的项目。某些选项只需要<code>1</code>个字节，它只包括<code>1</code>个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全<code>0</code>的填充字段补齐成为<code>4</code>字节的整数倍。增加首都的可变部分是为了增加<code>IP</code>数据报的功能，但这同时也使得<code>IP</code>数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的<code>IPv6</code>就将<code>IP</code>数据报的首部长度做成固定的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/13/网络编程/原始套接字实例_MAC头部报文/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/网络编程/原始套接字实例_MAC头部报文/" itemprop="url">原始套接字实例_MAC头部报文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T20:01:28+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;链路层封包格式如下：</p>
<p><img src="/2019/03/13/网络编程/原始套接字实例_MAC头部报文/1.jpg" height="284" width="543"></p>
<p>&emsp;&emsp;<code>MAC</code>头部(有线局域网)如下(<code>CRC</code>、<code>PAD</code>在组包时可以忽略)：</p>
<p><img src="/2019/03/13/网络编程/原始套接字实例_MAC头部报文/2.png"></p>
<p>&emsp;&emsp;链路层数据包的其中一种情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> msg[<span class="number">1024</span>] = &#123;</span><br><span class="line">    <span class="comment">/* 组MAC(14直接) */</span></span><br><span class="line">    <span class="number">0xb8</span>, <span class="number">0x88</span>, <span class="number">0xe3</span>, <span class="number">0xe1</span>, <span class="number">0x10</span>, <span class="number">0xe6</span>, <span class="comment">/* dst_mac: b8:88:e3:e1:10:e6 */</span></span><br><span class="line">    <span class="number">0xc8</span>, <span class="number">0x9c</span>, <span class="number">0xdc</span>, <span class="number">0xb7</span>, <span class="number">0x0f</span>, <span class="number">0x19</span>, <span class="comment">/* src_mac: c8:9c:dc:b7:0f:19 */</span></span><br><span class="line">    <span class="number">0x08</span>, <span class="number">0x00</span>,                         <span class="comment">/* 类型：0x0800(IP协议) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接收的链路层数据包，并对其进行简单分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ether.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">1024</span>] = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> sock_raw_fd = socket ( PF_PACKET, SOCK_RAW, htons ( ETH_P_ALL ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> src_mac[<span class="number">18</span>] = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> dst_mac[<span class="number">18</span>] = <span class="string">""</span>;</span><br><span class="line">        recvfrom ( sock_raw_fd, buf, <span class="keyword">sizeof</span> ( buf ), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> ); <span class="comment">/* 获取链路层的数据帧 */</span></span><br><span class="line">        <span class="comment">/* 从buf里提取目的mac、源mac */</span></span><br><span class="line">        <span class="built_in">sprintf</span> ( dst_mac, <span class="string">"%02x:%02x:%02x:%02x:%02x:%02x"</span>, buf[<span class="number">0</span>], buf[<span class="number">1</span>], buf[<span class="number">2</span>], buf[<span class="number">3</span>], buf[<span class="number">4</span>], buf[<span class="number">5</span>] );</span><br><span class="line">        <span class="built_in">sprintf</span> ( src_mac, <span class="string">"%02x:%02x:%02x:%02x:%02x:%02x"</span>, buf[<span class="number">6</span>], buf[<span class="number">7</span>], buf[<span class="number">8</span>], buf[<span class="number">9</span>], buf[<span class="number">10</span>], buf[<span class="number">11</span>] );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( buf[<span class="number">12</span>] == <span class="number">0x08</span> &amp;&amp; buf[<span class="number">13</span>] == <span class="number">0x00</span> ) &#123; <span class="comment">/* 判断是否为IP数据包 */</span></span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"______________IP数据报_______________\n"</span> );</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"MAC:%s &gt;&gt; %s\n"</span>, src_mac, dst_mac );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( buf[<span class="number">12</span>] == <span class="number">0x08</span> &amp;&amp; buf[<span class="number">13</span>] == <span class="number">0x06</span> ) &#123; <span class="comment">/* 判断是否为ARP数据包 */</span></span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"______________ARP数据报_______________\n"</span> );</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"MAC:%s &gt;&gt; %s\n"</span>, src_mac, dst_mac );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( buf[<span class="number">12</span>] == <span class="number">0x80</span> &amp;&amp; buf[<span class="number">13</span>] == <span class="number">0x35</span> ) &#123; <span class="comment">/* 判断是否为RARP数据包 */</span></span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"______________RARP数据报_______________\n"</span> );</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"MAC:%s&gt;&gt;%s\n"</span>, src_mac, dst_mac );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，要以管理者权限运行程序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/13/Linux系统编程/Linux视频采集与编码/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/Linux系统编程/Linux视频采集与编码/" itemprop="url">Linux视频采集与编码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T19:40:41+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;在<code>Linux</code>下用<code>V4L2</code>采集<code>yuv</code>视频，然后用<code>x264</code>编码成<code>h.264</code>文件。我将<code>yuv</code>视频保存到文件中(我采集视频的尺寸为<code>640 * 480</code>，<code>YUV</code>格式为<code>YUYV</code>即<code>YUV422</code>)，然后用<code>pyuv</code>播放器播放它，悲剧的是播放出来的视频花屏了。<br>&emsp;&emsp;后来认真看代码，发现其中有这么一句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;</span><br></pre></td></tr></table></figure>
<p>意思就是采集数据的时候使用的是隔行扫描的方式，也就是说采集到的<code>yuv</code>写到文件中的方式是用隔行扫描的方式保存。如果不将<code>Interleaved</code>复选框勾起来，播放器就不能正常的播放<code>yuv</code>文件。<code>V4L2</code>视频采集代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/types.h&gt; /* for videodev2.h */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/videodev2.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLEAR(x) memset (&amp;(x), 0, sizeof (x))</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    IO_METHOD_READ,</span><br><span class="line">    IO_METHOD_MMAP,</span><br><span class="line">    IO_METHOD_USERPTR,</span><br><span class="line">&#125; io_method;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *start;</span><br><span class="line">    <span class="keyword">size_t</span> length;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *dev_name = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> io_method io = IO_METHOD_MMAP;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">buffers</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_buffers = <span class="number">0</span>;</span><br><span class="line">​</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">char</span> *filename = <span class="string">"test.yuv\0"</span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">errno_exit</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *s )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"%s error %d, %s\n"</span>, s, errno, strerror ( errno ) );</span><br><span class="line">    <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xioctl</span> <span class="params">( <span class="keyword">int</span> fd, <span class="keyword">int</span> request, <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        r = ioctl ( fd, request, arg );</span><br><span class="line">    &#125; <span class="keyword">while</span> ( <span class="number">-1</span> == r &amp;&amp; EINTR == errno );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_image</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *p, <span class="keyword">int</span> size )</span> </span>&#123;</span><br><span class="line">    fwrite ( p, size, <span class="number">1</span>, fp );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">read_frame</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( io ) &#123;</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_READ:</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == read ( fd, buffers[<span class="number">0</span>].start, buffers[<span class="number">0</span>].length ) ) &#123;</span><br><span class="line">                <span class="keyword">switch</span> ( errno ) &#123;</span><br><span class="line">                    <span class="keyword">case</span> EAGAIN:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">​</span><br><span class="line">                    <span class="keyword">case</span> EIO:</span><br><span class="line">​</span><br><span class="line">                    <span class="comment">/* Could ignore EIO, see spec. */</span></span><br><span class="line">                    <span class="comment">/* fall through */</span></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        errno_exit ( <span class="string">"read"</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            process_image ( buffers[<span class="number">0</span>].start, buffers[<span class="number">0</span>].length );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_MMAP:</span><br><span class="line">            CLEAR ( buf );</span><br><span class="line">            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">            buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_DQBUF, &amp;buf ) ) &#123;</span><br><span class="line">                <span class="keyword">switch</span> ( errno ) &#123;</span><br><span class="line">                    <span class="keyword">case</span> EAGAIN:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">​</span><br><span class="line">                    <span class="keyword">case</span> EIO:</span><br><span class="line">​</span><br><span class="line">                    <span class="comment">/* Could ignore EIO, see spec. */</span></span><br><span class="line">​</span><br><span class="line">                    <span class="comment">/* fall through */</span></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        errno_exit ( <span class="string">"VIDIOC_DQBUF"</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            assert ( buf.index &lt; n_buffers );</span><br><span class="line">            process_image ( buffers[buf.index].start, buf.length );</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_QBUF, &amp;buf ) ) &#123;</span><br><span class="line">                errno_exit ( <span class="string">"VIDIOC_QBUF"</span> );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_USERPTR:</span><br><span class="line">            CLEAR ( buf );</span><br><span class="line">            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">            buf.memory = V4L2_MEMORY_USERPTR;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_DQBUF, &amp;buf ) ) &#123;</span><br><span class="line">                <span class="keyword">switch</span> ( errno ) &#123;</span><br><span class="line">                    <span class="keyword">case</span> EAGAIN:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">​</span><br><span class="line">                    <span class="keyword">case</span> EIO:</span><br><span class="line">​</span><br><span class="line">                    <span class="comment">/* Could ignore EIO, see spec. */</span></span><br><span class="line">​</span><br><span class="line">                    <span class="comment">/* fall through */</span></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        errno_exit ( <span class="string">"VIDIOC_DQBUF"</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n_buffers; ++i )</span><br><span class="line">                <span class="keyword">if</span> ( buf.m.userptr == ( <span class="keyword">unsigned</span> <span class="keyword">long</span> ) buffers[i].start</span><br><span class="line">                     &amp;&amp; buf.length == buffers[i].length ) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">​</span><br><span class="line">            assert ( i &lt; n_buffers );</span><br><span class="line">            process_image ( ( <span class="keyword">void</span> * ) buf.m.userptr, buf.length );</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_QBUF, &amp;buf ) ) &#123;</span><br><span class="line">                errno_exit ( <span class="string">"VIDIOC_QBUF"</span> );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mainloop</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    count = <span class="number">100</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( count-- &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">            fd_set fds;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">            <span class="keyword">int</span> r;</span><br><span class="line">            FD_ZERO ( &amp;fds );</span><br><span class="line">            FD_SET ( fd, &amp;fds );</span><br><span class="line">            <span class="comment">/* Timeout. */</span></span><br><span class="line">            tv.tv_sec = <span class="number">2</span>;</span><br><span class="line">            tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">            r = select ( fd + <span class="number">1</span>, &amp;fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv );</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == r ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( EINTR == errno ) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">​</span><br><span class="line">                errno_exit ( <span class="string">"select"</span> );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">0</span> == r ) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"select timeout\n"</span> );</span><br><span class="line">                <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( read_frame() ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="comment">/* EAGAIN - continue select loop. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stop_capturing</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> v4l2_buf_type type;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( io ) &#123;</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_READ:</span><br><span class="line">            <span class="comment">/* Nothing to do. */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_MMAP:</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_USERPTR:</span><br><span class="line">            type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_STREAMOFF, &amp;type ) ) &#123;</span><br><span class="line">                errno_exit ( <span class="string">"VIDIOC_STREAMOFF"</span> );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start_capturing</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">enum</span> v4l2_buf_type type;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( io ) &#123;</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_READ:</span><br><span class="line">            <span class="comment">/* Nothing to do. */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_MMAP:</span><br><span class="line">            <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n_buffers; ++i ) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">                CLEAR ( buf );</span><br><span class="line">                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">                buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">                buf.index = i;</span><br><span class="line">​</span><br><span class="line">                <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_QBUF, &amp;buf ) ) &#123;</span><br><span class="line">                    errno_exit ( <span class="string">"VIDIOC_QBUF"</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_STREAMON, &amp;type ) ) &#123;</span><br><span class="line">                errno_exit ( <span class="string">"VIDIOC_STREAMON"</span> );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_USERPTR:</span><br><span class="line">            <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n_buffers; ++i ) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">                CLEAR ( buf );</span><br><span class="line">                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">                buf.memory = V4L2_MEMORY_USERPTR;</span><br><span class="line">                buf.index = i;</span><br><span class="line">                buf.m.userptr = ( <span class="keyword">unsigned</span> <span class="keyword">long</span> ) buffers[i].start;</span><br><span class="line">                buf.length = buffers[i].length;</span><br><span class="line">​</span><br><span class="line">                <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_QBUF, &amp;buf ) ) &#123;</span><br><span class="line">                    errno_exit ( <span class="string">"VIDIOC_QBUF"</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_STREAMON, &amp;type ) ) &#123;</span><br><span class="line">                errno_exit ( <span class="string">"VIDIOC_STREAMON"</span> );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uninit_device</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( io ) &#123;</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_READ:</span><br><span class="line">            <span class="built_in">free</span> ( buffers[<span class="number">0</span>].start );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_MMAP:</span><br><span class="line">            <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n_buffers; ++i )</span><br><span class="line">                <span class="keyword">if</span> ( <span class="number">-1</span> == munmap ( buffers[i].start, buffers[i].length ) ) &#123;</span><br><span class="line">                    errno_exit ( <span class="string">"munmap"</span> );</span><br><span class="line">                &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_USERPTR:</span><br><span class="line">            <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n_buffers; ++i ) &#123;</span><br><span class="line">                <span class="built_in">free</span> ( buffers[i].start );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">free</span> ( buffers );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_read</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> buffer_size )</span> </span>&#123;</span><br><span class="line">    buffers = <span class="built_in">calloc</span> ( <span class="number">1</span>, <span class="keyword">sizeof</span> ( *buffers ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !buffers ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Out of memory\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    buffers[<span class="number">0</span>].length = buffer_size;</span><br><span class="line">    buffers[<span class="number">0</span>].start = <span class="built_in">malloc</span> ( buffer_size );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !buffers[<span class="number">0</span>].start ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Out of memory\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_mmap</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_requestbuffers</span> <span class="title">req</span>;</span></span><br><span class="line">    CLEAR ( req );</span><br><span class="line">    req.count = <span class="number">4</span>;</span><br><span class="line">    req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    req.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_REQBUFS, &amp;req ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( EINVAL == errno ) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"%s does not support memory mapping\n"</span>, dev_name );</span><br><span class="line">            <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            errno_exit ( <span class="string">"VIDIOC_REQBUFS"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( req.count &lt; <span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Insufficient buffer memory on %s\n"</span>, dev_name );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    buffers = <span class="built_in">calloc</span> ( req.count, <span class="keyword">sizeof</span> ( *buffers ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !buffers ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Out of memory\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( n_buffers = <span class="number">0</span>; n_buffers &lt; req.count; ++n_buffers ) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">        CLEAR ( buf );</span><br><span class="line">        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">        buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">        buf.index = n_buffers;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_QUERYBUF, &amp;buf ) ) &#123;</span><br><span class="line">            errno_exit ( <span class="string">"VIDIOC_QUERYBUF"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        buffers[n_buffers].length = buf.length;</span><br><span class="line">        buffers[n_buffers].start = mmap ( <span class="literal">NULL</span> <span class="comment">/* start anywhere */</span>,</span><br><span class="line">                                          buf.length,</span><br><span class="line">                                          PROT_READ | PROT_WRITE <span class="comment">/* required */</span>,</span><br><span class="line">                                          MAP_SHARED <span class="comment">/* recommended */</span>,</span><br><span class="line">                                          fd, buf.m.offset );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( MAP_FAILED == buffers[n_buffers].start ) &#123;</span><br><span class="line">            errno_exit ( <span class="string">"mmap"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_userp</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> buffer_size )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_requestbuffers</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> page_size;</span><br><span class="line">    page_size = getpagesize();</span><br><span class="line">    buffer_size = ( buffer_size + page_size - <span class="number">1</span> ) &amp; ~ ( page_size - <span class="number">1</span> );</span><br><span class="line">    CLEAR ( req );</span><br><span class="line">    req.count = <span class="number">4</span>;</span><br><span class="line">    req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    req.memory = V4L2_MEMORY_USERPTR;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_REQBUFS, &amp;req ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( EINVAL == errno ) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"%s does not support "</span></span><br><span class="line">                      <span class="string">"user pointer i/o\n"</span>, dev_name );</span><br><span class="line">            <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            errno_exit ( <span class="string">"VIDIOC_REQBUFS"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    buffers = <span class="built_in">calloc</span> ( <span class="number">4</span>, <span class="keyword">sizeof</span> ( *buffers ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !buffers ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Out of memory\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( n_buffers = <span class="number">0</span>; n_buffers &lt; <span class="number">4</span>; ++n_buffers ) &#123;</span><br><span class="line">        buffers[n_buffers].length = buffer_size;</span><br><span class="line">        buffers[n_buffers].start = memalign ( <span class="comment">/* boundary */</span>page_size,</span><br><span class="line">                                                            buffer_size );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( !buffers[n_buffers].start ) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Out of memory\n"</span> );</span><br><span class="line">            <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_device</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_capability</span> <span class="title">cap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_cropcap</span> <span class="title">cropcap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_crop</span> <span class="title">crop</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_format</span> <span class="title">fmt</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> min;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_QUERYCAP, &amp;cap ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( EINVAL == errno ) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"%s is no V4L2 device\n"</span>, dev_name );</span><br><span class="line">            <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            errno_exit ( <span class="string">"VIDIOC_QUERYCAP"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ! ( cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE ) ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"%s is no video capture device\n"</span>, dev_name );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( io ) &#123;</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_READ:</span><br><span class="line">            <span class="keyword">if</span> ( ! ( cap.capabilities &amp; V4L2_CAP_READWRITE ) ) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"%s does not support read i/o\n"</span>, dev_name );</span><br><span class="line">                <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_MMAP:</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_USERPTR:</span><br><span class="line">            <span class="keyword">if</span> ( ! ( cap.capabilities &amp; V4L2_CAP_STREAMING ) ) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"%s does not support streaming i/o\n"</span>, dev_name );</span><br><span class="line">                <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* Select video input, video standard and tune here. */</span></span><br><span class="line">    CLEAR ( cropcap );</span><br><span class="line">    cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">0</span> == xioctl ( fd, VIDIOC_CROPCAP, &amp;cropcap ) ) &#123;</span><br><span class="line">        crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">        crop.c = cropcap.defrect; <span class="comment">/* reset to default */</span></span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_S_CROP, &amp;crop ) ) &#123;</span><br><span class="line">            <span class="keyword">switch</span> ( errno ) &#123;</span><br><span class="line">                <span class="keyword">case</span> EINVAL:</span><br><span class="line">                    <span class="comment">/* Cropping not supported. */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">/* Errors ignored. */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Errors ignored. */</span></span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    CLEAR ( fmt );</span><br><span class="line">    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    fmt.fmt.pix.width = <span class="number">640</span>;</span><br><span class="line">    fmt.fmt.pix.height = <span class="number">480</span>;</span><br><span class="line">    fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;</span><br><span class="line">    fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_S_FMT, &amp;fmt ) ) &#123;</span><br><span class="line">        errno_exit ( <span class="string">"VIDIOC_S_FMT"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* Note VIDIOC_S_FMT may change width and height. */</span></span><br><span class="line">    <span class="comment">/* Buggy driver paranoia. */</span></span><br><span class="line">    min = fmt.fmt.pix.width * <span class="number">2</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( fmt.fmt.pix.bytesperline &lt; min ) &#123;</span><br><span class="line">        fmt.fmt.pix.bytesperline = min;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    min = fmt.fmt.pix.bytesperline * fmt.fmt.pix.height;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( fmt.fmt.pix.sizeimage &lt; min ) &#123;</span><br><span class="line">        fmt.fmt.pix.sizeimage = min;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( io ) &#123;</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_READ:</span><br><span class="line">            init_read ( fmt.fmt.pix.sizeimage );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_MMAP:</span><br><span class="line">            init_mmap();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_USERPTR:</span><br><span class="line">            init_userp ( fmt.fmt.pix.sizeimage );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close_device</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == close ( fd ) ) &#123;</span><br><span class="line">        errno_exit ( <span class="string">"close"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    fd = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open_device</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == stat ( dev_name, &amp;st ) ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Cannot identify '%s': %d, %s\n"</span>, dev_name, errno, strerror ( errno ) );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !S_ISCHR ( st.st_mode ) ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"%s is no device\n"</span>, dev_name );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    fd = open ( dev_name, O_RDWR <span class="comment">/* required */</span> | O_NONBLOCK, <span class="number">0</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == fd ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Cannot open '%s': %d, %s\n"</span>, dev_name, errno, strerror ( errno ) );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usage</span> <span class="params">( FILE *fp, <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span> ( fp, <span class="string">"Usage: %s [options]\n\n"</span></span><br><span class="line">              <span class="string">"Options:\n"</span></span><br><span class="line">              <span class="string">"-d | --device name  Video device name [/dev/video]\n"</span></span><br><span class="line">              <span class="string">"-h | --help         Print this message\n"</span></span><br><span class="line">              <span class="string">"-m | --mmap         Use memory mapped buffers\n"</span></span><br><span class="line">              <span class="string">"-r | --read         Use read() calls\n"</span></span><br><span class="line">              <span class="string">"-u | --userp        Use application allocated buffers\n"</span></span><br><span class="line">              <span class="string">""</span>, argv[<span class="number">0</span>] );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> short_options[] = <span class="string">"d:hmru"</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_options</span>[] = &#123;</span> &#123; <span class="string">"device"</span>, required_argument,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="string">'d'</span></span><br><span class="line">    &#125;, &#123; <span class="string">"help"</span>, no_argument, <span class="literal">NULL</span>, <span class="string">'h'</span> &#125;, &#123; <span class="string">"mmap"</span>, no_argument,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="string">'m'</span></span><br><span class="line">    &#125;, &#123; <span class="string">"read"</span>, no_argument, <span class="literal">NULL</span>, <span class="string">'r'</span> &#125;, &#123; <span class="string">"userp"</span>, no_argument,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="string">'u'</span></span><br><span class="line">    &#125;, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    dev_name = <span class="string">"/dev/video0"</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        c = getopt_long ( argc, argv, short_options, long_options, &amp;index );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( <span class="number">-1</span> == c ) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">switch</span> ( c ) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* getopt_long() flag */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">                dev_name = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">                usage ( <span class="built_in">stdout</span>, argc, argv );</span><br><span class="line">                <span class="built_in">exit</span> ( EXIT_SUCCESS );</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line">                io = IO_METHOD_MMAP;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">                io = IO_METHOD_READ;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">                io = IO_METHOD_USERPTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                usage ( <span class="built_in">stderr</span>, argc, argv );</span><br><span class="line">                <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    open_device();</span><br><span class="line">    init_device();</span><br><span class="line">    start_capturing();</span><br><span class="line">    fp = fopen ( filename, <span class="string">"wa+"</span> );</span><br><span class="line">    mainloop();</span><br><span class="line">    fclose ( fp );</span><br><span class="line">    stop_capturing();</span><br><span class="line">    uninit_device();</span><br><span class="line">    close_device();</span><br><span class="line">    <span class="built_in">exit</span> ( EXIT_SUCCESS );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>补充说明</strong>：这是我在计算机上的软件设置：</p>
<p><img src="/2019/03/13/Linux系统编程/Linux视频采集与编码/1.jpg"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/13/Linux系统编程/信号/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/Linux系统编程/信号/" itemprop="url">信号</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T14:20:36+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="信号通信"><a href="#信号通信" class="headerlink" title="信号通信"></a>信号通信</h3><p>&emsp;&emsp;信号(<code>signal</code>)机制是<code>Unix</code>系统中最为古老的进程间通信机制，很多条件可以产生一个信号：</p>
<ul>
<li>当用户按某些按键时，产生信号。</li>
<li>硬件异常产生信号：除数为<code>0</code>、无效的存储访问等等。这些情况通常由硬件检测到，将其通知内核，然后内核产生适当的信号通知进程，例如内核对正访问一个无效存储区的进程产生一个<code>SIGSEGV</code>信号。</li>
<li>进程用<code>kill</code>函数将信号发送给另一个进程。</li>
<li>用户可用<code>kill</code>命令将信号发送给其他进程。</li>
</ul>
<h3 id="信号类型"><a href="#信号类型" class="headerlink" title="信号类型"></a>信号类型</h3><p>&emsp;&emsp;下面是几种常见的信号：</p>
<ul>
<li><code>SIGHUP</code>：从终端上发出的结束信号。</li>
<li><code>SIGINT</code>：来自键盘的中断信号(<code>Ctrl-C</code>)。</li>
<li><code>SIGKILL</code>：该信号结束接收信号的进程。</li>
<li><code>SIGTERM</code>：<code>kill</code>命令发出的信号。</li>
<li><code>SIGCHLD</code>：标识子进程停止或结束的信号。</li>
<li><code>SIGSTOP</code>：来自键盘(<code>Ctrl-Z</code>)或调试程序的停止执行信号。</li>
<li><code>SIGQUIT</code>：来自键盘的退出信号(<code>Ctrl-\</code>)。</li>
<li><code>SIGFPE</code>：浮点异常信号(例如浮点运算溢出)。</li>
<li><code>SIGALRM</code>：进程的定时器到期，发送该信号。</li>
<li><code>SIGSEGV</code>：非法存储器访问，如访问不存在的内存单元。</li>
</ul>
<h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><p>&emsp;&emsp;当某信号出现时，将按照下列三种方式中的一种进行处理：</p>
<ul>
<li>忽略此信号：大多数信号都按照这种方式进行处理，但有两种信号却决不能被忽略，它们是<code>SIGKILL</code>和<code>SIGSTOP</code>。这两种信号不能被忽略的原因是：它们向超级用户提供了一种终止或停止进程的方法。</li>
<li>执行用户希望的动作：通知内核在某种信号发生时，调用一个用户函数。在用户函数中，执行用户希望的处理。</li>
<li>执行系统默认动作：对大多数信号的系统默认动作是终止该进程。</li>
</ul>
<h3 id="信号发送"><a href="#信号发送" class="headerlink" title="信号发送"></a>信号发送</h3><p>&emsp;&emsp;发送信号的主要函数有<code>kill</code>和<code>raise</code>。它们的区别是：<code>Kill</code>既可以向自身发送信号，也可以向其他进程发送信号。与<code>kill</code>函数不同的是，<code>raise</code>函数是向进程自身发送信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span> <span class="params">( <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signo )</span></span>; <span class="comment">/* 向进程号为pid的参数发送signo信号 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span> <span class="params">( <span class="keyword">int</span> signo )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>kill</code>的<code>pid</code>参数有四种不同的情况：</p>
<ul>
<li><code>pid &gt; 0</code>：将信号发送给进程<code>ID</code>为<code>pid</code>的进程。</li>
<li><code>pid = 0</code>：将信号发送给同组的进程。</li>
<li><code>pid &lt; 0</code>：将信号发送给其进程组<code>ID</code>等于<code>pid</code>绝对值的进程。</li>
<li><code>pid = -1</code>：将信号发送给所有进程(除了进程号最大的那个进程)。</li>
</ul>
<p>&emsp;&emsp;<code>raise</code>函数的使用如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/wait.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( pid = fork() ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fork"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123;</span><br><span class="line">        raise ( SIGSTOP );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"child process exit.\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"pid = %d\n"</span>, pid );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( ( waitpid ( pid, <span class="literal">NULL</span>, WNOHANG ) ) == <span class="number">0</span> ) &#123;</span><br><span class="line">            sleep ( <span class="number">1</span> );</span><br><span class="line">            kill ( pid, SIGKILL );</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"kill %d\n"</span>, pid );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><p>&emsp;&emsp;使用<code>alarm</code>函数可以设置一个时间值(闹钟时间)，当所设置的时间到了时，产生<code>SIGALRM</code>信号。如果不捕捉此信号，则默认动作是终止该进程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> seconds )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>seconds</code>为经过了指定的<code>seconds</code>秒后会产生信号<code>SIGALRM</code>。<br>&emsp;&emsp;每个进程只能有一个闹钟时间。如果在调用<code>alarm</code>时，以前已为该进程设置过闹钟时间，而且它还没有超时，以前登记的闹钟时间则被新值代换。如果有以前登记的尚未超过的闹钟时间，而这次<code>seconds</code>值是<code>0</code>，则表示取消以前的闹钟，其余留数仍作为函数的返回值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alarm_handler</span> <span class="params">( <span class="keyword">int</span> sign_no )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Alarm handler launched\n"</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    signal ( SIGALRM, alarm_handler );</span><br><span class="line">    alarm ( <span class="number">5</span> );</span><br><span class="line">    pause();</span><br><span class="line">    signal ( SIGALRM, SIG_DFL );</span><br><span class="line">    alarm ( <span class="number">2</span> );</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Pause"><a href="#Pause" class="headerlink" title="Pause"></a>Pause</h3><p>&emsp;&emsp;<code>pause</code>函数使调用进程挂起直至捕捉到一个信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span> <span class="params">( <span class="keyword">void</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>只有执行了一个信号处理函数后，挂起才结束。</p>
<h3 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h3><p>&emsp;&emsp;当系统捕捉到某个信号时，可以忽略该信号或是使用指定的处理函数来处理该信号，或者使用系统默认的方式。信号处理的主要方法有两种，一种是使用简单的<code>signal</code>函数，另一种是使用信号集函数组。</p>
<h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">( *<span class="keyword">sighandler_t</span> )</span> <span class="params">( <span class="keyword">int</span> )</span></span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> signal ( <span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler );</span><br></pre></td></tr></table></figure>
<p>函数执行成功则返回处理函数指针，失败则返回<code>SIG_ERR</code>。<code>handler</code>可能的值是：</p>
<ul>
<li><code>SIG_IGN</code>：忽略此信号。</li>
<li><code>SIG_DFL</code>：按系统默认方式处理。</li>
<li>信号处理函数名：使用该函数处理。</li>
</ul>
<p>&emsp;&emsp;对信号进行处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span> <span class="params">( <span class="keyword">int</span> sign_no )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( sign_no == SIGINT ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I have get SIGINT\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( sign_no == SIGQUIT ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I have get SIGQUIT\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 为信号SIGINT和SIGQUIT注册信号处理函数，</span></span><br><span class="line"><span class="comment">       如果没有信号过来，则程序一直等在那个地方 */</span></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Waiting for signal\n"</span> );</span><br><span class="line">    signal ( SIGINT,  myfunc );</span><br><span class="line">    signal ( SIGQUIT,  myfunc );</span><br><span class="line">    pause(); <span class="comment">/* 等待信号过来 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看进程号命令<code>ps -aux</code>，发送<code>SIGQUIT</code>信号<code>kill -s SIGQUIT 进程号</code>。</p>
<h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h3><p>&emsp;&emsp;<code>sigaction</code>函数的功能是用于改变进程接收到特定信号后的行为。<code>sigaction</code>检查或修改与指定信号相关联的处理动作，该函数取代了<code>signal</code>函数。因为<code>signal</code>函数在信号未决时接收信号可能出现问题，所以使用<code>sigaction</code>更安全。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span> <span class="params">( <span class="keyword">int</span> sig, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oact )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sig</code>：它是信号的值，可以为除了<code>SIGKILL</code>及<code>SIGSTOP</code>外的任何一个特定有效的信号(因为这两个信号定义了自己的处理函数，将导致信号安装错误)。</li>
<li><code>act</code>：它是指向<code>sigaction</code>一个实例的指针。在<code>sigaction</code>的实例中，指定了对特定信号的处理，可以为<code>NULL</code>，进程会以缺省方式对信号处理。</li>
<li><code>oact</code>：它指向的对象用来保存原来对相应信号的处理，可以为<code>NULL</code>。</li>
</ul>
<p>函数执行成功返回<code>0</code>，失败则返回<code>-1</code>。函数关键部分是<code>sigaction</code>结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> ( * ) ( <span class="keyword">int</span> ) sa_handle;</span><br><span class="line">    <span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line">    <span class="keyword">int</span> sa_flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其成员变量说明如下所示：<code>sa_handler</code>字段包含一个信号捕捉函数的地址；<code>sa_mask</code>字段说明了一个信号集，在调用该信号捕捉函数之前，这一信号集要加进进程的信号屏蔽字中，仅当从信号捕捉函数返回时，再将进程的信号屏蔽字复位为原先值。<code>sa_flags</code>的取值如下表，取<code>0</code>表示选用所有默认选项：</p>
<ul>
<li><code>SA_NOCLDSTOP</code>：用于表示信号<code>SIGCHLD</code>，当子进程被中断时，不产生此信号，当且仅当子进程结束时产生此信号。</li>
<li><code>SA_NOCLDWATI</code>：当信号为<code>SIGCHLD</code>时，可避免子进程僵死。</li>
<li><code>SA_NODEFER</code>：当信号处理函数正在进行时，不堵塞对于信号处理函数自身信号功能。</li>
<li><code>SA_NOMASK</code>：同<code>SA_NODEFER</code>。</li>
<li><code>SA_ONESHOT</code>：当用户注册的信号处理函数被执行过一次后，该信号的处理函数被设为系统默认的处理函数。</li>
<li><code>SA_RESETHAND</code>：同<code>SA_ONESHOT</code>。</li>
<li><code>SA_RESTART</code>：是本来不能重新于运行的系统调用自动重新运行。</li>
<li><code>SA_SIGINFO</code>：表明信号处理函数是由<code>SA_SIGACTION</code>指定的，而不是由<code>SA_HANDLER</code>指定的，它将显示更多的信号处理函数信息。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_handler</span> <span class="params">( <span class="keyword">int</span> sig )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"I got signal %d\n"</span>, sig );</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"i = %d\n"</span>, i );</span><br><span class="line">        sleep ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    act.sa_handler = show_handler;</span><br><span class="line">    sigaddset ( &amp;act.sa_mask, SIGQUIT );</span><br><span class="line">    act.sa_flags = SA_RESETHAND | SA_NODEFER;</span><br><span class="line">    sigaction ( SIGINT, &amp;act, &amp;oldact );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        sleep ( <span class="number">1</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"sleeping %d\n"</span>, i );</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="linux信号集"><a href="#linux信号集" class="headerlink" title="linux信号集"></a>linux信号集</h3><p>&emsp;&emsp;信号集被定义为一种数据类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sig[_NSIG_WORDS];</span><br><span class="line">&#125; <span class="keyword">sigset_t</span>;</span><br></pre></td></tr></table></figure>
<p>信号集用来描述信号的集合，每个信号占用一位。<code>Linux</code>所支持的所有信号可以全部或部分的出现在信号集中，主要与信号阻塞相关函数配合使用。下面是为信号集操作定义的相关函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 初始化由set指定的信号集，信号集里面的所有信号被清空，相当于64位置0 */</span></span><br><span class="line">sigemptyset ( <span class="keyword">sigset_t</span> *<span class="built_in">set</span> );</span><br><span class="line"><span class="comment">/* 调用该函数后，set指向的信号集中将包含linux支持的64种信号，相当于64位都置1 */</span></span><br><span class="line">sigfillset ( <span class="keyword">sigset_t</span> *<span class="built_in">set</span> );</span><br><span class="line"><span class="comment">/* 在set指向的信号集中加入signum信号，相当于将给定信号所对应的位置1 */</span></span><br><span class="line">sigaddset ( <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum );</span><br><span class="line"><span class="comment">/* 在set指向的信号集中删除signum信号，相当于将给定信号所对应的位置0 */</span></span><br><span class="line">sigdelset ( <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum );</span><br><span class="line"><span class="comment">/* 判定信号signum是否在set指向的信号集中，相当于检查给定信号所对应的位是0还是1 */</span></span><br><span class="line">sigismember ( <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum );</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sigset</span> <span class="params">( <span class="keyword">sigset_t</span> *<span class="built_in">set</span> )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> myset;</span><br><span class="line">    sigemptyset ( &amp;myset );</span><br><span class="line">    sigaddset ( &amp;myset, SIGINT );</span><br><span class="line">    sigaddset ( &amp;myset, SIGQUIT );</span><br><span class="line">    sigaddset ( &amp;myset, SIGUSR1 );</span><br><span class="line">    sigaddset ( &amp;myset, SIGRTMIN );</span><br><span class="line">    print_sigset ( &amp;myset );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sigset</span> <span class="params">( <span class="keyword">sigset_t</span> *<span class="built_in">set</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; NSIG; ++i ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( sigismember ( <span class="built_in">set</span>, i ) ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"1"</span> );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"0"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">putchar</span> ( <span class="string">'\n'</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="信号生命周期"><a href="#信号生命周期" class="headerlink" title="信号生命周期"></a>信号生命周期</h3><p>&emsp;&emsp;对于一个完整的信号生命周期(从信号发送到相应的处理函数执行完毕)来说，可以分为三个重要的阶段，这三个阶段由四个重要事件来刻画：信号诞生；信号在进程中注册完毕；信号在进程中的注销完毕；信号处理函数执行完毕。相邻两个事件的时间间隔构成信号生命周期的一个阶段。</p>
<p><img src="/2019/03/13/Linux系统编程/信号/1.png"></p>
<p>&emsp;&emsp;下面阐述四个事件的实际意义：</p>
<ul>
<li>信号诞生。信号的诞生指的是触发信号的事件发生(如检测到硬件异常、定时器超时以及调用信号发送函数<code>kill</code>或<code>sigqueue</code>等)。</li>
<li>信号在目标进程中注册。进程的<code>task_struct</code>结构中有关于本进程中未决信号的数据成员：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">head</span>, * *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> signal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第三个成员是进程中所有未决信号集，第一、第二个成员分别指向一个<code>sigqueue</code>类型的结构链(称之为<code>未决信号信息链</code>)的首尾，信息链中的每个<code>sigqueue</code>结构刻画一个特定信号所携带的信息，并指向下一个<code>sigqueue</code>结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">siginfo_t</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号在进程中注册指的就是信号值加入到进程的未决信号集中(<code>sigpending</code>结构的第二个成员<code>sigset_t signal</code>)，并且信号所携带的信息被保留到未决信号信息链的某个<code>sigqueue</code>结构中。只要信号在进程的未决信号集中，表明进程已经知道这些信号的存在，但还没来得及处理，或者该信号被进程阻塞。<br>&emsp;&emsp;当一个实时信号发送给一个进程时，不管该信号是否已经在进程中注册，都会被再注册一次，因此信号不会丢失，实时信号又叫做<code>可靠信号</code>。这意味着同一个实时信号可以在同一个进程的未决信号信息链中占有多个<code>sigqueue</code>结构(进程每收到一个实时信号，都会为它分配一个结构来登记该信号信息，并把该结构添加在未决信号链尾，即所有诞生的实时信号都会在目标进程中注册)。<br>&emsp;&emsp;当一个非实时信号发送给一个进程时，如果该信号已经在进程中注册，则该信号将被丢弃，造成信号丢失。因此，非实时信号又叫做<code>不可靠信号</code>。这意味着同一个非实时信号在进程的未决信号信息链中，至多占有一个<code>sigqueue</code>结构(一个非实时信号诞生后：如果发现相同的信号已经在目标结构中注册，则不再注册，对于进程来说，相当于不知道本次信号发生，信号丢失；如果进程的未决信号中没有相同信号，则在进程中注册自己。</p>
<ul>
<li>信号在进程中的注销。在目标进程执行过程中，会检测是否有信号等待处理(每次从系统空间返回到用户空间时都做这样的检查)。如果存在未决信号等待处理且该信号没有被进程阻塞，则在运行相应的信号处理函数前，进程会把信号在未决信号链中占有的结构卸掉。是否将信号从进程未决信号集中删除对于实时与非实时信号是不同的。对于非实时信号来说，由于在未决信号信息链中最多只占用一个<code>sigqueue</code>结构，因此该结构被释放后，应该把信号在进程未决信号集中删除(信号注销完毕)；而对于实时信号来说，可能在未决信号信息链中占用多个<code>sigqueue</code>结构，因此应该针对占用<code>sigqueue</code>结构的数目区别对待：如果只占用一个<code>sigqueue</code>结构(进程只收到该信号一次)，则应该把信号在进程的未决信号集中删除(信号注销完毕)。否则，不应该在进程的未决信号集中删除该信号(信号注销完毕)。进程在执行信号相应处理函数之前，首先要把信号在进程中注销。</li>
<li>信号生命终止。进程注销信号后，立即执行相应的信号处理函数，执行完毕后，信号的本次发送对进程的影响彻底结束。</li>
</ul>
<p>&emsp;&emsp;注意如下事项：</p>
<ul>
<li>信号注册与否，与发送信号的函数(如<code>kill</code>或<code>sigqueue</code>等)以及信号安装函数(<code>signal</code>及<code>sigaction</code>)无关，只与信号值有关(信号值小于<code>SIGRTMIN</code>的信号最多只注册一次，信号值在<code>SIGRTMIN</code>及<code>SIGRTMAX</code>之间的信号，只要被进程接收到就被注册)。</li>
<li>在信号被注销到相应的信号处理函数执行完毕这段时间内，如果进程又收到同一信号多次，则对实时信号来说，每一次都会在进程中注册；而对于非实时信号来说，无论收到多少次信号，都会视为只收到一个信号，只在进程中注册一次。</li>
</ul>
<h3 id="信号编程注意事项"><a href="#信号编程注意事项" class="headerlink" title="信号编程注意事项"></a>信号编程注意事项</h3><p>&emsp;&emsp;1. 防止不该丢失的信号丢失。如果对信号生命周期理解深刻的话，很容易知道信号会不会丢失，以及在哪里丢失。<br>&emsp;&emsp;2. 程序的可移植性：考虑到程序的可移植性，应该尽量采用<code>POSIX</code>信号函数，<code>POSIX</code>信号函数主要分为两类：</p>
<ul>
<li><code>POSIX 1003.1</code>信号函数：<code>kill</code>、<code>sigaction</code>、<code>sigaddset</code>、<code>sigdelset</code>、<code>sigemptyset</code>、<code>sigfillset</code>、<code>sigismember</code>、<code>sigpending</code>、<code>sigprocmask</code>、<code>sigsuspend</code>。</li>
<li><code>POSIX 1003.1b</code>信号函数：<code>POSIX 1003.1b</code>在信号的实时性方面对<code>POSIX 1003.1</code>做了扩展，包括以下三个函数：<code>sigqueue</code>、<code>sigtimedwait</code>、<code>sigwaitinfo</code>。其中，<code>sigqueue</code>主要针对信号发送，而<code>sigtimedwait</code>及<code>sigwaitinfo</code>主要用于取代<code>sigsuspend</code>函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigwaitinfo</span> <span class="params">( <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">siginfo_t</span> *info )</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数与<code>sigsuspend</code>类似，阻塞一个进程直到特定信号发生，但信号到来时不执行信号处理函数，而是返回信号值。因此为了避免执行相应的信号处理函数，必须在调用该函数前，使进程屏蔽掉<code>set</code>指向的信号，因此调用该函数的典型代码是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sigset_t</span> newmask;</span><br><span class="line"><span class="keyword">int</span> rcvd_sig;</span><br><span class="line"><span class="keyword">siginfo_t</span> info;</span><br><span class="line">sigemptyset ( &amp;newmask );</span><br><span class="line">sigaddset ( &amp;newmask, SIGRTMIN );</span><br><span class="line">sigprocmask ( SIG_BLOCK, &amp;newmask, <span class="literal">NULL</span> );</span><br><span class="line">rcvd_sig = sigwaitinfo ( &amp;newmask, &amp;info )</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( rcvd_sig == <span class="number">-1</span> ) &#123;</span><br><span class="line">    <span class="comment">/* user code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用成功返回信号值，否则返回<code>-1</code>。<code>sigtimedwait</code>功能相似，只不过增加了一个进程等待的时间。<br>&emsp;&emsp;为了增强程序的稳定性，在信号处理函数中应使用可重入函数。信号处理程序中应当使用可再入(可重入)函数。因为进程在收到信号后，就将跳转到信号处理函数去接着执行。如果信号处理函数中使用了不可重入函数，那么信号处理函数可能会修改原来进程中不应该被修改的数据，这样进程从信号处理函数中返回接着执行时，可能会出现不可预料的后果。不可再入函数在信号处理函数中被视为不安全函数。满足下列条件的函数多数是不可再入的：</p>
<ul>
<li>使用静态的数据结构，如<code>getlogin</code>、<code>gmtime</code>、<code>getgrgid</code>、<code>getgrnam</code>、<code>getpwuid</code>以及<code>getpwnam</code>等等。</li>
<li>函数实现时，调用了<code>malloc</code>或者<code>free</code>函数。</li>
<li>实现时使用了标准<code>I/O</code>函数的。</li>
</ul>
<p>&emsp;&emsp;<code>The Open Group</code>视下列函数为可再入的：<code>_exit</code>、<code>access</code>、<code>alarm</code>、<code>cfgetispeed</code>、<code>cfgetospeed</code>、<code>cfsetispeed</code>、<code>cfsetospeed</code>、<code>chdir</code>、<code>chmod</code>、<code>chown</code>、<code>close</code>、<code>creat</code>、<code>dup</code>、<code>dup2</code>、<code>execle</code>、<code>execve</code>、<code>fcntl</code>、<code>fork</code>、<code>fpathconf</code>、<code>fstat</code>、<code>fsync</code>、<code>getegid</code>、<code>geteuid</code>、<code>getgid</code>、<code>getgroups</code>、<code>getpgrp</code>、<code>getpid</code>、<code>getppid</code>、<code>getuid</code>、<code>kill</code>、<code>link</code>、<code>lseek</code>、<code>mkdir</code>、<code>mkfifo</code>、<code>open</code>、<code>pathconf</code>、<code>pause</code>、<code>pipe</code>、<code>raise</code>、<code>read</code>、<code>rename</code>、<code>rmdir</code>、<code>setgid</code>、<code>setpgid</code>、<code>setsid</code>、<code>setuid</code>、<code>sigaction</code>、<code>sigaddset</code>、<code>sigdelset</code>、<code>sigemptyset</code>、<code>sigfillset</code>、<code>sigismember</code>、<code>signal</code>、<code>sigpending</code>、<code>sigprocmask</code>、<code>sigsuspend</code>、<code>sleep</code>、<code>stat</code>、<code>sysconf</code>、<code>tcdrain</code>、<code>tcflow</code>、<code>tcflush</code>、<code>tcgetattr</code>、<code>tcgetpgrp</code>、<code>tcsendbreak</code>、<code>tcsetattr</code>、<code>tcsetpgrp</code>、<code>time</code>、<code>times</code>、<code>umask</code>、<code>uname</code>、<code>unlink</code>、<code>utime</code>、<code>wait</code>、<code>waitpid</code>、<code>write</code>。<br>&emsp;&emsp;即使信号处理函数使用的都是<code>安全函数</code>，同样要注意进入处理函数时，首先要保存<code>errno</code>的值，结束时，再恢复原值。因为信号处理过程中，<code>errno</code>值随时可能被改变。另外，<code>longjmp</code>以及<code>siglongjmp</code>没有被列为可再入函数，因为不能保证紧接着两个函数的其它调用是安全的。</p>
<h3 id="信号应用实例"><a href="#信号应用实例" class="headerlink" title="信号应用实例"></a>信号应用实例</h3><p>&emsp;&emsp;<code>Linux</code>下的信号应用并没有想象的那么恐怖，程序员所要做的最多只有三件事情：</p>
<ul>
<li>安装信号，推荐使用<code>sigaction</code>。</li>
<li>实现信号处理函数<code>handler(int signal, struct siginfo *info, void *)</code>。</li>
<li>发送信号，推荐使用<code>sigqueue</code>。</li>
</ul>
<p>实际上，对有些信号来说，只要安装信号就足够了(信号处理方式采用缺省或忽略)。其他可能要做的无非是与信号集相关的几种操作。<br>&emsp;&emsp;1. 信号发送及处理：实现一个信号接收程序<code>sigreceive</code>，其中信号安装由<code>sigaction</code>实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> * )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sig;</span><br><span class="line">    sig = atoi ( argv[<span class="number">1</span>] );</span><br><span class="line">    sigemptyset ( &amp;act.sa_mask );</span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    act.sa_sigaction = new_op;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigaction ( sig, &amp;act, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"install sigal error\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        sleep ( <span class="number">2</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"wait for the signal\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span> <span class="params">( <span class="keyword">int</span> signum, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *myact )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"receive signal %d"</span>, signum );</span><br><span class="line">    sleep ( <span class="number">5</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命令行参数为信号值，后台运行<code>sigreceive signo &amp;</code>，可获得该进程的<code>ID</code>，假设为<code>pid</code>，然后在另一终端上运行<code>kill -s signo pid</code>验证信号的发送接收及处理。同时，可验证信号的排队问题。<br>&emsp;&emsp;2. 信号传递附加信息：主要包括两个实例：</p>
<ul>
<li>向进程本身发送信号，并传递指针参数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> * )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">union</span> sigval mysigval;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sig;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memset</span> ( data, <span class="number">0</span>, <span class="keyword">sizeof</span> ( data ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">        data[i] = <span class="string">'2'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    mysigval.sival_ptr = data;</span><br><span class="line">    sig = atoi ( argv[<span class="number">1</span>] );</span><br><span class="line">    pid = getpid();</span><br><span class="line">    sigemptyset ( &amp;act.sa_mask );</span><br><span class="line">    act.sa_sigaction = new_op; <span class="comment">/* 三参数信号处理函数 */</span></span><br><span class="line">    act.sa_flags = SA_SIGINFO; <span class="comment">/* 信息传递开关 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigaction ( sig, &amp;act, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"install sigal error\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        sleep ( <span class="number">2</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"wait for the signal\n"</span> );</span><br><span class="line">        sigqueue ( pid, sig, mysigval ); <span class="comment">/* 向本进程发送信号，并传递附加信息 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span> <span class="params">( <span class="keyword">int</span> signum, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *myact )</span> </span>&#123; <span class="comment">/* 三参数信号处理函数的实现 */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"%c\n "</span>, ( * ( ( <span class="keyword">char</span> * ) ( ( *info ).si_ptr ) + i ) ) );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"handle signal %d over;"</span>, signum );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，信号实现了附加信息的传递，信号究竟如何对这些信息进行处理则取决于具体的应用。</p>
<ul>
<li>不同进程间传递整型参数：把<code>1</code>中的信号发送和接收放在两个程序中，并且在发送过程中传递整型参数。信号接收程序如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> * )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sig;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = getpid();</span><br><span class="line">    sig = atoi ( argv[<span class="number">1</span>] );</span><br><span class="line">    sigemptyset ( &amp;act.sa_mask );</span><br><span class="line">    act.sa_sigaction = new_op;</span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigaction ( sig, &amp;act, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"install sigal error\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        sleep ( <span class="number">2</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"wait for the signal\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span> <span class="params">( <span class="keyword">int</span> signum, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *myact )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"the int value is %d\n"</span>, info-&gt;si_int );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号发送程序：命令行第二个参数为信号值，第三个参数为接收进程<code>ID</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> signum;</span><br><span class="line">    <span class="keyword">union</span> sigval mysigval;</span><br><span class="line">    signum = atoi ( argv[<span class="number">1</span>] );</span><br><span class="line">    pid = ( <span class="keyword">pid_t</span> ) atoi ( argv[<span class="number">2</span>] );</span><br><span class="line">    mysigval.sival_int = <span class="number">8</span>; <span class="comment">/* 不代表具体含义，只用于说明问题 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigqueue ( pid, signum, mysigval ) == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"send error\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    sleep ( <span class="number">2</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例<code>2</code>的两个例子侧重点在于用信号来传递信息，目前关于在<code>linux</code>下通过信号传递信息的实例非常少。<br>&emsp;&emsp;3. 信号阻塞及信号集操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_op</span> <span class="params">( <span class="keyword">int</span> )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> new_mask, old_mask, pending_mask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    sigemptyset ( &amp;act.sa_mask );</span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    act.sa_sigaction = ( <span class="keyword">void</span> * ) my_op;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigaction ( SIGRTMIN + <span class="number">10</span>, &amp;act, <span class="literal">NULL</span> ) ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"install signal SIGRTMIN+10 error\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    sigemptyset ( &amp;new_mask );</span><br><span class="line">    sigaddset ( &amp;new_mask, SIGRTMIN + <span class="number">10</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigprocmask ( SIG_BLOCK, &amp;new_mask, &amp;old_mask ) ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"block signal SIGRTMIN+10 error\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    sleep ( <span class="number">10</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"now begin to get pending mask and unblock SIGRTMIN+10\n"</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigpending ( &amp;pending_mask ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"get pending mask error\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigismember ( &amp;pending_mask, SIGRTMIN + <span class="number">10</span> ) ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"signal SIGRTMIN+10 is pending\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigprocmask ( SIG_SETMASK, &amp;old_mask, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"unblock signal error\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"signal unblocked\n"</span> );</span><br><span class="line">    sleep ( <span class="number">10</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_op</span> <span class="params">( <span class="keyword">int</span> signum )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"receive signal %d\n"</span>, signum );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译该程序，并以后台方式运行。在另一终端向该进程发送信号(运行<code>kill -s 42 pid</code>，<code>SIGRTMIN + 10</code>为<code>42</code>)，查看结果可以看出几个关键函数的运行机制，信号集相关操作比较简单。<br>&emsp;&emsp;在上面几个实例中，使用了<code>printf</code>函数，只是作为诊断工具，<code>pringf</code>函数是不可重入的，不应在信号处理函数中使用。</p>
<hr>
<h3 id="司机售票员问题-signal"><a href="#司机售票员问题-signal" class="headerlink" title="司机售票员问题(signal)"></a>司机售票员问题(signal)</h3><p>&emsp;&emsp;创建子进程代表售票员，父进程代表司机，同步过程如下：</p>
<ul>
<li>售票员捕捉<code>SIGINT</code>(代表开车)，发<code>SIGUSR1</code>给司机，司机打印<code>Let&#39;s gogogo!</code>。</li>
<li>售票员捕捉<code>SIGQUIT</code>(代表停车)，发<code>SIGUSR2</code>给司机，司机打印<code>Stop the bus!</code>。</li>
<li>司机捕捉<code>SIGTSTP</code>(代表车到总站)，发<code>SIGUSR1</code>给售票员，售票员打印<code>please get off the bus!</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errno.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">driver_handler</span> <span class="params">( <span class="keyword">int</span> signo )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saler_handler</span> <span class="params">( <span class="keyword">int</span> signo )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( ( pid = fork() ) == <span class="number">-1</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fork"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        signal ( SIGTSTP, driver_handler );</span><br><span class="line">        signal ( SIGINT, SIG_IGN );</span><br><span class="line">        signal ( SIGQUIT, SIG_IGN );</span><br><span class="line">        signal ( SIGUSR1, driver_handler );</span><br><span class="line">        signal ( SIGUSR2, driver_handler );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        signal ( SIGINT, saler_handler );</span><br><span class="line">        signal ( SIGQUIT, saler_handler );</span><br><span class="line">        signal ( SIGTSTP, SIG_IGN );</span><br><span class="line">        signal ( SIGUSR1, saler_handler );</span><br><span class="line">        signal ( SIGUSR2, SIG_IGN );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">driver_handler</span> <span class="params">( <span class="keyword">int</span> signo )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( signo == SIGUSR1 ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Let's gogogo!\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( signo == SIGUSR2 ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Stop the bus!\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( signo == SIGTSTP ) &#123;</span><br><span class="line">        kill ( pid, SIGUSR1 );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saler_handler</span> <span class="params">( <span class="keyword">int</span> signo )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> ppid = getppid();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( signo == SIGINT ) &#123;</span><br><span class="line">        kill ( ppid, SIGUSR1 );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( signo == SIGQUIT ) &#123;</span><br><span class="line">        kill ( ppid, SIGUSR2 );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( signo == SIGUSR1 ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"please get off the bus!\n"</span> );</span><br><span class="line">        kill ( ppid, SIGKILL );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="双子进程signal"><a href="#双子进程signal" class="headerlink" title="双子进程signal"></a>双子进程signal</h3><p>&emsp;&emsp;编写一段程序，使用系统调用<code>fork</code>创建两个子进程，再用系统调用<code>signal</code>让父进程捕捉键盘上来的中断信号(即<code>Ctrl+C</code>)。当捕捉到中断信号后，父进程用系统调用<code>kill</code>向两个子进程发出信号。子进程捕捉到父进程发来的信号后，分别输出下列信息后终止：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child process <span class="number">1</span> is killed by parent!</span><br><span class="line">child process <span class="number">2</span> is killed by parent!</span><br></pre></td></tr></table></figure>
<p>父进程等待两个子进程终止后，输出下列信息后终止：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent process <span class="built_in">exit</span>!</span><br></pre></td></tr></table></figure>
<p>参考程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">int</span> wait_mask = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waiting</span> <span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span> <span class="params">( <span class="keyword">int</span> sign_no )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1, p2;</span><br><span class="line">    signal ( SIGINT, stop );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( ( p1 = fork() ) == <span class="number">-1</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( p1 &gt; <span class="number">0</span> ) &#123; <span class="comment">/* 在父进程中 */</span></span><br><span class="line">        <span class="keyword">while</span> ( ( p2 = fork() ) == <span class="number">-1</span> );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( p2 &gt; <span class="number">0</span> ) &#123; <span class="comment">/* 在父进程中 */</span></span><br><span class="line">            wait_mask = <span class="number">1</span>;</span><br><span class="line">            waiting();</span><br><span class="line">            kill ( p1, <span class="number">10</span> );</span><br><span class="line">            kill ( p2, <span class="number">12</span> );</span><br><span class="line">            wait ( <span class="literal">NULL</span> );</span><br><span class="line">            wait ( <span class="literal">NULL</span> );</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"parent process exit!\n"</span> );</span><br><span class="line">            <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 在子进程2中 */</span></span><br><span class="line">            wait_mask = <span class="number">1</span>;</span><br><span class="line">            signal ( <span class="number">12</span>, stop );</span><br><span class="line">            waiting();</span><br><span class="line">            lockf ( <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> );</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"child process 2 is killed by parent!\n"</span> );</span><br><span class="line">            lockf ( <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">            <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 在子进程1中 */</span></span><br><span class="line">        wait_mask = <span class="number">1</span>;</span><br><span class="line">        signal ( <span class="number">10</span>, stop );</span><br><span class="line">        waiting();</span><br><span class="line">        lockf ( <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"child process 1 is killed by parent!\n"</span> );</span><br><span class="line">        lockf ( <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waiting</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( wait_mask != <span class="number">0</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span> <span class="params">( <span class="keyword">int</span> sign_no )</span> </span>&#123;</span><br><span class="line">    wait_mask = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="双进程信号通信示例"><a href="#双进程信号通信示例" class="headerlink" title="双进程信号通信示例"></a>双进程信号通信示例</h3><p>&emsp;&emsp;<code>Aprocess.c</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 程序执行用“./Aprocess B进程pid” */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = atoi ( argv[<span class="number">1</span>] );</span><br><span class="line">    kill ( pid, SIGINT );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Bprocess.c</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/*程序执行后用“kill -n SIGINT 进程pid”来发送信号*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span> <span class="params">( <span class="keyword">int</span> s )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Prosess B receieve SIGINT\n"</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    signal ( SIGINT, myfunc );</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Linux信号种类"><a href="#Linux信号种类" class="headerlink" title="Linux信号种类"></a>Linux信号种类</h3><p>&emsp;&emsp;可以从两个不同的分类角度对信号进行分类：可靠性方面：可靠信号与不可靠信号；与时间的关系上：实时信号与非实时信号。</p>
<h4 id="不可靠信号"><a href="#不可靠信号" class="headerlink" title="不可靠信号"></a>不可靠信号</h4><p>&emsp;&emsp;<code>Linux</code>信号机制基本上是从<code>Unix</code>系统中继承过来的。早期<code>Unix</code>系统中的信号机制比较简单和原始，后来在实践中暴露出一些问题，因此把那些建立在早期机制上的信号叫做<code>不可靠信号</code>，信号值小于<code>SIGRTMIN</code>(<code>Red hat 7.2</code>中，<code>SIGRTMIN</code>为<code>32</code>，<code>SIGRTMAX</code>为<code>63</code>)的信号都是不可靠信号。这就是“不可靠信号”的来源，它的主要问题是：</p>
<ul>
<li>进程每次处理信号后，就将对信号的响应设置为默认动作。在某些情况下，将导致对信号的错误处理；因此，用户如果不希望这样的操作，那么就要在信号处理函数结尾再一次调用<code>signal</code>，重新安装该信号。</li>
<li>信号可能丢失，后面将对此详细阐述。如果在进程对某个信号进行处理时，这个信号发生多次，对后到来的这类信号不排队，那么仅传送该信号一次，即发生了信号丢失。</li>
</ul>
<p>&emsp;&emsp;因此，早期<code>unix</code>下的不可靠信号主要指的是进程可能对信号做出错误的反应以及信号可能丢失。<code>Linux</code>支持不可靠信号，但是对不可靠信号机制做了改进：在调用完信号处理函数后，不必重新调用该信号的安装函数(信号安装函数是在可靠机制上的实现)。因此，<code>Linux</code>下的不可靠信号问题主要指的是信号可能丢失。</p>
<h4 id="可靠信号"><a href="#可靠信号" class="headerlink" title="可靠信号"></a>可靠信号</h4><p>&emsp;&emsp;随着时间的发展，实践证明了有必要对信号的原始机制加以改进和扩充。所以，后来出现的各种<code>Unix</code>版本分别在这方面进行了研究，力图实现<code>可靠信号</code>。由于原来定义的信号已有许多应用，不好再做改动，最终只好又新增加了一些信号，并在一开始就把它们定义为可靠信号，这些信号支持排队，不会丢失。同时，信号的发送和安装也出现了新版本：信号发送函数<code>sigqueue</code>及信号安装函数<code>sigaction</code>。<code>POSIX.4</code>对可靠信号机制做了标准化。但是，<code>POSIX</code>只对可靠信号机制应具有的功能以及信号机制的对外接口做了标准化，对信号机制的实现没有作具体的规定。<br>&emsp;&emsp;信号值位于<code>SIGRTMIN</code>和<code>SIGRTMAX</code>之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。<code>Linux</code>在支持新版本的信号安装函数<code>sigation</code>以及信号发送函数<code>sigqueue</code>的同时，仍然支持早期的<code>signal</code>信号安装函数，支持信号发送函数<code>kill</code>。<br>&emsp;&emsp;不要有这样的误解：由<code>sigqueue</code>发送、<code>sigaction</code>安装的信号就是可靠的。事实上，可靠信号是指后来添加的新信号(信号值位于<code>SIGRTMIN</code>及<code>SIGRTMAX</code>之间)；不可靠信号是信号值小于<code>SIGRTMIN</code>的信号。信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。目前<code>linux</code>中的<code>signal</code>是通过<code>sigation</code>函数实现的，因此，即使通过<code>signal</code>安装的信号，在信号处理函数的结尾也不必再调用一次信号安装函数。同时，由<code>signal</code>安装的实时信号支持排队，同样不会丢失。<br>&emsp;&emsp;对于目前<code>linux</code>的两个信号安装函数<code>signal</code>及<code>sigaction</code>来说，它们都不能把<code>SIGRTMIN</code>以前的信号变成可靠信号(都不支持排队，仍有可能丢失，仍然是不可靠信号)，而且对<code>SIGRTMIN</code>以后的信号都支持排队。这两个函数的最大区别在于，经过<code>sigaction</code>安装的信号都能传递信息给信号处理函数(对所有信号这一点都成立)，而经过<code>signal</code>安装的信号却不能向信号处理函数传递信息。对于信号发送函数来说也是一样的。</p>
<h4 id="实时信号与非实时信号"><a href="#实时信号与非实时信号" class="headerlink" title="实时信号与非实时信号"></a>实时信号与非实时信号</h4><p>&emsp;&emsp;早期<code>Unix</code>系统只定义了<code>32</code>种信号，<code>Red hat 7.2</code>支持<code>64</code>种信号，编号为<code>0</code>至<code>63</code>(<code>SIGRTMIN</code>为<code>31</code>，<code>SIGRTMAX</code>为<code>63</code>)，将来可能进一步增加，这需要得到内核的支持。前<code>32</code>种信号已经有了预定义值，每个信号有了确定的用途及含义，并且每种信号都有各自的缺省动作。如按键盘的<code>CTRL + C</code>时，会产生<code>SIGINT</code>信号，对该信号的默认反应就是进程终止。后<code>32</code>个信号表示实时信号，等同于前面阐述的可靠信号。这保证了发送的多个实时信号都被接收。<br>&emsp;&emsp;实时信号是<code>POSIX</code>标准的一部分，可用于应用进程。非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。</p>
<hr>
<h3 id="signal-SIGHUP-SIG-IGN-的含义"><a href="#signal-SIGHUP-SIG-IGN-的含义" class="headerlink" title="signal(SIGHUP, SIG_IGN)的含义"></a>signal(SIGHUP, SIG_IGN)的含义</h3><p>&emsp;&emsp;<code>signal</code>信号函数第一个参数表示需要处理的信号值(<code>SIGHUP</code>)，第二个参数为处理函数或者是一个表示。这里，<code>SIG_IGN</code>表示忽略<code>SIGHUP</code>那个注册的信号。<br>&emsp;&emsp;<code>SIGHUP</code>和控制台操作有关。当控制台被关闭时，系统会向拥有控制台<code>sessionID</code>的所有进程发送<code>HUP</code>信号，默认<code>HUP</code>信号的<code>action</code>是<code>exit</code>。如果远程登陆启动某个服务进程并在程序运行时关闭连接的话，会导致服务进程退出，所以一般服务进程都会用<code>nohup</code>工具启动或写成一个<code>daemon</code>。</p>
<hr>
<h3 id="SIGKILL和SIGSTOP的区别"><a href="#SIGKILL和SIGSTOP的区别" class="headerlink" title="SIGKILL和SIGSTOP的区别"></a>SIGKILL和SIGSTOP的区别</h3><p>&emsp;&emsp;<code>SIGKILL</code>提供给管理员杀死进程的权利，<code>SIGSTOP</code>提供给管理员暂停进程的权利，所以这两个信号不能被忽略和重定义。<code>Kill</code>父进程后，子进程的父进程号为<code>1</code>；但是<code>stop</code>父进程后，子进程的父进程号还是该父进程。</p>
<h3 id="SIGSTOP和SIGTSTP的区别"><a href="#SIGSTOP和SIGTSTP的区别" class="headerlink" title="SIGSTOP和SIGTSTP的区别"></a>SIGSTOP和SIGTSTP的区别</h3><p>&emsp;&emsp;<code>SIGSTOP</code>提供给管理员暂停进程的特权，所以不能忽略和重定义。当用户按下<code>CTRL+Z</code>时，向前台进程组发送<code>SIGTSTP</code>信号以暂停进程(默认动作)，该信号可以被忽略和重定义。另外用户在控制终端上输入<code>CTRL+S</code>可以暂停进程的输出，输入<code>CTRL+Q</code>可以恢复进程的输出。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/13/Linux系统编程/共享内存总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/Linux系统编程/共享内存总结/" itemprop="url">共享内存总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T13:02:59+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;共享内存可以说是最有用的进程间通信方式，也是最快的<code>IPC</code>形式。两个不同进程<code>A</code>、<code>B</code>共享内存的意思是，同一块物理内存被映射到进程<code>A</code>、<code>B</code>各自的进程地址空间。进程<code>A</code>可以即时看到进程<code>B</code>对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。<br>&emsp;&emsp;采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。<br>&emsp;&emsp;<code>Linux</code>的<code>2.2.x</code>内核支持多种共享内存方式，如<code>mmap</code>系统调用、<code>Posix</code>共享内存以及系统<code>V</code>共享内存。<code>linux</code>发行版本如<code>Redhat 8.0</code>支持<code>mmap</code>系统调用及系统<code>V</code>共享内存，但还没实现<code>Posix</code>共享内存，本文将主要介绍<code>mmap</code>系统调用及系统V共享内存<code>API</code>的原理及应用。</p>
<h3 id="内核怎样保证各个进程寻址到同一个共享内存区域的内存页面"><a href="#内核怎样保证各个进程寻址到同一个共享内存区域的内存页面" class="headerlink" title="内核怎样保证各个进程寻址到同一个共享内存区域的内存页面"></a>内核怎样保证各个进程寻址到同一个共享内存区域的内存页面</h3><p>&emsp;&emsp;1. <code>page cache</code>及<code>swap cache</code>中页面的区分：一个被访问文件的物理页面都驻留在<code>page cache</code>或<code>swap cache</code>中，一个页面的所有信息由<code>struct page</code>来描述。<code>struct page</code>中有一个域为指针<code>mapping</code>，它指向一个<code>struct address_space</code>类型结构。<code>page cache</code>或<code>swap cache</code>中的所有页面就是根据<code>address_space</code>结构以及一个偏移量来区分的。<br>&emsp;&emsp;2. 文件与<code>address_space</code>结构的对应：一个具体的文件在打开后，内核会在内存中为之建立一个<code>struct inode</code>结构，其中的<code>i_mapping</code>域指向一个<code>address_space</code>结构。这样，一个文件就对应一个<code>address_space</code>结构，一个<code>address_space</code>与一个偏移量能够确定一个<code>page cache</code>或<code>swap cache</code>中的一个页面。因此，当要寻址某个数据时，很容易根据给定的文件及数据在文件内的偏移量而找到相应的页面。<br>&emsp;&emsp;3. 进程调用<code>mmap</code>时，只是在进程空间内新增了一块相应大小的缓冲区，并设置了相应的访问标识，但并没有建立进程空间到物理页面的映射。因此，第一次访问该空间时，会引发一个缺页异常。<br>&emsp;&emsp;4. 对于共享内存映射情况，缺页异常处理程序首先在<code>swap cache</code>中寻找目标页(符合<code>address_space</code>以及偏移量的物理页)，如果找到，则直接返回地址；如果没有找到，则判断该页是否在交换区(<code>swap area</code>)，如果在，则执行一个换入操作；如果上述两种情况都不满足，处理程序将分配新的物理页面，并把它插入到<code>page cache</code>中。进程最终将更新进程页表。<br>&emsp;&emsp;对于映射普通文件情况(非共享映射)，缺页异常处理程序首先会在<code>page cache</code>中根据<code>address_space</code>以及数据偏移量寻找相应的页面。如果没有找到，则说明文件数据还没有读入内存，处理程序会从磁盘读入相应的页面，并返回相应地址，同时进程页表也会更新。<br>&emsp;&emsp;5. 所有进程在映射同一个共享内存区域时，情况都一样，在建立线性地址与物理地址之间的映射之后，不论进程各自的返回地址如何，实际访问的必然是同一个共享内存区域对应的物理页面。<br>&emsp;&emsp;注意，一个共享内存区域可以看作是特殊文件系统shm中的一个文件，<code>shm</code>的安装点在交换区上。</p>
<h3 id="mmap及其相关系统调用"><a href="#mmap及其相关系统调用" class="headerlink" title="mmap及其相关系统调用"></a>mmap及其相关系统调用</h3><p>&emsp;&emsp;<code>mmap</code>系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必再调用<code>read</code>、<code>write</code>等操作。<br>&emsp;&emsp;实际上，<code>mmap</code>系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而<code>Posix</code>或系统<code>V</code>的共享内存<code>IPC</code>则纯粹用于共享目的，当然<code>mmap</code>实现共享内存也是其主要应用之一。<br>&emsp;&emsp;1. <code>mmap</code>系统调用形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span> <span class="params">( <span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>fd</code>为即将映射到进程空间的文件描述字，一般由<code>open</code>返回，同时<code>fd</code>可以指定为<code>-1</code>，此时须指定<code>flags</code>参数中的<code>MAP_ANON</code>，表明进行的是匿名映射(不涉及具体的文件名，避免了文件的创建及打开，很显然只能用于具有亲缘关系的进程间通信)。</p>
<ul>
<li><code>len</code>：映射到调用进程地址空间的字节数，它从被映射文件开头<code>offset</code>个字节开始算起。</li>
<li><code>prot</code>：指定共享内存的访问权限。可取如下几个值，可以以进行<code>或</code>计算：<code>PROT_READ</code>(可读)、<code>PROT_WRITE</code>(可写)、<code>PROT_EXEC</code>(可执行)、<code>PROT_NONE</code>(不可访问)。</li>
<li><code>flags</code>：由以下几个常值指定：<code>MAP_SHARED</code>、<code>MAP_PRIVATE</code>、<code>MAP_FIXED</code>，其中<code>MAP_SHARED</code>、<code>MAP_PRIVATE</code>必选其一，而<code>MAP_FIXED</code>则不推荐使用。</li>
<li><code>offset</code>：一般设为<code>0</code>，表示从文件头开始映射。</li>
<li><code>addr</code>：指定文件应被映射到进程空间的起始地址，一般被指定一个空指针，此时选择起始地址的任务留给内核来完成。</li>
</ul>
<p>函数的返回值为最后文件映射到进程空间的地址，进程可直接操作起始地址为该值的有效地址。<br>&emsp;&emsp;2. 系统调用<code>mmap</code>用于共享内存的两种方式：</p>
<ul>
<li>使用普通文件提供的内存映射：适用于任何进程之间；此时，需要打开或创建一个文件，然后再调用<code>mmap</code>。典型调用代码如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open ( name, flag, mode );</span><br><span class="line">ptr = mmap ( <span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li>使用特殊文件提供匿名内存映射：适用于具有亲缘关系的进程之间；由于父子进程特殊的亲缘关系，在父进程中先调用<code>mmap</code>，然后调用<code>fork</code>。那么在调用<code>fork</code>之后，子进程继承父进程匿名映射后的地址空间，同样也继承<code>mmap</code>返回的地址，这样父子进程就可以通过映射区域进行通信了。注意，这里不是一般的继承关系。一般来说，子进程单独维护从父进程继承下来的一些变量，而<code>mmap</code>返回的地址，却由父子进程共同维护。对于具有亲缘关系的进程实现共享内存，最好的方式应该是采用匿名内存映射的方式。此时，不必指定具体的文件，只要设置相应的标志即可。</li>
</ul>
<p>&emsp;&emsp;3. 系统调用<code>munmap</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span> <span class="params">( <span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len )</span></span>;</span><br></pre></td></tr></table></figure>
<p>该调用在进程地址空间中解除一个映射关系，<code>addr</code>是调用<code>mmap</code>时返回的地址，<code>len</code>是映射区的大小。当映射关系解除后，对原来映射地址的访问将导致段错误发生。<br>&emsp;&emsp;4. 系统调用<code>msync</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span> <span class="params">( <span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags )</span></span>;</span><br></pre></td></tr></table></figure>
<p>一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用<code>munmap</code>后才执行该操作。可以通过调用<code>msync</code>实现磁盘上文件内容与共享内存区的内容一致。</p>
<h3 id="mmap范例"><a href="#mmap范例" class="headerlink" title="mmap范例"></a>mmap范例</h3><p>&emsp;&emsp;范例<code>1</code>为两个进程通过映射普通文件实现共享内存通信。范例<code>1</code>包含两个子程序：<code>map_normalfile1.c</code>和<code>map_normalfile2.c</code>。编译两个程序，可执行文件分别为<code>map_normalfile1</code>和<code>map_normalfile2</code>。两个程序通过命令行参数指定同一个文件来实现共享内存方式的进程间通信。<code>map_normalfile2</code>试图打开命令行参数指定的一个普通文件，把该文件映射到进程的地址空间，并对映射后的地址空间进行写操作。<code>map_normalfile1</code>把命令行参数指定的文件映射到进程地址空间，然后对映射后的地址空间执行读操作。这样，两个进程通过命令行参数指定同一个文件来实现共享内存方式的进程间通信。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* map_normalfile1.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; people;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, i;</span><br><span class="line">    people *p_map;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    fd = open ( argv[<span class="number">1</span>], O_CREAT | O_RDWR | O_TRUNC, <span class="number">00777</span> );</span><br><span class="line">    lseek ( fd, <span class="keyword">sizeof</span> ( people ) * <span class="number">5</span> - <span class="number">1</span>, SEEK_SET );</span><br><span class="line">    write ( fd, <span class="string">" "</span>, <span class="number">1</span> );</span><br><span class="line">    p_map = ( people * ) mmap ( <span class="literal">NULL</span>, <span class="keyword">sizeof</span> ( people ) * <span class="number">10</span>, \</span><br><span class="line">                                PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span> );</span><br><span class="line">    close ( fd );</span><br><span class="line">    temp = <span class="string">'a'</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span> ( ( * ( p_map + i ) ).name, <span class="string">"%c"</span>, temp );</span><br><span class="line">        ( * ( p_map + i ) ).age = <span class="number">20</span> + i;</span><br><span class="line">        temp += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"initialize over\n"</span> );</span><br><span class="line">    sleep ( <span class="number">10</span> );</span><br><span class="line">    munmap ( p_map, <span class="keyword">sizeof</span> ( people ) * <span class="number">10</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"umap ok\n"</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* map_normalfile2.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; people;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, i;</span><br><span class="line">    people *p_map;</span><br><span class="line">    fd = open ( argv[<span class="number">1</span>], O_CREAT | O_RDWR, <span class="number">00777</span> );</span><br><span class="line">    p_map = ( people * ) mmap ( <span class="literal">NULL</span>, <span class="keyword">sizeof</span> ( people ) * <span class="number">10</span>, \</span><br><span class="line">                                PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"name: %s age %d;\n"</span>, ( * ( p_map + i ) ).name, ( * ( p_map + i ) ).age );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    munmap ( p_map, <span class="keyword">sizeof</span> ( people ) * <span class="number">10</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>map_normalfile1.c</code>首先定义了一个<code>people</code>数据结构，在这里采用数据结构的方式是因为，共享内存区的数据往往是有固定格式的，这由通信的各个进程决定，采用结构的方式有普遍代表性。<code>map_normfile1</code>首先打开或创建一个文件，并把文件的长度设置为<code>5</code>个<code>people</code>结构大小。然后从<code>mmap</code>的返回地址开始，设置了<code>10</code>个<code>people</code>结构。然后，进程睡眠<code>10</code>秒钟，等待其他进程映射同一个文件，最后解除映射。<code>map_normfile2.c</code>只是简单的映射一个文件，并以<code>people</code>数据结构的格式从<code>mmap</code>返回的地址处读取<code>10</code>个<code>people</code>结构，并输出读取的值，然后解除映射。<br>&emsp;&emsp;分别把两个程序编译成可执行文件<code>map_normalfile1</code>和<code>map_normalfile2</code>后，在一个终端上先运行<code>./map_normalfile1 /tmp/test_shm</code>，执行结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">initialize over</span><br><span class="line">umap ok</span><br></pre></td></tr></table></figure>
<p>在<code>map_normalfile1</code>输出<code>initialize over</code>之后，输出<code>umap ok</code>之前，在另一个终端上运行<code>./map_normalfile2 /tmp/test_shm</code>，将会产生如下输出(为了节省空间，输出结果为稍作整理后的结果)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">name: a age <span class="number">20</span>;</span><br><span class="line">name: b age <span class="number">21</span>;</span><br><span class="line">name: c age <span class="number">22</span>;</span><br><span class="line">name: d age <span class="number">23</span>;</span><br><span class="line">name: e age <span class="number">24</span>;</span><br><span class="line">name: f age <span class="number">25</span>;</span><br><span class="line">name: g age <span class="number">26</span>;</span><br><span class="line">name: h age <span class="number">27</span>;</span><br><span class="line">name: i age <span class="number">28</span>;</span><br><span class="line">name: j age <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<p>在<code>map_normalfile1</code>输出<code>umap ok</code>后，运行<code>map_normalfile2</code>则输出如下结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">name: a age <span class="number">20</span>;</span><br><span class="line">name: b age <span class="number">21</span>;</span><br><span class="line">name: c age <span class="number">22</span>;</span><br><span class="line">name: d age <span class="number">23</span>;</span><br><span class="line">name: e age <span class="number">24</span>;</span><br><span class="line">name:  age <span class="number">0</span>;</span><br><span class="line">name:  age <span class="number">0</span>;</span><br><span class="line">name:  age <span class="number">0</span>;</span><br><span class="line">name:  age <span class="number">0</span>;</span><br><span class="line">name:  age <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>从程序的运行结果中可以得出的结论：<br>&emsp;&emsp;1. 最终被映射文件的内容的长度不会超过文件本身的初始大小，即映射不能改变文件的大小。<br>&emsp;&emsp;2. 可以用于进程通信的有效地址空间大小大体上受限于被映射文件的大小，但不完全受限于文件大小。打开文件被截短为<code>5</code>个<code>people</code>结构大小，而在<code>map_normalfile1</code>中初始化了<code>10</code>个<code>people</code>数据结构，在恰当时候(<code>map_normalfile1</code>输出<code>initialize over</code>之后，输出<code>umap ok</code>之前)调用<code>map_normalfile2</code>会发现<code>map_normalfile2</code>将输出全部<code>10</code>个<code>people</code>结构的值。<br>&emsp;&emsp;在<code>linux</code>中，内存的保护是以页为基本单位的，即使被映射文件只有一个字节大小，内核也会为映射分配一个页面大小的内存。当被映射文件小于一个页面大小时，进程可以对从<code>mmap</code>返回地址开始的一个页面大小进行访问，而不会出错；但是，如果对一个页面以外的地址空间进行访问，则导致错误发生，后面将进一步描述。因此，可用于进程间通信的有效地址空间大小不会超过文件大小及一个页面大小的和。<br>&emsp;&emsp;3. 文件一旦被映射后，调用<code>mmap</code>的进程对返回地址的访问是对某一内存区域的访问，暂时脱离了磁盘上文件的影响。所有对<code>mmap</code>返回地址空间的操作只在内存中有意义，只有在调用了<code>munmap</code>后或者<code>msync</code>时，才把内存中的相应内容写回磁盘文件，所写内容仍然不能超过文件的大小。<br>&emsp;&emsp;范例<code>2</code>为父子进程通过匿名映射实现共享内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; people;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    people *p_map;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    p_map = ( people * ) mmap ( <span class="literal">NULL</span>, <span class="keyword">sizeof</span> ( people ) * <span class="number">10</span>, \</span><br><span class="line">                                PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( fork() == <span class="number">0</span> ) &#123;</span><br><span class="line">        sleep ( <span class="number">2</span> );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"child read: the %d people's age is %d\n"</span>, i + <span class="number">1</span>, ( * ( p_map + i ) ).age );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        ( *p_map ).age = <span class="number">100</span>;</span><br><span class="line">        munmap ( p_map, <span class="keyword">sizeof</span> ( people ) * <span class="number">10</span> ); <span class="comment">/* 实际上，进程终止时，会自动解除映射 */</span></span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    temp = <span class="string">'a'</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">        temp += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memcpy</span> ( ( * ( p_map + i ) ).name, &amp;temp, <span class="number">2</span> );</span><br><span class="line">        ( * ( p_map + i ) ).age = <span class="number">20</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    sleep ( <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"parent read: the first people's age is %d\n"</span>, ( *p_map ).age );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"umap\n"</span> );</span><br><span class="line">    munmap ( p_map, <span class="keyword">sizeof</span> ( people ) * <span class="number">10</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"umap ok\n"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看程序的输出结果，体会父子进程匿名共享内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">child read: the <span class="number">1</span> people's age is <span class="number">20</span></span><br><span class="line">child read: the <span class="number">2</span> people's age is <span class="number">21</span></span><br><span class="line">child read: the <span class="number">3</span> people's age is <span class="number">22</span></span><br><span class="line">child read: the <span class="number">4</span> people's age is <span class="number">23</span></span><br><span class="line">child read: the <span class="number">5</span> people's age is <span class="number">24</span></span><br><span class="line">parent read: the first people's age is <span class="number">100</span></span><br><span class="line">umap</span><br><span class="line">umap ok</span><br></pre></td></tr></table></figure>
<h3 id="对mmap返回地址的访问"><a href="#对mmap返回地址的访问" class="headerlink" title="对mmap返回地址的访问"></a>对mmap返回地址的访问</h3><p>&emsp;&emsp;前面对范例运行结构的讨论中已经提到，<code>linux</code>采用的是页式管理机制。对于用<code>mmap</code>映射普通文件来说，进程会在自己的地址空间新增一块空间，空间大小由<code>mmap</code>的<code>len</code>参数指定。注意，进程并不一定能够对全部新增空间都能进行有效访问。进程能够访问的有效地址大小取决于文件被映射部分的大小。简单的说，能够容纳文件被映射部分大小的最少页面个数决定了进程从<code>mmap</code>返回的地址开始，能够有效访问的地址空间大小。超过这个空间大小，内核会根据超过的严重程度返回发送不同的信号给进程。可用如下图示说明：</p>
<p><img src="/2019/03/13/Linux系统编程/共享内存总结/1.png"></p>
<p>&emsp;&emsp;注意，文件被映射部分而不是整个文件决定了进程能够访问的空间大小。另外，如果指定文件的偏移部分，一定要注意为页面大小的整数倍。下面是对进程映射地址空间的访问范例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; people;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, i;</span><br><span class="line">    <span class="keyword">int</span> pagesize, offset;</span><br><span class="line">    people *p_map;</span><br><span class="line">    pagesize = sysconf ( _SC_PAGESIZE );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"pagesize is %d\n"</span>, pagesize );</span><br><span class="line">    fd = open ( argv[<span class="number">1</span>], O_CREAT | O_RDWR | O_TRUNC, <span class="number">00777</span> );</span><br><span class="line">    lseek ( fd, pagesize * <span class="number">2</span> - <span class="number">100</span>, SEEK_SET );</span><br><span class="line">    write ( fd, <span class="string">" "</span>, <span class="number">1</span> );</span><br><span class="line">    offset = <span class="number">0</span>; <span class="comment">/* 此处“offset = 0”编译成版本1；“offset = pagesize”编译成版本2 */</span></span><br><span class="line">    p_map = ( people * ) mmap ( <span class="literal">NULL</span>, pagesize * <span class="number">3</span>, \</span><br><span class="line">                                PROT_READ | PROT_WRITE, MAP_SHARED, fd, offset );</span><br><span class="line">    close ( fd );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">        ( * ( p_map + pagesize / <span class="keyword">sizeof</span> ( people ) *i - <span class="number">2</span> ) ).age = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"access page %d over\n"</span>, i );</span><br><span class="line">        ( * ( p_map + pagesize / <span class="keyword">sizeof</span> ( people ) *i - <span class="number">1</span> ) ).age = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"access page %d edge over, now begin to access page %d\n"</span>, i, i + <span class="number">1</span> );</span><br><span class="line">        ( * ( p_map + pagesize / <span class="keyword">sizeof</span> ( people ) *i ) ).age = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"access page %d over\n"</span>, i + <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    munmap ( p_map, <span class="keyword">sizeof</span> ( people ) * <span class="number">10</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如程序中所注释的那样，把程序编译成两个版本，两个版本主要体现在文件被映射部分的大小不同。文件的大小介于一个页面与两个页面之间(大小为<code>pagesize * 2 - 99</code>)，版本<code>1</code>的被映射部分是整个文件，版本<code>2</code>的文件被映射部分是文件大小减去一个页面后的剩余部分，不到一个页面大小(大小为<code>pagesize - 99</code>)。程序中试图访问每一个页面边界，两个版本都试图在进程空间中映射<code>pagesize * 3</code>的字节数。<br>&emsp;&emsp;版本<code>1</code>的输出结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pagesize is <span class="number">4096</span></span><br><span class="line">access page <span class="number">1</span> over</span><br><span class="line">access page <span class="number">1</span> edge over, now begin to access page <span class="number">2</span></span><br><span class="line">access page <span class="number">2</span> over</span><br><span class="line">access page <span class="number">2</span> over</span><br><span class="line">access page <span class="number">2</span> edge over, now begin to access page <span class="number">3</span></span><br><span class="line">Bus error <span class="comment">/* 被映射文件在进程空间中覆盖了两个页面，此时进程试图访问第三个页面 */</span></span><br></pre></td></tr></table></figure>
<p>版本<code>2</code>的输出结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pagesize is <span class="number">4096</span></span><br><span class="line">access page <span class="number">1</span> over</span><br><span class="line">access page <span class="number">1</span> edge over, now begin to access page <span class="number">2</span></span><br><span class="line">Bus error <span class="comment">/* 被映射文件在进程空间中覆盖了一个页面，此时进程试图访问第二个页面 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;采用系统调用<code>mmap</code>实现进程间通信是很方便的，在应用层上接口非常简洁。内部实现机制区涉及到了<code>linux</code>存储管理以及文件系统等方面的内容，可以参考一下相关重要数据结构来加深理解。</p>
<hr>
<p>&emsp;&emsp;本部分将讨论系统<code>V</code>共享内存，并通过实验结果对比来阐述两者的异同。系统<code>V</code>共享内存指的是把所有共享数据放在共享内存区域(<code>IPC shared memory region</code>)，任何想要访问该数据的进程都必须在本进程的地址空间新增一块内存区域，用来映射存放共享数据的物理内存页面。<br>&emsp;&emsp;系统调用<code>mmap</code>通过映射一个普通文件实现共享内存，系统<code>V</code>则是通过映射特殊文件系统<code>shm</code>中的文件实现进程间的共享内存通信。也就是说，每个共享内存区域对应特殊文件系统<code>shm</code>中的一个文件(这是通过<code>shmid_kernel</code>结构联系起来的)。</p>
<h3 id="系统V共享内存原理"><a href="#系统V共享内存原理" class="headerlink" title="系统V共享内存原理"></a>系统V共享内存原理</h3><p>&emsp;&emsp;进程间需要共享的数据被放在一个叫做<code>IPC</code>共享内存区域的地方，所有需要访问该共享区域的进程都要把该共享区域映射到本进程的地址空间中去。系统<code>V</code>共享内存通过<code>shmget</code>获得或创建一个<code>IPC</code>共享内存区域，并返回相应的标识符。内核在保证<code>shmget</code>获得或创建一个共享内存区，初始化该共享内存区相应的<code>shmid_kernel</code>结构体时，还将在特殊文件系统<code>shm</code>中创建并打开一个同名文件，并在内存中建立起该文件的相应<code>dentry</code>及<code>inode</code>结构，新打开的文件不属于任何一个进程(任何进程都可以访问该共享内存区)。所有这一切都是系统调用<code>shmget</code>完成的。<br>&emsp;&emsp;每一个共享内存区都有一个控制结构<code>struct shmid_kernel</code>，<code>shmid_kernel</code>是共享内存区域中非常重要的一个数据结构，它是存储管理和文件系统结合起来的桥梁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> &#123;</span> <span class="comment">/* private to the kernel */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">shm_perm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">shm_file</span>;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> shm_nattch;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> shm_segsz;</span><br><span class="line">    <span class="keyword">time_t</span> shm_atim;</span><br><span class="line">    <span class="keyword">time_t</span> shm_dtim;</span><br><span class="line">    <span class="keyword">time_t</span> shm_ctim;</span><br><span class="line">    <span class="keyword">pid_t</span> shm_cprid;</span><br><span class="line">    <span class="keyword">pid_t</span> shm_lprid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构中最重要的一个域应该是<code>shm_file</code>，它存储了将被映射文件的地址。每个共享内存区对象都对应特殊文件系统<code>shm</code>中的一个文件，一般情况下，特殊文件系统<code>shm</code>中的文件是不能用<code>read</code>、<code>write</code>等方法访问的，当采取共享内存的方式把其中的文件映射到进程地址空间后，可直接采用访问内存的方式对其访问。<br>&emsp;&emsp;正如消息队列和信号灯一样，内核通过数据结构<code>struct ipc_ids shm_ids</code>维护系统中的所有共享内存区域。<code>shm_ids.entries</code>变量指向一个<code>ipc_id</code>结构数组，而每个<code>ipc_id</code>结构数组中有个指向<code>kern_ipc_perm</code>结构的指针。到这里读者应该很熟悉了，对于系统<code>V</code>共享内存区来说，<code>kern_ipc_perm</code>的宿主是<code>shmid_kernel</code>结构，<code>shmid_kernel</code>是用来描述一个共享内存区域的，这样内核就能够控制系统中所有的共享区域。同时，在<code>shmid_kernel</code>结构的<code>file</code>类型指针<code>shm_file</code>指向文件系统<code>shm</code>中相应的文件，这样共享内存区域就与<code>shm</code>文件系统中的文件对应起来。<br>&emsp;&emsp;在创建了一个共享内存区域后，还要将它映射到进程地址空间，系统调用<code>shmat</code>完成此项功能。由于在调用<code>shmget</code>时，已经创建了文件系统<code>shm</code>中的一个同名文件与共享内存区域相对应，因此调用<code>shmat</code>的过程相当于映射文件系统<code>shm</code>中的同名文件过程，原理与<code>mmap</code>大同小异。</p>
<h3 id="系统V共享内存API"><a href="#系统V共享内存API" class="headerlink" title="系统V共享内存API"></a>系统V共享内存API</h3><p>&emsp;&emsp;对于系统<code>V</code>共享内存，主要有以下几个<code>API</code>：<code>shmget</code>、<code>shmat</code>、<code>shmdt</code>及<code>shmctl</code>。<br>&emsp;&emsp;<code>shmget</code>用来获得共享内存区域的<code>ID</code>，如果不存在指定的共享区域，就创建相应的区域。<code>shmat</code>把共享内存区域映射到调用进程的地址空间中去，这样进程就可以方便地对共享区域进行访问操作。<code>shmdt</code>调用用来解除进程对共享内存区域的映射。<code>shmctl</code>实现对共享内存区域的控制操作。<br>&emsp;&emsp;<code>shmget</code>的内部实现包含了许多重要的系统<code>V</code>共享内存机制；<code>shmat</code>在把共享内存区域映射到进程空间时，并不真正改变进程的页表。当进程第一次访问内存映射区域访问时，会因为没有物理页表的分配而导致一个缺页异常，然后内核再根据相应的存储管理机制为共享内存映射区域分配相应的页表。</p>
<h3 id="系统V共享内存限制"><a href="#系统V共享内存限制" class="headerlink" title="系统V共享内存限制"></a>系统V共享内存限制</h3><p>&emsp;&emsp;在<code>/proc/sys/kernel/</code>目录下，记录着系统<code>V</code>共享内存的一下限制，如一个共享内存区的最大字节数<code>shmmax</code>，系统范围内最大共享内存区标识符数<code>shmmni</code>等，可以手工对其调整，但不推荐这样做。<br>&emsp;&emsp;系统<code>V</code>共享内存中的数据，从来不写入到实际磁盘文件中去；而通过<code>mmap</code>映射普通文件实现的共享内存通信可以指定何时将数据写入磁盘文件中。前面讲到，系统<code>V</code>共享内存机制实际是通过映射特殊文件系统<code>shm</code>中的文件实现的，文件系统<code>shm</code>的安装点在交换分区上，系统重新引导后，所有的内容都丢失。<br>&emsp;&emsp;系统<code>V</code>共享内存是随内核持续的，即使所有访问共享内存的进程都已经正常终止，共享内存区仍然存在(除非显式删除共享内存)，在内核重新引导之前，对该共享内存区域的任何改写操作都将一直保留。<br>&emsp;&emsp;通过调用<code>mmap</code>映射普通文件进行进程间通信时，一定要注意考虑进程何时终止对通信的影响。而通过系统<code>V</code>共享内存实现通信的进程则不然。<br>&emsp;&emsp;共享内存允许两个或多个进程共享一给定的存储区，因为数据不需要来回复制，所以是最快的一种进程间通信机制。共享内存可以通过<code>mmap</code>映射普通文件(特殊情况下还可以采用匿名映射)机制实现，也可以通过系统V共享内存机制实现。应用接口和原理很简单，内部机制复杂。为了实现更安全通信，往往还与信号灯等同步机制共同使用。<br>&emsp;&emsp;共享内存涉及到了存储管理以及文件系统等方面的知识，深入理解其内部机制有一定的难度，关键还要紧紧抓住内核使用的重要数据结构。系统V共享内存是以文件的形式组织在特殊文件系统<code>shm</code>中的。通过<code>shmget</code>可以创建或获得共享内存的标识符。取得共享内存标识符后，要通过<code>shmat</code>将这个内存区映射到本进程的虚拟地址空间。</p>
<hr>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>&emsp;&emsp;共享内存是被多个进程共享的一部分物理内存。共享内存是进程间共享数据的一种最快的方法，一个进程向共享内存区域写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容。<br>&emsp;&emsp;由原理图可知，共享内存的地址在进程<code>A</code>中的地址可能是<code>0x5000</code>，在进程<code>B</code>中的地址可能是<code>0x7000</code>，这是因为共享内存映射到不同进程当中的不同位置。</p>
<p><img src="/2019/03/13/Linux系统编程/共享内存总结/2.png"></p>
<p>&emsp;&emsp;共享内存实现分为两个步骤：</p>
<ol>
<li>创建共享内存，使用<code>shmget</code>函数(<code>share memory get</code>)。</li>
<li>映射共享内存，将这段创建的共享内存映射到具体的进程空间去，使用<code>shmat</code>函数。</li>
</ol>
<h3 id="创建共享内存"><a href="#创建共享内存" class="headerlink" title="创建共享内存"></a>创建共享内存</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span> <span class="params">( <span class="keyword">key_t</span> key, <span class="keyword">int</span> size, <span class="keyword">int</span> shmflg )</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>key</code>标识共享内存的键值，可以取<code>0</code>或<code>IPC_PRIVATE</code>。当<code>key</code>的取值为<code>IPC_PRIVATE</code>，则函数<code>shmget</code>将创建一块新的共享内存；如果<code>key</code>的取值为<code>0</code>，而参数<code>shmflg</code>中又设置<code>IPC_PRIVATE</code>这个标志，则同样会创建一块新的共享内存。<code>size</code>是创建共享内存的大小，以字节为单位。如果函数执行成功，返回共享内存标识符；如果失败，返回<code>-1</code>。</p>
<h3 id="共享内存映射"><a href="#共享内存映射" class="headerlink" title="共享内存映射"></a>共享内存映射</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmat</span> <span class="params">( <span class="keyword">int</span> shmid, <span class="keyword">char</span> *shmaddr, <span class="keyword">int</span> flag )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>shmid</code>：<code>shmget</code>函数返回的共享存储标识符。</li>
<li><code>flag</code>：决定以什么方式来确定映射的地址(通常为<code>0</code>)。</li>
<li><code>shmaddr</code>：我们不会向它传值，而是从它那里获取值，为<code>0</code>表示由系统来指定地址。</li>
</ul>
<p>如果函数执行成功，则返回共享内存映射到进程中的地址；如果失败，则返回<code>-1</code>。</p>
<h3 id="共享内存脱离"><a href="#共享内存脱离" class="headerlink" title="共享内存脱离"></a>共享内存脱离</h3><p>&emsp;&emsp;当一个进程不再需要共享内存时，需要把它从进程地址空间中脱离，使用如下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span> <span class="params">( <span class="keyword">char</span> *shmaddr )</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数参数<code>shmaddr</code>是从<code>shmat</code>中获得的。<br>&emsp;&emsp;共享内存的使用如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ShareMem_1.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERM S_IRUSR|S_IWUSR</span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">char</span> *p_addr, *c_addr;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Usage:%s\n\a"</span>, argv[<span class="number">0</span>] );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( shmid = shmget ( IPC_PRIVATE, <span class="number">1024</span>, PERM ) ) == <span class="number">-1</span> ) &#123; <span class="comment">/* 创建共享内存 */</span></span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Create Share Memory Error:%s\n\a"</span>, strerror ( errno ) );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 创建子进程 */</span></span><br><span class="line">    <span class="keyword">if</span> ( fork() ) &#123; <span class="comment">/* 父进程写 */</span></span><br><span class="line">        p_addr = shmat ( shmid, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">memset</span> ( p_addr, <span class="string">'\0'</span>, <span class="number">1024</span> );</span><br><span class="line">        <span class="built_in">strncpy</span> ( p_addr, argv[<span class="number">1</span>], <span class="number">1024</span> );</span><br><span class="line">        wait ( <span class="literal">NULL</span> ); <span class="comment">/* 释放资源，不关心终止状态 */</span></span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 子进程读 */</span></span><br><span class="line">        sleep ( <span class="number">1</span> ); <span class="comment">/* 暂停1秒 */</span></span><br><span class="line">        c_addr = shmat ( shmid, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Client get %s\n"</span>, c_addr );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* ShareMem_2.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/ipc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/shm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSZ 2048</span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">char</span> *shmadd;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( shmid = shmget ( IPC_PRIVATE, BUFSZ, <span class="number">0666</span> ) ) &lt; <span class="number">0</span> ) &#123; <span class="comment">/* 创建共享内存 */</span></span><br><span class="line">        perror ( <span class="string">"shmget"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"created shared-memeory: %d\n"</span>, shmid );</span><br><span class="line">    system ( <span class="string">"ipcs -m"</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( shmadd = ( <span class="keyword">char</span> * ) shmat ( shmid, <span class="number">0</span>, <span class="number">0</span> ) ) &lt; ( <span class="keyword">char</span> * ) <span class="number">0</span> ) &#123; <span class="comment">/* 映射共享内存 */</span></span><br><span class="line">        perror ( <span class="string">"shmat"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"attached shared-memory\n"</span> );</span><br><span class="line">    system ( <span class="string">"ipcs -m"</span> ); <span class="comment">/* 显示系统内存情况 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( shmdt ( shmadd ) &lt; <span class="number">0</span> ) &#123; <span class="comment">/* 取消共享内存映射 */</span></span><br><span class="line">        perror ( <span class="string">"shmat"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"detach shared-memory\n"</span> );</span><br><span class="line">    system ( <span class="string">"ipcs -m"</span> );</span><br><span class="line">    shmctl ( shmid, IPC_RMID, <span class="literal">NULL</span> ); <span class="comment">/* 删除共享内存对象 */</span></span><br><span class="line">    system ( <span class="string">"ipcs -m"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="共享内存使用示例"><a href="#共享内存使用示例" class="headerlink" title="共享内存使用示例"></a>共享内存使用示例</h3><p>&emsp;&emsp;<code>shm_com.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEXT_SZ 2048</span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shared_use_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> written_by_you;</span><br><span class="line">    <span class="keyword">char</span> some_text[TEXT_SZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>shm1.c</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shm_com.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> *shared_memory = ( <span class="keyword">void</span> * ) <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shared_use_st</span> *<span class="title">shared_stuff</span>;</span></span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="comment">/* 创建共享内存 */</span></span><br><span class="line">    shmid = shmget ( ( <span class="keyword">key_t</span> ) <span class="number">1234</span>, <span class="keyword">sizeof</span> ( struct shared_use_st ), <span class="number">0666</span> | IPC_CREAT );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( shmid == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"shmget failed\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    shared_memory = shmat ( shmid, ( <span class="keyword">void</span> * ) <span class="number">0</span>, <span class="number">0</span> ); <span class="comment">/* 映射共享内存 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( shared_memory == ( <span class="keyword">void</span> * ) - <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"shmat failed\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Memory attached at %X\n"</span>, ( <span class="keyword">int</span> ) shared_memory );</span><br><span class="line">    <span class="comment">/* 让结构体指针指向这块共享内存 */</span></span><br><span class="line">    shared_stuff = ( struct shared_use_st * ) shared_memory;</span><br><span class="line">    shared_stuff-&gt;written_by_you = <span class="number">0</span>; <span class="comment">/* 控制读写顺序 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( running ) &#123; <span class="comment">/* 循环的从共享内存中读数据，直到读到“end”为止 */</span></span><br><span class="line">        <span class="keyword">if</span> ( shared_stuff-&gt;written_by_you ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"You wrote:%s"</span>, shared_stuff-&gt;some_text );</span><br><span class="line">            sleep ( <span class="number">1</span> ); <span class="comment">/* 读进程睡一秒，同时会导致写进程睡一秒，这样做到读了之后再写 */</span></span><br><span class="line">            shared_stuff-&gt;written_by_you = <span class="number">0</span>;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">strncmp</span> ( shared_stuff-&gt;some_text, <span class="string">"end"</span>, <span class="number">3</span> ) == <span class="number">0</span> ) &#123;</span><br><span class="line">                running = <span class="number">0</span>; <span class="comment">/* 结束循环 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( shmdt ( shared_memory ) == <span class="number">-1</span> ) &#123; <span class="comment">/* 删除共享内存 */</span></span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"shmdt failed\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">exit</span> ( EXIT_SUCCESS );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>shm2.c</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shm_com.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> *shared_memory = ( <span class="keyword">void</span> * ) <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shared_use_st</span> *<span class="title">shared_stuff</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[BUFSIZ];</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="comment">/* 创建共享内存 */</span></span><br><span class="line">    shmid = shmget ( ( <span class="keyword">key_t</span> ) <span class="number">1234</span>, <span class="keyword">sizeof</span> ( struct shared_use_st ), <span class="number">0666</span> | IPC_CREAT );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( shmid == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"shmget failed\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    shared_memory = shmat ( shmid, ( <span class="keyword">void</span> * ) <span class="number">0</span>, <span class="number">0</span> ); <span class="comment">/* 映射共享内存 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( shared_memory == ( <span class="keyword">void</span> * ) - <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"shmat failed\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Memory attached at %X\n"</span>, ( <span class="keyword">int</span> ) shared_memory );</span><br><span class="line">    <span class="comment">/* 让结构体指针指向这块共享内存 */</span></span><br><span class="line">    shared_stuff = ( struct shared_use_st * ) shared_memory;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( running ) &#123; <span class="comment">/* 循环的向共享内存中写数据，直到写入的为“end”为止 */</span></span><br><span class="line">        <span class="keyword">while</span> ( shared_stuff-&gt;written_by_you == <span class="number">1</span> ) &#123;</span><br><span class="line">            sleep ( <span class="number">1</span> ); <span class="comment">/* 等到读进程读完之后再写 */</span></span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"waiting for client...\n"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Ener some text:"</span> );</span><br><span class="line">        fgets ( buffer, BUFSIZ, <span class="built_in">stdin</span> );</span><br><span class="line">        <span class="built_in">strncpy</span> ( shared_stuff-&gt;some_text, buffer, TEXT_SZ );</span><br><span class="line">        shared_stuff-&gt;written_by_you = <span class="number">1</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">strncmp</span> ( buffer, <span class="string">"end"</span>, <span class="number">3</span> ) == <span class="number">0</span> ) &#123;</span><br><span class="line">            running = <span class="number">0</span>; <span class="comment">/* 结束循环 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( shmdt ( shared_memory ) == <span class="number">-1</span> ) &#123; <span class="comment">/*删除共享内存*/</span></span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"shmdt failed\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">exit</span> ( EXIT_SUCCESS );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/94/">94</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">939</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
