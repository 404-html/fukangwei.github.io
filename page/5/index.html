<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="暴徒">
<meta property="og:url" content="http://fukangwei.gitee.io/page/5/index.html">
<meta property="og:site_name" content="暴徒">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="暴徒">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/5/">





  <title>暴徒</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">暴徒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/13/网络编程/IP数据报格式详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/网络编程/IP数据报格式详解/" itemprop="url">IP数据报格式详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T20:14:07+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>TCP/IP</code>协议定义了一个在因特网上传输的包，称为<code>IP</code>数据报(<code>IP Datagram</code>)。这是一个与硬件无关的虚拟包，由首部和数据两部分组成。首部的前一部分是固定长度，共<code>20</code>字节，是所有<code>IP</code>数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。首都中的源地址和目的地址都是<code>IP</code>协议地址。</p>
<p><img src="/2019/03/13/网络编程/IP数据报格式详解/1.jpg" height="235" width="370"></p>
<p>&emsp;&emsp;<code>IP</code>数据报首部的固定部分中的各字段：</p>
<ul>
<li>版本：占<code>4</code>位，指<code>IP</code>协议的版本，通信双方使用的<code>IP</code>协议版本必须一致。日前广泛使用的<code>IP</code>协议版本号为<code>4</code>(即<code>IPv4</code>)。</li>
<li>首部长度：占<code>4</code>位，可表示的最大十进制数值是<code>15</code>。请注意，这个字段所表示数的单位是<code>32</code>位字(<code>1</code>个<code>32</code>位字长是<code>4</code>字节)，因此当<code>IP</code>的首部长度为<code>1111</code>时(即十进制的<code>15</code>)，首部长度就达到<code>60</code>字节。当<code>IP</code>分组的首部长度不是<code>4</code>字节的整数倍时，必须利用最后的填充字段加以填充，因此数据部分永远在<code>4</code>字节的整数倍开始，这样在实现<code>IP</code>协议时较为方便。首部长度限制为<code>60</code>字节的缺点是有时可能不够用，这样做的目的是希望用户尽量减少开销。最常用的首部长度就是<code>20</code>字节(即首部长度为<code>0101</code>)，这时不使用任何选项。</li>
<li>服务：占<code>8</code>位，用来获得更好的服务，一般不使用。服务类型字段实际上被划分为<code>2</code>个部分，一部分为优先权，一部分为<code>TOS</code>。优先权用来设定报文的优先级，就像邮包分为挂号和平信一样。<code>TOS</code>允许按照吞吐量、时延、可靠性和费用方式选择传输服务，在早期的时候，<code>TOS</code>还被用来进行路由选择。在<code>QOS</code>中有时也会使用优先权，常见的优先权队列。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。<code>1998</code>年<code>IETF</code>把这个字段改名为区分服务<code>DS</code>(<code>Differentiated Services</code>)，只有在使用区分服务时，这个字段才起作用。</li>
<li>总长度：总长度指首都及数据之和的长度，单位为字节。因为总长度字段为<code>16</code>位，所以数据报的最大长度为<code>65535</code>字节。在<code>IP</code>层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，即最大传送单元<code>MTU</code>(<code>Maximum Transfer Unit</code>)。当一个数据报封装成链路层的帧时，此数据报的总长度(即首部加上数据部分)一定不能超过下面的数据链路层的<code>MTU</code>值。如果报文总长度大于数据链路可传输的最大传输单元，那么就会对报文进行分片。</li>
<li>标识(<code>Identification</code>)：占<code>16</code>位。<code>IP</code>软件在存储器中维持一个计数器，每产生一个数据报，计数器就加<code>1</code>，并将此值赋给标识字段。但这个<code>标识</code>并不是序号，因为<code>IP</code>是无连接的服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的<code>MTU</code>而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</li>
<li>标志(<code>Flag</code>)：占<code>3</code>位，但目前只有<code>2</code>位有意义，其中第一位没有被使用。第二位是不分片位，当<code>DF</code>位被置<code>1</code>，表示路由器不能对数据报文进行分片处理，如果报文由于不能被分片而不能被转发，那么路由器将丢弃这个数据包，并向源地址发送错误报告。这一功能可以用来测试线路的最大传输单元，只有当<code>DF = 0</code>时才允许分片。第三位为<code>MF</code>，当路由器对数据进行分片时，除了最后一个分片的<code>MF</code>位为<code>0</code>外，其他所有的<code>MF</code>全部为<code>1</code>，表示其后面还有其他的分片。<code>MF = 1</code>表示后面<code>还有分片</code>的数据报；<code>MF = 0</code>表示这已是若干数据报片中的最后一个。</li>
<li>片偏移：占<code>13</code>位。较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以<code>8</code>个字节为偏移单位。这就是说，每个分片的长度一定是<code>8</code>字节(<code>64</code>位)的整数倍。</li>
<li>生存时间：占<code>8</code>位，生存时间字段常用的英文缩写是<code>TTL</code>(<code>Time To Live</code>)，其表明数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子，因而白白消耗网络资源。每经过一个路由器时，就将<code>TTL</code>减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于<code>1</code>秒，就把<code>TTL</code>值减<code>1</code>。当<code>TTL</code>值为<code>0</code>时，就丢弃这个数据报，同时向源地址发送错误报告，促使重新发送。</li>
<li>协议：占<code>8</code>位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的<code>IP</code>层知道应将数据部分上交给哪个处理过程，常用的有<code>ICMP</code>(<code>1</code>)、<code>IGMP</code>(<code>2</code>)、<code>TCP</code>(<code>6</code>)、<code>UDP</code>(<code>17</code>)、<code>IPv6</code>(<code>41</code>)。</li>
<li>首部检验和：占<code>16</code>位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，都要重新计算一下首都检验和(一些字段，如生存时间、标志、片偏移等都可能发生变化)。不检验数据部分可减少计算的工作量。</li>
<li>源地址：发送方<code>IP</code>地址。</li>
<li>目的地址：接收方<code>IP</code>地址。</li>
</ul>
<p><img src="/2019/03/13/网络编程/IP数据报格式详解/2.jpg" height="207" width="359"></p>
<p>&emsp;&emsp;<code>IP</code>数据报首部的可变部分：<code>IP</code>首都的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从<code>1</code>个字节到<code>40</code>个字节不等，取决于所选择的项目。某些选项只需要<code>1</code>个字节，它只包括<code>1</code>个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全<code>0</code>的填充字段补齐成为<code>4</code>字节的整数倍。增加首都的可变部分是为了增加<code>IP</code>数据报的功能，但这同时也使得<code>IP</code>数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的<code>IPv6</code>就将<code>IP</code>数据报的首部长度做成固定的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/13/网络编程/原始套接字实例_MAC头部报文/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/网络编程/原始套接字实例_MAC头部报文/" itemprop="url">原始套接字实例_MAC头部报文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T20:01:28+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;链路层封包格式如下：</p>
<p><img src="/2019/03/13/网络编程/原始套接字实例_MAC头部报文/1.jpg" height="284" width="543"></p>
<p>&emsp;&emsp;<code>MAC</code>头部(有线局域网)如下(<code>CRC</code>、<code>PAD</code>在组包时可以忽略)：</p>
<p><img src="/2019/03/13/网络编程/原始套接字实例_MAC头部报文/2.png"></p>
<p>&emsp;&emsp;链路层数据包的其中一种情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> msg[<span class="number">1024</span>] = &#123;</span><br><span class="line">    <span class="comment">/* 组MAC(14直接) */</span></span><br><span class="line">    <span class="number">0xb8</span>, <span class="number">0x88</span>, <span class="number">0xe3</span>, <span class="number">0xe1</span>, <span class="number">0x10</span>, <span class="number">0xe6</span>, <span class="comment">/* dst_mac: b8:88:e3:e1:10:e6 */</span></span><br><span class="line">    <span class="number">0xc8</span>, <span class="number">0x9c</span>, <span class="number">0xdc</span>, <span class="number">0xb7</span>, <span class="number">0x0f</span>, <span class="number">0x19</span>, <span class="comment">/* src_mac: c8:9c:dc:b7:0f:19 */</span></span><br><span class="line">    <span class="number">0x08</span>, <span class="number">0x00</span>,                         <span class="comment">/* 类型：0x0800(IP协议) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接收的链路层数据包，并对其进行简单分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ether.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">1024</span>] = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> sock_raw_fd = socket ( PF_PACKET, SOCK_RAW, htons ( ETH_P_ALL ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> src_mac[<span class="number">18</span>] = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> dst_mac[<span class="number">18</span>] = <span class="string">""</span>;</span><br><span class="line">        recvfrom ( sock_raw_fd, buf, <span class="keyword">sizeof</span> ( buf ), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> ); <span class="comment">/* 获取链路层的数据帧 */</span></span><br><span class="line">        <span class="comment">/* 从buf里提取目的mac、源mac */</span></span><br><span class="line">        <span class="built_in">sprintf</span> ( dst_mac, <span class="string">"%02x:%02x:%02x:%02x:%02x:%02x"</span>, buf[<span class="number">0</span>], buf[<span class="number">1</span>], buf[<span class="number">2</span>], buf[<span class="number">3</span>], buf[<span class="number">4</span>], buf[<span class="number">5</span>] );</span><br><span class="line">        <span class="built_in">sprintf</span> ( src_mac, <span class="string">"%02x:%02x:%02x:%02x:%02x:%02x"</span>, buf[<span class="number">6</span>], buf[<span class="number">7</span>], buf[<span class="number">8</span>], buf[<span class="number">9</span>], buf[<span class="number">10</span>], buf[<span class="number">11</span>] );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( buf[<span class="number">12</span>] == <span class="number">0x08</span> &amp;&amp; buf[<span class="number">13</span>] == <span class="number">0x00</span> ) &#123; <span class="comment">/* 判断是否为IP数据包 */</span></span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"______________IP数据报_______________\n"</span> );</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"MAC:%s &gt;&gt; %s\n"</span>, src_mac, dst_mac );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( buf[<span class="number">12</span>] == <span class="number">0x08</span> &amp;&amp; buf[<span class="number">13</span>] == <span class="number">0x06</span> ) &#123; <span class="comment">/* 判断是否为ARP数据包 */</span></span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"______________ARP数据报_______________\n"</span> );</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"MAC:%s &gt;&gt; %s\n"</span>, src_mac, dst_mac );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( buf[<span class="number">12</span>] == <span class="number">0x80</span> &amp;&amp; buf[<span class="number">13</span>] == <span class="number">0x35</span> ) &#123; <span class="comment">/* 判断是否为RARP数据包 */</span></span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"______________RARP数据报_______________\n"</span> );</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"MAC:%s&gt;&gt;%s\n"</span>, src_mac, dst_mac );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，要以管理者权限运行程序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/13/Linux系统编程/Linux视频采集与编码/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/Linux系统编程/Linux视频采集与编码/" itemprop="url">Linux视频采集与编码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T19:40:41+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;在<code>Linux</code>下用<code>V4L2</code>采集<code>yuv</code>视频，然后用<code>x264</code>编码成<code>h.264</code>文件。我将<code>yuv</code>视频保存到文件中(我采集视频的尺寸为<code>640 * 480</code>，<code>YUV</code>格式为<code>YUYV</code>即<code>YUV422</code>)，然后用<code>pyuv</code>播放器播放它，悲剧的是播放出来的视频花屏了。<br>&emsp;&emsp;后来认真看代码，发现其中有这么一句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;</span><br></pre></td></tr></table></figure>
<p>意思就是采集数据的时候使用的是隔行扫描的方式，也就是说采集到的<code>yuv</code>写到文件中的方式是用隔行扫描的方式保存。如果不将<code>Interleaved</code>复选框勾起来，播放器就不能正常的播放<code>yuv</code>文件。<code>V4L2</code>视频采集代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/types.h&gt; /* for videodev2.h */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/videodev2.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLEAR(x) memset (&amp;(x), 0, sizeof (x))</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    IO_METHOD_READ,</span><br><span class="line">    IO_METHOD_MMAP,</span><br><span class="line">    IO_METHOD_USERPTR,</span><br><span class="line">&#125; io_method;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *start;</span><br><span class="line">    <span class="keyword">size_t</span> length;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *dev_name = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> io_method io = IO_METHOD_MMAP;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">buffers</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_buffers = <span class="number">0</span>;</span><br><span class="line">​</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">char</span> *filename = <span class="string">"test.yuv\0"</span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">errno_exit</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *s )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"%s error %d, %s\n"</span>, s, errno, strerror ( errno ) );</span><br><span class="line">    <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xioctl</span> <span class="params">( <span class="keyword">int</span> fd, <span class="keyword">int</span> request, <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        r = ioctl ( fd, request, arg );</span><br><span class="line">    &#125; <span class="keyword">while</span> ( <span class="number">-1</span> == r &amp;&amp; EINTR == errno );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_image</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *p, <span class="keyword">int</span> size )</span> </span>&#123;</span><br><span class="line">    fwrite ( p, size, <span class="number">1</span>, fp );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">read_frame</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( io ) &#123;</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_READ:</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == read ( fd, buffers[<span class="number">0</span>].start, buffers[<span class="number">0</span>].length ) ) &#123;</span><br><span class="line">                <span class="keyword">switch</span> ( errno ) &#123;</span><br><span class="line">                    <span class="keyword">case</span> EAGAIN:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">​</span><br><span class="line">                    <span class="keyword">case</span> EIO:</span><br><span class="line">​</span><br><span class="line">                    <span class="comment">/* Could ignore EIO, see spec. */</span></span><br><span class="line">                    <span class="comment">/* fall through */</span></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        errno_exit ( <span class="string">"read"</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            process_image ( buffers[<span class="number">0</span>].start, buffers[<span class="number">0</span>].length );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_MMAP:</span><br><span class="line">            CLEAR ( buf );</span><br><span class="line">            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">            buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_DQBUF, &amp;buf ) ) &#123;</span><br><span class="line">                <span class="keyword">switch</span> ( errno ) &#123;</span><br><span class="line">                    <span class="keyword">case</span> EAGAIN:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">​</span><br><span class="line">                    <span class="keyword">case</span> EIO:</span><br><span class="line">​</span><br><span class="line">                    <span class="comment">/* Could ignore EIO, see spec. */</span></span><br><span class="line">​</span><br><span class="line">                    <span class="comment">/* fall through */</span></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        errno_exit ( <span class="string">"VIDIOC_DQBUF"</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            assert ( buf.index &lt; n_buffers );</span><br><span class="line">            process_image ( buffers[buf.index].start, buf.length );</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_QBUF, &amp;buf ) ) &#123;</span><br><span class="line">                errno_exit ( <span class="string">"VIDIOC_QBUF"</span> );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_USERPTR:</span><br><span class="line">            CLEAR ( buf );</span><br><span class="line">            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">            buf.memory = V4L2_MEMORY_USERPTR;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_DQBUF, &amp;buf ) ) &#123;</span><br><span class="line">                <span class="keyword">switch</span> ( errno ) &#123;</span><br><span class="line">                    <span class="keyword">case</span> EAGAIN:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">​</span><br><span class="line">                    <span class="keyword">case</span> EIO:</span><br><span class="line">​</span><br><span class="line">                    <span class="comment">/* Could ignore EIO, see spec. */</span></span><br><span class="line">​</span><br><span class="line">                    <span class="comment">/* fall through */</span></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        errno_exit ( <span class="string">"VIDIOC_DQBUF"</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n_buffers; ++i )</span><br><span class="line">                <span class="keyword">if</span> ( buf.m.userptr == ( <span class="keyword">unsigned</span> <span class="keyword">long</span> ) buffers[i].start</span><br><span class="line">                     &amp;&amp; buf.length == buffers[i].length ) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">​</span><br><span class="line">            assert ( i &lt; n_buffers );</span><br><span class="line">            process_image ( ( <span class="keyword">void</span> * ) buf.m.userptr, buf.length );</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_QBUF, &amp;buf ) ) &#123;</span><br><span class="line">                errno_exit ( <span class="string">"VIDIOC_QBUF"</span> );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mainloop</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    count = <span class="number">100</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( count-- &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">            fd_set fds;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">            <span class="keyword">int</span> r;</span><br><span class="line">            FD_ZERO ( &amp;fds );</span><br><span class="line">            FD_SET ( fd, &amp;fds );</span><br><span class="line">            <span class="comment">/* Timeout. */</span></span><br><span class="line">            tv.tv_sec = <span class="number">2</span>;</span><br><span class="line">            tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">            r = select ( fd + <span class="number">1</span>, &amp;fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv );</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == r ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( EINTR == errno ) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">​</span><br><span class="line">                errno_exit ( <span class="string">"select"</span> );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">0</span> == r ) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"select timeout\n"</span> );</span><br><span class="line">                <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( read_frame() ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="comment">/* EAGAIN - continue select loop. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stop_capturing</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> v4l2_buf_type type;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( io ) &#123;</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_READ:</span><br><span class="line">            <span class="comment">/* Nothing to do. */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_MMAP:</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_USERPTR:</span><br><span class="line">            type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_STREAMOFF, &amp;type ) ) &#123;</span><br><span class="line">                errno_exit ( <span class="string">"VIDIOC_STREAMOFF"</span> );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start_capturing</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">enum</span> v4l2_buf_type type;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( io ) &#123;</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_READ:</span><br><span class="line">            <span class="comment">/* Nothing to do. */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_MMAP:</span><br><span class="line">            <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n_buffers; ++i ) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">                CLEAR ( buf );</span><br><span class="line">                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">                buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">                buf.index = i;</span><br><span class="line">​</span><br><span class="line">                <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_QBUF, &amp;buf ) ) &#123;</span><br><span class="line">                    errno_exit ( <span class="string">"VIDIOC_QBUF"</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_STREAMON, &amp;type ) ) &#123;</span><br><span class="line">                errno_exit ( <span class="string">"VIDIOC_STREAMON"</span> );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_USERPTR:</span><br><span class="line">            <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n_buffers; ++i ) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">                CLEAR ( buf );</span><br><span class="line">                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">                buf.memory = V4L2_MEMORY_USERPTR;</span><br><span class="line">                buf.index = i;</span><br><span class="line">                buf.m.userptr = ( <span class="keyword">unsigned</span> <span class="keyword">long</span> ) buffers[i].start;</span><br><span class="line">                buf.length = buffers[i].length;</span><br><span class="line">​</span><br><span class="line">                <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_QBUF, &amp;buf ) ) &#123;</span><br><span class="line">                    errno_exit ( <span class="string">"VIDIOC_QBUF"</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_STREAMON, &amp;type ) ) &#123;</span><br><span class="line">                errno_exit ( <span class="string">"VIDIOC_STREAMON"</span> );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uninit_device</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( io ) &#123;</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_READ:</span><br><span class="line">            <span class="built_in">free</span> ( buffers[<span class="number">0</span>].start );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_MMAP:</span><br><span class="line">            <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n_buffers; ++i )</span><br><span class="line">                <span class="keyword">if</span> ( <span class="number">-1</span> == munmap ( buffers[i].start, buffers[i].length ) ) &#123;</span><br><span class="line">                    errno_exit ( <span class="string">"munmap"</span> );</span><br><span class="line">                &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_USERPTR:</span><br><span class="line">            <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n_buffers; ++i ) &#123;</span><br><span class="line">                <span class="built_in">free</span> ( buffers[i].start );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">free</span> ( buffers );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_read</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> buffer_size )</span> </span>&#123;</span><br><span class="line">    buffers = <span class="built_in">calloc</span> ( <span class="number">1</span>, <span class="keyword">sizeof</span> ( *buffers ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !buffers ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Out of memory\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    buffers[<span class="number">0</span>].length = buffer_size;</span><br><span class="line">    buffers[<span class="number">0</span>].start = <span class="built_in">malloc</span> ( buffer_size );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !buffers[<span class="number">0</span>].start ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Out of memory\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_mmap</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_requestbuffers</span> <span class="title">req</span>;</span></span><br><span class="line">    CLEAR ( req );</span><br><span class="line">    req.count = <span class="number">4</span>;</span><br><span class="line">    req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    req.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_REQBUFS, &amp;req ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( EINVAL == errno ) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"%s does not support memory mapping\n"</span>, dev_name );</span><br><span class="line">            <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            errno_exit ( <span class="string">"VIDIOC_REQBUFS"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( req.count &lt; <span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Insufficient buffer memory on %s\n"</span>, dev_name );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    buffers = <span class="built_in">calloc</span> ( req.count, <span class="keyword">sizeof</span> ( *buffers ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !buffers ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Out of memory\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( n_buffers = <span class="number">0</span>; n_buffers &lt; req.count; ++n_buffers ) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">        CLEAR ( buf );</span><br><span class="line">        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">        buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">        buf.index = n_buffers;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_QUERYBUF, &amp;buf ) ) &#123;</span><br><span class="line">            errno_exit ( <span class="string">"VIDIOC_QUERYBUF"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        buffers[n_buffers].length = buf.length;</span><br><span class="line">        buffers[n_buffers].start = mmap ( <span class="literal">NULL</span> <span class="comment">/* start anywhere */</span>,</span><br><span class="line">                                          buf.length,</span><br><span class="line">                                          PROT_READ | PROT_WRITE <span class="comment">/* required */</span>,</span><br><span class="line">                                          MAP_SHARED <span class="comment">/* recommended */</span>,</span><br><span class="line">                                          fd, buf.m.offset );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( MAP_FAILED == buffers[n_buffers].start ) &#123;</span><br><span class="line">            errno_exit ( <span class="string">"mmap"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_userp</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> buffer_size )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_requestbuffers</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> page_size;</span><br><span class="line">    page_size = getpagesize();</span><br><span class="line">    buffer_size = ( buffer_size + page_size - <span class="number">1</span> ) &amp; ~ ( page_size - <span class="number">1</span> );</span><br><span class="line">    CLEAR ( req );</span><br><span class="line">    req.count = <span class="number">4</span>;</span><br><span class="line">    req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    req.memory = V4L2_MEMORY_USERPTR;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_REQBUFS, &amp;req ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( EINVAL == errno ) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"%s does not support "</span></span><br><span class="line">                      <span class="string">"user pointer i/o\n"</span>, dev_name );</span><br><span class="line">            <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            errno_exit ( <span class="string">"VIDIOC_REQBUFS"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    buffers = <span class="built_in">calloc</span> ( <span class="number">4</span>, <span class="keyword">sizeof</span> ( *buffers ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !buffers ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Out of memory\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( n_buffers = <span class="number">0</span>; n_buffers &lt; <span class="number">4</span>; ++n_buffers ) &#123;</span><br><span class="line">        buffers[n_buffers].length = buffer_size;</span><br><span class="line">        buffers[n_buffers].start = memalign ( <span class="comment">/* boundary */</span>page_size,</span><br><span class="line">                                                            buffer_size );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( !buffers[n_buffers].start ) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Out of memory\n"</span> );</span><br><span class="line">            <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_device</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_capability</span> <span class="title">cap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_cropcap</span> <span class="title">cropcap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_crop</span> <span class="title">crop</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_format</span> <span class="title">fmt</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> min;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_QUERYCAP, &amp;cap ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( EINVAL == errno ) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"%s is no V4L2 device\n"</span>, dev_name );</span><br><span class="line">            <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            errno_exit ( <span class="string">"VIDIOC_QUERYCAP"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ! ( cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE ) ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"%s is no video capture device\n"</span>, dev_name );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( io ) &#123;</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_READ:</span><br><span class="line">            <span class="keyword">if</span> ( ! ( cap.capabilities &amp; V4L2_CAP_READWRITE ) ) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"%s does not support read i/o\n"</span>, dev_name );</span><br><span class="line">                <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_MMAP:</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_USERPTR:</span><br><span class="line">            <span class="keyword">if</span> ( ! ( cap.capabilities &amp; V4L2_CAP_STREAMING ) ) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"%s does not support streaming i/o\n"</span>, dev_name );</span><br><span class="line">                <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* Select video input, video standard and tune here. */</span></span><br><span class="line">    CLEAR ( cropcap );</span><br><span class="line">    cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">0</span> == xioctl ( fd, VIDIOC_CROPCAP, &amp;cropcap ) ) &#123;</span><br><span class="line">        crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">        crop.c = cropcap.defrect; <span class="comment">/* reset to default */</span></span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_S_CROP, &amp;crop ) ) &#123;</span><br><span class="line">            <span class="keyword">switch</span> ( errno ) &#123;</span><br><span class="line">                <span class="keyword">case</span> EINVAL:</span><br><span class="line">                    <span class="comment">/* Cropping not supported. */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">/* Errors ignored. */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Errors ignored. */</span></span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    CLEAR ( fmt );</span><br><span class="line">    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    fmt.fmt.pix.width = <span class="number">640</span>;</span><br><span class="line">    fmt.fmt.pix.height = <span class="number">480</span>;</span><br><span class="line">    fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;</span><br><span class="line">    fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == xioctl ( fd, VIDIOC_S_FMT, &amp;fmt ) ) &#123;</span><br><span class="line">        errno_exit ( <span class="string">"VIDIOC_S_FMT"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* Note VIDIOC_S_FMT may change width and height. */</span></span><br><span class="line">    <span class="comment">/* Buggy driver paranoia. */</span></span><br><span class="line">    min = fmt.fmt.pix.width * <span class="number">2</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( fmt.fmt.pix.bytesperline &lt; min ) &#123;</span><br><span class="line">        fmt.fmt.pix.bytesperline = min;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    min = fmt.fmt.pix.bytesperline * fmt.fmt.pix.height;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( fmt.fmt.pix.sizeimage &lt; min ) &#123;</span><br><span class="line">        fmt.fmt.pix.sizeimage = min;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( io ) &#123;</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_READ:</span><br><span class="line">            init_read ( fmt.fmt.pix.sizeimage );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_MMAP:</span><br><span class="line">            init_mmap();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> IO_METHOD_USERPTR:</span><br><span class="line">            init_userp ( fmt.fmt.pix.sizeimage );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close_device</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == close ( fd ) ) &#123;</span><br><span class="line">        errno_exit ( <span class="string">"close"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    fd = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open_device</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == stat ( dev_name, &amp;st ) ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Cannot identify '%s': %d, %s\n"</span>, dev_name, errno, strerror ( errno ) );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !S_ISCHR ( st.st_mode ) ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"%s is no device\n"</span>, dev_name );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    fd = open ( dev_name, O_RDWR <span class="comment">/* required */</span> | O_NONBLOCK, <span class="number">0</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == fd ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Cannot open '%s': %d, %s\n"</span>, dev_name, errno, strerror ( errno ) );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usage</span> <span class="params">( FILE *fp, <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span> ( fp, <span class="string">"Usage: %s [options]\n\n"</span></span><br><span class="line">              <span class="string">"Options:\n"</span></span><br><span class="line">              <span class="string">"-d | --device name  Video device name [/dev/video]\n"</span></span><br><span class="line">              <span class="string">"-h | --help         Print this message\n"</span></span><br><span class="line">              <span class="string">"-m | --mmap         Use memory mapped buffers\n"</span></span><br><span class="line">              <span class="string">"-r | --read         Use read() calls\n"</span></span><br><span class="line">              <span class="string">"-u | --userp        Use application allocated buffers\n"</span></span><br><span class="line">              <span class="string">""</span>, argv[<span class="number">0</span>] );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> short_options[] = <span class="string">"d:hmru"</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_options</span>[] = &#123;</span> &#123; <span class="string">"device"</span>, required_argument,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="string">'d'</span></span><br><span class="line">    &#125;, &#123; <span class="string">"help"</span>, no_argument, <span class="literal">NULL</span>, <span class="string">'h'</span> &#125;, &#123; <span class="string">"mmap"</span>, no_argument,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="string">'m'</span></span><br><span class="line">    &#125;, &#123; <span class="string">"read"</span>, no_argument, <span class="literal">NULL</span>, <span class="string">'r'</span> &#125;, &#123; <span class="string">"userp"</span>, no_argument,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="string">'u'</span></span><br><span class="line">    &#125;, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    dev_name = <span class="string">"/dev/video0"</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        c = getopt_long ( argc, argv, short_options, long_options, &amp;index );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( <span class="number">-1</span> == c ) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">switch</span> ( c ) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* getopt_long() flag */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">                dev_name = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">                usage ( <span class="built_in">stdout</span>, argc, argv );</span><br><span class="line">                <span class="built_in">exit</span> ( EXIT_SUCCESS );</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line">                io = IO_METHOD_MMAP;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">                io = IO_METHOD_READ;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">                io = IO_METHOD_USERPTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                usage ( <span class="built_in">stderr</span>, argc, argv );</span><br><span class="line">                <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    open_device();</span><br><span class="line">    init_device();</span><br><span class="line">    start_capturing();</span><br><span class="line">    fp = fopen ( filename, <span class="string">"wa+"</span> );</span><br><span class="line">    mainloop();</span><br><span class="line">    fclose ( fp );</span><br><span class="line">    stop_capturing();</span><br><span class="line">    uninit_device();</span><br><span class="line">    close_device();</span><br><span class="line">    <span class="built_in">exit</span> ( EXIT_SUCCESS );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>补充说明</strong>：这是我在计算机上的软件设置：</p>
<p><img src="/2019/03/13/Linux系统编程/Linux视频采集与编码/1.jpg"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/13/Linux系统编程/信号/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/Linux系统编程/信号/" itemprop="url">信号</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T14:20:36+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="信号通信"><a href="#信号通信" class="headerlink" title="信号通信"></a>信号通信</h3><p>&emsp;&emsp;信号(<code>signal</code>)机制是<code>Unix</code>系统中最为古老的进程间通信机制，很多条件可以产生一个信号：</p>
<ul>
<li>当用户按某些按键时，产生信号。</li>
<li>硬件异常产生信号：除数为<code>0</code>、无效的存储访问等等。这些情况通常由硬件检测到，将其通知内核，然后内核产生适当的信号通知进程，例如内核对正访问一个无效存储区的进程产生一个<code>SIGSEGV</code>信号。</li>
<li>进程用<code>kill</code>函数将信号发送给另一个进程。</li>
<li>用户可用<code>kill</code>命令将信号发送给其他进程。</li>
</ul>
<h3 id="信号类型"><a href="#信号类型" class="headerlink" title="信号类型"></a>信号类型</h3><p>&emsp;&emsp;下面是几种常见的信号：</p>
<ul>
<li><code>SIGHUP</code>：从终端上发出的结束信号。</li>
<li><code>SIGINT</code>：来自键盘的中断信号(<code>Ctrl-C</code>)。</li>
<li><code>SIGKILL</code>：该信号结束接收信号的进程。</li>
<li><code>SIGTERM</code>：<code>kill</code>命令发出的信号。</li>
<li><code>SIGCHLD</code>：标识子进程停止或结束的信号。</li>
<li><code>SIGSTOP</code>：来自键盘(<code>Ctrl-Z</code>)或调试程序的停止执行信号。</li>
<li><code>SIGQUIT</code>：来自键盘的退出信号(<code>Ctrl-\</code>)。</li>
<li><code>SIGFPE</code>：浮点异常信号(例如浮点运算溢出)。</li>
<li><code>SIGALRM</code>：进程的定时器到期，发送该信号。</li>
<li><code>SIGSEGV</code>：非法存储器访问，如访问不存在的内存单元。</li>
</ul>
<h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><p>&emsp;&emsp;当某信号出现时，将按照下列三种方式中的一种进行处理：</p>
<ul>
<li>忽略此信号：大多数信号都按照这种方式进行处理，但有两种信号却决不能被忽略，它们是<code>SIGKILL</code>和<code>SIGSTOP</code>。这两种信号不能被忽略的原因是：它们向超级用户提供了一种终止或停止进程的方法。</li>
<li>执行用户希望的动作：通知内核在某种信号发生时，调用一个用户函数。在用户函数中，执行用户希望的处理。</li>
<li>执行系统默认动作：对大多数信号的系统默认动作是终止该进程。</li>
</ul>
<h3 id="信号发送"><a href="#信号发送" class="headerlink" title="信号发送"></a>信号发送</h3><p>&emsp;&emsp;发送信号的主要函数有<code>kill</code>和<code>raise</code>。它们的区别是：<code>Kill</code>既可以向自身发送信号，也可以向其他进程发送信号。与<code>kill</code>函数不同的是，<code>raise</code>函数是向进程自身发送信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span> <span class="params">( <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signo )</span></span>; <span class="comment">/* 向进程号为pid的参数发送signo信号 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span> <span class="params">( <span class="keyword">int</span> signo )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>kill</code>的<code>pid</code>参数有四种不同的情况：</p>
<ul>
<li><code>pid &gt; 0</code>：将信号发送给进程<code>ID</code>为<code>pid</code>的进程。</li>
<li><code>pid = 0</code>：将信号发送给同组的进程。</li>
<li><code>pid &lt; 0</code>：将信号发送给其进程组<code>ID</code>等于<code>pid</code>绝对值的进程。</li>
<li><code>pid = -1</code>：将信号发送给所有进程(除了进程号最大的那个进程)。</li>
</ul>
<p>&emsp;&emsp;<code>raise</code>函数的使用如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/wait.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( pid = fork() ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fork"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123;</span><br><span class="line">        raise ( SIGSTOP );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"child process exit.\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"pid = %d\n"</span>, pid );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( ( waitpid ( pid, <span class="literal">NULL</span>, WNOHANG ) ) == <span class="number">0</span> ) &#123;</span><br><span class="line">            sleep ( <span class="number">1</span> );</span><br><span class="line">            kill ( pid, SIGKILL );</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"kill %d\n"</span>, pid );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><p>&emsp;&emsp;使用<code>alarm</code>函数可以设置一个时间值(闹钟时间)，当所设置的时间到了时，产生<code>SIGALRM</code>信号。如果不捕捉此信号，则默认动作是终止该进程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> seconds )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>seconds</code>为经过了指定的<code>seconds</code>秒后会产生信号<code>SIGALRM</code>。<br>&emsp;&emsp;每个进程只能有一个闹钟时间。如果在调用<code>alarm</code>时，以前已为该进程设置过闹钟时间，而且它还没有超时，以前登记的闹钟时间则被新值代换。如果有以前登记的尚未超过的闹钟时间，而这次<code>seconds</code>值是<code>0</code>，则表示取消以前的闹钟，其余留数仍作为函数的返回值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alarm_handler</span> <span class="params">( <span class="keyword">int</span> sign_no )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Alarm handler launched\n"</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    signal ( SIGALRM, alarm_handler );</span><br><span class="line">    alarm ( <span class="number">5</span> );</span><br><span class="line">    pause();</span><br><span class="line">    signal ( SIGALRM, SIG_DFL );</span><br><span class="line">    alarm ( <span class="number">2</span> );</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Pause"><a href="#Pause" class="headerlink" title="Pause"></a>Pause</h3><p>&emsp;&emsp;<code>pause</code>函数使调用进程挂起直至捕捉到一个信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span> <span class="params">( <span class="keyword">void</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>只有执行了一个信号处理函数后，挂起才结束。</p>
<h3 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h3><p>&emsp;&emsp;当系统捕捉到某个信号时，可以忽略该信号或是使用指定的处理函数来处理该信号，或者使用系统默认的方式。信号处理的主要方法有两种，一种是使用简单的<code>signal</code>函数，另一种是使用信号集函数组。</p>
<h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">( *<span class="keyword">sighandler_t</span> )</span> <span class="params">( <span class="keyword">int</span> )</span></span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> signal ( <span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler );</span><br></pre></td></tr></table></figure>
<p>函数执行成功则返回处理函数指针，失败则返回<code>SIG_ERR</code>。<code>handler</code>可能的值是：</p>
<ul>
<li><code>SIG_IGN</code>：忽略此信号。</li>
<li><code>SIG_DFL</code>：按系统默认方式处理。</li>
<li>信号处理函数名：使用该函数处理。</li>
</ul>
<p>&emsp;&emsp;对信号进行处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span> <span class="params">( <span class="keyword">int</span> sign_no )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( sign_no == SIGINT ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I have get SIGINT\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( sign_no == SIGQUIT ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I have get SIGQUIT\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 为信号SIGINT和SIGQUIT注册信号处理函数，</span></span><br><span class="line"><span class="comment">       如果没有信号过来，则程序一直等在那个地方 */</span></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Waiting for signal\n"</span> );</span><br><span class="line">    signal ( SIGINT,  myfunc );</span><br><span class="line">    signal ( SIGQUIT,  myfunc );</span><br><span class="line">    pause(); <span class="comment">/* 等待信号过来 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看进程号命令<code>ps -aux</code>，发送<code>SIGQUIT</code>信号<code>kill -s SIGQUIT 进程号</code>。</p>
<h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h3><p>&emsp;&emsp;<code>sigaction</code>函数的功能是用于改变进程接收到特定信号后的行为。<code>sigaction</code>检查或修改与指定信号相关联的处理动作，该函数取代了<code>signal</code>函数。因为<code>signal</code>函数在信号未决时接收信号可能出现问题，所以使用<code>sigaction</code>更安全。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span> <span class="params">( <span class="keyword">int</span> sig, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oact )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sig</code>：它是信号的值，可以为除了<code>SIGKILL</code>及<code>SIGSTOP</code>外的任何一个特定有效的信号(因为这两个信号定义了自己的处理函数，将导致信号安装错误)。</li>
<li><code>act</code>：它是指向<code>sigaction</code>一个实例的指针。在<code>sigaction</code>的实例中，指定了对特定信号的处理，可以为<code>NULL</code>，进程会以缺省方式对信号处理。</li>
<li><code>oact</code>：它指向的对象用来保存原来对相应信号的处理，可以为<code>NULL</code>。</li>
</ul>
<p>函数执行成功返回<code>0</code>，失败则返回<code>-1</code>。函数关键部分是<code>sigaction</code>结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> ( * ) ( <span class="keyword">int</span> ) sa_handle;</span><br><span class="line">    <span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line">    <span class="keyword">int</span> sa_flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其成员变量说明如下所示：<code>sa_handler</code>字段包含一个信号捕捉函数的地址；<code>sa_mask</code>字段说明了一个信号集，在调用该信号捕捉函数之前，这一信号集要加进进程的信号屏蔽字中，仅当从信号捕捉函数返回时，再将进程的信号屏蔽字复位为原先值。<code>sa_flags</code>的取值如下表，取<code>0</code>表示选用所有默认选项：</p>
<ul>
<li><code>SA_NOCLDSTOP</code>：用于表示信号<code>SIGCHLD</code>，当子进程被中断时，不产生此信号，当且仅当子进程结束时产生此信号。</li>
<li><code>SA_NOCLDWATI</code>：当信号为<code>SIGCHLD</code>时，可避免子进程僵死。</li>
<li><code>SA_NODEFER</code>：当信号处理函数正在进行时，不堵塞对于信号处理函数自身信号功能。</li>
<li><code>SA_NOMASK</code>：同<code>SA_NODEFER</code>。</li>
<li><code>SA_ONESHOT</code>：当用户注册的信号处理函数被执行过一次后，该信号的处理函数被设为系统默认的处理函数。</li>
<li><code>SA_RESETHAND</code>：同<code>SA_ONESHOT</code>。</li>
<li><code>SA_RESTART</code>：是本来不能重新于运行的系统调用自动重新运行。</li>
<li><code>SA_SIGINFO</code>：表明信号处理函数是由<code>SA_SIGACTION</code>指定的，而不是由<code>SA_HANDLER</code>指定的，它将显示更多的信号处理函数信息。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_handler</span> <span class="params">( <span class="keyword">int</span> sig )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"I got signal %d\n"</span>, sig );</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"i = %d\n"</span>, i );</span><br><span class="line">        sleep ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    act.sa_handler = show_handler;</span><br><span class="line">    sigaddset ( &amp;act.sa_mask, SIGQUIT );</span><br><span class="line">    act.sa_flags = SA_RESETHAND | SA_NODEFER;</span><br><span class="line">    sigaction ( SIGINT, &amp;act, &amp;oldact );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        sleep ( <span class="number">1</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"sleeping %d\n"</span>, i );</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="linux信号集"><a href="#linux信号集" class="headerlink" title="linux信号集"></a>linux信号集</h3><p>&emsp;&emsp;信号集被定义为一种数据类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sig[_NSIG_WORDS];</span><br><span class="line">&#125; <span class="keyword">sigset_t</span>;</span><br></pre></td></tr></table></figure>
<p>信号集用来描述信号的集合，每个信号占用一位。<code>Linux</code>所支持的所有信号可以全部或部分的出现在信号集中，主要与信号阻塞相关函数配合使用。下面是为信号集操作定义的相关函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 初始化由set指定的信号集，信号集里面的所有信号被清空，相当于64位置0 */</span></span><br><span class="line">sigemptyset ( <span class="keyword">sigset_t</span> *<span class="built_in">set</span> );</span><br><span class="line"><span class="comment">/* 调用该函数后，set指向的信号集中将包含linux支持的64种信号，相当于64位都置1 */</span></span><br><span class="line">sigfillset ( <span class="keyword">sigset_t</span> *<span class="built_in">set</span> );</span><br><span class="line"><span class="comment">/* 在set指向的信号集中加入signum信号，相当于将给定信号所对应的位置1 */</span></span><br><span class="line">sigaddset ( <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum );</span><br><span class="line"><span class="comment">/* 在set指向的信号集中删除signum信号，相当于将给定信号所对应的位置0 */</span></span><br><span class="line">sigdelset ( <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum );</span><br><span class="line"><span class="comment">/* 判定信号signum是否在set指向的信号集中，相当于检查给定信号所对应的位是0还是1 */</span></span><br><span class="line">sigismember ( <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum );</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sigset</span> <span class="params">( <span class="keyword">sigset_t</span> *<span class="built_in">set</span> )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> myset;</span><br><span class="line">    sigemptyset ( &amp;myset );</span><br><span class="line">    sigaddset ( &amp;myset, SIGINT );</span><br><span class="line">    sigaddset ( &amp;myset, SIGQUIT );</span><br><span class="line">    sigaddset ( &amp;myset, SIGUSR1 );</span><br><span class="line">    sigaddset ( &amp;myset, SIGRTMIN );</span><br><span class="line">    print_sigset ( &amp;myset );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_sigset</span> <span class="params">( <span class="keyword">sigset_t</span> *<span class="built_in">set</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; NSIG; ++i ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( sigismember ( <span class="built_in">set</span>, i ) ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"1"</span> );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"0"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">putchar</span> ( <span class="string">'\n'</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="信号生命周期"><a href="#信号生命周期" class="headerlink" title="信号生命周期"></a>信号生命周期</h3><p>&emsp;&emsp;对于一个完整的信号生命周期(从信号发送到相应的处理函数执行完毕)来说，可以分为三个重要的阶段，这三个阶段由四个重要事件来刻画：信号诞生；信号在进程中注册完毕；信号在进程中的注销完毕；信号处理函数执行完毕。相邻两个事件的时间间隔构成信号生命周期的一个阶段。</p>
<p><img src="/2019/03/13/Linux系统编程/信号/1.png"></p>
<p>&emsp;&emsp;下面阐述四个事件的实际意义：</p>
<ul>
<li>信号诞生。信号的诞生指的是触发信号的事件发生(如检测到硬件异常、定时器超时以及调用信号发送函数<code>kill</code>或<code>sigqueue</code>等)。</li>
<li>信号在目标进程中注册。进程的<code>task_struct</code>结构中有关于本进程中未决信号的数据成员：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">head</span>, * *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> signal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第三个成员是进程中所有未决信号集，第一、第二个成员分别指向一个<code>sigqueue</code>类型的结构链(称之为<code>未决信号信息链</code>)的首尾，信息链中的每个<code>sigqueue</code>结构刻画一个特定信号所携带的信息，并指向下一个<code>sigqueue</code>结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">siginfo_t</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号在进程中注册指的就是信号值加入到进程的未决信号集中(<code>sigpending</code>结构的第二个成员<code>sigset_t signal</code>)，并且信号所携带的信息被保留到未决信号信息链的某个<code>sigqueue</code>结构中。只要信号在进程的未决信号集中，表明进程已经知道这些信号的存在，但还没来得及处理，或者该信号被进程阻塞。<br>&emsp;&emsp;当一个实时信号发送给一个进程时，不管该信号是否已经在进程中注册，都会被再注册一次，因此信号不会丢失，实时信号又叫做<code>可靠信号</code>。这意味着同一个实时信号可以在同一个进程的未决信号信息链中占有多个<code>sigqueue</code>结构(进程每收到一个实时信号，都会为它分配一个结构来登记该信号信息，并把该结构添加在未决信号链尾，即所有诞生的实时信号都会在目标进程中注册)。<br>&emsp;&emsp;当一个非实时信号发送给一个进程时，如果该信号已经在进程中注册，则该信号将被丢弃，造成信号丢失。因此，非实时信号又叫做<code>不可靠信号</code>。这意味着同一个非实时信号在进程的未决信号信息链中，至多占有一个<code>sigqueue</code>结构(一个非实时信号诞生后：如果发现相同的信号已经在目标结构中注册，则不再注册，对于进程来说，相当于不知道本次信号发生，信号丢失；如果进程的未决信号中没有相同信号，则在进程中注册自己。</p>
<ul>
<li>信号在进程中的注销。在目标进程执行过程中，会检测是否有信号等待处理(每次从系统空间返回到用户空间时都做这样的检查)。如果存在未决信号等待处理且该信号没有被进程阻塞，则在运行相应的信号处理函数前，进程会把信号在未决信号链中占有的结构卸掉。是否将信号从进程未决信号集中删除对于实时与非实时信号是不同的。对于非实时信号来说，由于在未决信号信息链中最多只占用一个<code>sigqueue</code>结构，因此该结构被释放后，应该把信号在进程未决信号集中删除(信号注销完毕)；而对于实时信号来说，可能在未决信号信息链中占用多个<code>sigqueue</code>结构，因此应该针对占用<code>sigqueue</code>结构的数目区别对待：如果只占用一个<code>sigqueue</code>结构(进程只收到该信号一次)，则应该把信号在进程的未决信号集中删除(信号注销完毕)。否则，不应该在进程的未决信号集中删除该信号(信号注销完毕)。进程在执行信号相应处理函数之前，首先要把信号在进程中注销。</li>
<li>信号生命终止。进程注销信号后，立即执行相应的信号处理函数，执行完毕后，信号的本次发送对进程的影响彻底结束。</li>
</ul>
<p>&emsp;&emsp;注意如下事项：</p>
<ul>
<li>信号注册与否，与发送信号的函数(如<code>kill</code>或<code>sigqueue</code>等)以及信号安装函数(<code>signal</code>及<code>sigaction</code>)无关，只与信号值有关(信号值小于<code>SIGRTMIN</code>的信号最多只注册一次，信号值在<code>SIGRTMIN</code>及<code>SIGRTMAX</code>之间的信号，只要被进程接收到就被注册)。</li>
<li>在信号被注销到相应的信号处理函数执行完毕这段时间内，如果进程又收到同一信号多次，则对实时信号来说，每一次都会在进程中注册；而对于非实时信号来说，无论收到多少次信号，都会视为只收到一个信号，只在进程中注册一次。</li>
</ul>
<h3 id="信号编程注意事项"><a href="#信号编程注意事项" class="headerlink" title="信号编程注意事项"></a>信号编程注意事项</h3><p>&emsp;&emsp;1. 防止不该丢失的信号丢失。如果对信号生命周期理解深刻的话，很容易知道信号会不会丢失，以及在哪里丢失。<br>&emsp;&emsp;2. 程序的可移植性：考虑到程序的可移植性，应该尽量采用<code>POSIX</code>信号函数，<code>POSIX</code>信号函数主要分为两类：</p>
<ul>
<li><code>POSIX 1003.1</code>信号函数：<code>kill</code>、<code>sigaction</code>、<code>sigaddset</code>、<code>sigdelset</code>、<code>sigemptyset</code>、<code>sigfillset</code>、<code>sigismember</code>、<code>sigpending</code>、<code>sigprocmask</code>、<code>sigsuspend</code>。</li>
<li><code>POSIX 1003.1b</code>信号函数：<code>POSIX 1003.1b</code>在信号的实时性方面对<code>POSIX 1003.1</code>做了扩展，包括以下三个函数：<code>sigqueue</code>、<code>sigtimedwait</code>、<code>sigwaitinfo</code>。其中，<code>sigqueue</code>主要针对信号发送，而<code>sigtimedwait</code>及<code>sigwaitinfo</code>主要用于取代<code>sigsuspend</code>函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigwaitinfo</span> <span class="params">( <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">siginfo_t</span> *info )</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数与<code>sigsuspend</code>类似，阻塞一个进程直到特定信号发生，但信号到来时不执行信号处理函数，而是返回信号值。因此为了避免执行相应的信号处理函数，必须在调用该函数前，使进程屏蔽掉<code>set</code>指向的信号，因此调用该函数的典型代码是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sigset_t</span> newmask;</span><br><span class="line"><span class="keyword">int</span> rcvd_sig;</span><br><span class="line"><span class="keyword">siginfo_t</span> info;</span><br><span class="line">sigemptyset ( &amp;newmask );</span><br><span class="line">sigaddset ( &amp;newmask, SIGRTMIN );</span><br><span class="line">sigprocmask ( SIG_BLOCK, &amp;newmask, <span class="literal">NULL</span> );</span><br><span class="line">rcvd_sig = sigwaitinfo ( &amp;newmask, &amp;info )</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( rcvd_sig == <span class="number">-1</span> ) &#123;</span><br><span class="line">    <span class="comment">/* user code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用成功返回信号值，否则返回<code>-1</code>。<code>sigtimedwait</code>功能相似，只不过增加了一个进程等待的时间。<br>&emsp;&emsp;为了增强程序的稳定性，在信号处理函数中应使用可重入函数。信号处理程序中应当使用可再入(可重入)函数。因为进程在收到信号后，就将跳转到信号处理函数去接着执行。如果信号处理函数中使用了不可重入函数，那么信号处理函数可能会修改原来进程中不应该被修改的数据，这样进程从信号处理函数中返回接着执行时，可能会出现不可预料的后果。不可再入函数在信号处理函数中被视为不安全函数。满足下列条件的函数多数是不可再入的：</p>
<ul>
<li>使用静态的数据结构，如<code>getlogin</code>、<code>gmtime</code>、<code>getgrgid</code>、<code>getgrnam</code>、<code>getpwuid</code>以及<code>getpwnam</code>等等。</li>
<li>函数实现时，调用了<code>malloc</code>或者<code>free</code>函数。</li>
<li>实现时使用了标准<code>I/O</code>函数的。</li>
</ul>
<p>&emsp;&emsp;<code>The Open Group</code>视下列函数为可再入的：<code>_exit</code>、<code>access</code>、<code>alarm</code>、<code>cfgetispeed</code>、<code>cfgetospeed</code>、<code>cfsetispeed</code>、<code>cfsetospeed</code>、<code>chdir</code>、<code>chmod</code>、<code>chown</code>、<code>close</code>、<code>creat</code>、<code>dup</code>、<code>dup2</code>、<code>execle</code>、<code>execve</code>、<code>fcntl</code>、<code>fork</code>、<code>fpathconf</code>、<code>fstat</code>、<code>fsync</code>、<code>getegid</code>、<code>geteuid</code>、<code>getgid</code>、<code>getgroups</code>、<code>getpgrp</code>、<code>getpid</code>、<code>getppid</code>、<code>getuid</code>、<code>kill</code>、<code>link</code>、<code>lseek</code>、<code>mkdir</code>、<code>mkfifo</code>、<code>open</code>、<code>pathconf</code>、<code>pause</code>、<code>pipe</code>、<code>raise</code>、<code>read</code>、<code>rename</code>、<code>rmdir</code>、<code>setgid</code>、<code>setpgid</code>、<code>setsid</code>、<code>setuid</code>、<code>sigaction</code>、<code>sigaddset</code>、<code>sigdelset</code>、<code>sigemptyset</code>、<code>sigfillset</code>、<code>sigismember</code>、<code>signal</code>、<code>sigpending</code>、<code>sigprocmask</code>、<code>sigsuspend</code>、<code>sleep</code>、<code>stat</code>、<code>sysconf</code>、<code>tcdrain</code>、<code>tcflow</code>、<code>tcflush</code>、<code>tcgetattr</code>、<code>tcgetpgrp</code>、<code>tcsendbreak</code>、<code>tcsetattr</code>、<code>tcsetpgrp</code>、<code>time</code>、<code>times</code>、<code>umask</code>、<code>uname</code>、<code>unlink</code>、<code>utime</code>、<code>wait</code>、<code>waitpid</code>、<code>write</code>。<br>&emsp;&emsp;即使信号处理函数使用的都是<code>安全函数</code>，同样要注意进入处理函数时，首先要保存<code>errno</code>的值，结束时，再恢复原值。因为信号处理过程中，<code>errno</code>值随时可能被改变。另外，<code>longjmp</code>以及<code>siglongjmp</code>没有被列为可再入函数，因为不能保证紧接着两个函数的其它调用是安全的。</p>
<h3 id="信号应用实例"><a href="#信号应用实例" class="headerlink" title="信号应用实例"></a>信号应用实例</h3><p>&emsp;&emsp;<code>Linux</code>下的信号应用并没有想象的那么恐怖，程序员所要做的最多只有三件事情：</p>
<ul>
<li>安装信号，推荐使用<code>sigaction</code>。</li>
<li>实现信号处理函数<code>handler(int signal, struct siginfo *info, void *)</code>。</li>
<li>发送信号，推荐使用<code>sigqueue</code>。</li>
</ul>
<p>实际上，对有些信号来说，只要安装信号就足够了(信号处理方式采用缺省或忽略)。其他可能要做的无非是与信号集相关的几种操作。<br>&emsp;&emsp;1. 信号发送及处理：实现一个信号接收程序<code>sigreceive</code>，其中信号安装由<code>sigaction</code>实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> * )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sig;</span><br><span class="line">    sig = atoi ( argv[<span class="number">1</span>] );</span><br><span class="line">    sigemptyset ( &amp;act.sa_mask );</span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    act.sa_sigaction = new_op;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigaction ( sig, &amp;act, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"install sigal error\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        sleep ( <span class="number">2</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"wait for the signal\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span> <span class="params">( <span class="keyword">int</span> signum, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *myact )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"receive signal %d"</span>, signum );</span><br><span class="line">    sleep ( <span class="number">5</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命令行参数为信号值，后台运行<code>sigreceive signo &amp;</code>，可获得该进程的<code>ID</code>，假设为<code>pid</code>，然后在另一终端上运行<code>kill -s signo pid</code>验证信号的发送接收及处理。同时，可验证信号的排队问题。<br>&emsp;&emsp;2. 信号传递附加信息：主要包括两个实例：</p>
<ul>
<li>向进程本身发送信号，并传递指针参数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> * )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">union</span> sigval mysigval;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sig;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memset</span> ( data, <span class="number">0</span>, <span class="keyword">sizeof</span> ( data ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">        data[i] = <span class="string">'2'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    mysigval.sival_ptr = data;</span><br><span class="line">    sig = atoi ( argv[<span class="number">1</span>] );</span><br><span class="line">    pid = getpid();</span><br><span class="line">    sigemptyset ( &amp;act.sa_mask );</span><br><span class="line">    act.sa_sigaction = new_op; <span class="comment">/* 三参数信号处理函数 */</span></span><br><span class="line">    act.sa_flags = SA_SIGINFO; <span class="comment">/* 信息传递开关 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigaction ( sig, &amp;act, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"install sigal error\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        sleep ( <span class="number">2</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"wait for the signal\n"</span> );</span><br><span class="line">        sigqueue ( pid, sig, mysigval ); <span class="comment">/* 向本进程发送信号，并传递附加信息 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span> <span class="params">( <span class="keyword">int</span> signum, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *myact )</span> </span>&#123; <span class="comment">/* 三参数信号处理函数的实现 */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"%c\n "</span>, ( * ( ( <span class="keyword">char</span> * ) ( ( *info ).si_ptr ) + i ) ) );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"handle signal %d over;"</span>, signum );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，信号实现了附加信息的传递，信号究竟如何对这些信息进行处理则取决于具体的应用。</p>
<ul>
<li>不同进程间传递整型参数：把<code>1</code>中的信号发送和接收放在两个程序中，并且在发送过程中传递整型参数。信号接收程序如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> * )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sig;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = getpid();</span><br><span class="line">    sig = atoi ( argv[<span class="number">1</span>] );</span><br><span class="line">    sigemptyset ( &amp;act.sa_mask );</span><br><span class="line">    act.sa_sigaction = new_op;</span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigaction ( sig, &amp;act, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"install sigal error\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        sleep ( <span class="number">2</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"wait for the signal\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span> <span class="params">( <span class="keyword">int</span> signum, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *myact )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"the int value is %d\n"</span>, info-&gt;si_int );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号发送程序：命令行第二个参数为信号值，第三个参数为接收进程<code>ID</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> signum;</span><br><span class="line">    <span class="keyword">union</span> sigval mysigval;</span><br><span class="line">    signum = atoi ( argv[<span class="number">1</span>] );</span><br><span class="line">    pid = ( <span class="keyword">pid_t</span> ) atoi ( argv[<span class="number">2</span>] );</span><br><span class="line">    mysigval.sival_int = <span class="number">8</span>; <span class="comment">/* 不代表具体含义，只用于说明问题 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigqueue ( pid, signum, mysigval ) == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"send error\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    sleep ( <span class="number">2</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例<code>2</code>的两个例子侧重点在于用信号来传递信息，目前关于在<code>linux</code>下通过信号传递信息的实例非常少。<br>&emsp;&emsp;3. 信号阻塞及信号集操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_op</span> <span class="params">( <span class="keyword">int</span> )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> new_mask, old_mask, pending_mask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    sigemptyset ( &amp;act.sa_mask );</span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    act.sa_sigaction = ( <span class="keyword">void</span> * ) my_op;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigaction ( SIGRTMIN + <span class="number">10</span>, &amp;act, <span class="literal">NULL</span> ) ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"install signal SIGRTMIN+10 error\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    sigemptyset ( &amp;new_mask );</span><br><span class="line">    sigaddset ( &amp;new_mask, SIGRTMIN + <span class="number">10</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigprocmask ( SIG_BLOCK, &amp;new_mask, &amp;old_mask ) ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"block signal SIGRTMIN+10 error\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    sleep ( <span class="number">10</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"now begin to get pending mask and unblock SIGRTMIN+10\n"</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigpending ( &amp;pending_mask ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"get pending mask error\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigismember ( &amp;pending_mask, SIGRTMIN + <span class="number">10</span> ) ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"signal SIGRTMIN+10 is pending\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( sigprocmask ( SIG_SETMASK, &amp;old_mask, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"unblock signal error\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"signal unblocked\n"</span> );</span><br><span class="line">    sleep ( <span class="number">10</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_op</span> <span class="params">( <span class="keyword">int</span> signum )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"receive signal %d\n"</span>, signum );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译该程序，并以后台方式运行。在另一终端向该进程发送信号(运行<code>kill -s 42 pid</code>，<code>SIGRTMIN + 10</code>为<code>42</code>)，查看结果可以看出几个关键函数的运行机制，信号集相关操作比较简单。<br>&emsp;&emsp;在上面几个实例中，使用了<code>printf</code>函数，只是作为诊断工具，<code>pringf</code>函数是不可重入的，不应在信号处理函数中使用。</p>
<hr>
<h3 id="司机售票员问题-signal"><a href="#司机售票员问题-signal" class="headerlink" title="司机售票员问题(signal)"></a>司机售票员问题(signal)</h3><p>&emsp;&emsp;创建子进程代表售票员，父进程代表司机，同步过程如下：</p>
<ul>
<li>售票员捕捉<code>SIGINT</code>(代表开车)，发<code>SIGUSR1</code>给司机，司机打印<code>Let&#39;s gogogo!</code>。</li>
<li>售票员捕捉<code>SIGQUIT</code>(代表停车)，发<code>SIGUSR2</code>给司机，司机打印<code>Stop the bus!</code>。</li>
<li>司机捕捉<code>SIGTSTP</code>(代表车到总站)，发<code>SIGUSR1</code>给售票员，售票员打印<code>please get off the bus!</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"errno.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">driver_handler</span> <span class="params">( <span class="keyword">int</span> signo )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saler_handler</span> <span class="params">( <span class="keyword">int</span> signo )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( ( pid = fork() ) == <span class="number">-1</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fork"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        signal ( SIGTSTP, driver_handler );</span><br><span class="line">        signal ( SIGINT, SIG_IGN );</span><br><span class="line">        signal ( SIGQUIT, SIG_IGN );</span><br><span class="line">        signal ( SIGUSR1, driver_handler );</span><br><span class="line">        signal ( SIGUSR2, driver_handler );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        signal ( SIGINT, saler_handler );</span><br><span class="line">        signal ( SIGQUIT, saler_handler );</span><br><span class="line">        signal ( SIGTSTP, SIG_IGN );</span><br><span class="line">        signal ( SIGUSR1, saler_handler );</span><br><span class="line">        signal ( SIGUSR2, SIG_IGN );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">driver_handler</span> <span class="params">( <span class="keyword">int</span> signo )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( signo == SIGUSR1 ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Let's gogogo!\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( signo == SIGUSR2 ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Stop the bus!\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( signo == SIGTSTP ) &#123;</span><br><span class="line">        kill ( pid, SIGUSR1 );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saler_handler</span> <span class="params">( <span class="keyword">int</span> signo )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> ppid = getppid();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( signo == SIGINT ) &#123;</span><br><span class="line">        kill ( ppid, SIGUSR1 );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( signo == SIGQUIT ) &#123;</span><br><span class="line">        kill ( ppid, SIGUSR2 );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( signo == SIGUSR1 ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"please get off the bus!\n"</span> );</span><br><span class="line">        kill ( ppid, SIGKILL );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="双子进程signal"><a href="#双子进程signal" class="headerlink" title="双子进程signal"></a>双子进程signal</h3><p>&emsp;&emsp;编写一段程序，使用系统调用<code>fork</code>创建两个子进程，再用系统调用<code>signal</code>让父进程捕捉键盘上来的中断信号(即<code>Ctrl+C</code>)。当捕捉到中断信号后，父进程用系统调用<code>kill</code>向两个子进程发出信号。子进程捕捉到父进程发来的信号后，分别输出下列信息后终止：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child process <span class="number">1</span> is killed by parent!</span><br><span class="line">child process <span class="number">2</span> is killed by parent!</span><br></pre></td></tr></table></figure>
<p>父进程等待两个子进程终止后，输出下列信息后终止：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent process <span class="built_in">exit</span>!</span><br></pre></td></tr></table></figure>
<p>参考程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">int</span> wait_mask = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waiting</span> <span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span> <span class="params">( <span class="keyword">int</span> sign_no )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1, p2;</span><br><span class="line">    signal ( SIGINT, stop );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( ( p1 = fork() ) == <span class="number">-1</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( p1 &gt; <span class="number">0</span> ) &#123; <span class="comment">/* 在父进程中 */</span></span><br><span class="line">        <span class="keyword">while</span> ( ( p2 = fork() ) == <span class="number">-1</span> );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( p2 &gt; <span class="number">0</span> ) &#123; <span class="comment">/* 在父进程中 */</span></span><br><span class="line">            wait_mask = <span class="number">1</span>;</span><br><span class="line">            waiting();</span><br><span class="line">            kill ( p1, <span class="number">10</span> );</span><br><span class="line">            kill ( p2, <span class="number">12</span> );</span><br><span class="line">            wait ( <span class="literal">NULL</span> );</span><br><span class="line">            wait ( <span class="literal">NULL</span> );</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"parent process exit!\n"</span> );</span><br><span class="line">            <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 在子进程2中 */</span></span><br><span class="line">            wait_mask = <span class="number">1</span>;</span><br><span class="line">            signal ( <span class="number">12</span>, stop );</span><br><span class="line">            waiting();</span><br><span class="line">            lockf ( <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> );</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"child process 2 is killed by parent!\n"</span> );</span><br><span class="line">            lockf ( <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">            <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 在子进程1中 */</span></span><br><span class="line">        wait_mask = <span class="number">1</span>;</span><br><span class="line">        signal ( <span class="number">10</span>, stop );</span><br><span class="line">        waiting();</span><br><span class="line">        lockf ( <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"child process 1 is killed by parent!\n"</span> );</span><br><span class="line">        lockf ( <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waiting</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( wait_mask != <span class="number">0</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span> <span class="params">( <span class="keyword">int</span> sign_no )</span> </span>&#123;</span><br><span class="line">    wait_mask = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="双进程信号通信示例"><a href="#双进程信号通信示例" class="headerlink" title="双进程信号通信示例"></a>双进程信号通信示例</h3><p>&emsp;&emsp;<code>Aprocess.c</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 程序执行用“./Aprocess B进程pid” */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = atoi ( argv[<span class="number">1</span>] );</span><br><span class="line">    kill ( pid, SIGINT );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Bprocess.c</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/*程序执行后用“kill -n SIGINT 进程pid”来发送信号*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span> <span class="params">( <span class="keyword">int</span> s )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Prosess B receieve SIGINT\n"</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    signal ( SIGINT, myfunc );</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Linux信号种类"><a href="#Linux信号种类" class="headerlink" title="Linux信号种类"></a>Linux信号种类</h3><p>&emsp;&emsp;可以从两个不同的分类角度对信号进行分类：可靠性方面：可靠信号与不可靠信号；与时间的关系上：实时信号与非实时信号。</p>
<h4 id="不可靠信号"><a href="#不可靠信号" class="headerlink" title="不可靠信号"></a>不可靠信号</h4><p>&emsp;&emsp;<code>Linux</code>信号机制基本上是从<code>Unix</code>系统中继承过来的。早期<code>Unix</code>系统中的信号机制比较简单和原始，后来在实践中暴露出一些问题，因此把那些建立在早期机制上的信号叫做<code>不可靠信号</code>，信号值小于<code>SIGRTMIN</code>(<code>Red hat 7.2</code>中，<code>SIGRTMIN</code>为<code>32</code>，<code>SIGRTMAX</code>为<code>63</code>)的信号都是不可靠信号。这就是“不可靠信号”的来源，它的主要问题是：</p>
<ul>
<li>进程每次处理信号后，就将对信号的响应设置为默认动作。在某些情况下，将导致对信号的错误处理；因此，用户如果不希望这样的操作，那么就要在信号处理函数结尾再一次调用<code>signal</code>，重新安装该信号。</li>
<li>信号可能丢失，后面将对此详细阐述。如果在进程对某个信号进行处理时，这个信号发生多次，对后到来的这类信号不排队，那么仅传送该信号一次，即发生了信号丢失。</li>
</ul>
<p>&emsp;&emsp;因此，早期<code>unix</code>下的不可靠信号主要指的是进程可能对信号做出错误的反应以及信号可能丢失。<code>Linux</code>支持不可靠信号，但是对不可靠信号机制做了改进：在调用完信号处理函数后，不必重新调用该信号的安装函数(信号安装函数是在可靠机制上的实现)。因此，<code>Linux</code>下的不可靠信号问题主要指的是信号可能丢失。</p>
<h4 id="可靠信号"><a href="#可靠信号" class="headerlink" title="可靠信号"></a>可靠信号</h4><p>&emsp;&emsp;随着时间的发展，实践证明了有必要对信号的原始机制加以改进和扩充。所以，后来出现的各种<code>Unix</code>版本分别在这方面进行了研究，力图实现<code>可靠信号</code>。由于原来定义的信号已有许多应用，不好再做改动，最终只好又新增加了一些信号，并在一开始就把它们定义为可靠信号，这些信号支持排队，不会丢失。同时，信号的发送和安装也出现了新版本：信号发送函数<code>sigqueue</code>及信号安装函数<code>sigaction</code>。<code>POSIX.4</code>对可靠信号机制做了标准化。但是，<code>POSIX</code>只对可靠信号机制应具有的功能以及信号机制的对外接口做了标准化，对信号机制的实现没有作具体的规定。<br>&emsp;&emsp;信号值位于<code>SIGRTMIN</code>和<code>SIGRTMAX</code>之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。<code>Linux</code>在支持新版本的信号安装函数<code>sigation</code>以及信号发送函数<code>sigqueue</code>的同时，仍然支持早期的<code>signal</code>信号安装函数，支持信号发送函数<code>kill</code>。<br>&emsp;&emsp;不要有这样的误解：由<code>sigqueue</code>发送、<code>sigaction</code>安装的信号就是可靠的。事实上，可靠信号是指后来添加的新信号(信号值位于<code>SIGRTMIN</code>及<code>SIGRTMAX</code>之间)；不可靠信号是信号值小于<code>SIGRTMIN</code>的信号。信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。目前<code>linux</code>中的<code>signal</code>是通过<code>sigation</code>函数实现的，因此，即使通过<code>signal</code>安装的信号，在信号处理函数的结尾也不必再调用一次信号安装函数。同时，由<code>signal</code>安装的实时信号支持排队，同样不会丢失。<br>&emsp;&emsp;对于目前<code>linux</code>的两个信号安装函数<code>signal</code>及<code>sigaction</code>来说，它们都不能把<code>SIGRTMIN</code>以前的信号变成可靠信号(都不支持排队，仍有可能丢失，仍然是不可靠信号)，而且对<code>SIGRTMIN</code>以后的信号都支持排队。这两个函数的最大区别在于，经过<code>sigaction</code>安装的信号都能传递信息给信号处理函数(对所有信号这一点都成立)，而经过<code>signal</code>安装的信号却不能向信号处理函数传递信息。对于信号发送函数来说也是一样的。</p>
<h4 id="实时信号与非实时信号"><a href="#实时信号与非实时信号" class="headerlink" title="实时信号与非实时信号"></a>实时信号与非实时信号</h4><p>&emsp;&emsp;早期<code>Unix</code>系统只定义了<code>32</code>种信号，<code>Red hat 7.2</code>支持<code>64</code>种信号，编号为<code>0</code>至<code>63</code>(<code>SIGRTMIN</code>为<code>31</code>，<code>SIGRTMAX</code>为<code>63</code>)，将来可能进一步增加，这需要得到内核的支持。前<code>32</code>种信号已经有了预定义值，每个信号有了确定的用途及含义，并且每种信号都有各自的缺省动作。如按键盘的<code>CTRL + C</code>时，会产生<code>SIGINT</code>信号，对该信号的默认反应就是进程终止。后<code>32</code>个信号表示实时信号，等同于前面阐述的可靠信号。这保证了发送的多个实时信号都被接收。<br>&emsp;&emsp;实时信号是<code>POSIX</code>标准的一部分，可用于应用进程。非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。</p>
<hr>
<h3 id="signal-SIGHUP-SIG-IGN-的含义"><a href="#signal-SIGHUP-SIG-IGN-的含义" class="headerlink" title="signal(SIGHUP, SIG_IGN)的含义"></a>signal(SIGHUP, SIG_IGN)的含义</h3><p>&emsp;&emsp;<code>signal</code>信号函数第一个参数表示需要处理的信号值(<code>SIGHUP</code>)，第二个参数为处理函数或者是一个表示。这里，<code>SIG_IGN</code>表示忽略<code>SIGHUP</code>那个注册的信号。<br>&emsp;&emsp;<code>SIGHUP</code>和控制台操作有关。当控制台被关闭时，系统会向拥有控制台<code>sessionID</code>的所有进程发送<code>HUP</code>信号，默认<code>HUP</code>信号的<code>action</code>是<code>exit</code>。如果远程登陆启动某个服务进程并在程序运行时关闭连接的话，会导致服务进程退出，所以一般服务进程都会用<code>nohup</code>工具启动或写成一个<code>daemon</code>。</p>
<hr>
<h3 id="SIGKILL和SIGSTOP的区别"><a href="#SIGKILL和SIGSTOP的区别" class="headerlink" title="SIGKILL和SIGSTOP的区别"></a>SIGKILL和SIGSTOP的区别</h3><p>&emsp;&emsp;<code>SIGKILL</code>提供给管理员杀死进程的权利，<code>SIGSTOP</code>提供给管理员暂停进程的权利，所以这两个信号不能被忽略和重定义。<code>Kill</code>父进程后，子进程的父进程号为<code>1</code>；但是<code>stop</code>父进程后，子进程的父进程号还是该父进程。</p>
<h3 id="SIGSTOP和SIGTSTP的区别"><a href="#SIGSTOP和SIGTSTP的区别" class="headerlink" title="SIGSTOP和SIGTSTP的区别"></a>SIGSTOP和SIGTSTP的区别</h3><p>&emsp;&emsp;<code>SIGSTOP</code>提供给管理员暂停进程的特权，所以不能忽略和重定义。当用户按下<code>CTRL+Z</code>时，向前台进程组发送<code>SIGTSTP</code>信号以暂停进程(默认动作)，该信号可以被忽略和重定义。另外用户在控制终端上输入<code>CTRL+S</code>可以暂停进程的输出，输入<code>CTRL+Q</code>可以恢复进程的输出。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/13/Linux系统编程/共享内存总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/Linux系统编程/共享内存总结/" itemprop="url">共享内存总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T13:02:59+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;共享内存可以说是最有用的进程间通信方式，也是最快的<code>IPC</code>形式。两个不同进程<code>A</code>、<code>B</code>共享内存的意思是，同一块物理内存被映射到进程<code>A</code>、<code>B</code>各自的进程地址空间。进程<code>A</code>可以即时看到进程<code>B</code>对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。<br>&emsp;&emsp;采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。<br>&emsp;&emsp;<code>Linux</code>的<code>2.2.x</code>内核支持多种共享内存方式，如<code>mmap</code>系统调用、<code>Posix</code>共享内存以及系统<code>V</code>共享内存。<code>linux</code>发行版本如<code>Redhat 8.0</code>支持<code>mmap</code>系统调用及系统<code>V</code>共享内存，但还没实现<code>Posix</code>共享内存，本文将主要介绍<code>mmap</code>系统调用及系统V共享内存<code>API</code>的原理及应用。</p>
<h3 id="内核怎样保证各个进程寻址到同一个共享内存区域的内存页面"><a href="#内核怎样保证各个进程寻址到同一个共享内存区域的内存页面" class="headerlink" title="内核怎样保证各个进程寻址到同一个共享内存区域的内存页面"></a>内核怎样保证各个进程寻址到同一个共享内存区域的内存页面</h3><p>&emsp;&emsp;1. <code>page cache</code>及<code>swap cache</code>中页面的区分：一个被访问文件的物理页面都驻留在<code>page cache</code>或<code>swap cache</code>中，一个页面的所有信息由<code>struct page</code>来描述。<code>struct page</code>中有一个域为指针<code>mapping</code>，它指向一个<code>struct address_space</code>类型结构。<code>page cache</code>或<code>swap cache</code>中的所有页面就是根据<code>address_space</code>结构以及一个偏移量来区分的。<br>&emsp;&emsp;2. 文件与<code>address_space</code>结构的对应：一个具体的文件在打开后，内核会在内存中为之建立一个<code>struct inode</code>结构，其中的<code>i_mapping</code>域指向一个<code>address_space</code>结构。这样，一个文件就对应一个<code>address_space</code>结构，一个<code>address_space</code>与一个偏移量能够确定一个<code>page cache</code>或<code>swap cache</code>中的一个页面。因此，当要寻址某个数据时，很容易根据给定的文件及数据在文件内的偏移量而找到相应的页面。<br>&emsp;&emsp;3. 进程调用<code>mmap</code>时，只是在进程空间内新增了一块相应大小的缓冲区，并设置了相应的访问标识，但并没有建立进程空间到物理页面的映射。因此，第一次访问该空间时，会引发一个缺页异常。<br>&emsp;&emsp;4. 对于共享内存映射情况，缺页异常处理程序首先在<code>swap cache</code>中寻找目标页(符合<code>address_space</code>以及偏移量的物理页)，如果找到，则直接返回地址；如果没有找到，则判断该页是否在交换区(<code>swap area</code>)，如果在，则执行一个换入操作；如果上述两种情况都不满足，处理程序将分配新的物理页面，并把它插入到<code>page cache</code>中。进程最终将更新进程页表。<br>&emsp;&emsp;对于映射普通文件情况(非共享映射)，缺页异常处理程序首先会在<code>page cache</code>中根据<code>address_space</code>以及数据偏移量寻找相应的页面。如果没有找到，则说明文件数据还没有读入内存，处理程序会从磁盘读入相应的页面，并返回相应地址，同时进程页表也会更新。<br>&emsp;&emsp;5. 所有进程在映射同一个共享内存区域时，情况都一样，在建立线性地址与物理地址之间的映射之后，不论进程各自的返回地址如何，实际访问的必然是同一个共享内存区域对应的物理页面。<br>&emsp;&emsp;注意，一个共享内存区域可以看作是特殊文件系统shm中的一个文件，<code>shm</code>的安装点在交换区上。</p>
<h3 id="mmap及其相关系统调用"><a href="#mmap及其相关系统调用" class="headerlink" title="mmap及其相关系统调用"></a>mmap及其相关系统调用</h3><p>&emsp;&emsp;<code>mmap</code>系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必再调用<code>read</code>、<code>write</code>等操作。<br>&emsp;&emsp;实际上，<code>mmap</code>系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而<code>Posix</code>或系统<code>V</code>的共享内存<code>IPC</code>则纯粹用于共享目的，当然<code>mmap</code>实现共享内存也是其主要应用之一。<br>&emsp;&emsp;1. <code>mmap</code>系统调用形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span> <span class="params">( <span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>fd</code>为即将映射到进程空间的文件描述字，一般由<code>open</code>返回，同时<code>fd</code>可以指定为<code>-1</code>，此时须指定<code>flags</code>参数中的<code>MAP_ANON</code>，表明进行的是匿名映射(不涉及具体的文件名，避免了文件的创建及打开，很显然只能用于具有亲缘关系的进程间通信)。</p>
<ul>
<li><code>len</code>：映射到调用进程地址空间的字节数，它从被映射文件开头<code>offset</code>个字节开始算起。</li>
<li><code>prot</code>：指定共享内存的访问权限。可取如下几个值，可以以进行<code>或</code>计算：<code>PROT_READ</code>(可读)、<code>PROT_WRITE</code>(可写)、<code>PROT_EXEC</code>(可执行)、<code>PROT_NONE</code>(不可访问)。</li>
<li><code>flags</code>：由以下几个常值指定：<code>MAP_SHARED</code>、<code>MAP_PRIVATE</code>、<code>MAP_FIXED</code>，其中<code>MAP_SHARED</code>、<code>MAP_PRIVATE</code>必选其一，而<code>MAP_FIXED</code>则不推荐使用。</li>
<li><code>offset</code>：一般设为<code>0</code>，表示从文件头开始映射。</li>
<li><code>addr</code>：指定文件应被映射到进程空间的起始地址，一般被指定一个空指针，此时选择起始地址的任务留给内核来完成。</li>
</ul>
<p>函数的返回值为最后文件映射到进程空间的地址，进程可直接操作起始地址为该值的有效地址。<br>&emsp;&emsp;2. 系统调用<code>mmap</code>用于共享内存的两种方式：</p>
<ul>
<li>使用普通文件提供的内存映射：适用于任何进程之间；此时，需要打开或创建一个文件，然后再调用<code>mmap</code>。典型调用代码如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open ( name, flag, mode );</span><br><span class="line">ptr = mmap ( <span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li>使用特殊文件提供匿名内存映射：适用于具有亲缘关系的进程之间；由于父子进程特殊的亲缘关系，在父进程中先调用<code>mmap</code>，然后调用<code>fork</code>。那么在调用<code>fork</code>之后，子进程继承父进程匿名映射后的地址空间，同样也继承<code>mmap</code>返回的地址，这样父子进程就可以通过映射区域进行通信了。注意，这里不是一般的继承关系。一般来说，子进程单独维护从父进程继承下来的一些变量，而<code>mmap</code>返回的地址，却由父子进程共同维护。对于具有亲缘关系的进程实现共享内存，最好的方式应该是采用匿名内存映射的方式。此时，不必指定具体的文件，只要设置相应的标志即可。</li>
</ul>
<p>&emsp;&emsp;3. 系统调用<code>munmap</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span> <span class="params">( <span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len )</span></span>;</span><br></pre></td></tr></table></figure>
<p>该调用在进程地址空间中解除一个映射关系，<code>addr</code>是调用<code>mmap</code>时返回的地址，<code>len</code>是映射区的大小。当映射关系解除后，对原来映射地址的访问将导致段错误发生。<br>&emsp;&emsp;4. 系统调用<code>msync</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span> <span class="params">( <span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags )</span></span>;</span><br></pre></td></tr></table></figure>
<p>一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用<code>munmap</code>后才执行该操作。可以通过调用<code>msync</code>实现磁盘上文件内容与共享内存区的内容一致。</p>
<h3 id="mmap范例"><a href="#mmap范例" class="headerlink" title="mmap范例"></a>mmap范例</h3><p>&emsp;&emsp;范例<code>1</code>为两个进程通过映射普通文件实现共享内存通信。范例<code>1</code>包含两个子程序：<code>map_normalfile1.c</code>和<code>map_normalfile2.c</code>。编译两个程序，可执行文件分别为<code>map_normalfile1</code>和<code>map_normalfile2</code>。两个程序通过命令行参数指定同一个文件来实现共享内存方式的进程间通信。<code>map_normalfile2</code>试图打开命令行参数指定的一个普通文件，把该文件映射到进程的地址空间，并对映射后的地址空间进行写操作。<code>map_normalfile1</code>把命令行参数指定的文件映射到进程地址空间，然后对映射后的地址空间执行读操作。这样，两个进程通过命令行参数指定同一个文件来实现共享内存方式的进程间通信。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* map_normalfile1.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; people;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, i;</span><br><span class="line">    people *p_map;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    fd = open ( argv[<span class="number">1</span>], O_CREAT | O_RDWR | O_TRUNC, <span class="number">00777</span> );</span><br><span class="line">    lseek ( fd, <span class="keyword">sizeof</span> ( people ) * <span class="number">5</span> - <span class="number">1</span>, SEEK_SET );</span><br><span class="line">    write ( fd, <span class="string">" "</span>, <span class="number">1</span> );</span><br><span class="line">    p_map = ( people * ) mmap ( <span class="literal">NULL</span>, <span class="keyword">sizeof</span> ( people ) * <span class="number">10</span>, \</span><br><span class="line">                                PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span> );</span><br><span class="line">    close ( fd );</span><br><span class="line">    temp = <span class="string">'a'</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span> ( ( * ( p_map + i ) ).name, <span class="string">"%c"</span>, temp );</span><br><span class="line">        ( * ( p_map + i ) ).age = <span class="number">20</span> + i;</span><br><span class="line">        temp += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"initialize over\n"</span> );</span><br><span class="line">    sleep ( <span class="number">10</span> );</span><br><span class="line">    munmap ( p_map, <span class="keyword">sizeof</span> ( people ) * <span class="number">10</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"umap ok\n"</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* map_normalfile2.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; people;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, i;</span><br><span class="line">    people *p_map;</span><br><span class="line">    fd = open ( argv[<span class="number">1</span>], O_CREAT | O_RDWR, <span class="number">00777</span> );</span><br><span class="line">    p_map = ( people * ) mmap ( <span class="literal">NULL</span>, <span class="keyword">sizeof</span> ( people ) * <span class="number">10</span>, \</span><br><span class="line">                                PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"name: %s age %d;\n"</span>, ( * ( p_map + i ) ).name, ( * ( p_map + i ) ).age );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    munmap ( p_map, <span class="keyword">sizeof</span> ( people ) * <span class="number">10</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>map_normalfile1.c</code>首先定义了一个<code>people</code>数据结构，在这里采用数据结构的方式是因为，共享内存区的数据往往是有固定格式的，这由通信的各个进程决定，采用结构的方式有普遍代表性。<code>map_normfile1</code>首先打开或创建一个文件，并把文件的长度设置为<code>5</code>个<code>people</code>结构大小。然后从<code>mmap</code>的返回地址开始，设置了<code>10</code>个<code>people</code>结构。然后，进程睡眠<code>10</code>秒钟，等待其他进程映射同一个文件，最后解除映射。<code>map_normfile2.c</code>只是简单的映射一个文件，并以<code>people</code>数据结构的格式从<code>mmap</code>返回的地址处读取<code>10</code>个<code>people</code>结构，并输出读取的值，然后解除映射。<br>&emsp;&emsp;分别把两个程序编译成可执行文件<code>map_normalfile1</code>和<code>map_normalfile2</code>后，在一个终端上先运行<code>./map_normalfile1 /tmp/test_shm</code>，执行结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">initialize over</span><br><span class="line">umap ok</span><br></pre></td></tr></table></figure>
<p>在<code>map_normalfile1</code>输出<code>initialize over</code>之后，输出<code>umap ok</code>之前，在另一个终端上运行<code>./map_normalfile2 /tmp/test_shm</code>，将会产生如下输出(为了节省空间，输出结果为稍作整理后的结果)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">name: a age <span class="number">20</span>;</span><br><span class="line">name: b age <span class="number">21</span>;</span><br><span class="line">name: c age <span class="number">22</span>;</span><br><span class="line">name: d age <span class="number">23</span>;</span><br><span class="line">name: e age <span class="number">24</span>;</span><br><span class="line">name: f age <span class="number">25</span>;</span><br><span class="line">name: g age <span class="number">26</span>;</span><br><span class="line">name: h age <span class="number">27</span>;</span><br><span class="line">name: i age <span class="number">28</span>;</span><br><span class="line">name: j age <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<p>在<code>map_normalfile1</code>输出<code>umap ok</code>后，运行<code>map_normalfile2</code>则输出如下结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">name: a age <span class="number">20</span>;</span><br><span class="line">name: b age <span class="number">21</span>;</span><br><span class="line">name: c age <span class="number">22</span>;</span><br><span class="line">name: d age <span class="number">23</span>;</span><br><span class="line">name: e age <span class="number">24</span>;</span><br><span class="line">name:  age <span class="number">0</span>;</span><br><span class="line">name:  age <span class="number">0</span>;</span><br><span class="line">name:  age <span class="number">0</span>;</span><br><span class="line">name:  age <span class="number">0</span>;</span><br><span class="line">name:  age <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>从程序的运行结果中可以得出的结论：<br>&emsp;&emsp;1. 最终被映射文件的内容的长度不会超过文件本身的初始大小，即映射不能改变文件的大小。<br>&emsp;&emsp;2. 可以用于进程通信的有效地址空间大小大体上受限于被映射文件的大小，但不完全受限于文件大小。打开文件被截短为<code>5</code>个<code>people</code>结构大小，而在<code>map_normalfile1</code>中初始化了<code>10</code>个<code>people</code>数据结构，在恰当时候(<code>map_normalfile1</code>输出<code>initialize over</code>之后，输出<code>umap ok</code>之前)调用<code>map_normalfile2</code>会发现<code>map_normalfile2</code>将输出全部<code>10</code>个<code>people</code>结构的值。<br>&emsp;&emsp;在<code>linux</code>中，内存的保护是以页为基本单位的，即使被映射文件只有一个字节大小，内核也会为映射分配一个页面大小的内存。当被映射文件小于一个页面大小时，进程可以对从<code>mmap</code>返回地址开始的一个页面大小进行访问，而不会出错；但是，如果对一个页面以外的地址空间进行访问，则导致错误发生，后面将进一步描述。因此，可用于进程间通信的有效地址空间大小不会超过文件大小及一个页面大小的和。<br>&emsp;&emsp;3. 文件一旦被映射后，调用<code>mmap</code>的进程对返回地址的访问是对某一内存区域的访问，暂时脱离了磁盘上文件的影响。所有对<code>mmap</code>返回地址空间的操作只在内存中有意义，只有在调用了<code>munmap</code>后或者<code>msync</code>时，才把内存中的相应内容写回磁盘文件，所写内容仍然不能超过文件的大小。<br>&emsp;&emsp;范例<code>2</code>为父子进程通过匿名映射实现共享内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; people;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    people *p_map;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    p_map = ( people * ) mmap ( <span class="literal">NULL</span>, <span class="keyword">sizeof</span> ( people ) * <span class="number">10</span>, \</span><br><span class="line">                                PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( fork() == <span class="number">0</span> ) &#123;</span><br><span class="line">        sleep ( <span class="number">2</span> );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"child read: the %d people's age is %d\n"</span>, i + <span class="number">1</span>, ( * ( p_map + i ) ).age );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        ( *p_map ).age = <span class="number">100</span>;</span><br><span class="line">        munmap ( p_map, <span class="keyword">sizeof</span> ( people ) * <span class="number">10</span> ); <span class="comment">/* 实际上，进程终止时，会自动解除映射 */</span></span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    temp = <span class="string">'a'</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">        temp += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memcpy</span> ( ( * ( p_map + i ) ).name, &amp;temp, <span class="number">2</span> );</span><br><span class="line">        ( * ( p_map + i ) ).age = <span class="number">20</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    sleep ( <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"parent read: the first people's age is %d\n"</span>, ( *p_map ).age );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"umap\n"</span> );</span><br><span class="line">    munmap ( p_map, <span class="keyword">sizeof</span> ( people ) * <span class="number">10</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"umap ok\n"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看程序的输出结果，体会父子进程匿名共享内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">child read: the <span class="number">1</span> people's age is <span class="number">20</span></span><br><span class="line">child read: the <span class="number">2</span> people's age is <span class="number">21</span></span><br><span class="line">child read: the <span class="number">3</span> people's age is <span class="number">22</span></span><br><span class="line">child read: the <span class="number">4</span> people's age is <span class="number">23</span></span><br><span class="line">child read: the <span class="number">5</span> people's age is <span class="number">24</span></span><br><span class="line">parent read: the first people's age is <span class="number">100</span></span><br><span class="line">umap</span><br><span class="line">umap ok</span><br></pre></td></tr></table></figure>
<h3 id="对mmap返回地址的访问"><a href="#对mmap返回地址的访问" class="headerlink" title="对mmap返回地址的访问"></a>对mmap返回地址的访问</h3><p>&emsp;&emsp;前面对范例运行结构的讨论中已经提到，<code>linux</code>采用的是页式管理机制。对于用<code>mmap</code>映射普通文件来说，进程会在自己的地址空间新增一块空间，空间大小由<code>mmap</code>的<code>len</code>参数指定。注意，进程并不一定能够对全部新增空间都能进行有效访问。进程能够访问的有效地址大小取决于文件被映射部分的大小。简单的说，能够容纳文件被映射部分大小的最少页面个数决定了进程从<code>mmap</code>返回的地址开始，能够有效访问的地址空间大小。超过这个空间大小，内核会根据超过的严重程度返回发送不同的信号给进程。可用如下图示说明：</p>
<p><img src="/2019/03/13/Linux系统编程/共享内存总结/1.png"></p>
<p>&emsp;&emsp;注意，文件被映射部分而不是整个文件决定了进程能够访问的空间大小。另外，如果指定文件的偏移部分，一定要注意为页面大小的整数倍。下面是对进程映射地址空间的访问范例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; people;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, i;</span><br><span class="line">    <span class="keyword">int</span> pagesize, offset;</span><br><span class="line">    people *p_map;</span><br><span class="line">    pagesize = sysconf ( _SC_PAGESIZE );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"pagesize is %d\n"</span>, pagesize );</span><br><span class="line">    fd = open ( argv[<span class="number">1</span>], O_CREAT | O_RDWR | O_TRUNC, <span class="number">00777</span> );</span><br><span class="line">    lseek ( fd, pagesize * <span class="number">2</span> - <span class="number">100</span>, SEEK_SET );</span><br><span class="line">    write ( fd, <span class="string">" "</span>, <span class="number">1</span> );</span><br><span class="line">    offset = <span class="number">0</span>; <span class="comment">/* 此处“offset = 0”编译成版本1；“offset = pagesize”编译成版本2 */</span></span><br><span class="line">    p_map = ( people * ) mmap ( <span class="literal">NULL</span>, pagesize * <span class="number">3</span>, \</span><br><span class="line">                                PROT_READ | PROT_WRITE, MAP_SHARED, fd, offset );</span><br><span class="line">    close ( fd );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">        ( * ( p_map + pagesize / <span class="keyword">sizeof</span> ( people ) *i - <span class="number">2</span> ) ).age = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"access page %d over\n"</span>, i );</span><br><span class="line">        ( * ( p_map + pagesize / <span class="keyword">sizeof</span> ( people ) *i - <span class="number">1</span> ) ).age = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"access page %d edge over, now begin to access page %d\n"</span>, i, i + <span class="number">1</span> );</span><br><span class="line">        ( * ( p_map + pagesize / <span class="keyword">sizeof</span> ( people ) *i ) ).age = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"access page %d over\n"</span>, i + <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    munmap ( p_map, <span class="keyword">sizeof</span> ( people ) * <span class="number">10</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如程序中所注释的那样，把程序编译成两个版本，两个版本主要体现在文件被映射部分的大小不同。文件的大小介于一个页面与两个页面之间(大小为<code>pagesize * 2 - 99</code>)，版本<code>1</code>的被映射部分是整个文件，版本<code>2</code>的文件被映射部分是文件大小减去一个页面后的剩余部分，不到一个页面大小(大小为<code>pagesize - 99</code>)。程序中试图访问每一个页面边界，两个版本都试图在进程空间中映射<code>pagesize * 3</code>的字节数。<br>&emsp;&emsp;版本<code>1</code>的输出结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pagesize is <span class="number">4096</span></span><br><span class="line">access page <span class="number">1</span> over</span><br><span class="line">access page <span class="number">1</span> edge over, now begin to access page <span class="number">2</span></span><br><span class="line">access page <span class="number">2</span> over</span><br><span class="line">access page <span class="number">2</span> over</span><br><span class="line">access page <span class="number">2</span> edge over, now begin to access page <span class="number">3</span></span><br><span class="line">Bus error <span class="comment">/* 被映射文件在进程空间中覆盖了两个页面，此时进程试图访问第三个页面 */</span></span><br></pre></td></tr></table></figure>
<p>版本<code>2</code>的输出结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pagesize is <span class="number">4096</span></span><br><span class="line">access page <span class="number">1</span> over</span><br><span class="line">access page <span class="number">1</span> edge over, now begin to access page <span class="number">2</span></span><br><span class="line">Bus error <span class="comment">/* 被映射文件在进程空间中覆盖了一个页面，此时进程试图访问第二个页面 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;采用系统调用<code>mmap</code>实现进程间通信是很方便的，在应用层上接口非常简洁。内部实现机制区涉及到了<code>linux</code>存储管理以及文件系统等方面的内容，可以参考一下相关重要数据结构来加深理解。</p>
<hr>
<p>&emsp;&emsp;本部分将讨论系统<code>V</code>共享内存，并通过实验结果对比来阐述两者的异同。系统<code>V</code>共享内存指的是把所有共享数据放在共享内存区域(<code>IPC shared memory region</code>)，任何想要访问该数据的进程都必须在本进程的地址空间新增一块内存区域，用来映射存放共享数据的物理内存页面。<br>&emsp;&emsp;系统调用<code>mmap</code>通过映射一个普通文件实现共享内存，系统<code>V</code>则是通过映射特殊文件系统<code>shm</code>中的文件实现进程间的共享内存通信。也就是说，每个共享内存区域对应特殊文件系统<code>shm</code>中的一个文件(这是通过<code>shmid_kernel</code>结构联系起来的)。</p>
<h3 id="系统V共享内存原理"><a href="#系统V共享内存原理" class="headerlink" title="系统V共享内存原理"></a>系统V共享内存原理</h3><p>&emsp;&emsp;进程间需要共享的数据被放在一个叫做<code>IPC</code>共享内存区域的地方，所有需要访问该共享区域的进程都要把该共享区域映射到本进程的地址空间中去。系统<code>V</code>共享内存通过<code>shmget</code>获得或创建一个<code>IPC</code>共享内存区域，并返回相应的标识符。内核在保证<code>shmget</code>获得或创建一个共享内存区，初始化该共享内存区相应的<code>shmid_kernel</code>结构体时，还将在特殊文件系统<code>shm</code>中创建并打开一个同名文件，并在内存中建立起该文件的相应<code>dentry</code>及<code>inode</code>结构，新打开的文件不属于任何一个进程(任何进程都可以访问该共享内存区)。所有这一切都是系统调用<code>shmget</code>完成的。<br>&emsp;&emsp;每一个共享内存区都有一个控制结构<code>struct shmid_kernel</code>，<code>shmid_kernel</code>是共享内存区域中非常重要的一个数据结构，它是存储管理和文件系统结合起来的桥梁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> &#123;</span> <span class="comment">/* private to the kernel */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">shm_perm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">shm_file</span>;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> shm_nattch;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> shm_segsz;</span><br><span class="line">    <span class="keyword">time_t</span> shm_atim;</span><br><span class="line">    <span class="keyword">time_t</span> shm_dtim;</span><br><span class="line">    <span class="keyword">time_t</span> shm_ctim;</span><br><span class="line">    <span class="keyword">pid_t</span> shm_cprid;</span><br><span class="line">    <span class="keyword">pid_t</span> shm_lprid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构中最重要的一个域应该是<code>shm_file</code>，它存储了将被映射文件的地址。每个共享内存区对象都对应特殊文件系统<code>shm</code>中的一个文件，一般情况下，特殊文件系统<code>shm</code>中的文件是不能用<code>read</code>、<code>write</code>等方法访问的，当采取共享内存的方式把其中的文件映射到进程地址空间后，可直接采用访问内存的方式对其访问。<br>&emsp;&emsp;正如消息队列和信号灯一样，内核通过数据结构<code>struct ipc_ids shm_ids</code>维护系统中的所有共享内存区域。<code>shm_ids.entries</code>变量指向一个<code>ipc_id</code>结构数组，而每个<code>ipc_id</code>结构数组中有个指向<code>kern_ipc_perm</code>结构的指针。到这里读者应该很熟悉了，对于系统<code>V</code>共享内存区来说，<code>kern_ipc_perm</code>的宿主是<code>shmid_kernel</code>结构，<code>shmid_kernel</code>是用来描述一个共享内存区域的，这样内核就能够控制系统中所有的共享区域。同时，在<code>shmid_kernel</code>结构的<code>file</code>类型指针<code>shm_file</code>指向文件系统<code>shm</code>中相应的文件，这样共享内存区域就与<code>shm</code>文件系统中的文件对应起来。<br>&emsp;&emsp;在创建了一个共享内存区域后，还要将它映射到进程地址空间，系统调用<code>shmat</code>完成此项功能。由于在调用<code>shmget</code>时，已经创建了文件系统<code>shm</code>中的一个同名文件与共享内存区域相对应，因此调用<code>shmat</code>的过程相当于映射文件系统<code>shm</code>中的同名文件过程，原理与<code>mmap</code>大同小异。</p>
<h3 id="系统V共享内存API"><a href="#系统V共享内存API" class="headerlink" title="系统V共享内存API"></a>系统V共享内存API</h3><p>&emsp;&emsp;对于系统<code>V</code>共享内存，主要有以下几个<code>API</code>：<code>shmget</code>、<code>shmat</code>、<code>shmdt</code>及<code>shmctl</code>。<br>&emsp;&emsp;<code>shmget</code>用来获得共享内存区域的<code>ID</code>，如果不存在指定的共享区域，就创建相应的区域。<code>shmat</code>把共享内存区域映射到调用进程的地址空间中去，这样进程就可以方便地对共享区域进行访问操作。<code>shmdt</code>调用用来解除进程对共享内存区域的映射。<code>shmctl</code>实现对共享内存区域的控制操作。<br>&emsp;&emsp;<code>shmget</code>的内部实现包含了许多重要的系统<code>V</code>共享内存机制；<code>shmat</code>在把共享内存区域映射到进程空间时，并不真正改变进程的页表。当进程第一次访问内存映射区域访问时，会因为没有物理页表的分配而导致一个缺页异常，然后内核再根据相应的存储管理机制为共享内存映射区域分配相应的页表。</p>
<h3 id="系统V共享内存限制"><a href="#系统V共享内存限制" class="headerlink" title="系统V共享内存限制"></a>系统V共享内存限制</h3><p>&emsp;&emsp;在<code>/proc/sys/kernel/</code>目录下，记录着系统<code>V</code>共享内存的一下限制，如一个共享内存区的最大字节数<code>shmmax</code>，系统范围内最大共享内存区标识符数<code>shmmni</code>等，可以手工对其调整，但不推荐这样做。<br>&emsp;&emsp;系统<code>V</code>共享内存中的数据，从来不写入到实际磁盘文件中去；而通过<code>mmap</code>映射普通文件实现的共享内存通信可以指定何时将数据写入磁盘文件中。前面讲到，系统<code>V</code>共享内存机制实际是通过映射特殊文件系统<code>shm</code>中的文件实现的，文件系统<code>shm</code>的安装点在交换分区上，系统重新引导后，所有的内容都丢失。<br>&emsp;&emsp;系统<code>V</code>共享内存是随内核持续的，即使所有访问共享内存的进程都已经正常终止，共享内存区仍然存在(除非显式删除共享内存)，在内核重新引导之前，对该共享内存区域的任何改写操作都将一直保留。<br>&emsp;&emsp;通过调用<code>mmap</code>映射普通文件进行进程间通信时，一定要注意考虑进程何时终止对通信的影响。而通过系统<code>V</code>共享内存实现通信的进程则不然。<br>&emsp;&emsp;共享内存允许两个或多个进程共享一给定的存储区，因为数据不需要来回复制，所以是最快的一种进程间通信机制。共享内存可以通过<code>mmap</code>映射普通文件(特殊情况下还可以采用匿名映射)机制实现，也可以通过系统V共享内存机制实现。应用接口和原理很简单，内部机制复杂。为了实现更安全通信，往往还与信号灯等同步机制共同使用。<br>&emsp;&emsp;共享内存涉及到了存储管理以及文件系统等方面的知识，深入理解其内部机制有一定的难度，关键还要紧紧抓住内核使用的重要数据结构。系统V共享内存是以文件的形式组织在特殊文件系统<code>shm</code>中的。通过<code>shmget</code>可以创建或获得共享内存的标识符。取得共享内存标识符后，要通过<code>shmat</code>将这个内存区映射到本进程的虚拟地址空间。</p>
<hr>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>&emsp;&emsp;共享内存是被多个进程共享的一部分物理内存。共享内存是进程间共享数据的一种最快的方法，一个进程向共享内存区域写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容。<br>&emsp;&emsp;由原理图可知，共享内存的地址在进程<code>A</code>中的地址可能是<code>0x5000</code>，在进程<code>B</code>中的地址可能是<code>0x7000</code>，这是因为共享内存映射到不同进程当中的不同位置。</p>
<p><img src="/2019/03/13/Linux系统编程/共享内存总结/2.png"></p>
<p>&emsp;&emsp;共享内存实现分为两个步骤：</p>
<ol>
<li>创建共享内存，使用<code>shmget</code>函数(<code>share memory get</code>)。</li>
<li>映射共享内存，将这段创建的共享内存映射到具体的进程空间去，使用<code>shmat</code>函数。</li>
</ol>
<h3 id="创建共享内存"><a href="#创建共享内存" class="headerlink" title="创建共享内存"></a>创建共享内存</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span> <span class="params">( <span class="keyword">key_t</span> key, <span class="keyword">int</span> size, <span class="keyword">int</span> shmflg )</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>key</code>标识共享内存的键值，可以取<code>0</code>或<code>IPC_PRIVATE</code>。当<code>key</code>的取值为<code>IPC_PRIVATE</code>，则函数<code>shmget</code>将创建一块新的共享内存；如果<code>key</code>的取值为<code>0</code>，而参数<code>shmflg</code>中又设置<code>IPC_PRIVATE</code>这个标志，则同样会创建一块新的共享内存。<code>size</code>是创建共享内存的大小，以字节为单位。如果函数执行成功，返回共享内存标识符；如果失败，返回<code>-1</code>。</p>
<h3 id="共享内存映射"><a href="#共享内存映射" class="headerlink" title="共享内存映射"></a>共享内存映射</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmat</span> <span class="params">( <span class="keyword">int</span> shmid, <span class="keyword">char</span> *shmaddr, <span class="keyword">int</span> flag )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>shmid</code>：<code>shmget</code>函数返回的共享存储标识符。</li>
<li><code>flag</code>：决定以什么方式来确定映射的地址(通常为<code>0</code>)。</li>
<li><code>shmaddr</code>：我们不会向它传值，而是从它那里获取值，为<code>0</code>表示由系统来指定地址。</li>
</ul>
<p>如果函数执行成功，则返回共享内存映射到进程中的地址；如果失败，则返回<code>-1</code>。</p>
<h3 id="共享内存脱离"><a href="#共享内存脱离" class="headerlink" title="共享内存脱离"></a>共享内存脱离</h3><p>&emsp;&emsp;当一个进程不再需要共享内存时，需要把它从进程地址空间中脱离，使用如下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span> <span class="params">( <span class="keyword">char</span> *shmaddr )</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数参数<code>shmaddr</code>是从<code>shmat</code>中获得的。<br>&emsp;&emsp;共享内存的使用如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ShareMem_1.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERM S_IRUSR|S_IWUSR</span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">char</span> *p_addr, *c_addr;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Usage:%s\n\a"</span>, argv[<span class="number">0</span>] );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( shmid = shmget ( IPC_PRIVATE, <span class="number">1024</span>, PERM ) ) == <span class="number">-1</span> ) &#123; <span class="comment">/* 创建共享内存 */</span></span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Create Share Memory Error:%s\n\a"</span>, strerror ( errno ) );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 创建子进程 */</span></span><br><span class="line">    <span class="keyword">if</span> ( fork() ) &#123; <span class="comment">/* 父进程写 */</span></span><br><span class="line">        p_addr = shmat ( shmid, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">memset</span> ( p_addr, <span class="string">'\0'</span>, <span class="number">1024</span> );</span><br><span class="line">        <span class="built_in">strncpy</span> ( p_addr, argv[<span class="number">1</span>], <span class="number">1024</span> );</span><br><span class="line">        wait ( <span class="literal">NULL</span> ); <span class="comment">/* 释放资源，不关心终止状态 */</span></span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 子进程读 */</span></span><br><span class="line">        sleep ( <span class="number">1</span> ); <span class="comment">/* 暂停1秒 */</span></span><br><span class="line">        c_addr = shmat ( shmid, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Client get %s\n"</span>, c_addr );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* ShareMem_2.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/ipc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/shm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSZ 2048</span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">char</span> *shmadd;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( shmid = shmget ( IPC_PRIVATE, BUFSZ, <span class="number">0666</span> ) ) &lt; <span class="number">0</span> ) &#123; <span class="comment">/* 创建共享内存 */</span></span><br><span class="line">        perror ( <span class="string">"shmget"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"created shared-memeory: %d\n"</span>, shmid );</span><br><span class="line">    system ( <span class="string">"ipcs -m"</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( shmadd = ( <span class="keyword">char</span> * ) shmat ( shmid, <span class="number">0</span>, <span class="number">0</span> ) ) &lt; ( <span class="keyword">char</span> * ) <span class="number">0</span> ) &#123; <span class="comment">/* 映射共享内存 */</span></span><br><span class="line">        perror ( <span class="string">"shmat"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"attached shared-memory\n"</span> );</span><br><span class="line">    system ( <span class="string">"ipcs -m"</span> ); <span class="comment">/* 显示系统内存情况 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( shmdt ( shmadd ) &lt; <span class="number">0</span> ) &#123; <span class="comment">/* 取消共享内存映射 */</span></span><br><span class="line">        perror ( <span class="string">"shmat"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"detach shared-memory\n"</span> );</span><br><span class="line">    system ( <span class="string">"ipcs -m"</span> );</span><br><span class="line">    shmctl ( shmid, IPC_RMID, <span class="literal">NULL</span> ); <span class="comment">/* 删除共享内存对象 */</span></span><br><span class="line">    system ( <span class="string">"ipcs -m"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="共享内存使用示例"><a href="#共享内存使用示例" class="headerlink" title="共享内存使用示例"></a>共享内存使用示例</h3><p>&emsp;&emsp;<code>shm_com.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEXT_SZ 2048</span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shared_use_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> written_by_you;</span><br><span class="line">    <span class="keyword">char</span> some_text[TEXT_SZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>shm1.c</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shm_com.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> *shared_memory = ( <span class="keyword">void</span> * ) <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shared_use_st</span> *<span class="title">shared_stuff</span>;</span></span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="comment">/* 创建共享内存 */</span></span><br><span class="line">    shmid = shmget ( ( <span class="keyword">key_t</span> ) <span class="number">1234</span>, <span class="keyword">sizeof</span> ( struct shared_use_st ), <span class="number">0666</span> | IPC_CREAT );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( shmid == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"shmget failed\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    shared_memory = shmat ( shmid, ( <span class="keyword">void</span> * ) <span class="number">0</span>, <span class="number">0</span> ); <span class="comment">/* 映射共享内存 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( shared_memory == ( <span class="keyword">void</span> * ) - <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"shmat failed\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Memory attached at %X\n"</span>, ( <span class="keyword">int</span> ) shared_memory );</span><br><span class="line">    <span class="comment">/* 让结构体指针指向这块共享内存 */</span></span><br><span class="line">    shared_stuff = ( struct shared_use_st * ) shared_memory;</span><br><span class="line">    shared_stuff-&gt;written_by_you = <span class="number">0</span>; <span class="comment">/* 控制读写顺序 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( running ) &#123; <span class="comment">/* 循环的从共享内存中读数据，直到读到“end”为止 */</span></span><br><span class="line">        <span class="keyword">if</span> ( shared_stuff-&gt;written_by_you ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"You wrote:%s"</span>, shared_stuff-&gt;some_text );</span><br><span class="line">            sleep ( <span class="number">1</span> ); <span class="comment">/* 读进程睡一秒，同时会导致写进程睡一秒，这样做到读了之后再写 */</span></span><br><span class="line">            shared_stuff-&gt;written_by_you = <span class="number">0</span>;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">strncmp</span> ( shared_stuff-&gt;some_text, <span class="string">"end"</span>, <span class="number">3</span> ) == <span class="number">0</span> ) &#123;</span><br><span class="line">                running = <span class="number">0</span>; <span class="comment">/* 结束循环 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( shmdt ( shared_memory ) == <span class="number">-1</span> ) &#123; <span class="comment">/* 删除共享内存 */</span></span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"shmdt failed\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">exit</span> ( EXIT_SUCCESS );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>shm2.c</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shm_com.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> *shared_memory = ( <span class="keyword">void</span> * ) <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shared_use_st</span> *<span class="title">shared_stuff</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[BUFSIZ];</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="comment">/* 创建共享内存 */</span></span><br><span class="line">    shmid = shmget ( ( <span class="keyword">key_t</span> ) <span class="number">1234</span>, <span class="keyword">sizeof</span> ( struct shared_use_st ), <span class="number">0666</span> | IPC_CREAT );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( shmid == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"shmget failed\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    shared_memory = shmat ( shmid, ( <span class="keyword">void</span> * ) <span class="number">0</span>, <span class="number">0</span> ); <span class="comment">/* 映射共享内存 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( shared_memory == ( <span class="keyword">void</span> * ) - <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"shmat failed\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Memory attached at %X\n"</span>, ( <span class="keyword">int</span> ) shared_memory );</span><br><span class="line">    <span class="comment">/* 让结构体指针指向这块共享内存 */</span></span><br><span class="line">    shared_stuff = ( struct shared_use_st * ) shared_memory;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( running ) &#123; <span class="comment">/* 循环的向共享内存中写数据，直到写入的为“end”为止 */</span></span><br><span class="line">        <span class="keyword">while</span> ( shared_stuff-&gt;written_by_you == <span class="number">1</span> ) &#123;</span><br><span class="line">            sleep ( <span class="number">1</span> ); <span class="comment">/* 等到读进程读完之后再写 */</span></span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"waiting for client...\n"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Ener some text:"</span> );</span><br><span class="line">        fgets ( buffer, BUFSIZ, <span class="built_in">stdin</span> );</span><br><span class="line">        <span class="built_in">strncpy</span> ( shared_stuff-&gt;some_text, buffer, TEXT_SZ );</span><br><span class="line">        shared_stuff-&gt;written_by_you = <span class="number">1</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">strncmp</span> ( buffer, <span class="string">"end"</span>, <span class="number">3</span> ) == <span class="number">0</span> ) &#123;</span><br><span class="line">            running = <span class="number">0</span>; <span class="comment">/* 结束循环 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( shmdt ( shared_memory ) == <span class="number">-1</span> ) &#123; <span class="comment">/*删除共享内存*/</span></span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"shmdt failed\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">exit</span> ( EXIT_SUCCESS );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/13/Linux系统编程/管道/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/Linux系统编程/管道/" itemprop="url">管道</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T10:35:44+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>&emsp;&emsp;什么是管道？管道是单向的、先进先出的，它把一个进程的输出和另一个进程的输入连接在一起。一个进程(写进程)在管道的尾部写入数据，另一个进程(读进程)从管道的头部读出数据。数据被一个进程读出后，将被从管道中删除，其它读进程将不能再读到这些数据。管道提供了简单的流控制机制，进程试图读空管道时，进程将阻塞。同样，管道已经满时，进程再试图向管道写入数据，进程将阻塞。</p>
<h4 id="管道创建"><a href="#管道创建" class="headerlink" title="管道创建"></a>管道创建</h4><p>&emsp;&emsp;管道包括无名管道和有名管道两种，前者用于父进程和子进程间(兄弟进程)的通信，后者可用于运行于同一系统中的任意两个进程间的通信。无名管道由<code>pipe</code>函数创建：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span> <span class="params">( <span class="keyword">int</span> filedis[<span class="number">2</span>] )</span></span>;</span><br></pre></td></tr></table></figure>
<p>当一个管道建立时，它会创建两个文件描述符：<code>filedis[0]</code>用于读管道，<code>filedis[1]</code>用于写管道。<br>&emsp;&emsp;在<code>linux</code>系统中，无名管道一旦创建完成后，操作无名管道等同于操作文件，无名管道的读端被视为一个文件，写端也被视为一个文件，因此可以使用<code>read</code>、<code>write</code>和<code>close</code>等函数进行操作。在对<code>pipe</code>进行读写时，为了保证数据的流向，需要关闭一个进程的读端和另一个进程的写端。注意，必须在<code>fork</code>前调用<code>pipe</code>，否则子进程不会继承文件描述符。<br>&emsp;&emsp;如果管道的读端不存在，则认为已经读到了数据的末尾，读函数返回的读出字节数为<code>0</code>；当管道的读端存在时，如果请求的字节数目大于<code>PIPE_BUF</code>，则返回管道中现有的数据字节数，如果请求的字节数目不大于<code>PIPE_BUF</code>，则返回管道中现有数据字节数(此时，管道中数据量小于请求的数据量)；或者返回请求的字节数(此时，管道中数据量不小于请求的数据量)。<code>PIPE_BUF</code>在<code>include/linux/limits.h</code>中定义，不同的内核版本可能会有所不同。<code>Posix.1</code>要求<code>PIPE_BUF</code>至少为<code>512</code>字节，<code>red hat 7.2</code>中为<code>4096</code>。</p>
<p><img src="/2019/03/13/Linux系统编程/管道/1.jpg" height="217" width="576"></p>
<h4 id="管道关闭"><a href="#管道关闭" class="headerlink" title="管道关闭"></a>管道关闭</h4><p>&emsp;&emsp;关闭管道只需将这两个文件描述符关闭即可，可以使用普通的<code>close</code>函数逐个关闭。对无名管道进行操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf_r[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span> *p_wbuf;</span><br><span class="line">    <span class="keyword">int</span> r_num;</span><br><span class="line">    <span class="built_in">memset</span> ( buf_r, <span class="number">0</span>, <span class="keyword">sizeof</span> ( buf_r ) ); <span class="comment">/* 清空buf_r */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pipe ( pipe_fd ) &lt; <span class="number">0</span> ) &#123; <span class="comment">/* 创建管道 */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"pipe create error\n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( pid = fork() ) == <span class="number">0</span> ) &#123; <span class="comment">/* 创建子进程 */</span></span><br><span class="line">        close ( pipe_fd[<span class="number">1</span>] );</span><br><span class="line">        sleep ( <span class="number">2</span> ); <span class="comment">/* 睡眠为了保证父进程向管道内写完数据 */</span></span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( ( r_num = read ( pipe_fd[<span class="number">0</span>], buf_r, <span class="number">100</span> ) ) &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"%d numbers read from the pipe is %s\n"</span>, r_num, buf_r );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        close ( pipe_fd[<span class="number">0</span>] );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( pid &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        close ( pipe_fd[<span class="number">0</span>] );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( write ( pipe_fd[<span class="number">1</span>], <span class="string">"Hello"</span>, <span class="number">5</span> ) != <span class="number">-1</span> ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"parent write1 Hello!\n"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( write ( pipe_fd[<span class="number">1</span>], <span class="string">" Pipe"</span>, <span class="number">5</span> ) != <span class="number">-1</span> ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"parent write2 Pipe!\n"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        close ( pipe_fd[<span class="number">1</span>] );</span><br><span class="line">        sleep ( <span class="number">3</span> );</span><br><span class="line">        waitpid ( pid, <span class="literal">NULL</span>, <span class="number">0</span> ); <span class="comment">/* 等待子进程结束 */</span></span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命名管道-FIFO"><a href="#命名管道-FIFO" class="headerlink" title="命名管道(FIFO)"></a>命名管道(FIFO)</h3><p>&emsp;&emsp;命名管道和无名管道基本相同，但也有不同点：无名管道只能由父子进程使用；但是通过命名管道，不相关的进程也能交换数据。<br>&emsp;&emsp;<code>FIFO</code>文件和普通文件的区别：读取<code>FIFO</code>的进程只能以<code>RDONLY</code>的方式打开<code>FIFO</code>文件；写<code>FIFO</code>文件的进程只能以<code>WRONLY</code>的方式打开<code>FIFO</code>文件；<code>FIFO</code>文件里的内容在读取后就消失了。<br>&emsp;&emsp;1. 从<code>FIFO</code>中读取数据：如果一个进程为了从<code>FIFO</code>中读取数据而阻塞打开了<code>FIFO</code>，那么称该进程内的读操作为设置了阻塞标志的读操作。</p>
<ul>
<li>如果有进程写打开<code>FIFO</code>，且当前<code>FIFO</code>为空，则对于设置了阻塞标志的读操作来说，将一直阻塞下去，直到有数据可以读时才继续执行；对于没有设置阻塞标志的读操作来说，则返回<code>-1</code>，当前<code>errno</code>值为<code>EAGAIN</code>，提醒以后再试。</li>
<li>对于设置了阻塞标志的读操作来说，造成阻塞的原因有两种：</li>
</ul>
<ol>
<li>当前<code>FIFO</code>内有数据，但有其它进程在读这些数据。</li>
<li><code>FIFO</code>本身为空。</li>
</ol>
<p>解阻塞的原因是：<code>FIFO</code>中有新的数据写入，不论写入数据量的大小，也不论读操作请求多少数据量，只要有数据写入即可。</p>
<ul>
<li>读打开的阻塞标志只对本进程第一个读操作施加作用，如果本进程中有多个读操作序列，则在第一个读操作被唤醒并完成读操作后，其它将要执行的读操作将不再阻塞，即使在执行读操作时，<code>FIFO</code>中没有数据也一样(此时读操作返回<code>0</code>)。</li>
<li>如果没有进程写打开<code>FIFO</code>，则设置了阻塞标志的读操作会阻塞。</li>
<li>如果<code>FIFO</code>中有数据，则设置了阻塞标志的读操作不会因为<code>FIFO</code>中的字节数少于请求的字节数而阻塞，此时读操作会返回<code>FIFO</code>中现有的数据量。</li>
</ul>
<p>&emsp;&emsp;2. 从<code>FIFO</code>中写入数据：如果一个进程为了向<code>FIFO</code>中写入数据而阻塞打开<code>FIFO</code>，那么称该进程内的写操作为设置了阻塞标志的写操作。<br>&emsp;&emsp;<code>FIFO</code>的长度是需要考虑的一个很重要因素。系统对任一时刻在一个<code>FIFO</code>中可以存在的数据长度是有限制的。它由<code>#define PIPE_BUF</code>定义，在头文件<code>limits.h</code>中。在<code>Linux</code>和许多其他类<code>UNIX</code>系统中，它的值通常是<code>4096</code>字节，<code>Fedora 9</code>下是<code>4096</code>，但在某些系统中它可能会小到<code>512</code>字节。<br>&emsp;&emsp;虽然对于只有一个<code>FIFO</code>写进程和一个<code>FIFO</code>读进程而言，这个限制并不重要，但只使用一个<code>FIFO</code>并允许多个不同进程向一个<code>FIFO</code>读进程发送请求的情况是很常见的。如果几个不同的程序尝试同时向<code>FIFO</code>写数据，能否保证来自不同程序的数据块不相互交错就非常关键了。也就是说，每个写操作必须<code>原子化</code>。<br>&emsp;&emsp;对于设置了阻塞标志的写操作：</p>
<ul>
<li>当要写入的数据量不大于<code>PIPE_BUF</code>时，<code>Linux</code>将保证写入的原子性。如果此时管道空闲缓冲区不足以容纳要写入的字节数，则进入睡眠，直到当缓冲区中能够容纳要写入的字节数时，才开始进行一次性写操作。即写入的数据长度小于等于<code>PIPE_BUF</code>时，那么或者写入全部字节，或者一个字节都不写入，它属于一个一次性行为，具体要看<code>FIFO</code>中是否有足够的缓冲区。</li>
<li>当要写入的数据量大于<code>PIPE_BUF</code>时，<code>Linux</code>将不再保证写入的原子性。<code>FIFO</code>缓冲区一有空闲区域，写进程就会试图向管道写入数据，写操作在写完所有请求写的数据后返回。</li>
</ul>
<p>&emsp;&emsp;对于没有设置阻塞标志的写操作：</p>
<ul>
<li>当要写入的数据量不大于<code>PIPE_BUF</code>时，<code>Linux</code>将保证写入的原子性。如果当前<code>FIFO</code>空闲缓冲区能够容纳请求写入的字节数，写完后成功返回；如果当前<code>FIFO</code>空闲缓冲区不能够容纳请求写入的字节数，则返回<code>EAGAIN</code>错误，提醒以后再写。</li>
<li>当要写入的数据量大于<code>PIPE_BUF</code>时，<code>Linux</code>将不再保证写入的原子性。在写满所有<code>FIFO</code>空闲缓冲区后，写操作返回。</li>
</ul>
<h4 id="创建FIFO"><a href="#创建FIFO" class="headerlink" title="创建FIFO"></a>创建FIFO</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pathname</code>：<code>FIFO</code>文件名。<br><code>mode</code>：属性，与文件处理的属性一样。</li>
</ul>
<p>若成功，则返回<code>0</code>，否则返回<code>-1</code>，错误原因存于<code>errno</code>中：</p>
<ul>
<li><code>EACCESS</code>：参数<code>pathname</code>所指定的目录路径无可执行的权限。</li>
<li><code>EEXIST</code>：参数<code>pathname</code>所指定的文件已存在。</li>
<li><code>ENAMETOOLONG</code>：参数<code>pathname</code>的路径名称太长。</li>
<li><code>ENOENT</code>：参数<code>pathname</code>包含的目录不存在。</li>
<li><code>ENOSPC</code>：文件系统的剩余空间不足。</li>
<li><code>ENOTDIR</code>：参数<code>pathname</code>路径中的目录存在，但却非真正的目录。</li>
<li><code>EROFS</code>：参数<code>pathname</code>指定的文件存在于只读文件系统内。</li>
</ul>
<p>一旦创建了一个<code>FIFO</code>，就可用<code>open</code>打开它，一般的文件访问函数(<code>close</code>、<code>read</code>、<code>write</code>等)都可用于<code>FIFO</code>。</p>
<h4 id="操作FIFO"><a href="#操作FIFO" class="headerlink" title="操作FIFO"></a>操作FIFO</h4><p>&emsp;&emsp;当打开<code>FIFO</code>时，非阻塞标志(<code>O_NONBLOCK</code>)将对以后的读写产生如下影响：</p>
<ul>
<li>没有使用<code>O_NONBLOCK</code>：访问要求无法满足时进程将阻塞。如试图读取空的<code>FIFO</code>，将导致进程阻塞。</li>
<li>使用<code>O_NONBLOCK</code>：访问要求无法满足时不阻塞，立刻出错返回，<code>errno</code>是<code>ENXIO</code>。</li>
</ul>
<p>&emsp;&emsp;对<code>FIFO</code>文件进行操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fifo_read.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fcntl.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c_buf[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = open ( <span class="string">"./myfifo"</span>, O_RDONLY );</span><br><span class="line">    read ( fd, c_buf, <span class="number">11</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"read %s\n"</span>, c_buf );</span><br><span class="line">    close ( fd );</span><br><span class="line">    unlink ( <span class="string">"./myfifo"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----------------------------------------*/</span></span><br><span class="line"><span class="comment">/* fifo_write.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fcntl.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    mkfifo ( <span class="string">"./myfifo"</span>, <span class="number">0666</span> ); <span class="comment">/* 创建fifo文件 */</span></span><br><span class="line">    fd = open ( <span class="string">"./myfifo"</span>, O_WRONLY ); <span class="comment">/* 打开fifo文件 */</span></span><br><span class="line">    write ( fd, <span class="string">"hello fifo"</span>, <span class="number">11</span> ); <span class="comment">/* 写入数据到fifo文件 */</span></span><br><span class="line">    close ( fd );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>&emsp;&emsp;关于管道的读规则验证，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> r_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span> w_buf[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">char</span> *p_wbuf;</span><br><span class="line">    <span class="keyword">int</span> r_num;</span><br><span class="line">    <span class="keyword">int</span> cmd;</span><br><span class="line">    <span class="built_in">memset</span> ( r_buf, <span class="number">0</span>, <span class="keyword">sizeof</span> ( r_buf ) );</span><br><span class="line">    <span class="built_in">memset</span> ( w_buf, <span class="number">0</span>, <span class="keyword">sizeof</span> ( w_buf ) );</span><br><span class="line">    p_wbuf = w_buf;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pipe ( pipe_fd ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"pipe create error\n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( pid = fork() ) == <span class="number">0</span> ) &#123;</span><br><span class="line">        close ( pipe_fd[<span class="number">1</span>] );</span><br><span class="line">        sleep ( <span class="number">3</span> );<span class="comment">/* 确保父进程关闭写端 */</span></span><br><span class="line">        r_num = read ( pipe_fd[<span class="number">0</span>], r_buf, <span class="number">100</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"read num is %d, the data read from the pipe is %d\n"</span>, r_num, atoi ( r_buf ) );</span><br><span class="line">        close ( pipe_fd[<span class="number">0</span>] );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( pid &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        close ( pipe_fd[<span class="number">0</span>] ); <span class="comment">/* read */</span></span><br><span class="line">        <span class="built_in">strcpy</span> ( w_buf, <span class="string">"111"</span> );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( write ( pipe_fd[<span class="number">1</span>], w_buf, <span class="number">4</span> ) != <span class="number">-1</span> ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"parent write over\n"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        close ( pipe_fd[<span class="number">1</span>] ); <span class="comment">/* write */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"parent close fd[1] over\n"</span> );</span><br><span class="line">        sleep ( <span class="number">10</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent write over</span><br><span class="line">parent close fd[<span class="number">1</span>] over</span><br><span class="line">read num is <span class="number">4</span>, the data read from the pipe is <span class="number">111</span></span><br></pre></td></tr></table></figure>
<p>结论为：管道写端关闭后，写入的数据将一直存在，直到读出为止。<br>&emsp;&emsp;向管道中写入数据时，<code>linux</code>将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。<br>&emsp;&emsp;只有在管道的读端存在时，向管道中写入数据才有意义。否则，向管道中写入数据的进程将收到内核传来的<code>SIGPIPE</code>信号，应用程序可以处理该信号，也可以忽略(默认动作则是应用程序终止)。<br>&emsp;&emsp;对管道的写规则的验证(写端对读端存在的依赖性)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> r_buf[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">char</span> *w_buf;</span><br><span class="line">    <span class="keyword">int</span> writenum;</span><br><span class="line">    <span class="keyword">int</span> cmd;</span><br><span class="line">    <span class="built_in">memset</span> ( r_buf, <span class="number">0</span>, <span class="keyword">sizeof</span> ( r_buf ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pipe ( pipe_fd ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"pipe create error\n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( pid = fork() ) == <span class="number">0</span> ) &#123;</span><br><span class="line">        close ( pipe_fd[<span class="number">0</span>] );</span><br><span class="line">        close ( pipe_fd[<span class="number">1</span>] );</span><br><span class="line">        sleep ( <span class="number">10</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( pid &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        sleep ( <span class="number">1</span> );</span><br><span class="line">        close ( pipe_fd[<span class="number">0</span>] );</span><br><span class="line">        w_buf = <span class="string">"111"</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( ( writenum = write ( pipe_fd[<span class="number">1</span>], w_buf, <span class="number">4</span> ) ) == <span class="number">-1</span> ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"write to pipe error\n"</span> );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"the bytes write to pipe is %d\n"</span>, writenum );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        close ( pipe_fd[<span class="number">1</span>] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则输出结果为无，原因就是该管道以及它的所有<code>fork</code>产物的读端都已经被关闭。如果在父进程中保留读端，即在写完<code>pipe</code>后，再关闭父进程的读端，也会正常写入<code>pipe</code>。因此，在向管道写入数据时，至少应该存在某一个进程，其中管道读端没有被关闭，否则就会出现上述错误(管道断裂，进程收到了<code>SIGPIPE</code>信号，默认动作是进程终止)。<br>&emsp;&emsp;对管道的写规则的验证(<code>linux</code>不保证写管道的原子性验证)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> r_buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">char</span> w_buf[<span class="number">4096</span> * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> writenum;</span><br><span class="line">    <span class="keyword">int</span> rnum;</span><br><span class="line">    <span class="built_in">memset</span> ( r_buf, <span class="number">0</span>, <span class="keyword">sizeof</span> ( r_buf ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pipe ( pipe_fd ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"pipe create error\n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( pid = fork() ) == <span class="number">0</span> ) &#123;</span><br><span class="line">        close ( pipe_fd[<span class="number">1</span>] );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">            sleep ( <span class="number">1</span> );</span><br><span class="line">            rnum = read ( pipe_fd[<span class="number">0</span>], r_buf, <span class="number">1000</span> );</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"child: readnum is %d\n"</span>, rnum );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        close ( pipe_fd[<span class="number">0</span>] );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( pid &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        close ( pipe_fd[<span class="number">0</span>] );</span><br><span class="line">        <span class="built_in">memset</span> ( r_buf, <span class="number">0</span>, <span class="keyword">sizeof</span> ( r_buf ) );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( ( writenum = write ( pipe_fd[<span class="number">1</span>], w_buf, <span class="number">1024</span> ) ) == <span class="number">-1</span> ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"write to pipe error\n"</span> );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"the bytes write to pipe is %d\n"</span>, writenum );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        writenum = write ( pipe_fd[<span class="number">1</span>], w_buf, <span class="number">4096</span> );</span><br><span class="line">        close ( pipe_fd[<span class="number">1</span>] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">the bytes write to pipe <span class="number">1000</span></span><br><span class="line">the bytes write to pipe <span class="number">1000</span> <span class="comment">/* 注意，此行输出说明了写入的非原子性 */</span></span><br><span class="line">the bytes write to pipe <span class="number">1000</span></span><br><span class="line">the bytes write to pipe <span class="number">1000</span></span><br><span class="line">the bytes write to pipe <span class="number">1000</span></span><br><span class="line">the bytes write to pipe <span class="number">120</span> <span class="comment">/* 注意，此行输出说明了写入的非原子性 */</span></span><br><span class="line">the bytes write to pipe <span class="number">0</span></span><br><span class="line">the bytes write to pipe <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>结论为：写入数目小于<code>4096</code>时写入是非原子的。如果把父进程中的两次写入字节数都改为<code>5000</code>，则很容易得出下面结论：写入管道的数据量大于<code>4096</code>字节时，缓冲区的空闲空间将被写入数据(补齐)，直到写完所有数据为止，如果没有进程读数据，则一直阻塞。</p>
<hr>
<h3 id="双子进程pipe"><a href="#双子进程pipe" class="headerlink" title="双子进程pipe"></a>双子进程pipe</h3><p>&emsp;&emsp;代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">int</span> pid1, pid2;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> outpipe[<span class="number">100</span>], inpipe[<span class="number">100</span>];</span><br><span class="line">    pipe ( fd );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( ( pid1 = fork() ) == <span class="number">-1</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid1 == <span class="number">0</span> ) &#123;</span><br><span class="line">        lockf ( fd[<span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">sprintf</span> ( outpipe, <span class="string">"child 1 process is sending message!"</span> );</span><br><span class="line">        write ( fd[<span class="number">1</span>], outpipe, <span class="number">50</span> );</span><br><span class="line">        sleep ( <span class="number">5</span> );</span><br><span class="line">        lockf ( fd[<span class="number">1</span>], <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( ( pid2 = fork() ) == <span class="number">-1</span> );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( pid2 == <span class="number">0</span> ) &#123;</span><br><span class="line">            lockf ( fd[<span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span> ); <span class="comment">/* 互斥 */</span></span><br><span class="line">            <span class="built_in">sprintf</span> ( outpipe, <span class="string">"child 2 process is sending message!"</span> );</span><br><span class="line">            write ( fd[<span class="number">1</span>], outpipe, <span class="number">50</span> );</span><br><span class="line">            sleep ( <span class="number">5</span> );</span><br><span class="line">            lockf ( fd[<span class="number">1</span>], <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">            <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wait ( <span class="literal">NULL</span> ); <span class="comment">/* 同步 */</span></span><br><span class="line">            read ( fd[<span class="number">0</span>], inpipe, <span class="number">50</span> );</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"%s\n"</span>, inpipe );</span><br><span class="line">            wait ( <span class="literal">NULL</span> );</span><br><span class="line">            read ( fd[<span class="number">0</span>], inpipe, <span class="number">50</span> );</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"%s\n"</span>, inpipe );</span><br><span class="line">            <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="基于管道的popen和pclose函数"><a href="#基于管道的popen和pclose函数" class="headerlink" title="基于管道的popen和pclose函数"></a>基于管道的popen和pclose函数</h3><p>&emsp;&emsp;标准<code>I/O</code>函数库提供了<code>popen</code>函数，它启动另外一个进程去执行一个<code>shell</code>命令行。这里我们称调用<code>popen</code>的进程为父进程，由<code>popen</code>启动的进程称为子进程。<br>&emsp;&emsp;<code>popen</code>函数还创建一个管道用于父子进程间通信。父进程要么从管道读信息，要么向管道写信息，至于是读还是写取决于父进程调用<code>popen</code>时传递的参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">popen</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *type )</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>popen</code>会调用<code>fork</code>产生子进程，然后从子进程中调用<code>/bin/sh -c</code>来执行参数<code>command</code>的指令。参数<code>type</code>可使用<code>r</code>代表读取，<code>w</code>代表写入。依照此<code>type</code>值，<code>popen</code>会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。若成功，则返回文件指针，否则返回<code>NULL</code>，错误原因存于<code>errno</code>中。<br>&emsp;&emsp;<code>pclose</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span> <span class="params">( FILE *stream )</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>pclose</code>用来关闭由<code>popen</code>所建立的管道及文件指针。参数<code>stream</code>为先前由<code>popen</code>所返回的文件指针。若成功，返回<code>shell</code>的终止状态(也即子进程的终止状态)，若出错返回<code>-1</code>，错误原因存于<code>errno</code>中。<br>&emsp;&emsp;下面通过例子看一下<code>popen</code>的使用：假如我们想取得当前目录下的文件个数，在<code>shell</code>下我们可以使用命令<code>ls | wc - l</code>。可以在程序中这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 取得当前目录下的文件个数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1024</span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> result_buf[MAXLINE], command[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> rc = <span class="number">0</span>; <span class="comment">/* 用于接收命令返回值 */</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="comment">/* 将要执行的命令写入buf */</span></span><br><span class="line">    <span class="built_in">snprintf</span> ( command, <span class="keyword">sizeof</span> ( command ), <span class="string">"ls ./ | wc -l"</span> );</span><br><span class="line">    fp = popen ( command, <span class="string">"r"</span> ); <span class="comment">/* 执行预先设定的命令，并读出该命令的标准输出 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == fp ) &#123;</span><br><span class="line">        perror ( <span class="string">"popen执行失败！"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( fgets ( result_buf, <span class="keyword">sizeof</span> ( result_buf ), fp ) != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="comment">/* 为了下面输出好看一些，把命令返回的换行符去掉 */</span></span><br><span class="line">        <span class="keyword">if</span> ( <span class="string">'\n'</span> == result_buf[<span class="built_in">strlen</span> ( result_buf ) - <span class="number">1</span>] ) &#123;</span><br><span class="line">            result_buf[<span class="built_in">strlen</span> ( result_buf ) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"命令【%s】 输出【%s】\r\n"</span>, command, result_buf );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    rc = pclose ( fp ); <span class="comment">/* 等待命令执行完毕并关闭管道及文件指针 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == rc ) &#123;</span><br><span class="line">        perror ( <span class="string">"关闭文件指针失败"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"命令【%s】子进程结束状态【%d】命令返回值【%d】\r\n"</span>, \</span><br><span class="line">                 command, rc, WEXITSTATUS ( rc ) );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令【ls ./ | wc -l】 输出【<span class="number">2</span>】</span><br><span class="line">命令【ls ./ | wc -l】子进程结束状态【<span class="number">0</span>】命令返回值【<span class="number">0</span>】</span><br></pre></td></tr></table></figure>
<p>上面<code>popen</code>只捕获了<code>command</code>的标准输出，如果<code>command</code>执行失败，子进程会把错误信息打印到标准错误输出，父进程就无法获取。比如，<code>command</code>命令为<code>ls nofile.txt</code>，事实上我们根本没有<code>nofile.txt</code>这个文件，这时<code>shell</code>会输出<code>ls: nofile.txt: No such file or directory</code>。这个输出是在标准错误输出上的。通过上面的程序并无法获取。<br>&emsp;&emsp;如果你把上面程序中的<code>command</code>设成<code>ls nofile.txt</code>，则执行结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls: nofile.txt: No such file <span class="keyword">or</span> directory</span><br><span class="line">命令【ls nofile.txt】子进程结束状态【<span class="number">256</span>】命令返回值【<span class="number">1</span>】</span><br></pre></td></tr></table></figure>
<p>需要注意的是第一行输出并不是父进程的输出，而是子进程的标准错误输出。<br>&emsp;&emsp;有时子进程的错误信息是很有用的，那么父进程怎么才能获取子进程的错误信息呢？这里我们可以重定向子进程的错误输出，让错误输出重定向到标准输出(<code>2&gt;&amp;1</code>)，这样父进程就可以捕获子进程的错误信息了。例如<code>command</code>为<code>ls nofile.txt 2&gt;&amp;1</code>，输出如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令【ls nofile.txt <span class="number">2</span>&gt;&amp;<span class="number">1</span>】 输出【ls: nofile.txt: No such file <span class="keyword">or</span> directory】</span><br><span class="line">命令【ls nofile.txt <span class="number">2</span>&gt;&amp;<span class="number">1</span>】子进程结束状态【<span class="number">256</span>】命令返回值【<span class="number">1</span>】</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;子进程的终止状态判断涉及到的宏，设进程终止状态为<code>status</code>。</p>
<ul>
<li><code>WIFEXITED(status)</code>：如果子进程正常结束则为非<code>0</code>值。</li>
<li><code>WEXITSTATUS(status)</code>：取得子进程<code>exit</code>返回的结束代码，一般会先用<code>WIFEXITED</code>来判断是否正常结束才能使用此宏。</li>
<li><code>WIFSIGNALED(status)</code>：如果子进程是因为信号而结束，则此宏值为真。</li>
<li><code>WTERMSIG(status)</code>：取得子进程因信号而中止的信号代码，一般会先用<code>WIFSIGNALED</code>来判断后才使用此宏。</li>
<li><code>WIFSTOPPED(status)</code>：如果子进程处于暂停执行情况，则此宏值为真。一般只有使用<code>WUNTRACED</code>时才会有此情况。</li>
<li><code>WSTOPSIG(status)</code>：取得引发子进程暂停的信号代码，一般会先用<code>WIFSTOPPED</code>来判断后才使用此宏。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/13/Linux系统编程/消息队列/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/Linux系统编程/消息队列/" itemprop="url">消息队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T10:00:55+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="键值"><a href="#键值" class="headerlink" title="键值"></a>键值</h3><p>&emsp;&emsp;消息队列的内核持续性要求每个消息队列都在系统范围内对应唯一的键值，所以，要获得一个消息队列的描述字，必须提供该消息队列的键值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="keyword">key_t</span> ftok ( <span class="keyword">char</span> *pathname, <span class="keyword">char</span> proj ); <span class="comment">/* f是file，k是key */</span></span><br></pre></td></tr></table></figure>
<p>功能为返回文件名对应的键值。参数<code>pathname</code>是文件名，<code>proj</code>是项目名(不为<code>0</code>即可)。得到键值后，就可以去获取消息队列描述字。</p>
<h3 id="打开-创建消息队列"><a href="#打开-创建消息队列" class="headerlink" title="打开/创建消息队列"></a>打开/创建消息队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span> <span class="params">( <span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>key</code>是键值，由<code>ftok</code>获得；<code>msgflg</code>是标志位。函数返回与健值<code>key</code>相对应的消息队列描述字。<code>msgflg</code>有如下选项(或三者的<code>或</code>结果)：</p>
<ul>
<li><code>IPC_CREAT</code>：创建新的消息队列。</li>
<li><code>IPC_EXCL</code>：与<code>IPC_CREAT</code>一同使用，表示如果要创建的消息队列已经存在，则返回错误。</li>
<li><code>IPC_NOWAIT</code>：读写消息队列要求无法得到满足时，不阻塞。</li>
</ul>
<p>&emsp;&emsp;在以下两种情况下，将创建一个新的消息队列：</p>
<ul>
<li>如果没有与健值<code>key</code>相对应的消息队列，并且<code>msgflg</code>中包含了<code>IPC_CREAT</code>标志位。</li>
<li><code>vkey</code>参数为<code>IPC_PRIVATE</code>。</li>
</ul>
<p>&emsp;&emsp;打开消息队列的操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_queue</span> <span class="params">( <span class="keyword">key_t</span> keyval )</span> </span>&#123;</span><br><span class="line">    intqid;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( qid = msgget ( keyval, IPC_CREAT ) ) == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> ( qid );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span> <span class="params">( <span class="keyword">int</span> msqid, struct msgbuf *msgp, <span class="keyword">int</span> msgsz, <span class="keyword">int</span> msgflg )</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能为向消息队列中发送一条消息。</p>
<ul>
<li><code>msqid</code>：已打开的消息队列<code>id</code>。</li>
<li><code>msgp</code>：存放消息的结构。</li>
<li><code>msgsz</code>：消息数据长度。</li>
<li><code>msgflg</code>：发送标志，有意义的<code>msgflg</code>标志为<code>IPC_NOWAIT</code>，指明在消息队列没有足够空间容纳要发送的消息时，<code>msgsnd</code>是否等待。造成<code>msgsnd</code>等待的条件有两种：</li>
</ul>
<ol>
<li>当前消息的大小与当前消息队列中的字节数之和超过了消息队列的总容量。</li>
<li>当前消息队列的消息数(单位<code>个</code>)不小于消息队列的总容量(单位<code>字节数</code>)，此时虽然消息队列中的消息数目很多，但基本上都只有一个字节。</li>
</ol>
<p>&emsp;&emsp;<code>msgsnd</code>解除阻塞的条件有三个：</p>
<ul>
<li>不满足上述两个条件，即消息队列中有容纳该消息的空间。</li>
<li><code>msqid</code>代表的消息队列被删除。</li>
<li>调用<code>msgsnd</code>的进程被信号中断。</li>
</ul>
<p>调用函数成功返回<code>0</code>，否则返回<code>-1</code>。</p>
<h3 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype; <span class="comment">/* 消息类型 &gt; 0 */</span></span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1</span>]; <span class="comment">/* 消息数据的首地址 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span> <span class="params">( <span class="keyword">int</span> msqid, struct msgbuf *msgp, <span class="keyword">int</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg )</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能为从<code>msqid</code>代表的消息队列中读取一个<code>msgtyp</code>类型的消息，并把消息存储在<code>msgp</code>指向的<code>msgbuf</code>结构中。在成功地读取了一条消息以后，队列中的这条消息将被删除。注意，发送的数据类型应该和接收的数据类型一致。读消息标志<code>msgflg</code>可以为以下几个常值的或：</p>
<ul>
<li><code>IPC_NOWAIT</code>：如果没有满足条件的消息，调用立即返回，此时<code>errno</code>为<code>ENOMSG</code>。</li>
<li><code>IPC_EXCEPT</code>：与<code>msgtyp &gt; 0</code>配合使用，返回队列中第一个类型不为<code>msgtyp</code>的消息。</li>
<li><code>IPC_NOERROR</code>：如果队列中满足条件的消息内容大于所请求的<code>msgsz</code>字节，则把该消息截断，截断部分将丢失。</li>
</ul>
<p>&emsp;&emsp;<code>msgrcv</code>解除阻塞的条件有三个：消息队列中有了满足条件的消息；<code>msqid</code>代表的消息队列被删除；调用<code>msgrcv</code>的进程被信号中断。调用函数成功，返回读出消息的实际字节数，否则返回<code>-1</code>。</p>
<h3 id="消息队列控制"><a href="#消息队列控制" class="headerlink" title="消息队列控制"></a>消息队列控制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span> <span class="params">( <span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf )</span></span>;</span><br></pre></td></tr></table></figure>
<p>该系统调用对由<code>msqid</code>标识的消息队列执行<code>cmd</code>操作，共有三种<code>cmd</code>操作：</p>
<ul>
<li><code>IPC_STAT</code>：该命令用来获取消息队列信息，返回的信息存贮在<code>buf</code>指向的<code>msqid</code>结构中。</li>
<li><code>IPC_SET</code>：该命令用来设置消息队列的属性，要设置的属性存储在<code>buf</code>指向的<code>msqid</code>结构中。可设置属性包括<code>msg_perm.uid</code>、<code>msg_perm.gid</code>、<code>msg_perm.mode</code>以及<code>msg_qbytes</code>，同时也影响<code>msg_ctime</code>成员。</li>
<li><code>IPC_RMID</code>：删除<code>msqid</code>标识的消息队列。</li>
</ul>
<p>调用函数成功返回<code>0</code>，否则返回<code>-1</code>。<br>&emsp;&emsp;从消息队列中接收数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_message</span> <span class="params">( <span class="keyword">int</span> qid, <span class="keyword">long</span> type, struct mymsgbuf *qbuf )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result, length;</span><br><span class="line">    length = <span class="keyword">sizeof</span> ( struct mymsgbuf ) - <span class="keyword">sizeof</span> ( <span class="keyword">long</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( result = msgrcv ( qid, qbuf, length, type, <span class="number">0</span> ) ) == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> ( result );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对消息队列的操作如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 消息队列_1.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_buf</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">255</span>];</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_buf</span> <span class="title">msgbuf</span>;</span></span><br><span class="line">    key = ftok ( <span class="string">"./"</span>, <span class="string">'a'</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"key =[%x]\n"</span>, key );</span><br><span class="line">    msgid = msgget ( key, IPC_CREAT | <span class="number">0666</span> ); <span class="comment">/* 通过文件对应 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( msgid == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"create error\n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    msgbuf.mtype = getpid();</span><br><span class="line">    <span class="built_in">strcpy</span> ( msgbuf.data, <span class="string">"test haha"</span> );</span><br><span class="line">    ret = msgsnd ( msgid, &amp;msgbuf, <span class="keyword">sizeof</span> ( msgbuf.data ), IPC_NOWAIT );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ret == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"send message err\n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">memset</span> ( &amp;msgbuf, <span class="number">0</span>, <span class="keyword">sizeof</span> ( msgbuf ) );</span><br><span class="line">    ret = msgrcv ( msgid, &amp;msgbuf, <span class="keyword">sizeof</span> ( msgbuf.data ), getpid(), IPC_NOWAIT );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ret == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"recv message err\n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"recv msg =[%s]\n"</span>, msgbuf.data );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* 消息队列_2.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/ipc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/msg.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSZ 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 100</span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[BUFSZ];</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> qid, len;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">msg</span>;</span></span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 根据不同报告的路径和关键字产生标准的key */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( key = ftok ( <span class="string">"./"</span>, <span class="string">'a'</span> ) ) == <span class="number">-1</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"ftok"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 创建消息队列 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( qid = msgget ( key, IPC_CREAT | <span class="number">0666</span> ) ) == <span class="number">-1</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"msgget"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"opened queue %d\n"</span>, qid );</span><br><span class="line">    <span class="built_in">puts</span> ( <span class="string">"please enter the message to queue:"</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( fgets ( ( &amp;msg )-&gt;mtext, BUFSZ, <span class="built_in">stdin</span> ) ) == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">puts</span> ( <span class="string">"no message"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    msg.mtype = TRUE;</span><br><span class="line">    len = <span class="built_in">strlen</span> ( msg.mtext ) + <span class="number">1</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 添加消息到消息队列 */</span></span><br><span class="line">    <span class="keyword">if</span> ( msgsnd ( qid, &amp;msg, len , <span class="number">0</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"msgsnd"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 从消息队列读取消息 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( msgrcv ( qid, &amp;msg, BUFSIZ, <span class="number">0</span>, <span class="number">0</span> ) ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"msgrcv"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"message is %s\n"</span>, ( &amp;msg )-&gt;mtext );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( msgctl ( qid, IPC_RMID, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"msgctl"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>&emsp;&emsp;消息队列(也叫做报文队列)能够克服早期<code>unix</code>通信机制的一些缺点。作为早期<code>unix</code>通信机制之一的信号能够传送的信息量有限，后来虽然<code>POSIX 1003.1b</code>在信号的实时性方面作了拓广，使得信号在传递信息量方面有了相当程度的改进，但是信号这种通信方式更像<code>即时</code>的通信方式，它要求接受信号的进程在某个时间范围内对信号做出反应，因此该信号最多在接受信号进程的生命周期内才有意义，信号所传递的信息是接近于随进程持续的概念(<code>process-persistent</code>)。管道及有名管道及有名管道则是典型的随进程持续<code>IPC</code>，并且只能传送无格式的字节流无疑会给应用程序开发带来不便，另外它的缓冲区大小也受到限制。<br>&emsp;&emsp;消息队列就是一个消息的链表。可以把消息看作一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向中按照一定的规则添加新消息；对消息队列有读权限的进程则可以从消息队列中读走消息。消息队列是随内核持续的。目前主要有两种类型的消息队列：<code>POSIX</code>消息队列以及系统V消息队列，系统<code>V</code>消息队列目前被大量使用。考虑到程序的可移植性，新开发的应用程序应尽量使用<code>POSIX</code>消息队列。<br>&emsp;&emsp;本文将主要介绍系统<code>V</code>消息队列及其相应<code>API</code>。在没有声明的情况下，以下讨论中指的都是系统<code>V</code>消息队列。</p>
<h4 id="消息队列基本概念"><a href="#消息队列基本概念" class="headerlink" title="消息队列基本概念"></a>消息队列基本概念</h4><p>&emsp;&emsp;系统<code>V</code>消息队列是随内核持续的，只有在内核重起或者显示删除一个消息队列时，该消息队列才会真正被删除。因此系统中记录消息队列的数据结构(<code>struct ipc_ids msg_ids</code>)位于内核中，系统中的所有消息队列都可以在结构<code>msg_ids</code>中找到访问入口。<br>&emsp;&emsp;每个消息队列都有一个队列头，用结构<code>struct msg_queue</code>来描述。队列头中包含了该消息队列的大量信息，包括消息队列键值、用户<code>ID</code>、组<code>ID</code>、消息队列中消息数目等等，甚至记录了最近对消息队列读写进程的<code>ID</code>。读者可以访问这些信息，也可以设置其中的某些信息。下图说明了内核与消息队列是怎样建立起联系的，其中<code>struct ipc_ids msg_ids</code>是内核中记录消息队列的全局数据结构；<code>struct msg_queue</code>是每个消息队列的队列头。</p>
<p><img src="/2019/03/13/Linux系统编程/消息队列/1.png"></p>
<p>&emsp;&emsp;从上图可以看出，全局数据结构<code>struct ipc_ids msg_ids</code>可以访问到每个消息队列头的第一个成员，即<code>struct kern_ipc_perm</code>；而每个<code>struct kern_ipc_perm</code>能够与具体的消息队列对应起来是因为在该结构中，有一个<code>key_t</code>类型成员<code>key</code>，而<code>key</code>则唯一确定一个消息队列。<code>kern_ipc_perm</code>结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 内核中记录消息队列的全局数据结构msg_ids能够访问到该结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="keyword">key_t</span> key; <span class="comment">/* 该键值则唯一对应一个消息队列 */</span></span><br><span class="line">    <span class="keyword">uid_t</span> uid;</span><br><span class="line">    <span class="keyword">gid_t</span> gid;</span><br><span class="line">    <span class="keyword">uid_t</span> cuid;</span><br><span class="line">    <span class="keyword">gid_t</span> cgid;</span><br><span class="line">    <span class="keyword">mode_t</span> mode;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="操作消息队列"><a href="#操作消息队列" class="headerlink" title="操作消息队列"></a>操作消息队列</h4><p>&emsp;&emsp;对消息队列的操作无非有下面三种类型：<br>&emsp;&emsp;1. 打开或创建消息队列：消息队列的内核持续性要求每个消息队列都在系统范围内对应唯一的键值，所以要获得一个消息队列的描述字，只需提供该消息队列的键值即可。注意，消息队列描述字是由在系统范围内唯一的键值生成的，而键值可以看作对应系统内的一条路经。<br>&emsp;&emsp;2. 读写操作：消息读写操作非常简单，对开发人员来说，每个消息都类似如下的数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>mtype</code>成员代表消息类型，从消息队列中读取消息的一个重要依据就是消息的类型；<code>mtext</code>是消息内容，当然长度不一定为<code>1</code>。因此，对于发送消息来说，首先预置一个<code>msgbuf</code>缓冲区并写入消息类型和内容，调用相应的发送函数即可；对读取消息来说，首先分配这样一个<code>msgbuf</code>缓冲区，然后把消息读入该缓冲区即可。<br>&emsp;&emsp;3. 获得或设置消息队列属性：消息队列的信息基本上都保存在消息队列头中，因此可以分配一个类似于消息队列头的结构<code>struct msqid_ds</code>来返回消息队列的属性；同样可以设置该数据结构。</p>
<p><img src="/2019/03/13/Linux系统编程/消息队列/2.png"></p>
<h4 id="消息队列的限制"><a href="#消息队列的限制" class="headerlink" title="消息队列的限制"></a>消息队列的限制</h4><p>&emsp;&emsp;每个消息队列的容量(所能容纳的字节数)都有限制，该值因系统不同而不同。另一个限制是每个消息队列所能容纳的最大消息数：在<code>redhad 8.0</code>中，该限制是受消息队列容量制约的：消息个数要小于消息队列的容量(字节数)。<br>&emsp;&emsp;上述两个限制是针对每个消息队列而言的，系统对消息队列的限制还有系统范围内的最大消息队列个数，以及整个系统范围内的最大消息数。一般来说，实际开发过程中不会超过这个限制。<br>&emsp;&emsp;消息队列与管道以及有名管道相比，具有更大的灵活性。首先，它提供有格式字节流，有利于减少开发人员的工作量；其次，消息具有类型，在实际应用中，可作为优先级使用。这两点是管道以及有名管道所不能比的。同样，消息队列可以在几个进程间复用，而不管这几个进程是否具有亲缘关系，这一点与有名管道很相似；但消息队列是随内核持续的，与有名管道(随进程持续)相比，生命力更强，应用空间更大。</p>
<hr>
<h3 id="消息队列服务器"><a href="#消息队列服务器" class="headerlink" title="消息队列服务器"></a>消息队列服务器</h3><p>&emsp;&emsp;本实验需要用消息队列设计一个简易的双人聊天程序(一个服务器，两个客户端)。消息队列重点在于消息类型的匹配，客户端和服务端的<code>通信协议</code>的设计。</p>
<ul>
<li>服务器端：接受客户端发来的任何消息，并根据其消息类型，转发给对应的客户端。同时，检测是否有退出标志，有则给所有的客户端发送退出标志，等待<code>1s</code>后，确定客户端都退出后，删除消息队列，释放空间，并退出。</li>
<li>客户端：<code>A</code>和<code>B</code>。<code>A</code>给<code>B</code>发送信息，先发给服务器，由服务器根据自定义协议转发该消息给<code>B</code>。同<code>B</code>也可以通过服务器给<code>A</code>发送消息。</li>
</ul>
<p>&emsp;&emsp;<code>server.c</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/ipc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/msg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_MSG 0x101 <span class="comment">/* 使用共有的IPC key */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGSIZE 64</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* 定义消息结构体：消息类型和消息数据 */</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[MSGSIZE];</span><br><span class="line">&#125; msgbuf;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN sizeof(msgbuf) - sizeof(long)</span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    msgbuf buf1, buf2;</span><br><span class="line">    msgid = msgget ( KEY_MSG, IPC_CREAT | <span class="number">0666</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123; <span class="comment">/* 无限循环，退出标志则会break */</span></span><br><span class="line">        msgrcv ( msgid, &amp;buf1, LEN, <span class="number">1L</span>, <span class="number">0</span> ); <span class="comment">/* 接收客户端1的消息 */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Receive client1, message:%s\n"</span>, buf1.mtext ); <span class="comment">/* 打印接收到的消息 */</span></span><br><span class="line">​</span><br><span class="line">        <span class="comment">/* 若是退出标志，则给2个客户端都发退出消息 */</span></span><br><span class="line">        <span class="keyword">if</span> ( buf1.mtext[<span class="number">0</span>] == <span class="string">'x'</span> || buf1.mtext[<span class="number">0</span>] == <span class="string">'X'</span> ) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span> ( buf1.mtext, <span class="string">"x"</span> );</span><br><span class="line">            buf1.mtype = <span class="number">3L</span>;</span><br><span class="line">            msgsnd ( msgid, &amp;buf1, LEN, <span class="number">0</span> );</span><br><span class="line">            buf1.mtype = <span class="number">4L</span>;</span><br><span class="line">            msgsnd ( msgid, &amp;buf1, LEN, <span class="number">0</span> );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        buf1.mtype = <span class="number">4L</span>;</span><br><span class="line">        msgsnd ( msgid, &amp;buf1, LEN, <span class="number">0</span> ); <span class="comment">/* 将客户端1的消息转发给客户端2 */</span></span><br><span class="line">        msgrcv ( msgid, &amp;buf2, LEN, <span class="number">2L</span>, <span class="number">0</span> ); <span class="comment">/* 接收客户端2的消息 */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Receieve client2 message:%s\n"</span>, buf2.mtext ); <span class="comment">/* 打印接收到的消息 */</span></span><br><span class="line">​</span><br><span class="line">        <span class="comment">/* 若是退出标志，则给2个客户端都发退出消息 */</span></span><br><span class="line">        <span class="keyword">if</span> ( buf2.mtext[<span class="number">0</span>] == <span class="string">'x'</span> || buf2.mtext[<span class="number">0</span>] == <span class="string">'X'</span> ) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span> ( buf2.mtext, <span class="string">"x"</span> );</span><br><span class="line">            buf1.mtype = <span class="number">3L</span>;</span><br><span class="line">            msgsnd ( msgid, &amp;buf2, LEN, <span class="number">0</span> );</span><br><span class="line">            buf1.mtype = <span class="number">4L</span>;</span><br><span class="line">            msgsnd ( msgid, &amp;buf2, LEN, <span class="number">0</span> );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        buf2.mtype = <span class="number">3L</span>;</span><br><span class="line">        msgsnd ( msgid, &amp;buf2, LEN, <span class="number">0</span> ); <span class="comment">/* 将客户端2的消息转发给客户端1 */</span></span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    sleep ( <span class="number">1</span> ); <span class="comment">/* 若退出，则先等待，以确保客户端程序退出 */</span></span><br><span class="line">    msgctl ( msgid, IPC_RMID, <span class="literal">NULL</span> ); <span class="comment">/* 删除消息队列，释放空间 */</span></span><br><span class="line">    <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>client1.c</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/ipc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/msg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_MSG 0x101</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGSIZE 64</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[MSGSIZE];</span><br><span class="line">&#125; msgbuf;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN sizeof(msgbuf) - sizeof(long)</span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    msgbuf buf1, buf2;</span><br><span class="line">    msgid = msgget ( KEY_MSG, <span class="number">0666</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"input the message to client 2:"</span> );</span><br><span class="line">        <span class="built_in">scanf</span> ( <span class="string">"%s"</span>, buf1.mtext );</span><br><span class="line">        buf1.mtype = <span class="number">1L</span>;</span><br><span class="line">        msgsnd ( msgid, &amp;buf1, LEN, <span class="number">0</span> ); <span class="comment">/* 客户端1获取消息并发往服务器 */</span></span><br><span class="line">        msgrcv ( msgid, &amp;buf2, LEN, <span class="number">3L</span>, <span class="number">0</span> ); <span class="comment">/* 准备从客户端2获取数据 */</span></span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( buf2.mtext[<span class="number">0</span>] == <span class="string">'x'</span> || buf2.mtext[<span class="number">0</span>] == <span class="string">'X'</span> ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"client 1 will quit!\n"</span> );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"Receieve from client2, message:%s\n"</span>, buf2.mtext );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>client2.c</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/ipc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/msg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_MSG 0x101</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGSIZE 64</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[MSGSIZE];</span><br><span class="line">&#125; msgbuf;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN sizeof(msgbuf) - sizeof(long)</span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    msgbuf buf1, buf2;</span><br><span class="line">    msgid = msgget ( KEY_MSG, <span class="number">0666</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        msgrcv ( msgid, &amp;buf2, LEN, <span class="number">4L</span>, <span class="number">0</span> ); <span class="comment">/* 等待客户端1发消息 */</span></span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( buf2.mtext[<span class="number">0</span>] == <span class="string">'x'</span> || buf2.mtext[<span class="number">0</span>] == <span class="string">'X'</span> ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"client 2 will quit!\n"</span> );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"Receieve from client1, message:%s\n"</span>, buf2.mtext );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        sleep ( <span class="number">1</span> ); <span class="comment">/* 等待1秒钟，以确保客户端1已经收到了回执 */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"input the message to client 1:"</span> );</span><br><span class="line">        <span class="built_in">scanf</span> ( <span class="string">"%s"</span>, buf1.mtext );</span><br><span class="line">        buf1.mtype = <span class="number">2L</span>;</span><br><span class="line">        msgsnd ( msgid, &amp;buf1, LEN, <span class="number">0</span> ); <span class="comment">/* 给客户端1发送回执消息 */</span></span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，先运行<code>server</code>，再运行<code>client1</code>，最后运行<code>client2</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/13/Linux系统编程/Linux套接字编程中的5个隐患/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/Linux系统编程/Linux套接字编程中的5个隐患/" itemprop="url">Linux套接字编程中的5个隐患</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T09:30:04+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>Socket API</code>是网络应用程序开发中实际应用的标准<code>API</code>。它是在<code>4.2 BSD UNIX</code>操作系统中首次引入的，现在是任何操作系统的标准特性。事实上，很难找到一种不支持<code>Sockets API</code>的现代语言。尽管该<code>API</code>简单，但是开发新手可能会经历一些常见的问题。本文识别一些最常见的隐患并向您展示如何避免它们。</p>
<h3 id="隐患1：忽略返回状态"><a href="#隐患1：忽略返回状态" class="headerlink" title="隐患1：忽略返回状态"></a>隐患1：忽略返回状态</h3><p>&emsp;&emsp;第一个隐患很明显，但它是开发新手最容易犯的一个错误。如果您忽略函数的返回状态，当它们失败或部分成功的时候，您也许会迷失。反过来，这可能传播错误，使得定位问题的源头变得困难。捕获并检查每一个返回状态，而不是忽略它们。考虑清单<code>1</code>显示的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> status, sock, mode;</span><br><span class="line"><span class="comment">/* Create a new stream (TCP) socket */</span></span><br><span class="line">sock = socket ( AF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">...</span><br><span class="line">status = send ( sock, buffer, buflen, MSG_DONTWAIT );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( status == <span class="number">-1</span> ) &#123;</span><br><span class="line">    <span class="comment">/* send failed */</span></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"send failed: %s\n"</span>, strerror ( errno ) );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* send succeeded -- or did it? */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清单<code>1</code>探究一个函数片断，它完成套接字<code>send</code>操作(通过套接字发送数据)。函数的错误状态被捕获并测试，但这个例子忽略了<code>send</code>在无阻塞模式(由<code>MSG_DONTWAIT</code>标志启用)下的一个特性。<br>&emsp;&emsp;<code>send</code>函数有三类可能的返回值：</p>
<ul>
<li>如果数据成功地排到传输队列，则返回<code>0</code>。</li>
<li>如果排队失败，则返回<code>-1</code>(通过使用<code>errno</code>变量可以了解失败的原因)。</li>
<li>如果不是所有的字符都能够在函数调用时排队，则最终的返回值是发送的字符数。</li>
</ul>
<p>&emsp;&emsp;由于<code>send</code>的<code>MSG_DONTWAIT</code>变量的无阻塞性质，函数调用在发送完所有的数据、一些数据或没有发送任何数据后返回。在这里忽略返回状态将导致不完全的发送和随后的数据丢失。</p>
<h3 id="隐患2：对等套接字闭包"><a href="#隐患2：对等套接字闭包" class="headerlink" title="隐患2：对等套接字闭包"></a>隐患2：对等套接字闭包</h3><p>&emsp;&emsp;<code>UNIX</code>有趣的一面是，您几乎可以把任何东西看成是一个文件，文件本身、目录、管道、设备和套接字都被当作文件。这是新颖的抽象，意味着一整套的<code>API</code>可以用在广泛的设备类型上。<br>&emsp;&emsp;考虑<code>read</code>函数，它从文件读取一定数量的字节。<code>read</code>函数返回读取的字节数(最高为您指定的最大值)；或者<code>-1</code>，表示错误；或者<code>0</code>，如果已经到达文件末尾。<br>&emsp;&emsp;如果在一个套接字上完成一个<code>read</code>操作并得到一个为<code>0</code>的返回值，这表明远程套接字端的对等层调用了<code>close</code>方法。该指示与文件读取相同，即没有多余的数据可以通过描述符读取。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sock, status;</span><br><span class="line">sock = socket ( AF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">...</span><br><span class="line">status = read ( sock, buffer, buflen );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( status &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="comment">/* Data read from the socket */</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( status == <span class="number">-1</span> ) &#123;</span><br><span class="line">    <span class="comment">/* Error, check errno, take action... */</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( status == <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="comment">/* Peer closed the socket, finish the close */</span></span><br><span class="line">    close ( sock );</span><br><span class="line">    <span class="comment">/* Further processing... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，可以用<code>write</code>函数来探测对等套接字的闭包。在这种情况下，接收<code>SIGPIPE</code>信号，或如果该信号阻塞，<code>write</code>函数将返回<code>-1</code>，并设置<code>errno</code>为<code>EPIPE</code>。</p>
<h3 id="隐患3：地址使用错误-EADDRINUSE"><a href="#隐患3：地址使用错误-EADDRINUSE" class="headerlink" title="隐患3：地址使用错误(EADDRINUSE)"></a>隐患3：地址使用错误(EADDRINUSE)</h3><p>&emsp;&emsp;您可以使用<code>bind</code>函数来绑定一个地址(一个接口和一个端口)到一个套接字端点。可以在服务器设置中使用这个函数，以便限制可能有连接到来的接口。也可以在客户端设置中使用这个函数，以便限制应当供出去的连接所使用的接口。<code>bind</code>最常见的用法是关联端口号和服务器，并使用通配符地址(<code>INADDR_ANY</code>)，它允许任何接口为到来的连接所使用。<br>&emsp;&emsp;<code>bind</code>普遍遭遇的问题是试图绑定一个已经在使用的端口。该陷阱是也许没有活动的套接字存在，但仍然禁止绑定端口(<code>bind</code>返回<code>EADDRINUSE</code>)，它由<code>TCP</code>套接字状态<code>TIME_WAIT</code>引起。该状态在套接字关闭后约保留<code>2</code>到<code>4</code>分钟。在<code>TIME_WAIT</code>状态退出之后，套接字被删除，该地址才能被重新绑定而不出问题。<br>&emsp;&emsp;等待<code>TIME_WAIT</code>结束可能是令人恼火的一件事，特别是如果您正在开发一个套接字服务器，就需要停止服务器来做一些改动，然后重启。幸运的是，有方法可以避开<code>TIME_WAIT</code>状态。可以给套接字应用<code>SO_REUSEADDR</code>套接字选项，以便端口可以马上重用。<br>&emsp;&emsp;考虑下面的例子，在绑定地址之前，我以<code>SO_REUSEADDR</code>选项调用<code>setsockopt</code>。为了允许地址重用，我设置整型参数<code>on</code>为<code>1</code>(当然可以设为<code>0</code>来禁止地址重用)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sock, ret, on;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"><span class="comment">/* Create a new stream (TCP) socket */</span></span><br><span class="line">sock = socket ( AF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line"><span class="comment">/* Enable address reuse */</span></span><br><span class="line">on = <span class="number">1</span>;</span><br><span class="line">ret = setsockopt ( sock, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span> ( on ) );</span><br><span class="line"><span class="comment">/* Allow connections to port 8080 from any available interface */</span></span><br><span class="line"><span class="built_in">memset</span> ( &amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span> ( servaddr ) );</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl ( INADDR_ANY );</span><br><span class="line">servaddr.sin_port = htons ( <span class="number">45000</span> );</span><br><span class="line"><span class="comment">/* Bind to the address (interface/port) */</span></span><br><span class="line">ret = bind ( sock, ( struct sockaddr * ) &amp;servaddr, <span class="keyword">sizeof</span> ( servaddr ) );</span><br></pre></td></tr></table></figure>
<p>在应用了<code>SO_REUSEADDR</code>选项之后，<code>bind</code>函数将允许地址的立即重用。</p>
<h3 id="隐患4：发送结构化数据"><a href="#隐患4：发送结构化数据" class="headerlink" title="隐患4：发送结构化数据"></a>隐患4：发送结构化数据</h3><p>&emsp;&emsp;套接字是发送无结构二进制字节流或<code>ASCII</code>数据流(比如<code>HTTP</code>上的<code>HTTP</code>页面，或<code>SMTP</code>上的电子邮件)的完美工具。但是如果试图在一个套接字上发送二进制数据，事情将会变得更加复杂。<br>&emsp;&emsp;例如您想要发送一个整数，您可以肯定接收者将使用同样的方式来解释该整数吗？运行在同一架构上的应用程序可以依赖它们共同的平台来对该类型的数据做出相同的解释。但是如果一个运行在高位优先的<code>PowerPC</code>上的客户端发送一个<code>32</code>位的整数到一个低位优先的<code>Intel</code>，那将会发生什么呢？字节排列将引起不正确的解释。<br>&emsp;&emsp;通过套接字发送一个<code>C</code>语言结构会怎么样呢？这里也会遇到麻烦，因为不是所有的编译器都以相同的方式排列一个结构的元素。结构也可能被压缩以便使浪费的空间最少，这进一步使结构中的元素错位。<br>&emsp;&emsp;幸好有解决这个问题的方案，能够保证两端数据的一致解释。过去，远程过程调用(<code>Remote Procedure Call</code>，<code>RPC</code>)套装工具提供所谓的外部数据表示(<code>External Data Representation</code>，<code>XDR</code>)。<code>XDR</code>为数据定义一个标准的表示来支持异构网络应用程序通信的开发。<br>&emsp;&emsp;现在有两个新的协议提供相似的功能。<code>可扩展标记语言/远程过程调用</code>(<code>XML/RPC</code>)以<code>XML</code>格式安排<code>HTTP</code>上的过程调用。数据和元数据用<code>XML</code>进行编码并作为字符串传输，并通过主机架构把值和它们的物理表示分开。<code>SOAP</code>跟随<code>XML-RPC</code>，以更好的特性和功能扩展了它的思想。</p>
<h3 id="隐患5：TCP中的帧同步假定"><a href="#隐患5：TCP中的帧同步假定" class="headerlink" title="隐患5：TCP中的帧同步假定"></a>隐患5：TCP中的帧同步假定</h3><p>&emsp;&emsp;<code>TCP</code>不提供帧同步，这使得它对于面向字节流的协议是完美的。这是<code>TCP</code>与<code>UDP</code>的一个重要区别。<code>UDP</code>是面向消息的协议，它保留发送者和接收者之间的消息边界。<code>TCP</code>是一个面向流的协议，它假定正在通信的数据是无结构的，如图<code>1</code>所示：</p>
<p><img src="/2019/03/13/Linux系统编程/Linux套接字编程中的5个隐患/1.png" height="336" width="377"></p>
<p align="center" style="color:green">图1 UDP的帧同步能力和缺乏帧同步的TCP</p>

<p>&emsp;&emsp;图<code>1</code>的上部说明一个<code>UDP</code>客户端和服务器。左边的对等层完成两个套接字的写操作，每个为<code>100</code>字节。协议栈的<code>UDP</code>层追踪写的数量，并确保当右边的接收者通过套接字获取数据时，它以同样数量的字节到达。换句话说，为读者保留了写者提供的消息边界。<br>&emsp;&emsp;现在看图<code>1</code>的底部，它为<code>TCP</code>层演示了相同粒度的写操作。两个独立的写操作(每个为<code>100</code>字节)写入流套接字。但在本例中，流套接字的读者得到的是<code>200</code>字节。协议栈的<code>TCP</code>层聚合了两次写操作，这种聚合可以发生在<code>TCP/IP</code>协议栈的发送者或接收者中任何一方。重要的是，要注意到聚合也许不会发生，即<code>TCP</code>只保证数据的有序发送。<br>&emsp;&emsp;对大多数开发人员来说，该陷阱会引起困惑。您想要获得<code>TCP</code>的可靠性和<code>UDP</code>的帧同步。除非改用其他的传输协议，比如流传输控制协议<code>STCP</code>，否则就要求应用层开发人员来实现缓冲和分段功能。</p>
<h3 id="调试套接字应用程序的工具"><a href="#调试套接字应用程序的工具" class="headerlink" title="调试套接字应用程序的工具"></a>调试套接字应用程序的工具</h3><p>&emsp;&emsp;<code>GNU/Linux</code>提供几个工具，它们可以帮助您发现套接字应用程序中的一些问题。此外，使用这些工具还有教育意义，而且能够帮助解释应用程序和<code>TCP/IP</code>协议栈的行为。</p>
<h4 id="查看网络子系统的细节"><a href="#查看网络子系统的细节" class="headerlink" title="查看网络子系统的细节"></a>查看网络子系统的细节</h4><p>&emsp;&emsp;<code>netstat</code>工具提供查看<code>GNU/Linux</code>网络子系统的能力。使用<code>netstat</code>可以查看当前活动的连接(按单个协议进行查看)，查看特定状态的连接(比如处于监听状态的服务器套接字)和许多其他的信息。下面展示了<code>netstat</code>提供的一些选项和它们启用的特性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">netstat --tcp  <span class="comment"># View all TCP sockets currently active</span></span><br><span class="line">netstat --udp  <span class="comment"># View all UDP sockets</span></span><br><span class="line">netstat --listening  <span class="comment"># View all TCP sockets in the listening state</span></span><br><span class="line">netstat --groups  <span class="comment"># View the multicast group membership information</span></span><br><span class="line">netstat --masquerade  <span class="comment"># Display the list of masqueraded connections</span></span><br><span class="line">netstat --statistics  <span class="comment"># View statistics for each protocol</span></span><br></pre></td></tr></table></figure>
<p>尽管存在许多其他的实用程序，但<code>netstat</code>的功能很全面，它覆盖了<code>route</code>、<code>ifconfig</code>和其他标准<code>GNU/Linux</code>工具的功能。</p>
<h4 id="监视流量"><a href="#监视流量" class="headerlink" title="监视流量"></a>监视流量</h4><p>&emsp;&emsp;可以使用<code>GNU/Linux</code>的几个工具来检查网络上的低层流量。<code>tcpdump</code>工具是一个比较老的工具，它从网上嗅探网络数据包，打印到<code>stdout</code>或记录在一个文件中。该功能允许查看应用程序产生的流量和<code>TCP</code>生成的低层流控制机制。一个叫做<code>tcpflow</code>的新工具与<code>tcpdump</code>相辅相成，它提供协议流分析和适当地重构数据流的方法，而不管数据包的顺序或重发。下面展示了<code>tcpdump</code>的两个用法模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -l -i eth0  <span class="comment"># Display all traffic on the eth0 interface for the local host</span></span><br><span class="line">tcpdump host plato  <span class="comment"># Show all traffic on the network coming from or going to host plato</span></span><br><span class="line">tcpdump host camus and (port http)  <span class="comment"># Show all HTTP traffic for host camus</span></span><br><span class="line">tcpdump tcp port 45000  <span class="comment"># View traffic coming from or going to TCP port 45000 on the local host</span></span><br></pre></td></tr></table></figure>
<p><code>tcpdump</code>和<code>tcpflow</code>工具有大量的选项，包括创建复杂过滤表达式的能力。</p>
<h3 id="字节交换还是不呢？"><a href="#字节交换还是不呢？" class="headerlink" title="字节交换还是不呢？"></a>字节交换还是不呢？</h3><p>&emsp;&emsp;<code>Endianness</code>是指内存中字节的排列顺序。高位优先(<code>big endian</code>)按最高有效字节在前排列，然而低位优先(<code>little endian</code>)按照最低有效字节在前排序。<br>&emsp;&emsp;高位优先架构(比如<code>PowerPC</code>)比低位优先架构(比如<code>Intel</code>的<code>Pentium</code>系列，其网络字节顺序是高位优先)有优势。这意味着对高位优先的机器来说，在<code>TCP/IP</code>内控制数据是自然有序的。低位优先架构要求字节交换，对网络应用程序来说，这是一个轻微的性能弱点。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/12/C语言语法详解/类型转换/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/12/C语言语法详解/类型转换/" itemprop="url">类型转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-12T18:17:20+08:00">
                2019-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>C</code>语言规定，不同类型的数据在参加运算时，要先转换成相同的类型，然后再进行运算。运算结果的类型是转换后的类型。而类型转换的规则可归纳为<code>3</code>种转换方式：算术运算时的自动类型转换、赋值运算时的类型转换和强制类型转换。</p>
<h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>&emsp;&emsp;自动类型转换的规则为：双目运算符的两个运算量中，值域较窄的类型向值域较宽的类型转换：</p>
<p><img src="/2019/03/12/C语言语法详解/类型转换/1.png"></p>
<ul>
<li>有符号和无符号<code>short</code>型及<code>char</code>型一律转换为<code>int</code>型。</li>
<li><code>int</code>型与<code>unsigned</code>型数据运算，直接将<code>int</code>型转换成<code>unsigned</code>型。</li>
<li><code>int</code>型与<code>long</code>型数据运算，直接将<code>int</code>型转换成<code>long</code>型。</li>
<li><code>int</code>型与<code>double</code>型数据运算，直接将<code>int</code>型转换成<code>double</code>型。</li>
<li><code>float</code>型数据自动转换成<code>double</code>型。</li>
</ul>
<h3 id="赋值转换"><a href="#赋值转换" class="headerlink" title="赋值转换"></a>赋值转换</h3><p>&emsp;&emsp;对于赋值运算，<code>C</code>语言规定：当赋值运算符右边表达式的类型与左边变量的类型不一致时，首先将右边表达式的类型转换为左边变量的类型，然后将转换后表达式的结果值赋给左边变量，整个赋值表达式的结果类型是左边变量的类型。赋值类型转换具体规则如下：</p>
<p>&emsp;&emsp;1、将整型数据赋给单、双精度变量时，数值不变，但以单、双精度实型数形式存储到变量中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> x;</span><br><span class="line">x = <span class="number">9</span>; <span class="comment">/* x的值为9.000000 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 将单、双精度实型数据赋给整型变量时，舍去实数的小数部分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">n = <span class="number">3.14159</span>; <span class="comment">/* n的值为3 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3. 字符型数据赋给整型变量时，由于字符型数据只占一个字节，而整型变量占<code>2</code>个字节。因此，将字符型数据存放到整型变量低<code>8</code>位中，而在高<code>8</code>位中补<code>1</code>或<code>0</code>(视具体机器系统处理有符号量或无符号量两种不同情况而定)。</p>
<p><img src="/2019/03/12/C语言语法详解/类型转换/2.png"></p>
<p>&emsp;&emsp;4. 带符号整型数据<code>int</code>赋给<code>long int</code>型变量时，要进行符号扩展。<br>&emsp;&emsp;5. <code>unsigned int</code>型数据赋给<code>long int</code>型变量时，只需在高位补<code>0</code>即可。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>&emsp;&emsp;在程序中可以使用强制类型转换操作符来实现数据类型的转换。强制类型转换也称为显式转换，而自动类型转换又称为隐式转换。强制类型转换的一般形式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(类型说明符) (表达式)</span><br></pre></td></tr></table></figure>
<p>其功能是把表达式的运算结果强制转换成类型说明符所表示的数据类型。例如<code>(float)(7 % 4)</code>将表达式<code>7 % 4</code>的结果转换为实型，<code>(int)(x + y)</code>将表达式<code>x + y</code>的结果转换为整型。<br>&emsp;&emsp;在使用强制类型转换时应注意以下问题：</p>
<ul>
<li>类型说明符和表达式都必须加括号(单个变量可以不加括号)。例如将<code>(int)(x + y)</code>写成<code>(int)x + y</code>则成了只将<code>x</code>转换成<code>int</code>型之后再与<code>y</code>相加。</li>
<li>无论是强制类型转换或是自动类型转换，都只是为了本次运算的需要而对常量或变量的值的类型进行临时性转换，而常量或变量本身的数据类型和值并不改变。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/12/C语言语法详解/mem函数群/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/12/C语言语法详解/mem函数群/" itemprop="url">mem函数群</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-12T17:51:29+08:00">
                2019-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="memchr"><a href="#memchr" class="headerlink" title="memchr"></a>memchr</h3><p>&emsp;&emsp;<code>memchr</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">memchr</span> <span class="params">( <span class="keyword">void</span> *ptr, <span class="keyword">int</span> value, <span class="keyword">size_t</span> num )</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数作用为从<code>ptr</code>所指内存区域的前<code>num</code>个字节查找字符<code>value</code>，当第一次遇到字符<code>ch</code>时停止查找如果成功，返回指向字符<code>ch</code>的指针，否则返回<code>NULL</code>。<br>&emsp;&emsp;与<code>strchr</code>的区别是，<code>memchr</code>检测的是一段内存，<code>strchr</code>检测的是一个字符串，如果一段内存中有<code>0x0</code>的话，显然不能用<code>strchr</code>去查找。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *pch = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"Example string"</span>;</span><br><span class="line">    pch = ( <span class="keyword">char</span> * ) <span class="built_in">memchr</span> ( str, <span class="string">'p'</span>, <span class="built_in">strlen</span> ( str ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pch != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"'p' found at position %d\n"</span>, pch - str + <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"'p' not found.\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymemchar</span> <span class="params">( <span class="keyword">void</span> *buffer, <span class="keyword">int</span> ch, <span class="keyword">size_t</span> count )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ss[] = <span class="string">"Hello, Programmers!\n"</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = ( <span class="keyword">char</span> * ) mymemchar ( ss, <span class="string">'P'</span>, <span class="built_in">strlen</span> ( ss ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( p ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"%s\n"</span>, p );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Not Found\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymemchar</span> <span class="params">( <span class="keyword">void</span> *buffer, <span class="keyword">int</span> ch, <span class="keyword">size_t</span> count )</span> </span>&#123;</span><br><span class="line">    assert ( <span class="literal">NULL</span> != buffer );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( count &amp;&amp; ( * ( <span class="keyword">unsigned</span> <span class="keyword">char</span> * ) buffer != ( <span class="keyword">unsigned</span> <span class="keyword">char</span> ) ch ) ) &#123;</span><br><span class="line">        buffer = ( <span class="keyword">unsigned</span> <span class="keyword">char</span> * ) buffer + <span class="number">1</span>;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> ( count ? ( <span class="keyword">void</span> * ) buffer : <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memcmp"><a href="#memcmp" class="headerlink" title="memcmp"></a>memcmp</h3><p>&emsp;&emsp;<code>memcmp</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *buf1, <span class="keyword">const</span> <span class="keyword">void</span> *buf2, <span class="keyword">unsigned</span> <span class="keyword">int</span> count )</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>memcmp</code>比较内存区域<code>buf1</code>和<code>buf2</code>的前<code>count</code>个字节，该函数是按字节比较的。其返回值为：</p>
<ul>
<li>当<code>buf1 &lt; buf2</code>时，返回值<code>&lt; 0</code>。</li>
<li>当<code>buf1 = buf2</code>时，返回值<code>= 0</code>。</li>
<li>当<code>buf1 &gt; buf2</code>时，返回值<code>&gt; 0</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer1[] = <span class="string">"DWgaOtP12df0"</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer2[] = <span class="string">"DWGAOTP12DF0"</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    n = <span class="built_in">memcmp</span> ( buffer1, buffer2, <span class="keyword">sizeof</span> ( buffer1 ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( n &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"'%s' is greater than '%s'.\n"</span>, buffer1, buffer2 );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( n &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"'%s' is less than '%s'.\n"</span>, buffer1, buffer2 );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"'%s' is the same as '%s'.\n"</span>, buffer1, buffer2 );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">'DWgaOtP12df0' is greater than 'DWGAOTP12DF0'.</span><br></pre></td></tr></table></figure>
<h3 id="memcpy、memmove和memccpy"><a href="#memcpy、memmove和memccpy" class="headerlink" title="memcpy、memmove和memccpy"></a>memcpy、memmove和memccpy</h3><p>&emsp;&emsp;<code>memcpy</code>和<code>memmove</code>都是<code>C</code>语言中的库函数，作用是拷贝一定长度的内存的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span> <span class="params">( <span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span> <span class="params">( <span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count )</span></span>;</span><br></pre></td></tr></table></figure>
<p>它们的作用是一样的，唯一的区别是当内存发生局部重叠的时候，<code>memmove</code>保证拷贝的结果是正确的，<code>memcpy</code>不保证拷贝的结果的正确。实际上，<code>memcpy</code>只是<code>memmove</code>的一个子集，<code>memcpy</code>比<code>memmove</code>的速度要快一些。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"Golden Global View"</span>;</span><br><span class="line">    memmove ( s, s + <span class="number">7</span>, <span class="built_in">strlen</span> ( s ) + <span class="number">1</span> - <span class="number">7</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"%s"</span>, s );</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果为<code>Global View</code>。注意，这里的拷贝长度<code>strlen(s) + 1 - 7</code>表示把字符串结尾的<code>\0</code>也拷贝进来。</p>
<p><img src="/2019/03/12/C语言语法详解/mem函数群/1.png" height="232" width="325"></p>
<p>&emsp;&emsp;第一种情况下，拷贝重叠的区域不会出现问题，内容均可以被正确地拷贝。第二种情况下，问题出现在右边的两个字节，这两个字节的原来的内容首先就被覆盖了，而且没有保存。所以接下来拷贝的时候，拷贝的是已经被覆盖的内容，显然这是有问题的。<br>&emsp;&emsp;对于库函数来说，由于没有办法知道传递给它的内存区域的情况，所以应该使用<code>memmove</code>函数。通过这个函数，可以保证不会出现任何内存块重叠问题。而对于应用程序来说，因为代码<code>知道</code>两个内存块不会重叠，所以可以安全地使用<code>memcpy</code>函数。<br>&emsp;&emsp;<code>memcpy</code>、<code>memmove</code>和<code>memccpy</code>这三个函数的功能均是将某个内存块复制到另一个内存块。前两个函数的区别在于它们处理内存区域重叠(<code>overlapping</code>)的方式不同。第三个函数的功能也是复制内存，但是如果遇到某个特定值时立即停止复制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memccpy</span> <span class="params">( <span class="keyword">void</span> *dest, <span class="keyword">void</span> *src, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch, <span class="keyword">unsigned</span> <span class="keyword">int</span> count )</span></span>;</span><br></pre></td></tr></table></figure>
<p>由<code>src</code>所指内存区域复制不多于<code>count</code>个字节到<code>dest</code>所指内存区域，如果遇到字符<code>ch</code>则停止复制(<code>ch</code>也被复制)。注意，返回指向字符<code>ch</code>后的第一个字符的指针，如果<code>src</code>前<code>n</code>个字节中不存在<code>ch</code>，则返回<code>NULL</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[] = <span class="string">"Goldenx Global View"</span>;</span><br><span class="line"><span class="keyword">char</span> d[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">p = ( <span class="keyword">char</span> * ) memccpy ( d, s, <span class="string">'x'</span>, <span class="built_in">strlen</span> ( s ) );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( p ) &#123;</span><br><span class="line">    *p = <span class="string">'\0'</span>; <span class="comment">/* MUST Do This */</span></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Char found: %s.\n"</span>, d );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Char not found.\n"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关于<code>memmove</code>的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymemmove</span> <span class="params">( <span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp[n];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> *d = dest;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s = src;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">        temp[i] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">        d[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;关于<code>memcpy</code>的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymemcpy</span> <span class="params">( <span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *d = dest;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s = src;</span><br><span class="line">    <span class="keyword">int</span> *di;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *si;</span><br><span class="line">    <span class="keyword">int</span> r = n % <span class="number">4</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( r-- ) &#123;</span><br><span class="line">        *d++ = *s++;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    di = ( <span class="keyword">int</span> * ) d;</span><br><span class="line">    si = ( <span class="keyword">const</span> <span class="keyword">int</span> * ) s;</span><br><span class="line">    n /= <span class="number">4</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( n-- ) &#123;</span><br><span class="line">        *di++ = *si++;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="memset函数详解"><a href="#memset函数详解" class="headerlink" title="memset函数详解"></a>memset函数详解</h3><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span> <span class="params">( <span class="keyword">void</span> *s, <span class="keyword">char</span> ch, <span class="keyword">unsigned</span> n )</span></span>;</span><br></pre></td></tr></table></figure>
<p>其功能是将<code>s</code>所指向的某一块内存中的每个字节的内容全部设置为<code>ch</code>指定的<code>ASCII</code>值，内存大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[] = <span class="string">"Hello world\n"</span>;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Buffer before memset: %s\n"</span>, buffer );</span><br><span class="line">    <span class="built_in">memset</span> ( buffer, <span class="string">'*'</span>, <span class="built_in">strlen</span> ( buffer ) );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Buffer after memset: %s\n"</span>, buffer );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buffer before <span class="built_in">memset</span>: Hello world</span><br><span class="line">Buffer after <span class="built_in">memset</span>: ***********</span><br></pre></td></tr></table></figure>
<h3 id="memcpy函数"><a href="#memcpy函数" class="headerlink" title="memcpy函数"></a>memcpy函数</h3><p>&emsp;&emsp;<code>memcpy</code>用来做内存拷贝，你可以用它拷贝任何数据类型的对象(可以指定拷贝的数据长度)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>], b[<span class="number">50</span>];</span><br><span class="line"><span class="comment">/* 注意如用sizeof(a)，会造成b的内存地址溢出 */</span></span><br><span class="line"><span class="built_in">memcpy</span> ( b, a, <span class="keyword">sizeof</span> ( b ) );</span><br><span class="line"><span class="built_in">strcpy</span>只能拷贝字符串，它遇到“\<span class="number">0</span>”就结束拷贝：</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>], b[<span class="number">50</span>];</span><br><span class="line"><span class="comment">/* 要注意a中的字符串长度是否超过50，如果超过，则会造成b的内存地址溢出 */</span></span><br><span class="line"><span class="built_in">strcpy</span> ( a, b );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>memset</code>可以很方便地清空一个结构类型的变量或数组，例如有如下结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sample_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> csName[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> iSeq;</span><br><span class="line">    <span class="keyword">int</span> iType;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于变量<code>struct sample_strcut stTest;</code>，清空<code>stTest</code>的一般方法为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stTest.csName[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">stTest.iSeq = <span class="number">0</span>;</span><br><span class="line">stTest.iType = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>用<code>memset</code>就非常方便：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span> ( &amp;stTest, <span class="number">0</span>, <span class="keyword">sizeof</span> ( struct sample_struct ) );</span><br></pre></td></tr></table></figure>
<p>如果是数组<code>struct sample_struct TEST[10];</code>，则清空方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span> ( TEST, <span class="number">0</span>, <span class="keyword">sizeof</span> ( struct sample_struct ) * <span class="number">10</span> );</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/94/">94</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">934</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
