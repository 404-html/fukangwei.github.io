<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="暴徒">
<meta property="og:url" content="http://fukangwei.gitee.io/page/4/index.html">
<meta property="og:site_name" content="暴徒">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="暴徒">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/4/">





  <title>暴徒</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">暴徒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/17/Qt语法详解/Qt之QDateTimeEdit、QDateEdit和QTimeEdit/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/17/Qt语法详解/Qt之QDateTimeEdit、QDateEdit和QTimeEdit/" itemprop="url">Qt之QDateTimeEdit、QDateEdit和QTimeEdit</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-17T11:31:58+08:00">
                2019-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>&emsp;&emsp;<code>QDateTime</code>类提供了一个部件，用于编辑日期和时间。<code>QDateTimeEdit</code>允许用户编辑日期，通过使用键盘或箭头键来增加和减少日期和时间值。箭头键可以在<code>QDateTimeEdit</code>内进行部分移动，日期和时间的格式按照<code>setDisplayFormat</code>设置的显示。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>&emsp;&emsp;<code>QDateTimeEdit</code>有多个构造函数，分别看看它们是如何使用的。</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QDateTimeEdit、QDateEdit和QTimeEdit/1.png"></p>
<p>&emsp;&emsp;默认情况下，如果<code>QDateTimeEdit</code>构造时不指定日期时间，系统会为其设置一个和本地相同的日期时间格式(右下角可更改本地日期时间格式)，并且值为<code>2000年1月1日0时0分0秒</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QDateTimeEdit *dateTimeEdit = <span class="keyword">new</span> QDateTimeEdit ( <span class="keyword">this</span> );</span><br><span class="line">QDateTimeEdit *dateTimeEdit2 = <span class="keyword">new</span> QDateTimeEdit ( QDateTime::currentDateTime(), <span class="keyword">this</span> );</span><br><span class="line">QDateTimeEdit *dateEdit = <span class="keyword">new</span> QDateTimeEdit ( QDate::currentDate(), <span class="keyword">this</span> );</span><br><span class="line">QDateTimeEdit *timeEdit = <span class="keyword">new</span> QDateTimeEdit ( QTime::currentTime(), <span class="keyword">this</span> );</span><br></pre></td></tr></table></figure>
<h3 id="日期时间格式"><a href="#日期时间格式" class="headerlink" title="日期时间格式"></a>日期时间格式</h3><p>&emsp;&emsp;如果不想要系统默认的格式，可以通过<code>setDisplayFormat</code>来自定设置。</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QDateTimeEdit、QDateEdit和QTimeEdit/2.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QDateTimeEdit *dateTimeEdit = <span class="keyword">new</span> QDateTimeEdit ( <span class="keyword">this</span> );</span><br><span class="line">QDateTimeEdit *dateTimeEdit2 = <span class="keyword">new</span> QDateTimeEdit ( QDateTime::currentDateTime(), <span class="keyword">this</span> );</span><br><span class="line">QDateTimeEdit *dateEdit = <span class="keyword">new</span> QDateTimeEdit ( QDate::currentDate(), <span class="keyword">this</span> );</span><br><span class="line">QDateTimeEdit *timeEdit = <span class="keyword">new</span> QDateTimeEdit ( QTime::currentTime(), <span class="keyword">this</span> );</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 设置日期时间格式 */</span></span><br><span class="line">dateTimeEdit-&gt;setDisplayFormat ( <span class="string">"yyyy-MM-dd HH:mm:ss"</span> );</span><br><span class="line">dateTimeEdit2-&gt;setDisplayFormat ( <span class="string">"yyyy/MM/dd HH-mm-ss"</span> );</span><br><span class="line">dateEdit-&gt;setDisplayFormat ( <span class="string">"yyyy.M.d"</span> );</span><br><span class="line">timeEdit-&gt;setDisplayFormat ( <span class="string">"H:mm"</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>yyyy</code>：年，用<code>4</code>个数表示。</li>
<li><code>MM</code>：月，<code>01</code>至<code>12</code>。</li>
<li><code>dd</code>：日，<code>01</code>至<code>31</code>。</li>
<li><code>HH</code>：时，<code>00</code>至<code>23</code>。</li>
<li><code>mm</code>：分，<code>00</code>至<code>59</code>。</li>
<li><code>ss</code>：秒，<code>00</code>至<code>59</code>。</li>
</ul>
<h3 id="日期时间范围"><a href="#日期时间范围" class="headerlink" title="日期时间范围"></a>日期时间范围</h3><p>&emsp;&emsp;创建了<code>QDateTimeEdit</code>对象，并设置其日期时间为今天(<code>currentDate</code>)，同时限制有效日期的范围，例如距离今天<code>±365</code>天。</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QDateTimeEdit、QDateEdit和QTimeEdit/3.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDateTimeEdit *dateEdit = <span class="keyword">new</span> QDateTimeEdit ( QDate::currentDate(), <span class="keyword">this</span> );</span><br><span class="line">dateEdit-&gt;setMinimumDate ( QDate::currentDate().addDays ( <span class="number">-365</span> ) ); <span class="comment">/* -365天 */</span></span><br><span class="line">dateEdit-&gt;setMaximumDate ( QDate::currentDate().addDays ( <span class="number">365</span> ) ); <span class="comment">/* +365天 */</span></span><br></pre></td></tr></table></figure>
<p>其他同功能的有用函数：<code>setDateTimeRange</code>、<code>setDateRange</code>、<code>setTimeRange</code>、<code>setMaximumDateTime</code>和<code>setMinimumDateTime</code>、<code>setMinimumTime</code>和<code>setMaximumTime</code>。</p>
<h3 id="显示日历"><a href="#显示日历" class="headerlink" title="显示日历"></a>显示日历</h3><p>&emsp;&emsp;默认情况下只能通过鼠标点击上下箭头来改变日期时间，如果要弹出日期控件，只需调用<code>setCalendarPopup(true)</code>即可。</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QDateTimeEdit、QDateEdit和QTimeEdit/4.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QDateTimeEdit *dateEdit = <span class="keyword">new</span> QDateTimeEdit ( QDate::currentDate(), <span class="keyword">this</span> );</span><br><span class="line">dateEdit-&gt;setMinimumDate ( QDate::currentDate().addDays ( <span class="number">-365</span> ) ); <span class="comment">/* -365天 */</span></span><br><span class="line">dateEdit-&gt;setMaximumDate ( QDate::currentDate().addDays ( <span class="number">365</span> ) ); <span class="comment">/* +365天 */</span></span><br><span class="line">dateEdit-&gt;setCalendarPopup ( <span class="literal">true</span> ); <span class="comment">/* 日历弹出 */</span></span><br></pre></td></tr></table></figure>
<p>这时的上/下箭头就变为下拉箭头了。当点击下拉箭头之后，就会弹出日历控件，由于我们设置了日期范围，所以不在范围内的日期是无法选择的(<code>disabled</code>)。</p>
<h3 id="获取日期时间"><a href="#获取日期时间" class="headerlink" title="获取日期时间"></a>获取日期时间</h3><p>&emsp;&emsp;可以通过<code>date</code>、<code>dateTime</code>等接口来获取日期时间对象，如果要获取年、月、日等信息，可以调用例如<code>QDate</code>的<code>year</code>、<code>month</code>、<code>day</code>等函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">QDateTimeEdit *dateEdit = <span class="keyword">new</span> QDateTimeEdit ( QDate::currentDate(), <span class="keyword">this</span> );</span><br><span class="line">dateEdit-&gt;setMinimumDate ( QDate::currentDate().addDays ( <span class="number">-365</span> ) ); <span class="comment">/* -365天 */</span></span><br><span class="line">dateEdit-&gt;setMaximumDate ( QDate::currentDate().addDays ( <span class="number">365</span> ) ); <span class="comment">/* +365天 */</span></span><br><span class="line">​</span><br><span class="line">QDate date = dateEdit-&gt;date(); <span class="comment">/* 日期 */</span></span><br><span class="line">QDateTime dateTime = dateEdit-&gt;dateTime(); <span class="comment">/* 日期时间 */</span></span><br><span class="line">QDate maxDate = dateEdit-&gt;maximumDate(); <span class="comment">/* 最大日期 */</span></span><br><span class="line">QDateTime maxDateTime = dateEdit-&gt;maximumDateTime(); <span class="comment">/* 最大日期时间 */</span></span><br><span class="line">QTime maxTime = dateEdit-&gt;maximumTime(); <span class="comment">/* 最大时间 */</span></span><br><span class="line">QDate minDate = dateEdit-&gt;minimumDate(); <span class="comment">/* 最小日期 */</span></span><br><span class="line">QDateTime minDateTime = dateEdit-&gt;minimumDateTime(); <span class="comment">/* 最小日期时间 */</span></span><br><span class="line">QTime minTime = dateEdit-&gt;minimumTime(); <span class="comment">/* 最小时间 */</span></span><br><span class="line">​</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"Date : "</span> &lt;&lt; date;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"DateTime : "</span> &lt;&lt; dateTime;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"MaxDate : "</span> &lt;&lt; maxDate;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"MaxDateTime : "</span> &lt;&lt; maxDateTime;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"MaxTime : "</span> &lt;&lt; maxTime;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"MinDate : "</span> &lt;&lt; minDate;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"MinDateTime : "</span> &lt;&lt; minDateTime;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"MinTime : "</span> &lt;&lt; minTime;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Date : QDate(“<span class="number">2016</span><span class="number">-09</span><span class="number">-01</span>”)</span><br><span class="line">DateTime : QDateTime(<span class="number">2016</span><span class="number">-09</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00.000</span> 中国标准时间 Qt::TimeSpec(LocalTime))</span><br><span class="line">MaxDate : QDate(“<span class="number">2017</span><span class="number">-09</span><span class="number">-01</span>”)</span><br><span class="line">MaxDateTime : QDateTime(<span class="number">2017</span><span class="number">-09</span><span class="number">-01</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59.999</span> 中国标准时间 Qt::TimeSpec(LocalTime))</span><br><span class="line">MaxTime : QTime(“<span class="number">23</span>:<span class="number">59</span>:<span class="number">59.999</span>”)</span><br><span class="line">MinDate : QDate(“<span class="number">2015</span><span class="number">-09</span><span class="number">-02</span>”)</span><br><span class="line">MinDateTime : QDateTime(<span class="number">2015</span><span class="number">-09</span><span class="number">-02</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00.000</span> 中国标准时间 Qt::TimeSpec(LocalTime))</span><br><span class="line">MinTime : QTime(“<span class="number">00</span>:<span class="number">00</span>:<span class="number">00.000</span>”)</span><br></pre></td></tr></table></figure>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>&emsp;&emsp;常用的三个信号是<code>dateChanged</code>、<code>dateTimeChanged</code>、<code>timeChanged</code>，当日期、日期时间、时间改变时发射。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QDateTimeEdit *dateTimeEdit = <span class="keyword">new</span> QDateTimeEdit ( QDateTime::currentDateTime(), <span class="keyword">this</span> );</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 连接信号和槽 */</span></span><br><span class="line">connect ( dateTimeEdit, SIGNAL ( dateChanged ( QDate ) ), <span class="keyword">this</span>, SLOT ( onDateChanged ( QDate ) ) );</span><br><span class="line">connect ( dateTimeEdit, SIGNAL ( dateTimeChanged ( QDateTime ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SLOT ( onDateTimeChanged ( QDateTime ) ) );</span><br><span class="line">connect ( dateTimeEdit, SIGNAL ( timeChanged ( QTime ) ), <span class="keyword">this</span>, SLOT ( onTimeChanged ( QTime ) ) );</span><br></pre></td></tr></table></figure>
<p>槽函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 日期发生改变时执行 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onDateChanged</span> <span class="params">( <span class="keyword">const</span> QDate &amp;date )</span> </span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"QDate : "</span> &lt;&lt; date;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 无论日期还是时间发生改变，都会执行 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onDateTimeChanged</span> <span class="params">( <span class="keyword">const</span> QDateTime &amp;dateTime )</span> </span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"QDateTime : "</span> &lt;&lt; dateTime;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 时间发生改变时执行 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onTimeChanged</span> <span class="params">( <span class="keyword">const</span> QTime &amp;time )</span> </span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"QTime : "</span> &lt;&lt; time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="日期时间部分"><a href="#日期时间部分" class="headerlink" title="日期时间部分"></a>日期时间部分</h3><p>&emsp;&emsp;枚举为<code>QDateTimeEdit::Section</code>，标识为<code>QDateTimeEdit::Sections</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QDateTimeEdit::NoSection</code></td>
<td><code>0x0000</code></td>
</tr>
<tr>
<td><code>QDateTimeEdit::AmPmSection</code></td>
<td><code>0x0001</code></td>
</tr>
<tr>
<td><code>QDateTimeEdit::MSecSection</code></td>
<td><code>0x0002</code></td>
</tr>
<tr>
<td><code>QDateTimeEdit::SecondSection</code></td>
<td><code>0x0004</code></td>
</tr>
<tr>
<td><code>QDateTimeEdit::MinuteSection</code></td>
<td><code>0x0008</code></td>
</tr>
<tr>
<td><code>QDateTimeEdit::HourSection</code></td>
<td><code>0x0010</code></td>
</tr>
<tr>
<td><code>QDateTimeEdit::DaySection</code></td>
<td><code>0x0100</code></td>
</tr>
<tr>
<td><code>QDateTimeEdit::MonthSection</code></td>
<td><code>0x0200</code></td>
</tr>
<tr>
<td><code>QDateTimeEdit::YearSection</code></td>
<td><code>0x0400</code></td>
</tr>
</tbody>
</table>
</div>
<p>常用的日期时间格式为<code>yyyy/MM/dd HH:mm:ss</code>，包含<code>6</code>部分，分别是年月日时分秒，可以通过<code>sectionCount</code>来获取数量。通过调用<code>setSelectedSection</code>可以设置当前选择的部分，如果需要获取某部分的值，可以调用<code>sectionText</code>；通过<code>sectionAt</code>来获取下标对应的部分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">QDateTimeEdit *dateEdit = <span class="keyword">new</span> QDateTimeEdit ( QDateTime::currentDateTime(), <span class="keyword">this</span> );</span><br><span class="line">dateEdit-&gt;setDisplayFormat ( <span class="string">"yyyy/MM/dd HH:mm:ss"</span> ); <span class="comment">/* 设置显示格式 */</span></span><br><span class="line">dateEdit-&gt;setSelectedSection ( QDateTimeEdit::DaySection ); <span class="comment">/* 设置所选部分 */</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">int</span> nCount = dateEdit-&gt;sectionCount(); <span class="comment">/* 部分数量 */</span></span><br><span class="line">QDateTimeEdit::Section monthSection = dateEdit-&gt;sectionAt ( <span class="number">1</span> ); <span class="comment">/* 下标为1对应的部分 */</span></span><br><span class="line">QDateTimeEdit::Section section = dateEdit-&gt;currentSection(); <span class="comment">/* 当前部分 */</span></span><br><span class="line"><span class="keyword">int</span> nIndex = dateEdit-&gt;currentSectionIndex(); <span class="comment">/* 当前部分下标 */</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 各部分对应的值 */</span></span><br><span class="line">QString strYear = dateEdit-&gt;sectionText ( QDateTimeEdit::YearSection );</span><br><span class="line">QString strMonth = dateEdit-&gt;sectionText ( QDateTimeEdit::MonthSection );</span><br><span class="line">QString strDay = dateEdit-&gt;sectionText ( QDateTimeEdit::DaySection );</span><br><span class="line">QString strHour = dateEdit-&gt;sectionText ( QDateTimeEdit::HourSection );</span><br><span class="line">QString strMinute = dateEdit-&gt;sectionText ( QDateTimeEdit::MinuteSection );</span><br><span class="line">QString strSecond = dateEdit-&gt;sectionText ( QDateTimeEdit::SecondSection );</span><br><span class="line">​</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"SectionCount : "</span> &lt;&lt; nCount;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"MonthSection : "</span> &lt;&lt; monthSection;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"CurrentSection : "</span> &lt;&lt; section;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"CurrentSectionIndex : "</span> &lt;&lt; nIndex;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"Year : "</span> &lt;&lt; strYear;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"Month : "</span> &lt;&lt; strMonth;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"Day : "</span> &lt;&lt; strDay;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"Hour : "</span> &lt;&lt; strHour;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"Minute : "</span> &lt;&lt; strMinute;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"Second : "</span> &lt;&lt; strSecond;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SectionCount : <span class="number">6</span></span><br><span class="line">MonthSection : QDateTimeEdit::Section(MonthSection)</span><br><span class="line">CurrentSection : QDateTimeEdit::Section(DaySection)</span><br><span class="line">CurrentSectionIndex : <span class="number">2</span></span><br><span class="line">Year : <span class="string">"2016"</span></span><br><span class="line">Month : <span class="string">"09"</span></span><br><span class="line">Day : <span class="string">"01"</span></span><br><span class="line">Hour : <span class="string">"14"</span></span><br><span class="line">Minute : <span class="string">"50"</span></span><br><span class="line">Second : <span class="string">"29"</span></span><br></pre></td></tr></table></figure>
<p>如果格式为<code>yyyy/MM/dd</code>，那么<code>sectionCount</code>将会返回<code>3</code>。<code>sectionAt(0)</code>将会返回<code>YearSection</code>；<code>sectionAt(1)</code>返回<code>MonthSection</code>；<code>sectionAt(2)</code>返回<code>YearSection</code>。<br>&emsp;&emsp;<strong>补充说明</strong>：<code>text</code>函数返回<code>QDateTimeEdit</code>的内容。</p>
<hr>
<h3 id="Qt之QDateEdit和QTimeEdit"><a href="#Qt之QDateEdit和QTimeEdit" class="headerlink" title="Qt之QDateEdit和QTimeEdit"></a>Qt之QDateEdit和QTimeEdit</h3><p>&emsp;&emsp;<code>QDateEdit</code>类提供了一个部件，用于编辑日期；<code>QTimeEdit</code>类提供了一个部件，用于编辑时间。<code>QDateEdit</code>和<code>QTimeEdit</code>均继承自<code>QDateTimeEdit</code>，许多特性和功能都由<code>QDateTimeEdit</code>提供。<br>&emsp;&emsp;<code>QDateEdit</code>：</p>
<ul>
<li><code>date</code>：保存了部件的显示日期。</li>
<li><code>minimumDate</code>：定义了用户可以设置的最小日期。</li>
<li><code>maximumDate</code>：定义了用户可以设置的最大日期。</li>
<li><code>displayFormat</code>：包含了一个字符串用于格式化日期。</li>
</ul>
<p>&emsp;&emsp;<code>QTimeEdit</code>：</p>
<ul>
<li><code>time</code>：保存了部件的显示时间。</li>
<li><code>minimumTime</code>：定义了用户可以设置的最小时间。</li>
<li><code>maximumTime</code>：定义了用户可以设置的最大时间。</li>
<li><code>displayFormat</code>：包含了一个字符串用于格式化时间。</li>
</ul>
<p>&emsp;&emsp;使用<code>QDateEdit</code>时，如果不设置日期，则系统会为其指定一个默认的日期，即<code>2000</code>年<code>1</code>月<code>1</code>日。使用<code>QTimeEdit</code>时，如果不设置时间，则系统会为其指定一个默认的时间，即<code>0</code>时<code>0</code>分<code>0</code>秒。所以一般都会指定一个合适的日期和时间(当前日期时间)：</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QDateTimeEdit、QDateEdit和QTimeEdit/5.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QDateEdit *dateEdit = <span class="keyword">new</span> QDateEdit ( QDate::currentDate(), <span class="keyword">this</span> );</span><br><span class="line">QTimeEdit *timeEdit = <span class="keyword">new</span> QTimeEdit ( QTime::currentTime(), <span class="keyword">this</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>QDateEdit</code>用于编辑日期，而<code>QTimeEdit</code>用于编辑时间。所以不要用<code>QDateEdit</code>来设置或获取时间，也不要用<code>QTimeEdit</code>来设置或获取日期。如果要同时操作日期时间，请使用<code>QDateTimeEdit</code>。</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QDateTimeEdit、QDateEdit和QTimeEdit/6.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QDateEdit *dateEdit = <span class="keyword">new</span> QDateEdit ( <span class="keyword">this</span> );</span><br><span class="line">QTimeEdit *timeEdit = <span class="keyword">new</span> QTimeEdit ( <span class="keyword">this</span> );</span><br><span class="line">dateEdit-&gt;setDisplayFormat ( <span class="string">"yyyy/MM/dd"</span> );</span><br><span class="line">timeEdit-&gt;setDisplayFormat ( <span class="string">"HH:mm:ss"</span> );</span><br><span class="line">dateEdit-&gt;setDateTime ( QDateTime::currentDateTime() );</span><br><span class="line">timeEdit-&gt;setDateTime ( QDateTime::currentDateTime() );</span><br></pre></td></tr></table></figure>
<p>当点击<code>QDateEdit</code>的上下箭头时，只能改变日期，而改变不了时间。同理，当点击<code>QTimeEdit</code>的上下箭头时，只能改变时间，而改变不了日期。所以即使语法正确，也不建议把<code>QDateEdit</code>和<code>QTimeEdit</code>当做<code>QDateTimeEdit</code>来用。注意，即使是设置显示格式，对于<code>QDateEdit</code>来说，只需要设置年月日即可，例如<code>yyyy/MM/dd</code>；对于<code>QTimeEdit</code>，只需要设置时分秒，例如<code>HH:mm:ss</code>。<br>&emsp;&emsp;在<code>QDateTimeEdit</code>使用过程中，分享了如何显示日历。而日历是对应的是<code>QDate</code>，而非<code>QTime</code>。所以<code>QDateEdit</code>、<code>QDateTimeEdit</code>可以使用，而<code>QTimeEdit</code>并不能使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QDateTimeEdit *dateTimeEdit = <span class="keyword">new</span> QDateTimeEdit ( <span class="keyword">this</span> );</span><br><span class="line">QDateEdit *dateEdit = <span class="keyword">new</span> QDateEdit ( <span class="keyword">this</span> );</span><br><span class="line">QTimeEdit *timeEdit = <span class="keyword">new</span> QTimeEdit ( <span class="keyword">this</span> );</span><br><span class="line">dateTimeEdit-&gt;setCalendarPopup ( <span class="literal">true</span> ); <span class="comment">/* 正确 */</span></span><br><span class="line">dateEdit-&gt;setCalendarPopup ( <span class="literal">true</span> ); <span class="comment">/* 正确 */</span></span><br><span class="line">timeEdit-&gt;setCalendarPopup ( <span class="literal">true</span> ); <span class="comment">/* 语法正确但实际上是错误的 */</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/17/Qt语法详解/Qt之进度条/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/17/Qt语法详解/Qt之进度条/" itemprop="url">Qt之进度条</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-17T10:33:10+08:00">
                2019-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>Qt</code>可以用<code>QProgressBar</code>或着<code>QProgressDialog</code>来实现进度条。</p>
<h3 id="QProgressBar"><a href="#QProgressBar" class="headerlink" title="QProgressBar"></a>QProgressBar</h3><p>&emsp;&emsp;首先在<code>Qt Designer</code>中拖一个按钮和进度条部件，按照下面的方法进行初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;progressBar-&gt;setRange ( <span class="number">0</span>, <span class="number">50000</span> - <span class="number">1</span> );</span><br><span class="line">ui-&gt;progressBar-&gt;setValue ( <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p>按钮的事件处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::on_pushButton_clicked() &#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20000</span>; j++ ); <span class="comment">/* 延时作用 */</span></span><br><span class="line">​</span><br><span class="line">        ui-&gt;progressBar-&gt;setValue ( i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以显示进度条了，并自动计算和显示百分比：</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之进度条/1.png"></p>
<h3 id="QProgressDialog"><a href="#QProgressDialog" class="headerlink" title="QProgressDialog"></a>QProgressDialog</h3><p>&emsp;&emsp;<code>QProcessDialog</code>也是类似的，只不过这是以对话框形式显示；并且它还提供了一个取消按钮，用来取消操作。<code>QProcessDialog</code>会自动计算并显示百分比：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::on_pushButton_clicked() &#123;</span><br><span class="line">    <span class="function">QProgressDialog <span class="title">process</span> <span class="params">( <span class="keyword">this</span> )</span></span>;</span><br><span class="line">    process.setLabelText ( tr ( <span class="string">"processing..."</span> ) );</span><br><span class="line">    process.setRange ( <span class="number">0</span>, <span class="number">50000</span> );</span><br><span class="line">    process.setModal ( <span class="literal">true</span> );</span><br><span class="line">    process.setCancelButtonText ( tr ( <span class="string">"cancel"</span> ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20000</span>; j++ );</span><br><span class="line">​</span><br><span class="line">        process.setValue ( i );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( process.wasCanceled() ) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/17/Qt语法详解/Qt之进度条/2.png"></p>
<p>或者如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对话框标签内容、取消按钮的显示文本、最小值、最大值、父窗口 */</span></span><br><span class="line"><span class="function">QProgressDialog <span class="title">dialog</span> <span class="params">( tr ( <span class="string">"文件复制进度"</span> ), tr ( <span class="string">"取消"</span> ), <span class="number">0</span>, <span class="number">50000</span>, <span class="keyword">this</span> )</span></span>;</span><br><span class="line">dialog.setWindowTitle ( tr ( <span class="string">"进度对话框"</span> ) ); <span class="comment">/* 设置窗口标题 */</span></span><br><span class="line">dialog.setWindowModality ( Qt::WindowModal ); <span class="comment">/* 将对话框设置为模态 */</span></span><br><span class="line">dialog.show();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++ ) &#123; <span class="comment">/* 演示复制进度 */</span></span><br><span class="line">    dialog.setValue ( i ); <span class="comment">/* 设置进度条的当前值 */</span></span><br><span class="line">    QCoreApplication::processEvents(); <span class="comment">/* 避免界面冻结 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( dialog.wasCanceled() ) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">/* 按下取消按钮则中断 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 这样才能显示100%，因为for循环中少加了一个数 */</span></span><br><span class="line">dialog.setValue ( <span class="number">50000</span> );</span><br><span class="line">qDebug() &lt;&lt; tr ( <span class="string">"复制结束！"</span> );</span><br></pre></td></tr></table></figure>
<p>可以使用<code>setMinimum(int)</code>和<code>setMaximum(int)</code>函数来设置进度条范围的最小值与最大值。<br>&emsp;&emsp;当进行数据或者文件传输时，进度条的设置类似于下面的方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">connect ( ftp, SIGNAL ( dataTransferProgress ( qint64, qint64 ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SLOT ( updateDataTransferProgress ( qint64, qint64 ) ) );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MainWindow::updateDataTransferProgress ( qint64 readBytes, qint64 totalBytes ) &#123;</span><br><span class="line">    ui-&gt;progressBar-&gt;setMaximum ( totalBytes );</span><br><span class="line">    ui-&gt;progressBar-&gt;setValue ( readBytes );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>hide：实现<code>QProgressBar</code>进度条的隐藏。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/16/Qt语法详解/Qt之键盘事件/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/16/Qt语法详解/Qt之键盘事件/" itemprop="url">Qt之键盘事件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T18:57:05+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;在<code>Qt</code>中，可以使用<code>void QWidget::keyPressEvent ( QKeyEvent * event )</code>来进行键盘响应：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Widget::keyPressEvent ( QKeyEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;key() == Qt::Key_A ) &#123;</span><br><span class="line">        <span class="comment">/* 当按下按键“A”时，do something */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( event-&gt;key() == Qt::Key_D ) &#123;</span><br><span class="line">        <span class="comment">/* 当按下按键“D”时，do something */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( event-&gt;key() == Qt::Key_W ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( event-&gt;state() == Qt::ShiftButton ) &#123;</span><br><span class="line">            <span class="comment">/* 当按下“Shift+W”时，do something */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mylineedit.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYLINEEDIT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYLINEEDIT_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLineEdit&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLineEdit</span> :</span> <span class="keyword">public</span> QLineEdit &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyLineEdit</span> <span class="params">( QWidget *parent = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">keyPressEvent</span> <span class="params">( QKeyEvent *event )</span></span>;</span><br><span class="line">signals:</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYLINEEDIT_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>widget.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDGET_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLineEdit</span>;</span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> QWidget &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span> <span class="params">( QWidget *parent = <span class="number">0</span> )</span></span>;</span><br><span class="line">    ~Widget();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">keyPressEvent</span> <span class="params">( QKeyEvent *event )</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">    MyLineEdit *lineEdit;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>widget.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mylineedit.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QKeyEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line">​</span><br><span class="line">Widget::Widget ( QWidget *parent ) : QWidget ( parent ),</span><br><span class="line">    ui ( <span class="keyword">new</span> Ui::Widget ) &#123;</span><br><span class="line">    ui-&gt;setupUi ( <span class="keyword">this</span> );</span><br><span class="line">    lineEdit = <span class="keyword">new</span> MyLineEdit ( <span class="keyword">this</span> );</span><br><span class="line">    lineEdit-&gt;move ( <span class="number">100</span>, <span class="number">100</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">Widget::~Widget() &#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> Widget::keyPressEvent ( QKeyEvent *event ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; tr ( <span class="string">"Widget键盘按下事件"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mylineedit.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mylineedit.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QKeyEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line">​</span><br><span class="line">MyLineEdit::MyLineEdit ( QWidget *parent ) : QLineEdit ( parent ) &#123;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MyLineEdit::keyPressEvent ( QKeyEvent *event ) &#123; <span class="comment">/* 键盘按下事件 */</span></span><br><span class="line">    qDebug() &lt;&lt; tr ( <span class="string">"MyLineEdit键盘按下事件"</span> );</span><br><span class="line">    QLineEdit::keyPressEvent ( event ); <span class="comment">/* 执行QLineEdit类的默认事件处理 */</span></span><br><span class="line">    event-&gt;ignore(); <span class="comment">/* 忽略该事件 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增加代码<code>QLineEdit::keyPressEvent(event);</code>是为了让行编辑器能够正常工作，即显示字符。事件是先传递给指定窗口部件的，这里确切地说应该是先传递给获得焦点的窗口部件的。但是如果该部件忽略掉该事件，那么这个事件就会传递给这个部件的父部件。在重新实现事件处理函数时，一般要调用父类的相应事件处理函数来实现默认操作。</p>
<p><img src="/2019/03/16/Qt语法详解/Qt之键盘事件/1.png"></p>
<p>&emsp;&emsp;关于<code>Qt</code>中的方向键，代码如下：<br>&emsp;&emsp;<code>widget.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDGET_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> QWidget &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span> <span class="params">( QWidget *parent = <span class="number">0</span> )</span></span>;</span><br><span class="line">    ~Widget();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">keyPressEvent</span> <span class="params">( QKeyEvent *event )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">keyReleaseEvent</span> <span class="params">( QKeyEvent *event )</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">    <span class="keyword">bool</span> keyUp; <span class="comment">/* 向上方向键按下的标志 */</span></span><br><span class="line">    <span class="keyword">bool</span> keyLeft; <span class="comment">/* 向左方向键按下的标志 */</span></span><br><span class="line">    <span class="keyword">bool</span> move; <span class="comment">/* 是否完成了一次移动 */</span></span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>widget.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QKeyEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line">​</span><br><span class="line">Widget::Widget ( QWidget *parent ) : QWidget ( parent ), ui ( <span class="keyword">new</span> Ui::Widget ) &#123;</span><br><span class="line">    ui-&gt;setupUi ( <span class="keyword">this</span> );</span><br><span class="line">    setFocus(); <span class="comment">/* 使主界面获得焦点 */</span></span><br><span class="line">    <span class="comment">/* 初始化变量 */</span></span><br><span class="line">    keyUp = <span class="literal">false</span>;</span><br><span class="line">    keyLeft = <span class="literal">false</span>;</span><br><span class="line">    move = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">Widget::~Widget() &#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 键盘按下事件 */</span></span><br><span class="line"><span class="keyword">void</span> Widget::keyPressEvent ( QKeyEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;key() == Qt::Key_Up ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( event-&gt;isAutoRepeat() ) &#123; <span class="comment">/* 按键重复时不做处理 */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        keyUp = <span class="literal">true</span>; <span class="comment">/* 标记向上方向键已经按下 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( event-&gt;key() == Qt::Key_Left ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( event-&gt;isAutoRepeat() ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        keyLeft = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 按键释放事件 */</span></span><br><span class="line"><span class="keyword">void</span> Widget::keyReleaseEvent ( QKeyEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;key() == Qt::Key_Up ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( event-&gt;isAutoRepeat() ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        keyUp = <span class="literal">false</span>; <span class="comment">/* 释放按键后将标志设置为false */</span></span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( move ) &#123; <span class="comment">/* 如果已经完成了移动 */</span></span><br><span class="line">            move = <span class="literal">false</span>; <span class="comment">/* 设置标志为false */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( keyLeft ) &#123; <span class="comment">/* 如果向左方向键已经按下且没有释放 */</span></span><br><span class="line">            ui-&gt;pushButton-&gt;move ( <span class="number">30</span>, <span class="number">80</span> ); <span class="comment">/* 斜移 */</span></span><br><span class="line">            move = <span class="literal">true</span>; <span class="comment">/* 标记已经移动 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ui-&gt;pushButton-&gt;move ( <span class="number">120</span>, <span class="number">80</span> ); <span class="comment">/* 否则直接上移 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( event-&gt;key() == Qt::Key_Left ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( event-&gt;isAutoRepeat() ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        keyLeft = <span class="literal">false</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( move ) &#123;</span><br><span class="line">            move = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( keyUp ) &#123;</span><br><span class="line">            ui-&gt;pushButton-&gt;move ( <span class="number">30</span>, <span class="number">80</span> );</span><br><span class="line">            move = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ui-&gt;pushButton-&gt;move ( <span class="number">30</span>, <span class="number">120</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( event-&gt;key() == Qt::Key_Down ) &#123; <span class="comment">/* 使用向下方向键来还原按钮的位置 */</span></span><br><span class="line">        ui-&gt;pushButton-&gt;move ( <span class="number">120</span>, <span class="number">120</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里先在键盘按下事件处理函数中对向上方向键和向左方向键是否按下做了标记，并且当它们自动重复时不做任何处理。然后在按键释放事件处理函数中分别对这两个按键的释放做了处理。大致过程是这样的：当按下向左方向键时，在键盘按下事件处理函数中便会标记<code>keyLeft</code>为真，此时若又按下向上方向键，那么<code>keyUp</code>也标记为真。先放开向上方向键，在按键释放事件处理函数中会标记<code>keyUp</code>为假，因为此时<code>keyLeft</code>为真，所以进行斜移，并且将已经移动标志<code>move</code>标志为真。此时再释放向左方向键，在按键释放事件处理函数中会标记<code>keyLeft</code>为假，因为已经进行了斜移操作，<code>move</code>此时为真，所以这里不再进行操作，将<code>move</code>标记为假。这样就完成了整个斜移操作，而且所有的标志又恢复了操作前的状态。这个程序只是提供一种思路，并不是实现这种操作的最好办法，因为这里按键重复功能被忽略了。</p>
<p><img src="/2019/03/16/Qt语法详解/Qt之键盘事件/2.png" height="270" width="312"></p>
<p>&emsp;&emsp;如果想要实现按下<code>Ctrl + M</code>来实现窗口的最大化，把代码进行如下修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Widget::keyPressEvent ( QKeyEvent *event ) &#123; <span class="comment">/* 键盘按下事件 */</span></span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;modifiers() == Qt::ControlModifier ) &#123; <span class="comment">/* 是否按下Ctrl键 */</span></span><br><span class="line">        <span class="keyword">if</span> ( event-&gt;key() == Qt::Key_M ) &#123; <span class="comment">/* 是否按下M键 */</span></span><br><span class="line">            setWindowState ( Qt::WindowMaximized ); <span class="comment">/* 窗口最大化 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        QWidget::keyPressEvent ( event );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> Widget::keyReleaseEvent ( QKeyEvent *event ) &#123; <span class="comment">/* 按键释放事件 */</span></span><br><span class="line">    <span class="comment">/* 其他操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/16/Qt语法详解/Qt之QSpinBox和QDoubleSpinBox/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/16/Qt语法详解/Qt之QSpinBox和QDoubleSpinBox/" itemprop="url">Qt之QSpinBox和QDoubleSpinBox</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T17:08:43+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>&emsp;&emsp;<code>QSpinBox</code>和<code>QDoubleSpinBox</code>均派生自<code>QAbstractSpinBox</code>。<code>QSpinBox</code>旨在处理整数和离散值(例如月份名称)，<code>QDoubleSpinBox</code>则用于处理浮点值。它们之间的区别就是处理数据的类型不同，其他功能都基本相同。<code>QDoubleSpinBox</code>的默认的精度是<code>2</code>位小数，但可以通过<code>setDecimals</code>来改变。</p>
<h3 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h3><p>&emsp;&emsp;<code>QSpinBox</code>类提供了一个微调框部件。<code>QSpinBox</code>允许用户选择一个值，通过单击<code>向上/向下</code>按钮或按下键盘的<code>上/下</code>箭头来增加或减少当前显示的值，用户也可以输入值。微调框支持整数值，但可以被扩展为不同的字符串，使用<code>validate</code>、<code>textFromValue</code>和<code>valueFromText</code>。<br>&emsp;&emsp;当<code>QSpinBox</code>的值发生改变时，会发射两个<code>valueChanged</code>信号，其中一个提供<code>int</code>类型，另一个则是<code>QString</code>类型，该<code>QString</code>提供了<code>prefix</code>和<code>suffix</code>。当前值可以用<code>value</code>来读取，<code>setValue</code>来设置。<br>&emsp;&emsp;单击<code>向上/向下</code>按钮或按下键盘的<code>上/下</code>箭头时，将以<code>singleStep</code>为步长增加或减少当前值。如果想改变这种行为，可以重载虚函数<code>stepBy</code>。最小值、最大值和步长可以使用其中的一个构造函数来设置，以后可以用<code>setMinimum</code>、<code>setMaximum</code>和<code>setSingleStep</code>来修改。<br>&emsp;&emsp;大多数微调框是定向的，但也可以设置为循环的。例如如果取值范围是<code>0</code>至<code>99</code>，当前值是<code>99</code>时，如果<code>wrapping</code>被设置为<code>true</code>，点击<code>向上</code>按钮值会变为<code>0</code>。如果你想要一个循环微调框，可以使用<code>setWrapping</code>函数。显示的值可以和任意的字符串进行附加，使用<code>setPrefix</code>和<code>setSuffix</code>分别可以设置前缀和后缀，例如货币或计量单位。微调框中的文本可以用<code>text</code>函数(包括任何前缀和后缀)或者通过<code>cleanText</code>函数(没有前缀、没有后缀、无前导或结尾空白)来获取。<br>&emsp;&emsp;除了数值的范围，通常需要使用<code>setSpecialValueText</code>给用户一个特殊(默认)的选择。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>&emsp;&emsp;构建一个<code>QSpinBox</code>，范围是<code>20</code>至<code>200</code>，步长为<code>10</code>，开启循环。</p>
<p><img src="/2019/03/16/Qt语法详解/Qt之QSpinBox和QDoubleSpinBox/1.png"></p>
<p>&emsp;&emsp;设置步长为<code>10</code>以后，当值发生改变时，就会在当前值的基础上<code>±10</code>(相当于一个等差数列，公差为<code>10</code>)。开启循环后，当前值达到最大或者最小时，就会循环(类似于听歌的列表循环)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSpinBox&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> CustomWindow &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit MainWindow ( QWidget *parent = 0 ) : CustomWindow ( parent ) &#123;</span><br><span class="line">        QSpinBox *pSpinBox = <span class="keyword">new</span> QSpinBox ( <span class="keyword">this</span> );</span><br><span class="line">        pSpinBox-&gt;setRange ( <span class="number">20</span>, <span class="number">200</span> ); <span class="comment">/* 范围 */</span></span><br><span class="line">        pSpinBox-&gt;setSingleStep ( <span class="number">10</span> ); <span class="comment">/* 步长 */</span></span><br><span class="line">        pSpinBox-&gt;setValue ( <span class="number">150</span> ); <span class="comment">/* 当前值 */</span></span><br><span class="line">        pSpinBox-&gt;setPrefix ( <span class="string">"$ "</span> ); <span class="comment">/* 前缀 */</span></span><br><span class="line">        pSpinBox-&gt;setSuffix ( <span class="string">" %"</span> ); <span class="comment">/* 后缀 */</span></span><br><span class="line">        pSpinBox-&gt;setWrapping ( <span class="literal">true</span> ); <span class="comment">/* 开启循环 */</span></span><br><span class="line">        connect ( pSpinBox, <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> ( QSpinBox::* ) ( <span class="keyword">int</span> ) &gt; \</span><br><span class="line">            ( &amp;QSpinBox::valueChanged ), [ = ] ( <span class="keyword">int</span> value ) &#123;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">"Value : "</span>  &lt;&lt; value;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">"Text : "</span>  &lt;&lt; pSpinBox-&gt;text();</span><br><span class="line">        &#125; );</span><br><span class="line">        connect ( pSpinBox, <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> ( QSpinBox::* ) ( <span class="keyword">const</span> QString &amp; ) &gt; \</span><br><span class="line">            ( &amp;QSpinBox::valueChanged ), [ = ] ( <span class="keyword">const</span> QString &amp; text ) &#123;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">"Text Value : "</span>  &lt;&lt; text;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">"Clean Text : "</span> &lt;&lt; pSpinBox-&gt;cleanText();</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里使用了<code>Qt5</code>的信号与槽语法，由于<code>valueChanged</code>是一个重载信号，所以需要进行参数类别区分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Text Value : <span class="string">"$ 170 %"</span></span><br><span class="line">Clean Text : <span class="string">"170"</span></span><br><span class="line">Value : <span class="number">170</span></span><br><span class="line">Text : <span class="string">"$ 170 %"</span></span><br></pre></td></tr></table></figure>
<h3 id="特殊文本值"><a href="#特殊文本值" class="headerlink" title="特殊文本值"></a>特殊文本值</h3><p>&emsp;&emsp;如果设置了<code>specialValueText</code>，只要当前值等于微调框的最小值时，将显示该文本，而不是一个数值。典型的用途是表明此选择具有特殊(默认)的意思。</p>
<p><img src="/2019/03/16/Qt语法详解/Qt之QSpinBox和QDoubleSpinBox/2.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QSpinBox *zoomSpinBox = <span class="keyword">new</span> QSpinBox ( <span class="keyword">this</span> );</span><br><span class="line">zoomSpinBox-&gt;setRange ( <span class="number">0</span>, <span class="number">1000</span> ); <span class="comment">/* 范围 */</span></span><br><span class="line">zoomSpinBox-&gt;setSingleStep ( <span class="number">10</span> ); <span class="comment">/* 步长 */</span></span><br><span class="line">zoomSpinBox-&gt;setSuffix ( <span class="string">"%"</span> ); <span class="comment">/* 前缀 */</span></span><br><span class="line">zoomSpinBox-&gt;setSpecialValueText ( tr ( <span class="string">"Automatic"</span> ) ); <span class="comment">/* 特殊文本值 */</span></span><br><span class="line">zoomSpinBox-&gt;setValue ( <span class="number">100</span> ); <span class="comment">/* 当前值 */</span></span><br></pre></td></tr></table></figure>
<p>一旦当前值变为最小值时，显示的就是<code>Automatic</code>。</p>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>&emsp;&emsp;如果使用<code>prefix</code>、<code>suffix</code>和<code>specialValueText</code>没有提供足够的控制，可以子类化<code>QSpinBox</code>，重写<code>valueFromText</code>和<code>textFromValue</code>。例如自定义一个微调框，允许用户输入图标大小(例如<code>32 * 32</code>)：</p>
<p><img src="/2019/03/16/Qt语法详解/Qt之QSpinBox和QDoubleSpinBox/3.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSpinBox&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IconSizeSpinBox</span> :</span> <span class="keyword">public</span> QSpinBox &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">IconSizeSpinBox</span> <span class="params">( QWidget *parent = <span class="number">0</span> )</span> </span>&#123;&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/* 将输入的文本解读为适当的值 */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">valueFromText</span> <span class="params">( <span class="keyword">const</span> QString &amp;text )</span> <span class="keyword">const</span> Q_DECL_OVERRIDE </span>&#123;</span><br><span class="line">        <span class="function">QRegExp <span class="title">regExp</span> <span class="params">( tr ( <span class="string">"(\\d+)(\\s*[xx]\\s*\\d+)?"</span> ) )</span></span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( regExp.exactMatch ( text ) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> regExp.cap ( <span class="number">1</span> ).toInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 根据输入的值返回文本 */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QString <span class="title">textFromValue</span> <span class="params">( <span class="keyword">int</span> value )</span> <span class="keyword">const</span> Q_DECL_OVERRIDE </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tr ( <span class="string">"%1 x %1"</span> ).arg ( value );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="QDoubleSpinBox"><a href="#QDoubleSpinBox" class="headerlink" title="QDoubleSpinBox"></a>QDoubleSpinBox</h3><p>&emsp;&emsp;上面的所有功能对于<code>QDoubleSpinBox</code>同样适用。一般使用<code>setDecimals</code>设置精度，然后利用<code>setSingleStep</code>来设置步长。</p>
<p><img src="/2019/03/16/Qt语法详解/Qt之QSpinBox和QDoubleSpinBox/4.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QDoubleSpinBox *pSpinBox = <span class="keyword">new</span> QDoubleSpinBox ( <span class="keyword">this</span> );</span><br><span class="line">pSpinBox-&gt;setRange ( <span class="number">0</span>, <span class="number">20</span> ); <span class="comment">/* 范围 */</span></span><br><span class="line">pSpinBox-&gt;setDecimals ( <span class="number">3</span> ); <span class="comment">/* 精度 */</span></span><br><span class="line">pSpinBox-&gt;setSingleStep ( <span class="number">0.005</span> ); <span class="comment">/* 步长 */</span></span><br><span class="line"></span><br><span class="line">connect ( pSpinBox, <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> ( QDoubleSpinBox::* ) ( <span class="keyword">const</span> QString &amp; ) &gt; \</span><br><span class="line">    ( &amp;QDoubleSpinBox::valueChanged ), [ = ] ( <span class="keyword">const</span> QString &amp;text ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; text;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/16/Qt应用示例/Qt添加资源文件/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/16/Qt应用示例/Qt添加资源文件/" itemprop="url">Qt添加资源文件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T16:51:49+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;编写<code>gui</code>时，可能需要一些额外的资源(比如贴图用的图片)，可以使用<code>Qt</code>的资源文件进行统一管理。<br>&emsp;&emsp;1. 右击项目文件夹，选择添加新文件，然后选择<code>Qt</code>，最后是<code>Qt resource file</code>。</p>
<p><img src="/2019/03/16/Qt应用示例/Qt添加资源文件/1.png" height="250" width="433"></p>
<p>&emsp;&emsp;2. 填写好<code>name</code>后点下一步，最终完成资源文件的创建。然后右击项目中生成的<code>.qrc</code>文件，点击<code>添加前缀</code>。</p>
<p><img src="/2019/03/16/Qt应用示例/Qt添加资源文件/2.png"></p>
<p>&emsp;&emsp;3. 添加好前缀之后就可以添加图片文件了。选择需要添加的文件，然后保存，这样就可以在资源浏览器中看到那些添加的图片资源，也就能在代码中引用了。</p>
<p><img src="/2019/03/16/Qt应用示例/Qt添加资源文件/3.png" height="260" width="284"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/16/Linux系统编程/fork和vfork函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/16/Linux系统编程/fork和vfork函数/" itemprop="url">fork和vfork函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T15:40:43+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>&emsp;&emsp;<code>fork</code>函数的功能是创建子进程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork ( <span class="keyword">void</span> );</span><br></pre></td></tr></table></figure>
<p><code>fork</code>的奇妙之处在于它被调用一次，却返回两次，它可能有三种不同的返回值：</p>
<ul>
<li>在父进程中，<code>fork</code>返回新创建的子进程的<code>PID</code>。</li>
<li>在子进程中，<code>fork</code>返回<code>0</code>。</li>
<li>如果出现错误，<code>fork</code>返回一个负值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"This is father process\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"This is child process\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在<code>pid = fork();</code>之前，只有一个进程在执行，但在这条语句执行之后，就变成两个进程在执行了，这两个进程的共享代码段，将要执行的下一条语句都是<code>if(pid == 0)</code>。两个进程中，原来就存在的那个进程被称作<code>父进程</code>，新出现的那个进程被称作<code>子进程</code>，父子进程的区别在于进程标识符(<code>PID</code>)不同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    pid = fork();</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"count is %d\n"</span>, count );</span><br><span class="line">    <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">1</span></span><br><span class="line">count = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对<code>fork</code>函数，子进程的数据空间、堆栈空间都会从父进程得到一个拷贝，而不是共享。在子进程中对<code>count</code>进行加<code>1</code>的操作，并没有影响到父进程中的<code>count</code>值，父进程中的<code>count</code>值仍然为<code>0</code>。</p>
<h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><p>&emsp;&emsp;<code>vfork</code>函数的功能是创建子进程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> vfork ( <span class="keyword">void</span> );</span><br></pre></td></tr></table></figure>
<p><code>vfork</code>和<code>fork</code>的区别如下：</p>
<ul>
<li><code>fork</code>：子进程拷贝父进程的数据段，父、子进程的执行次序不确定。</li>
<li><code>vfork</code>：子进程与父进程共享数据段，子进程先运行，父进程后运行。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    pid = vfork();</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"count is %d\n"</span>, count );</span><br><span class="line">    <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="vfork挂掉的一个问题"><a href="#vfork挂掉的一个问题" class="headerlink" title="vfork挂掉的一个问题"></a>vfork挂掉的一个问题</h3><p>&emsp;&emsp;有个人问了这样的一个问题：为什么<code>vfork</code>的子进程里用<code>return</code>，整个程序会挂掉，而且<code>exit</code>不会？但如果把子进程的<code>return</code>改成<code>exit(0)</code>就没事。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    var = <span class="number">88</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( pid = vfork() ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"vfork error"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123; <span class="comment">/* 子进程 */</span></span><br><span class="line">        var++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"pid = %d, glob = %d, var = %d\n"</span>, getpid(), glob, var );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>&emsp;&emsp;首先说一下<code>fork</code>和<code>vfork</code>的差别：</p>
<ul>
<li><code>fork</code>是创建一个子进程，并把父进程的内存数据<code>copy</code>到子进程中。</li>
<li><code>vfork</code>是创建一个子进程，并和父进程的内存数据<code>share</code>一起用。</li>
</ul>
<p>这两个的差别是，一个是<code>copy</code>，一个是<code>share</code>。<code>vfork</code>是这样的工作的：保证子进程先执行；当子进程调用<code>exit</code>或<code>exec</code>后，父进程往下执行。</p>
<h4 id="为什么return会挂掉，exit不会？"><a href="#为什么return会挂掉，exit不会？" class="headerlink" title="为什么return会挂掉，exit不会？"></a>为什么return会挂掉，exit不会？</h4><p>&emsp;&emsp;从上面可以知道，结束子进程的调用是<code>exit</code>而不是<code>return</code>，如果你在<code>vfork</code>中<code>return</code>了，那么这就意味<code>main</code>函数<code>return</code>了，注意因为函数栈父子进程共享，所以整个程序的栈就跪了。如果你在子进程中<code>return</code>，那么基本是下面的过程：</p>
<ol>
<li>子进程的<code>main</code>函数<code>return</code>了，于是程序的函数栈发生了变化。</li>
<li>而<code>main</code>函数<code>return</code>后，通常会调用<code>exit</code>或相似的函数，如<code>_exit</code>、<code>_exitgroup</code>。</li>
<li>这时父进程收到子进程<code>exit</code>，开始从<code>vfork</code>返回。但是父进程的栈都被子进程的<code>return</code>给废掉了，于是代码崩溃了(对于某些内核版本，直接报<code>栈错误</code>就给跪了。然而对于其他内核版本，有可能会再次调用<code>main</code>，于是进入了一个无限循环的结果，直到<code>vfork</code>调用返回<code>error</code>)。</li>
</ol>
<p>&emsp;&emsp;现在再回到<code>return</code>和<code>exit</code>，<code>return</code>会释放局部变量并弹栈，回到上级函数执行；<code>exit</code>直接退掉。如果用过<code>C++</code>就会知道，<code>return</code>会调用局部对象的析构函数，<code>exit</code>不会(<code>exit</code>不是系统调用，是<code>glibc</code>对系统调用<code>_exit</code>或<code>_exitgroup</code>的封装)。可见，子进程调用<code>exit</code>没有修改函数栈，所以父进程得以顺利执行。</p>
<h4 id="关于fork的优化"><a href="#关于fork的优化" class="headerlink" title="关于fork的优化"></a>关于fork的优化</h4><p>&emsp;&emsp;<code>fork</code>太耗费资源，而<code>vfork</code>又太危险，所以就有人开始优化<code>fork</code>。优化的技术用到了著名的写时拷贝(<code>COW</code>)，也就是说对于<code>fork</code>后并不是马上拷贝内存，而是只有你在需要改变的时候，才会从父进程中拷贝到子进程中，这样<code>fork</code>后立马执行<code>exec</code>的成本就非常小了。所以<code>Linux</code>的<code>Man Page</code>中并不鼓励使用<code>vfork</code>。</p>
<hr>
<h3 id="Linux下fork的运行机制"><a href="#Linux下fork的运行机制" class="headerlink" title="Linux下fork的运行机制"></a>Linux下fork的运行机制</h3><p>&emsp;&emsp;面试题代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid1;</span><br><span class="line">    <span class="keyword">pid_t</span> pid2;</span><br><span class="line">    pid1 = fork();</span><br><span class="line">    pid2 = fork();</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"pid1:%d, pid2:%d\n"</span>, pid1, pid2 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>条件为：已知从这个程序执行到这个程序的所有进程结束这个时间段内，没有其它新进程执行。</p>
<ul>
<li>请说出执行这个程序后，将一共运行几个进程。</li>
<li>如果其中一个进程的输出结果是<code>pid1:1001, pid2:1002</code>，写出其他进程的输出结果(不考虑进程执行顺序)。</li>
</ul>
<h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><ul>
<li>进程可以看做程序的一次执行过程。<code>Linux</code>下的每个进程有唯一的<code>PID</code>标识进程。<code>PID</code>是一个从<code>1</code>到<code>32768</code>的正整数，其中<code>1</code>一般是特殊进程<code>init</code>，其它进程从<code>2</code>开始依次编号。当用完<code>32768</code>后，从<code>2</code>重新开始。</li>
<li><code>Linux</code>中有一个叫进程表的结构，用来存储当前正在运行的进程。可以使用<code>ps -aux</code>命令查看所有正在运行的进程。</li>
<li>进程在<code>Linux</code>中呈树状结构，<code>init</code>为根节点，其它进程均有父进程，某进程的父进程就是启动这个进程的进程，这个进程叫做父进程的子进程。</li>
<li><code>fork</code>的作用是复制一个与当前进程一样的进程。新进程的所有数据(变量、环境变量、程序计数器等)数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</li>
</ul>
<h4 id="解题的关键"><a href="#解题的关键" class="headerlink" title="解题的关键"></a>解题的关键</h4><p>&emsp;&emsp;我认为解题的关键就是要认识到<code>fork</code>将程序切成两段：</p>
<p><img src="/2019/03/16/Linux系统编程/fork和vfork函数/1.png"></p>
<p>&emsp;&emsp;上图表示一个含有<code>fork</code>的程序，而<code>fork</code>语句可以看成将程序切为<code>A</code>、<code>B</code>两个部分。然后整个程序会如下运行：</p>
<ol>
<li>设由<code>shell</code>直接执行程序，生成了进程<code>P</code>。<code>P</code>执行完<code>Part.A</code>的所有代码。</li>
<li>当执行到<code>pid = fork();</code>时，<code>P</code>启动一个进程<code>Q</code>，<code>Q</code>是<code>P</code>的子进程，和<code>P</code>是同一个程序的进程。<code>Q</code>继承<code>P</code>的所有变量、环境变量、程序计数器的当前值。</li>
<li>在<code>P</code>进程中，<code>fork()</code>将<code>Q</code>的<code>PID</code>返回给变量<code>pid</code>，并继续执行<code>Part.B</code>的代码。</li>
<li>在进程<code>Q</code>中，将<code>0</code>赋给<code>pid</code>，并继续执行<code>Part.B</code>的代码。</li>
</ol>
<p>&emsp;&emsp;这里有三个点非常关键：</p>
<ul>
<li><code>P</code>执行了所有程序，而<code>Q</code>只执行了<code>Part.B</code>，即<code>fork</code>后面的程序，这是因为<code>Q</code>继承了<code>P</code>的<code>PC</code>，即程序计数器。</li>
<li><code>Q</code>继承了<code>fork</code>语句执行时当前的环境，而不是程序的初始环境。</li>
<li><code>P</code>中<code>fork</code>语句启动子进程<code>Q</code>，并将<code>Q</code>的<code>PID</code>返回，而<code>Q</code>中的<code>fork</code>语句不启动新进程，仅将<code>0</code>返回。</li>
</ul>
<h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><p>&emsp;&emsp;下面利用上文阐述的知识进行解题。这里我把两个问题放在一起进行分析。</p>
<ol>
<li>从<code>shell</code>中执行此程序，启动了一个进程，我们设这个进程为<code>P0</code>，设其<code>PID</code>为<code>XXX</code>(解题过程不需知道其<code>PID</code>)。</li>
<li>当执行到<code>pid1 = fork();</code>时，<code>P0</code>启动一个子进程<code>P1</code>，由题目知<code>P1</code>的<code>PID</code>为<code>1001</code>。我们暂且不管<code>P1</code>。</li>
<li><code>P0</code>中的<code>fork</code>返回<code>1001</code>给<code>pid1</code>，继续执行到<code>pid2 = fork();</code>，此时启动另一个新进程，设为<code>P2</code>，由题目知<code>P2</code>的<code>PID</code>为<code>1002</code>。同样暂且不管<code>P2</code>。</li>
<li><code>P0</code>中的第二个<code>fork</code>返回<code>1002</code>给<code>pid2</code>，继续执行完后续程序，结束。所以<code>P0</code>的结果为<code>pid1:1001, pid2:1002</code>。</li>
<li>再看<code>P2</code>，<code>P2</code>生成时，<code>P0</code>中<code>pid1</code>为<code>1001</code>，所以<code>P2</code>中<code>pid1</code>继承<code>P0</code>的<code>1001</code>，而作为子进程<code>pid2</code>为<code>0</code>。<code>P2</code>从第二个<code>fork</code>后开始执行，结束后输出<code>pid1:1001, pid2:0</code>。</li>
<li>接着看<code>P1</code>，<code>P1</code>中第一条<code>fork</code>返回<code>0</code>给<code>pid1</code>，然后接着执行后面的语句。而后面接着的语句是<code>pid2 = fork();</code>。执行到这里，<code>P1</code>又产生了一个新进程，设为<code>P3</code>。先不管<code>P3</code>。</li>
<li><code>P1</code>中第二条<code>fork</code>将<code>P3</code>的<code>PID</code>返回给<code>pid2</code>，由预备知识知<code>P3</code>的<code>PID</code>为<code>1003</code>，所以<code>P1</code>的<code>pid2</code>为<code>1003</code>。<code>P1</code>继续执行后续程序，结束，输出<code>pid1:0, pid2:1003</code>。</li>
<li><code>P3</code>作为<code>P1</code>的子进程，继承<code>P1</code>中<code>pid1</code>为<code>0</code>，并且第二条<code>fork</code>将<code>0</code>返回给<code>pid2</code>，所以<code>P3</code>最后输出<code>pid1:0, pid2:0</code>。至此，整个执行过程完毕。</li>
</ol>
<p>&emsp;&emsp;所得答案如下：</p>
<ul>
<li>一共执行了四个进程(<code>P0</code>、<code>P1</code>、<code>P2</code>和<code>P3</code>)。</li>
<li>另外几个进程的输出分别为：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid1:<span class="number">1001</span>, pid2:<span class="number">0</span></span><br><span class="line">pid1:<span class="number">0</span>, pid2:<span class="number">1003</span></span><br><span class="line">pid1:<span class="number">0</span>, pid2:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以给出一个以<code>P0</code>为根的进程树：</p>
<p><img src="/2019/03/16/Linux系统编程/fork和vfork函数/2.png" height="270" width="355"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/16/Linux系统编程/孤儿进程与僵尸进程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/16/Linux系统编程/孤儿进程与僵尸进程/" itemprop="url">孤儿进程与僵尸进程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T12:20:37+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>&emsp;&emsp;我们知道在<code>unix/linux</code>中，正常情况下子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。当一个进程完成它的工作终止之后，它的父进程需要调用<code>wait</code>或者<code>waitpid</code>系统调用取得子进程的终止状态。</p>
<ul>
<li>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被<code>init</code>进程(进程号为<code>1</code>)所收养，并由<code>init</code>进程对它们完成状态收集工作。</li>
<li>僵尸进程：一个进程使用<code>fork</code>创建子进程，如果子进程退出，而父进程并没有调用<code>wait</code>或<code>waitpid</code>获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</li>
</ul>
<h3 id="问题及危害"><a href="#问题及危害" class="headerlink" title="问题及危害"></a>问题及危害</h3><p>&emsp;&emsp;<code>unix</code>提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息就可以得到。这种机制就是：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件、占用的内存等。但是仍然为其保留一定的信息(包括进程号<code>the process ID</code>、退出状态<code>the termination status of the process</code>、运行时间<code>the amount of CPU time taken by the process</code>等)，直到父进程通过<code>wait/waitpid</code>来取时才释放。但这样就导致了问题，如果父进程不调用<code>wait/waitpid</code>的话，那么保留的那段信息就不会释放，其进程号就会一直被占用。但是系统所能使用的进程号是有限的，如果大量地产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，这就是僵尸进程的危害。<br>&emsp;&emsp;孤儿进程是没有父进程的进程，孤儿进程的处理这个重任就落到了<code>init</code>进程身上。<code>init</code>进程就好像是一个收容所，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为<code>init</code>，而<code>init</code>进程会循环地<code>wait</code>它的已经退出的子进程。这样当一个孤儿进程结束了其生命周期的时候，<code>init</code>进程就会处理它的一切善后工作，因此孤儿进程并不会有什么危害。<br>&emsp;&emsp;任何一个子进程(<code>init</code>除外)在<code>exit</code>之后，并非马上就消失掉，而是留下一个称为僵尸进程(<code>Zombie</code>)的数据结构，等待父进程处理，这是每个子进程在结束时都要经过的阶段。如果子进程在<code>exit</code>之后，父进程没有来得及处理，这时用<code>ps</code>命令就能看到子进程的状态是<code>Z</code>。如果父进程能及时处理，可能用<code>ps</code>命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。如果父进程在子进程结束之前退出，则子进程将由<code>init</code>接管。<code>init</code>将会以父进程的身份对僵尸状态的子进程进行处理。<br>&emsp;&emsp;僵尸进程危害场景：例如有个进程，它定期地产生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短。但是父进程只管生成新的子进程，至于子进程退出之后的事情，则一概不闻不问。这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，如果用ps命令查看的话，就会看到很多状态为<code>Z</code>的进程。严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大量僵死进程的那个元凶枪毙掉(也就是通过<code>kill</code>发送<code>SIGTERM</code>或者<code>SIGKILL</code>信号了)。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被<code>init</code>进程接管，<code>init</code>进程会<code>wait</code>这些孤儿进程，释放它们占用的系统进程表中的资源。这样，这些已经僵死的孤儿进程就能瞑目而去了。</p>
<h3 id="孤儿进程和僵尸进程测试"><a href="#孤儿进程和僵尸进程测试" class="headerlink" title="孤儿进程和僵尸进程测试"></a>孤儿进程和僵尸进程测试</h3><p>&emsp;&emsp;孤儿进程测试程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork(); <span class="comment">/* 创建一个进程 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123; <span class="comment">/* 创建失败 */</span></span><br><span class="line">        perror ( <span class="string">"fork error:"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123; <span class="comment">/* 子进程 */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I am the child process.\n"</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"pid: %d\tppid:%d\n"</span>, getpid(), getppid() ); <span class="comment">/* 输出进程ID和父进程ID */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I will sleep five seconds.\n"</span> );</span><br><span class="line">        sleep ( <span class="number">5</span> ); <span class="comment">/* 睡眠5s，保证父进程先退出 */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"pid: %d\tppid:%d\n"</span>, getpid(), getppid() );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"child process is exited.\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* 父进程 */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I am father process.\n"</span> );</span><br><span class="line">        sleep ( <span class="number">1</span> ); <span class="comment">/* 父进程睡眠1s，保证子进程输出进程id */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"father process is  exited.\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/16/Linux系统编程/孤儿进程与僵尸进程/1.png"></p>
<p>&emsp;&emsp;僵尸进程测试程序<code>1</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fork error:"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I am child process.I am exiting.\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"I am father process.I will sleep two seconds\n"</span> );</span><br><span class="line">    sleep ( <span class="number">2</span> ); <span class="comment">/* 等待子进程先退出 */</span></span><br><span class="line">    system ( <span class="string">"ps -o pid,ppid,state,tty,command"</span> ); <span class="comment">/* 输出进程信息 */</span></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"father process is exiting.\n"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/16/Linux系统编程/孤儿进程与僵尸进程/2.png"></p>
<p>&emsp;&emsp;僵尸进程测试程序<code>2</code>：父进程循环创建子进程，子进程退出，造成多个僵尸进程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span>  pid;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123; <span class="comment">/* 循环创建子进程 */</span></span><br><span class="line">        pid = fork();</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">            perror ( <span class="string">"fork error:"</span> );</span><br><span class="line">            <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"I am a child process.\nI am exiting.\n"</span> );</span><br><span class="line">            <span class="built_in">exit</span> ( <span class="number">0</span> ); <span class="comment">/* 子进程退出，成为僵尸进程 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sleep ( <span class="number">20</span> ); <span class="comment">/* 父进程休眠20s继续创建子进程 */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/16/Linux系统编程/孤儿进程与僵尸进程/3.png" height="278" width="310"></p>
<h3 id="僵尸进程解决办法"><a href="#僵尸进程解决办法" class="headerlink" title="僵尸进程解决办法"></a>僵尸进程解决办法</h3><p>&emsp;&emsp;1. 通过信号机制：子进程退出时向父进程发送<code>SIGCHLD</code>信号，父进程处理<code>SIGCHLD</code>信号，在信号处理函数中调用<code>wait</code>进行处理僵尸进程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_child</span> <span class="params">( <span class="keyword">int</span> signo )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    signal ( SIGCHLD, sig_child ); <span class="comment">/* 创建捕捉子进程退出信号 */</span></span><br><span class="line">    pid = fork();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fork error:"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I am child process,pid id %d.I am exiting.\n"</span>, getpid() );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"I am father process.I will sleep two seconds\n"</span> );</span><br><span class="line">    sleep ( <span class="number">2</span> ); <span class="comment">/* 等待子进程先退出 */</span></span><br><span class="line">    system ( <span class="string">"ps -o pid,ppid,state,tty,command"</span> ); <span class="comment">/* 输出进程信息 */</span></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"father process is exiting.\n"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_child</span> <span class="params">( <span class="keyword">int</span> signo )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> stat;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( ( pid = waitpid ( <span class="number">-1</span>, &amp;stat, WNOHANG ) ) &gt; <span class="number">0</span> ) &#123; <span class="comment">/* 处理僵尸进程 */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"child %d terminated.\n"</span>, pid );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. <code>fork</code>两次：<code>Unix环境高级编程</code>的<code>8.6</code>节说的非常详细，原理是将子进程成为孤儿进程，从而其父进程变为<code>init</code>进程，通过<code>init</code>进程可以处理僵尸进程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span>  pid;</span><br><span class="line">    pid = fork(); <span class="comment">/* 创建第一个子进程 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fork error:"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123; <span class="comment">/* 第一个子进程 */</span></span><br><span class="line">        <span class="comment">/* 子进程再创建子进程 */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I am the first child process.pid:%d\tppid:%d\n"</span>, getpid(), getppid() );</span><br><span class="line">        pid = fork();</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">            perror ( <span class="string">"fork error:"</span> );</span><br><span class="line">            <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( pid &gt; <span class="number">0</span> ) &#123; <span class="comment">/* 第一个子进程退出 */</span></span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"first procee is exited.\n"</span> );</span><br><span class="line">            <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">/* 第二个子进程睡眠3s保证第一个子进程退出，这样第二个子进程的父亲就是init进程 */</span></span><br><span class="line">        sleep ( <span class="number">3</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"I am the second child process.pid: %d\tppid:%d\n"</span>, getpid(), getppid() );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( waitpid ( pid, <span class="literal">NULL</span>, <span class="number">0</span> ) != pid ) &#123; <span class="comment">/* 父进程处理第一个子进程退出 */</span></span><br><span class="line">        perror ( <span class="string">"waitepid error:"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/16/Linux系统编程/孤儿进程与僵尸进程/4.png"></p>
<hr>
<h3 id="僵尸进程概念"><a href="#僵尸进程概念" class="headerlink" title="僵尸进程概念"></a>僵尸进程概念</h3><p>&emsp;&emsp;僵尸进程(<code>Zombie Process</code>)：就是已经结束了的进程，但是没有从进程表中删除。太多了会导致进程表里面条目满了，进而导致系统崩溃，倒是不占用其他系统资源。<br>&emsp;&emsp;在<code>Linux</code>进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集。除此之外，僵尸进程不再占有任何内存空间。它需要它的父进程来为它收尸，如果他的父进程没安装<code>SIGCHLD</code>信号处理函数调用<code>wait</code>或<code>waitpid</code>等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态。如果这时父进程结束了，那么<code>init</code>进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。</p>
<h3 id="僵尸进程产生的原因"><a href="#僵尸进程产生的原因" class="headerlink" title="僵尸进程产生的原因"></a>僵尸进程产生的原因</h3><p>&emsp;&emsp;每个<code>Linux</code>进程在进程表里都有一个进入点(<code>entry</code>)，核心程序执行该进程时使用到的一切信息都存储在进入点。当用<code>ps</code>命令察看系统中的进程信息时，看到的就是进程表中的相关数据。当用<code>fork</code>系统调用建立一个新的进程后，核心进程就会在进程表中给这个新进程分配一个进入点，然后将相关信息存储在该进入点所对应的进程表内。这些信息中有一项是其父进程的识别码。当这个进程走完了自己的生命周期后，它会执行<code>exit</code>系统调用，此时原来进程表中的数据会被该进程的退出码(<code>exit code</code>)、执行时所用的<code>CPU</code>时间等数据所取代，这些数据会一直保留到系统将它传递给它的父进程为止。由此可见，僵尸进程的出现时间是在子进程终止后，但是父进程尚未读取这些数据之前。</p>
<h3 id="僵尸进程的解决方法"><a href="#僵尸进程的解决方法" class="headerlink" title="僵尸进程的解决方法"></a>僵尸进程的解决方法</h3><ul>
<li>父进程通过<code>wait</code>和<code>waitpid</code>等函数等待子进程结束，这会导致父进程挂起。执行<code>wait</code>或<code>waitpid</code>系统调用，则子进程在终止后会立即把它在进程表中的数据返回给父进程，此时系统会立即删除该进入点。在这种情形下就不会产生僵尸进程。</li>
<li>如果父进程很忙，那么可以用<code>signal</code>函数为<code>SIGCHLD</code>安装<code>handler</code>。在子进程结束后，父进程会收到该信号，可以在<code>handler</code>中调用<code>wait</code>回收。</li>
<li>如果父进程不关心子进程什么时候结束，那么可以用<code>signal(SIGCLD, SIG_IGN)</code>或<code>signal(SIGCHLD, SIG_IGN)</code>通知内核，自己对子进程的结束不感兴趣。那么子进程结束后，内核会回收子进程的资源，并不再给父进程发送信号。</li>
<li><code>fork</code>两次，父进程<code>fork</code>一个子进程，然后继续工作。子进程<code>fork</code>一个孙进程后退出，那么孙进程会被<code>init</code>接管，孙进程结束后，<code>init</code>会回收它的资源。不过子进程的回收还要自己来做。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/14/数学和物理/数学符号/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/数学和物理/数学符号/" itemprop="url">数学符号</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:57:21+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="运算符号"><a href="#运算符号" class="headerlink" title="运算符号"></a>运算符号</h3><p>&emsp;&emsp;加号($+$)，减号($-$)，乘号($\times$或$\cdot$)，除号($\div$或$/$)，两个集合的并集($\bigcup$)，交集($\bigcap$)，根号($\sqrt{x}$)，对数($\log$、$\lg$、$\ln$)，比($:$)，绝对值符号($\left| x \right|$)，微分($\mathrm{d}$)，积分($\int$)，闭合曲面(曲线)积分($\int$)。</p>
<h3 id="关系符号"><a href="#关系符号" class="headerlink" title="关系符号"></a>关系符号</h3><p>&emsp;&emsp;等号($=$)，近似符号($\approx$)，不等号($\neq$)，大于符号($&gt;$)，小于符号($&lt;$)，大于或等于符号($\geq$)，小于或等于符号($\leq$)，变量变化的趋势($\to$)，相似符号($\sim$)，全等号($\cong$)，平行符号($\parallel$)，不平行符号($\nparallel$)，垂直符号($\perp$)，正比例符号($\propto$)，属于符号($\in$)，不属于符号($\notin$)，包含于符号($\subseteq$)，包含符号($\supseteq$)，$a|b$表示<code>a</code>能整除<code>b</code>)。</p>
<h3 id="结合符号"><a href="#结合符号" class="headerlink" title="结合符号"></a>结合符号</h3><p>&emsp;&emsp;小括号($()$)，中括号($[]$)，大括号(${}$)。</p>
<h3 id="性质符号"><a href="#性质符号" class="headerlink" title="性质符号"></a>性质符号</h3><p>&emsp;&emsp;正号($+$)，负号($-$)，正负号($\pm$)。</p>
<h3 id="省略符号"><a href="#省略符号" class="headerlink" title="省略符号"></a>省略符号</h3><p>&emsp;&emsp;三角形($\bigtriangleup$)，正弦($\sin$)，双曲正弦函数($\sinh$)，<code>x</code>的函数($f(x)$)，极限($\lim$)，角($\angle$)，因为($\because$)，所以($\therefore$)，连续加($\sum$)，连续乘($\prod$)，幂($a^x$)，阶乘($!$)。</p>
<h3 id="离散数学符号"><a href="#离散数学符号" class="headerlink" title="离散数学符号"></a>离散数学符号</h3><p>&emsp;&emsp;全称量词($\forall$)，存在量词($\exists$)，命题的<code>非</code>运算($\neg$)，命题的<code>与</code>运算($\wedge$)，命题的<code>或</code>运算($\vee$)，命题的<code>条件</code>运算($\to$)，命题的<code>双条件</code>运算($\leftrightarrow$)，命题<code>p</code>与<code>q</code>的等价关系($p \Leftrightarrow q$)；$p \Rightarrow q$是命题<code>p</code>与<code>q</code>的蕴涵关系(<code>p</code>是<code>q</code>的充分条件，<code>q</code>是<code>p</code>的必要条件)，空集($\emptyset$)，真包含($\subset$)；集合的并运算($\cup$)，集合的交运算($\cap$)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/14/办公/Markdown中写数学公式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/办公/Markdown中写数学公式/" itemprop="url">Markdown中写数学公式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T10:09:21+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;一些扩展的<code>Markdown</code>语法支持采用<code>LaTex</code>语法写数学公式，而在网页中使用<code>Mathjax</code>插件来显示数学公式。在<code>Markdown</code>中插入数学公式的语法是<code>$数学公式$</code>和<code>$$数学公式$$</code>。<br>&emsp;&emsp;行内公式是可以让公式在文中与文字或其他东西混编，不独占一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">质能方程$E = mc^2$</span><br></pre></td></tr></table></figure>
<p>质能方程$E = mc^2$。<br>&emsp;&emsp;独立公式使公式单独占一行，不与文中其他文字等混编：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$E = mc^2$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">E = mc^2</script><h3 id="普通公式"><a href="#普通公式" class="headerlink" title="普通公式"></a>普通公式</h3><p>&emsp;&emsp;普通的加减乘除数学公式的输入方法与平常的书写一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$x = 100 * y + z - 10 / 33 + 10 % 3$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">x = 100 * y + z - 10 / 33 + 10 % 3</script><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>&emsp;&emsp;使用<code>^</code>来表示上标，<code>_</code>来表示下标，同时如果上下标的内容多于一个字符，可以使用<code>{}</code>来将这些内容括起来当做一个整体。实际上，上下标是可以嵌套的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$x = a_&#123;1&#125;^n + a_&#123;2&#125;^n + a_&#123;3&#125;^n$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">x = a_{1}^n + a_{2}^n + a_{3}^n</script><p>如果希望左右两边都能有上下标，可以使用<code>\sideset</code>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\sideset&#123;^1_2&#125;&#123;^3_4&#125;A$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\sideset{^1_2}{^3_4}A</script><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p>&emsp;&emsp;<code>()</code>、<code>[]</code>和<code>|</code>都表示它们自己，但是<code>{}</code>因为有特殊作用，因此当需要显示大括号时，一般使用<code>\lbrace \rbrace</code>来表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace</script><h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><p>&emsp;&emsp;分数使用<code>\frac{分母}{分子}</code>这样的语法，不过推荐使用<code>\cfrac</code>来代替<code>\frac</code>，显示公式不会太挤。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\frac&#123;1&#125;&#123;3&#125; 与 \cfrac&#123;1&#125;&#123;3&#125;$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\frac{1}{3} 与 \cfrac{1}{3}</script><h3 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h3><p>&emsp;&emsp;开方使用<code>\sqrt[次数]{被开方数}</code>这样的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$$\sqrt[3]&#123;X&#125;$$</span><br><span class="line">$$\sqrt&#123;5 - x&#125;$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\sqrt[3]{X}</script><script type="math/tex; mode=display">\sqrt{5 - x}</script><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>显示</th>
<th>代码</th>
<th>显示</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$A$</code></td>
<td>$A$</td>
<td><code>$\alpha$</code></td>
<td>$\alpha$</td>
</tr>
<tr>
<td><code>$B$</code></td>
<td>$B$</td>
<td><code>$\beta$</code></td>
<td>$\beta$</td>
</tr>
<tr>
<td><code>$\Gamma$</code></td>
<td>$\Gamma$</td>
<td><code>$\gamma$</code></td>
<td>$\gamma$</td>
</tr>
<tr>
<td><code>$\Delta$</code></td>
<td>$\Delta$</td>
<td><code>$\delta$</code></td>
<td>$\delta$</td>
</tr>
<tr>
<td><code>$E$</code></td>
<td>$E$</td>
<td><code>$\epsilon$</code></td>
<td>$\epsilon$</td>
</tr>
<tr>
<td><code>$Z$</code></td>
<td>$Z$</td>
<td><code>$\zeta$</code></td>
<td>$\zeta$</td>
</tr>
<tr>
<td><code>$H$</code></td>
<td>$H$</td>
<td><code>$\eta$</code></td>
<td>$\eta$</td>
</tr>
<tr>
<td><code>$\Theta$</code></td>
<td>$\Theta$</td>
<td><code>$\theta$</code></td>
<td>$\theta$</td>
</tr>
<tr>
<td><code>$I$</code></td>
<td>$I$</td>
<td><code>$\iota$</code></td>
<td>$\iota$</td>
</tr>
<tr>
<td><code>$K$</code></td>
<td>$K$</td>
<td><code>$\kappa$</code></td>
<td>$\kappa$</td>
</tr>
<tr>
<td><code>$\Lambda$</code></td>
<td>$\Lambda$</td>
<td><code>$\lambda$</code></td>
<td>$\lambda$</td>
</tr>
<tr>
<td><code>$M$</code></td>
<td>$M$</td>
<td><code>$\mu$</code></td>
<td>$\mu$</td>
</tr>
<tr>
<td><code>$N$</code></td>
<td>$N$</td>
<td><code>$\nu$</code></td>
<td>$\nu$</td>
</tr>
<tr>
<td><code>$\Xi$</code></td>
<td>$\Xi$</td>
<td><code>$\xi$</code></td>
<td>$\xi$</td>
</tr>
<tr>
<td><code>$O$</code></td>
<td>$O$</td>
<td><code>$\omicron$</code></td>
<td>$\omicron$</td>
</tr>
<tr>
<td><code>$\Pi$</code></td>
<td>$\Pi$</td>
<td><code>$\pi$</code></td>
<td>$\pi$</td>
</tr>
<tr>
<td><code>$P$</code></td>
<td>$P$</td>
<td><code>$\rho$</code></td>
<td>$\rho$</td>
</tr>
<tr>
<td><code>$\Sigma$</code></td>
<td>$\Sigma$</td>
<td><code>$\sigma$</code></td>
<td>$\sigma$</td>
</tr>
<tr>
<td><code>$T$</code></td>
<td>$T$</td>
<td><code>$\tau$</code></td>
<td>$\tau$</td>
</tr>
<tr>
<td><code>$\Upsilon$</code></td>
<td>$\Upsilon$</td>
<td><code>$\upsilon$</code></td>
<td>$\upsilon$</td>
</tr>
<tr>
<td><code>$\Phi$</code></td>
<td>$\Phi$</td>
<td><code>$\phi$</code></td>
<td>$\phi$</td>
</tr>
<tr>
<td><code>$X$</code></td>
<td>$X$</td>
<td><code>$\chi$</code></td>
<td>$\chi$</td>
</tr>
<tr>
<td><code>$\Psi$</code></td>
<td>$\Psi$</td>
<td><code>$\psi$</code></td>
<td>$\psi$</td>
</tr>
<tr>
<td><code>$\Omega$</code></td>
<td>$\Omega$</td>
<td><code>$\omega$</code></td>
<td>$\omega$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\emptyset$</code></td>
<td>$\emptyset$</td>
<td><code>$\in$</code></td>
<td>$\in$</td>
</tr>
<tr>
<td><code>$\notin$</code></td>
<td>$\notin$</td>
<td><code>$\subset$</code></td>
<td>$\subset$</td>
</tr>
<tr>
<td><code>$\supset$</code></td>
<td>$\supset$</td>
<td><code>$\subseteq$</code></td>
<td>$\subseteq$</td>
</tr>
<tr>
<td><code>$\supseteq$</code></td>
<td>$\supseteq$</td>
<td><code>$\bigcap$</code></td>
<td>$\bigcap$</td>
</tr>
<tr>
<td><code>$\bigcup$</code></td>
<td>$\bigcup$</td>
<td><code>$\bigvee$</code></td>
<td>$\bigvee$</td>
</tr>
<tr>
<td><code>$\bigwedge$</code></td>
<td>$\bigwedge$</td>
<td><code>$\biguplus$</code></td>
<td>$\biguplus$</td>
</tr>
<tr>
<td><code>$\bigsqcup$</code></td>
<td>$\bigsqcup$</td>
<td><code>$\ni$</code></td>
<td>$\ni$</td>
</tr>
<tr>
<td><code>$\forall$</code></td>
<td>$\forall$</td>
<td><code>$\exists$</code></td>
<td>$\exists$</td>
</tr>
<tr>
<td><code>$\neg$</code></td>
<td>$\neg$</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="对数运算符"><a href="#对数运算符" class="headerlink" title="对数运算符"></a>对数运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\log$</code></td>
<td>$\log$</td>
<td><code>$\lg$</code></td>
<td>$\lg$</td>
</tr>
<tr>
<td><code>$\ln$</code></td>
<td>$\ln$</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="三角运算符"><a href="#三角运算符" class="headerlink" title="三角运算符"></a>三角运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\bot$</code></td>
<td>$\bot$</td>
<td><code>$\angle$</code></td>
<td>$\angle$</td>
</tr>
<tr>
<td><code>$\sin$</code></td>
<td>$\sin$</td>
<td><code>$\cos$</code></td>
<td>$\cos$</td>
</tr>
<tr>
<td><code>$\tan$</code></td>
<td>$\tan$</td>
<td><code>$\cot$</code></td>
<td>$\cot$</td>
</tr>
<tr>
<td><code>$\sec</code></td>
<td>$\sec$</td>
<td><code>$\csc$</code></td>
<td>$\csc$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="微积分运算符"><a href="#微积分运算符" class="headerlink" title="微积分运算符"></a>微积分运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\prime$</code></td>
<td>$\prime$</td>
<td><code>$\int$</code></td>
<td>$\int$</td>
</tr>
<tr>
<td><code>$\iint$</code></td>
<td>$\iint$</td>
<td><code>$\iiint$</code></td>
<td>$\iiint$</td>
</tr>
<tr>
<td><code>$\oint$</code></td>
<td>$\oint$</td>
<td><code>$\lim$</code></td>
<td>$\lim$</td>
</tr>
<tr>
<td><code>$\infty$</code></td>
<td>$\infty$</td>
<td><code>$\nabla$</code></td>
<td>$\nabla$</td>
</tr>
<tr>
<td><code>$\mathrm{d}$</code></td>
<td>$\mathrm{d}$</td>
<td><code>$\partial$</code></td>
<td>$\partial$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a>绝对值</h3><p>&emsp;&emsp;代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\left| x \right|$</span><br></pre></td></tr></table></figure>
<p>$\left| x \right|$</p>
<h3 id="箭头符号"><a href="#箭头符号" class="headerlink" title="箭头符号"></a>箭头符号</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\gets$</code></td>
<td>$\gets$</td>
<td><code>$\to$</code></td>
<td>$\to$</td>
</tr>
<tr>
<td><code>$\leftarrow$</code></td>
<td>$\leftarrow$</td>
<td><code>$\Leftarrow$</code></td>
<td>$\Leftarrow$</td>
</tr>
<tr>
<td><code>$\rightarrow$</code></td>
<td>$\rightarrow$</td>
<td><code>$\Rightarrow$</code></td>
<td>$\Rightarrow$</td>
</tr>
<tr>
<td><code>$\leftrightarrow$</code></td>
<td>$\leftrightarrow$</td>
<td><code>$\Leftrightarrow$</code></td>
<td>$\Leftrightarrow$</td>
</tr>
<tr>
<td><code>$\mapsto$</code></td>
<td>$\mapsto$</td>
<td><code>$\hookleftarrow$</code></td>
<td>$\hookleftarrow$</td>
</tr>
<tr>
<td><code>$\leftharpoonup$</code></td>
<td>$\leftharpoonup$</td>
<td><code>$\leftharpoondown$</code></td>
<td>$\leftharpoondown$</td>
</tr>
<tr>
<td><code>$\rightleftharpoons$</code></td>
<td>$\rightleftharpoons$</td>
<td><code>$\longleftarrow$</code></td>
<td>$\longleftarrow$</td>
</tr>
<tr>
<td><code>$\Longleftarrow$</code></td>
<td>$\Longleftarrow$</td>
<td><code>$\longrightarrow$</code></td>
<td>$\longrightarrow$</td>
</tr>
<tr>
<td><code>$\Longrightarrow$</code></td>
<td>$\Longrightarrow$</td>
<td><code>$\longleftrightarrow$</code></td>
<td>$\longleftrightarrow$</td>
</tr>
<tr>
<td><code>$\Longleftrightarrow$</code></td>
<td>$\Longleftrightarrow$</td>
<td><code>$\longmapsto$</code></td>
<td>$\longmapsto$</td>
</tr>
<tr>
<td><code>$\hookrightarrow$</code></td>
<td>$\hookrightarrow$</td>
<td><code>$\rightharpoonup$</code></td>
<td>$\rightharpoonup$</td>
</tr>
<tr>
<td><code>$\rightharpoondown$</code></td>
<td>$\rightharpoondown$</td>
<td><code>$\leadsto$</code></td>
<td>$\leadsto$</td>
</tr>
<tr>
<td><code>$\uparrow$</code></td>
<td>$\uparrow$</td>
<td><code>$\Uparrow$</code></td>
<td>$\Uparrow$</td>
</tr>
<tr>
<td><code>$\downarrow$</code></td>
<td>$\downarrow$</td>
<td><code>$\Downarrow$</code></td>
<td>$\Downarrow$</td>
</tr>
<tr>
<td><code>$\updownarrow$</code></td>
<td>$\updownarrow$</td>
<td><code>$\Updownarrow$</code></td>
<td>$\Updownarrow$</td>
</tr>
<tr>
<td><code>$\nearrow$</code></td>
<td>$\nearrow$</td>
<td><code>$\searrow$</code></td>
<td>$\searrow$</td>
</tr>
<tr>
<td><code>$\swarrow$</code></td>
<td>$\swarrow$</td>
<td><code>$\nwarrow$</code></td>
<td>$\nwarrow$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\pm$</code></td>
<td>$\pm$</td>
<td><code>$\mp$</code></td>
<td>$\mp$</td>
<td><code>$\times$</code></td>
<td>$\times$</td>
</tr>
<tr>
<td><code>$\div$</code></td>
<td>$\div$</td>
<td><code>$\cdot$</code></td>
<td>$\cdot$</td>
<td><code>$\ast$</code></td>
<td>$\ast$</td>
</tr>
<tr>
<td><code>$\star$</code></td>
<td>$\star$</td>
<td><code>$\dagger$</code></td>
<td>$\dagger$</td>
<td><code>$\ddagger$</code></td>
<td>$\ddagger$</td>
</tr>
<tr>
<td><code>$\amalg$</code></td>
<td>$\amalg$</td>
<td><code>$\cap$</code></td>
<td>$\cap$</td>
<td><code>$\cup$</code></td>
<td>$\cup$</td>
</tr>
<tr>
<td><code>$\uplus$</code></td>
<td>$\uplus$</td>
<td><code>$\sqcap$</code></td>
<td>$\sqcap$</td>
<td><code>$\sqcup$</code></td>
<td>$\sqcup$</td>
</tr>
<tr>
<td><code>$\vee$</code></td>
<td>$\vee$</td>
<td><code>$\wedge$</code></td>
<td>$\wedge$</td>
<td><code>$\oplus$</code></td>
<td>$\oplus$</td>
</tr>
<tr>
<td><code>$\ominus$</code></td>
<td>$\ominus$</td>
<td><code>$\otimes$</code></td>
<td>$\otimes$</td>
<td><code>$\circ$</code></td>
<td>$\circ$</td>
</tr>
<tr>
<td><code>$\bullet$</code></td>
<td>$\bullet$</td>
<td><code>$\diamond$</code></td>
<td>$\diamond$</td>
<td><code>$\lhd$</code></td>
<td>$\lhd$</td>
</tr>
<tr>
<td><code>$\rhd$</code></td>
<td>$\rhd$</td>
<td><code>$\unlhd$</code></td>
<td>$\unlhd$</td>
<td><code>$\unrhd$</code></td>
<td>$\unrhd$</td>
</tr>
<tr>
<td><code>$\oslash$</code></td>
<td>$\oslash$</td>
<td><code>$\odot$</code></td>
<td>$\odot$</td>
<td><code>$\bigcirc$</code></td>
<td>$\bigcirc$</td>
</tr>
<tr>
<td><code>$\triangleleft$</code></td>
<td>$\triangleleft$</td>
<td><code>$\Diamond$</code></td>
<td>$\Diamond$</td>
<td><code>$\bigtriangleup$</code></td>
<td>$\bigtriangleup$</td>
</tr>
<tr>
<td><code>$\bigtriangledown$</code></td>
<td>$\bigtriangledown$</td>
<td><code>$\Box$</code></td>
<td>$\Box$</td>
<td><code>$\triangleright$</code></td>
<td>$\triangleright$</td>
</tr>
<tr>
<td><code>$\setminus$</code></td>
<td>$\setminus$</td>
<td><code>$\wr$</code></td>
<td>$\wr$</td>
<td><code>$\sqrt{x}$</code></td>
<td>$\sqrt{x}$</td>
</tr>
<tr>
<td><code>$x^{\circ}$</code></td>
<td>$x^{\circ}$</td>
<td><code>$\triangledown$</code></td>
<td>$\triangledown$</td>
<td><code>$\sqrt[n]{x}$</code></td>
<td>$\sqrt[n]{x}$</td>
</tr>
<tr>
<td><code>$a^x$</code></td>
<td>$a^x$</td>
<td><code>$a^{xyz}$</code></td>
<td>$a^{xyz}$</td>
<td><code>$\sum$</code></td>
<td>$\sum$</td>
</tr>
<tr>
<td><code>$\prod$</code></td>
<td>$\prod$</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\le$</code></td>
<td>$\le$</td>
<td><code>$\ge$</code></td>
<td>$\ge$</td>
<td><code>$\neq$</code></td>
<td>$\neq$</td>
</tr>
<tr>
<td><code>$\sim$</code></td>
<td>$\sim$</td>
<td><code>$\ll$</code></td>
<td>$\ll$</td>
<td><code>$\gg$</code></td>
<td>$\gg$</td>
</tr>
<tr>
<td><code>$\doteq$</code></td>
<td>$\doteq$</td>
<td><code>$\simeq$</code></td>
<td>$\simeq$</td>
<td><code>$\lneqq$</code></td>
<td>$\lneqq$</td>
</tr>
<tr>
<td><code>$\gneqq$</code></td>
<td>$\gneqq$</td>
<td><code>$\approx$</code></td>
<td>$\approx$</td>
<td><code>$\asymp$</code></td>
<td>$\asymp$</td>
</tr>
<tr>
<td><code>$\lnsim$</code></td>
<td>$\lnsim$</td>
<td><code>$\gneq$</code></td>
<td>$\gneq$</td>
<td><code>$\cong$</code></td>
<td>$\cong$</td>
</tr>
<tr>
<td><code>$\smile$</code></td>
<td>$\smile$</td>
<td><code>$\sqsubset$</code></td>
<td>$\sqsubset$</td>
<td><code>$\sqsupset$</code></td>
<td>$\sqsupset$</td>
</tr>
<tr>
<td><code>$\equiv$</code></td>
<td>$\equiv$</td>
<td><code>$\frown$</code></td>
<td>$\frown$</td>
<td><code>$\sqsubseteq$</code></td>
<td>$\sqsubseteq$</td>
</tr>
<tr>
<td><code>$\sqsupseteq$</code></td>
<td>$\sqsupseteq$</td>
<td><code>$\propto$</code></td>
<td>$\propto$</td>
<td><code>$\bowtie$</code></td>
<td>$\bowtie$</td>
</tr>
<tr>
<td><code>$\lneq$</code></td>
<td>$\lneq$</td>
<td><code>$\ngtr$</code></td>
<td>$\ngtr$</td>
<td><code>$\prec$</code></td>
<td>$\prec$</td>
</tr>
<tr>
<td><code>$\succ$</code></td>
<td>$\succ$</td>
<td><code>$\vdash$</code></td>
<td>$\vdash$</td>
<td><code>$\dashv$</code></td>
<td>$\dashv$</td>
</tr>
<tr>
<td><code>$\preceq$</code></td>
<td>$\preceq$</td>
<td><code>$\succeq$</code></td>
<td>$\succeq$</td>
<td><code>$\models$</code></td>
<td>$\models$</td>
</tr>
<tr>
<td><code>$\perp$</code></td>
<td>$\perp$</td>
<td><code>$\parallel$</code></td>
<td>$\parallel$</td>
<td><code>$\mid$</code></td>
<td>$\mid$</td>
</tr>
<tr>
<td><code>$\bumpeq$</code></td>
<td>$\bumpeq$</td>
<td><code>$\nmid$</code></td>
<td>$\nmid$</td>
<td><code>$\nleq$</code></td>
<td>$\nleq$</td>
</tr>
<tr>
<td><code>$\ngeq$</code></td>
<td>$\ngeq$</td>
<td><code>$\nsim$</code></td>
<td>$\nsim$</td>
<td><code>$\ncong$</code></td>
<td>$\ncong$</td>
</tr>
<tr>
<td><code>$\nparallel$</code></td>
<td>$\nparallel$</td>
<td><code>$\not&lt;$</code></td>
<td>$\not&lt;$</td>
<td><code>$\not&gt;$</code></td>
<td>$\not&gt;$</td>
</tr>
<tr>
<td><code>$\not=$</code></td>
<td>$\not=$</td>
<td><code>$\not\le$</code></td>
<td>$\not\le$</td>
<td><code>$\not\ge$</code></td>
<td>$\not\ge$</td>
</tr>
<tr>
<td><code>$\not\sim$</code></td>
<td>$\not\sim$</td>
<td><code>$\not \approx$</code></td>
<td>$\not\approx$</td>
<td><code>$\not\cong$</code></td>
<td>$\not\cong$</td>
</tr>
<tr>
<td><code>$\not\equiv$</code></td>
<td>$\not\equiv$</td>
<td><code>$\not\parallel$</code></td>
<td>$\not\parallel$</td>
<td><code>$\nless$</code></td>
<td>$\nless$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Accents符号"><a href="#Accents符号" class="headerlink" title="Accents符号"></a>Accents符号</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\hat{x}$</code></td>
<td>$\hat{x}$</td>
<td><code>$\check{x}$</code></td>
<td>$\check{x}$</td>
<td><code>$\dot{x}$</code></td>
<td>$\dot{x}$</td>
</tr>
<tr>
<td><code>$\breve{x}$</code></td>
<td>$\breve{x}$</td>
<td><code>$\acute{x}$</code></td>
<td>$\acute{x}$</td>
<td><code>$\ddot{x}$</code></td>
<td>$\ddot{x}$</td>
</tr>
<tr>
<td><code>$\grave{x}$</code></td>
<td>$\grave{x}$</td>
<td><code>$\tilde{x}$</code></td>
<td>$\tilde{x}$</td>
<td><code>$\mathring{x}$</code></td>
<td>$\mathring{x}$</td>
</tr>
<tr>
<td><code>$\bar{x}$</code></td>
<td>$\bar{x}$</td>
<td><code>$\vec{x}$</code></td>
<td>$\vec{x}$</td>
<td><code>$\vec{\jmath}$</code></td>
<td>$\vec{\jmath}$</td>
</tr>
<tr>
<td><code>$\tilde{\imath}$</code></td>
<td>$\tilde{\imath}$</td>
<td><code>$\widehat{7+x}$</code></td>
<td>$\widehat{7+x}$</td>
<td><code>$\widetilde{abc}$</code></td>
<td>$\widetilde{abc}$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Bracketing符号"><a href="#Bracketing符号" class="headerlink" title="Bracketing符号"></a>Bracketing符号</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\{$</code></td>
<td>$\{$</td>
<td><code>$\}$</code></td>
<td>$\}$</td>
<td><code>$\rangle$</code></td>
<td>$\rangle$</td>
</tr>
<tr>
<td><code>$\backslash$</code></td>
<td>$\backslash$</td>
<td><code>$\lfloor$</code></td>
<td>$\lfloor$</td>
<td><code>$\rfloor$</code></td>
<td>$\rfloor$</td>
</tr>
<tr>
<td><code>$\lceil$</code></td>
<td>$\lceil$</td>
<td><code>$\rceil$</code></td>
<td>$\rceil$</td>
<td><code>$\langle$</code></td>
<td>$\langle$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="点符号"><a href="#点符号" class="headerlink" title="点符号"></a>点符号</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\cdot$</code></td>
<td>$\cdot$</td>
<td><code>$\vdots$</code></td>
<td>$\vdots$</td>
</tr>
<tr>
<td><code>$\dots$</code></td>
<td>$\dots$</td>
<td><code>$\ddots$</code></td>
<td>$\ddots$</td>
</tr>
<tr>
<td><code>$\cdots$</code></td>
<td>$\cdots$</td>
<td><code>$\because$</code></td>
<td>$\because$</td>
</tr>
<tr>
<td><code>$\therefore$</code></td>
<td>$\therefore$</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>&emsp;&emsp;You might notice that if you use any of these to typeset an expression that is vertically large, like</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\frac&#123;a&#125;&#123;x&#125;)^2</span><br></pre></td></tr></table></figure>
<p>the parentheses don’t come out the right size:</p>
<p>$(\frac{a}{x})^2$</p>
<p>If we put <code>\left</code> and <code>\right</code> before the relevant parentheses, we get a prettier expression:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\left(\frac&#123;a&#125;&#123;x&#125; \right)^2</span><br></pre></td></tr></table></figure>
<p>$\left(\frac{a}{x} \right)^2$</p>
<p>&emsp;&emsp;if you type this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\underbrace&#123;a_0+a_1+a_2+\cdots+a_n&#125;_&#123;x&#125;</span><br></pre></td></tr></table></figure>
<p>Gives</p>
<p>$\underbrace{a_0+a_1+a_2+\cdots+a_n}_{x}$</p>
<p>Or</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\overbrace&#123;a_0+a_1+a_2+\cdots+a_n&#125;^&#123;x&#125;</span><br></pre></td></tr></table></figure>
<p>Gives</p>
<p>$\overbrace{a_0+a_1+a_2+\cdots+a_n}^{x}$</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/14/Linux系统编程/多进程编程之信号量/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/Linux系统编程/多进程编程之信号量/" itemprop="url">多进程编程之信号量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T08:33:40+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="semget系统调用"><a href="#semget系统调用" class="headerlink" title="semget系统调用"></a>semget系统调用</h3><p>&emsp;&emsp;<code>semget</code>系统调用创建一个新的信号量集，或者获取一个已经存在的信号量集。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span> <span class="params">( <span class="keyword">key_t</span> key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>key</code>：一个键值，用来标识一个全局唯一的信号量集，就像文件名全局唯一的标识一个文件一样。要通过信号量通信的进程需要使用相同的键值来创建或获取该信号量。</li>
<li><code>num_sems</code>：指定要创建或获取的信号量集中信号量的数目。如果是创建信号量，则该值必须指定；如果是获取已存在的信号量，则可以设置为<code>0</code>。</li>
<li><code>sem_flags</code>：指定一组标志。它低端的<code>9</code>个比特是该信号量的权限，其格式和含义都与系统调用<code>open</code>的<code>mode</code>参数相同。我们可以和<code>IPC_CREAT</code>标志做按位<code>或</code>运算，此时即使信号量存大，<code>semget</code>也不会报错。我们还可以用<code>IPC_CREAT</code>和<code>IPC_EXCL</code>标志来确保创建一组新的、唯一的信号量集，此时若信号量存在，<code>semget</code>返回错误并设置<code>errno</code>为<code>EEXIST</code>。</li>
</ul>
<p>&emsp;&emsp;<code>semget</code>调用成功时返回一个正整数，它是信号量集的标识符；失败时返回<code>-1</code>，并设置<code>errno</code>。</p>
<h3 id="semop系统调用"><a href="#semop系统调用" class="headerlink" title="semop系统调用"></a>semop系统调用</h3><p>&emsp;&emsp;<code>semop</code>系统调用改变信号量的值，即执行<code>P</code>和<code>V</code>操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span> <span class="params">( <span class="keyword">int</span> sem_id, struct sembuf *sem_ops, <span class="keyword">size_t</span> num_sem_ops )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sem_id</code>：由<code>semget</code>调用返回的信号量集标识符，用以指定被操作的目标信号量集。</li>
<li><code>num_sem_ops</code>：指定要执行的操作个数，即<code>sem_ops</code>数组中无素的个数。<code>semop</code>对数组中的每个成员按数组顺序依次执行，该过程是原子操作。</li>
<li><code>sem_ops</code>：指向一个sembuf结构体的数组：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sem_num;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sem_op;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sem_flg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体成员说明如下：</p>
<ol>
<li><code>sem_num</code>是信号量集中信号量的编号，像数组一样，从<code>0</code>开始。</li>
<li><code>sem_op</code>指定操作类型，可选值为正整数、<code>0</code>和负整数。每种类型的操作行为又受到<code>sem_flg</code>的影响。</li>
<li><code>sem_flg</code>的可选值是<code>IPC_NOWAIT</code>、<code>SEM_UNDO</code>。<code>IPC_NOWAIT</code>指无论信号量操作是否成功，<code>semop</code>调用都将立即返回，类似于非阻塞；<code>SEM_UNDO</code>指当进程退出时取消正在进行的<code>semop</code>操作。</li>
</ol>
<p>&emsp;&emsp;<code>semop</code>成功时返回<code>0</code>，失败时返回<code>-1</code>并设置<code>errno</code>。</p>
<h3 id="semctl系统调用"><a href="#semctl系统调用" class="headerlink" title="semctl系统调用"></a>semctl系统调用</h3><p>&emsp;&emsp;<code>semctl</code>系统调用允许调用者对信号量进行直接控制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span> <span class="params">( <span class="keyword">int</span> sem_id, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> command, ... )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sem_id</code>：由<code>semget</code>调用返回的信号量集标识符，用以指定被操作的信号量集。</li>
<li><code>sem_num</code>：指定被操作的信号量在信号量集中的编号。</li>
<li><code>command</code>：指定要执行的命令。</li>
</ul>
<p>&emsp;&emsp;有的命令需要第<code>4</code>个参数。第<code>4</code>个参数由用户自己定义，但<code>sys/sem.h</code>给出了推荐格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">    <span class="keyword">int</span> val; <span class="comment">/* 用于SETVAL命令 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span> <span class="comment">/* 用于IPC_STAT和IPC_SET命令 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>; <span class="comment">/* 用于GETALL和SETALL命令 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span> <span class="comment">/* 用于IPC_INFO命令 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sem_ctl</code>成功时的返回值取决于<code>command</code>参数，失败时返回<code>-1</code>并设置<code>errno</code>。</p>
<h3 id="特殊键值IPC-PRIVATE"><a href="#特殊键值IPC-PRIVATE" class="headerlink" title="特殊键值IPC_PRIVATE"></a>特殊键值IPC_PRIVATE</h3><p>&emsp;&emsp;<code>semget</code>的调用可以给其<code>key</code>参数传递一个特殊的键值<code>IPC_PRIVATE</code>，其值为<code>0</code>，这样无论该信号量是否存在，<code>semget</code>都将创建一个新的信号量。使用该值创建的信号量并非像它的名字声称的那样是进程私有的。</p>
<h3 id="使用IPC-PRIVATE创建信号量"><a href="#使用IPC-PRIVATE创建信号量" class="headerlink" title="使用IPC_PRIVATE创建信号量"></a>使用IPC_PRIVATE创建信号量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* op为“-1”时执行P操作，op为1时执行V操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pv</span> <span class="params">( <span class="keyword">int</span> sem_id, <span class="keyword">int</span> op )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = op;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    semop ( sem_id, &amp;sem_b, <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sem_id = semget ( IPC_PRIVATE, <span class="number">1</span>, <span class="number">0666</span> );</span><br><span class="line">    <span class="keyword">union</span> semun sem_un;</span><br><span class="line">    sem_un.val = <span class="number">1</span>;</span><br><span class="line">    semctl ( sem_id, <span class="number">0</span>, SETVAL, sem_un );</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( id &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"fork failed.\n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( id == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"child try to get binary sem\n"</span> );</span><br><span class="line">        pv ( sem_id, <span class="number">-1</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"child get the sem and would release it after 5 seconds\n"</span> );</span><br><span class="line">        sleep ( <span class="number">5</span> );</span><br><span class="line">        pv ( sem_id, <span class="number">1</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"parent try to get binary sem\n"</span> );</span><br><span class="line">        pv ( sem_id, <span class="number">-1</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"parent get the sem and would release it after 3 seconds\n"</span> );</span><br><span class="line">        sleep ( <span class="number">3</span> );</span><br><span class="line">        pv ( sem_id, <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    waitpid ( id, <span class="literal">NULL</span>, <span class="number">0</span> );</span><br><span class="line">    semctl ( sem_id, <span class="number">0</span>, IPC_RMID, sem_un ); <span class="comment">/* 删除信号量 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="linux的信号灯"><a href="#linux的信号灯" class="headerlink" title="linux的信号灯"></a>linux的信号灯</h3><h4 id="信号灯概述"><a href="#信号灯概述" class="headerlink" title="信号灯概述"></a>信号灯概述</h4><p>&emsp;&emsp;信号灯与其他进程间通信方式不大相同，它主要提供对进程间共享资源访问控制机制。相当于内存中的标志，进程可以根据它判定是否能够访问某些共享资源，同时进程也可以修改该标志。除了用于访问控制外，还可用于进程同步。信号灯有以下两种类型：</p>
<ul>
<li>二值信号灯：最简单的信号灯形式，信号灯的值只能取<code>0</code>或<code>1</code>，类似于互斥锁。</li>
<li>计算信号灯：信号灯的值可以取任意非负值(当然受内核本身的约束)。</li>
</ul>
<p>&emsp;&emsp;二值信号灯能够实现互斥锁的功能，但两者的关注内容不同。信号灯强调共享资源，只要共享资源可用，其他进程同样可以修改信号灯的值；互斥锁更强调进程，占用资源的进程使用完资源后，必须由进程本身来解锁。</p>
<h4 id="Linux信号灯"><a href="#Linux信号灯" class="headerlink" title="Linux信号灯"></a>Linux信号灯</h4><p>&emsp;&emsp;<code>Linux</code>对信号灯的支持状况与消息队列一样，在<code>Red hat 8.0</code>发行版本中支持的是系统<code>V</code>的信号灯，因此本文将主要介绍系统<code>V</code>信号灯及其相应<code>API</code>。在没有声明的情况下，以下讨论中指的都是系统<code>V</code>信号灯。注意，通常所说的系统<code>V</code>信号灯指的是计数信号灯集。</p>
<h4 id="信号灯与内核"><a href="#信号灯与内核" class="headerlink" title="信号灯与内核"></a>信号灯与内核</h4><p>&emsp;&emsp;系统<code>V</code>信号灯是随内核持续的，只有在内核重起或者显示删除一个信号灯集时，该信号灯集才会真正被删除。因此系统中记录信号灯的数据结构<code>struct ipc_ids sem_ids</code>位于内核中，系统中的所有信号灯都可以在结构<code>sem_ids</code>中找到访问入口。<br>&emsp;&emsp;下图说明了内核与信号灯是怎样建立起联系的，其中<code>struct ipc_ids sem_ids</code>是内核中记录信号灯的全局数据结构，描述一个具体的信号灯及其相关信息。</p>
<p><img src="/2019/03/14/Linux系统编程/多进程编程之信号量/1.png"></p>
<p>&emsp;&emsp;<code>struct sem</code>结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> semval; <span class="comment">/* current value */</span></span><br><span class="line">    <span class="keyword">int</span> sempid <span class="comment">/* pid of last operation */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上图可以看出，全局数据结构<code>struct ipc_ids sem_ids</code>可以访问到<code>struct kern_ipc_perm</code>的第一个成员，即<code>struct kern_ipc_perm</code>；而每个<code>struct kern_ipc_perm</code>能够与具体的信号灯对应起来是因为在该结构中，有一个<code>key_t</code>类型成员<code>key</code>，而<code>key</code>则唯一确定一个信号灯集；同时，结构<code>struct kern_ipc_perm</code>的最后一个成员<code>sem_nsems</code>确定了该信号灯在信号灯集中的顺序，这样内核就能够记录每个信号灯的信息了。</p>
<h4 id="操作信号灯"><a href="#操作信号灯" class="headerlink" title="操作信号灯"></a>操作信号灯</h4><p>&emsp;&emsp;对消息队列的操作无非有下面三种类型：</p>
<ul>
<li>打开或创建信号灯：与消息队列的创建及打开基本相同，不再详述。</li>
<li>信号灯值操作：<code>linux</code>可以增加或减小信号灯的值，相应于对共享资源的释放和占有。具体参见后面的<code>semop</code>系统调用。</li>
<li>获得或设置信号灯属性：系统中的每一个信号灯集都对应一个<code>struct sem_array</code>结构，该结构记录了信号灯集的各种信息，存在于系统空间。为了设置、获得该信号灯集的各种信息及属性，在用户空间有一个重要的联合结构与之对应，即<code>union semun</code>。</li>
</ul>
<p><img src="/2019/03/14/Linux系统编程/多进程编程之信号量/2.png"></p>
<h4 id="信号灯API"><a href="#信号灯API" class="headerlink" title="信号灯API"></a>信号灯API</h4><p>&emsp;&emsp;1. 文件名到键值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="keyword">key_t</span> ftok ( <span class="keyword">char</span> *pathname, <span class="keyword">char</span> proj );</span><br></pre></td></tr></table></figure>
<p>它返回与路径<code>pathname</code>相对应的一个键值，具体用法请参考消息队列。<br>&emsp;&emsp;2. <code>linux</code>特有的<code>ipc</code>调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipc</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> call, <span class="keyword">int</span> first, <span class="keyword">int</span> second, <span class="keyword">int</span> third, <span class="keyword">void</span> *ptr, <span class="keyword">long</span> fifth )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>call</code>取不同值时，对应信号灯的三个系统调用：</p>
<ul>
<li>当<code>call</code>为<code>SEMOP</code>时，对应<code>int semop(int semid, struct sembuf *sops, unsigned nsops)</code>调用。</li>
<li>当<code>call</code>为<code>SEMGET</code>时，对应<code>int semget(key_t key, int nsems, int semflg)</code>调用。</li>
<li>当<code>call</code>为<code>SEMCTL</code>时，对应<code>int semctl(int semid, int semnum, int cmd, union semun arg)</code>调用。</li>
</ul>
<p>本人不主张采用系统调用<code>ipc</code>，而更倾向于采用系统<code>V</code>或者<code>POSIX</code>进程间通信<code>API</code>。<br>&emsp;&emsp;3. 系统<code>V</code>信号灯<code>API</code>：系统<code>V</code>消息队列<code>API</code>只有三个，使用时需要包括几个头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>semget</code>函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span> <span class="params">( <span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg )</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>key</code>：一个键值，由<code>ftok</code>获得，唯一标识一个信号灯集，用法与<code>msgget</code>中的<code>key</code>相同。</li>
<li><code>nsems</code>：指定打开或者新创建的信号灯集中将包含信号灯的数目。</li>
<li><code>semflg</code>：一些标志位。</li>
</ol>
<p>参数<code>key</code>和<code>semflg</code>的取值，以及何时打开已有信号灯集或者创建一个新的信号灯集与<code>msgget</code>中的对应部分相同，不再祥述。该调用返回与健值<code>key</code>相对应的信号灯集描述字。函数执行成功返回信号灯集描述字，否则返回<code>-1</code>。<br>&emsp;&emsp;如果<code>key</code>所代表的信号灯已经存在，且<code>semget</code>指定了<code>IPC_CREAT | IPC_EXCL</code>标志，那么即使参数<code>nsems</code>与原来信号灯的数目不等，返回的也是<code>EEXIST</code>错误；如果<code>semget</code>只指定了<code>IPC_CREAT</code>标志。</p>
<ul>
<li><code>semop</code>函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span> <span class="params">( <span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">unsigned</span> nsops )</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>semid</code>是信号灯集<code>ID</code>，<code>sops</code>指向数组的每一个<code>sembuf</code>结构都刻画一个在特定信号灯上的操作；<code>nsops</code>为<code>sops</code>指向数组的大小。<code>sembuf</code>结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sem_num; <span class="comment">/* semaphore index in array */</span></span><br><span class="line">    <span class="keyword">short</span> sem_op; <span class="comment">/* semaphore operation */</span></span><br><span class="line">    <span class="keyword">short</span> sem_flg; <span class="comment">/* operation flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>sem_num</code>对应信号集中的信号灯，<code>0</code>对应第一个信号灯。<code>sem_flg</code>可取<code>IPC_NOWAIT</code>以及<code>SEM_UNDO</code>两个标志。如果设置了<code>SEM_UNDO</code>标志，那么在进程结束时，相应的操作将被取消，这是比较重要的一个标志位。如果设置了该标志位，那么在进程没有释放共享资源就退出时，内核将代为释放。如果为一个信号灯设置了该标志，内核都要分配一个<code>sem_undo</code>结构来记录它，为的是确保以后资源能够安全释放。事实上，如果进程退出了，那么它所占用就释放了，但信号灯值却没有改变，此时，信号灯值反映的已经不是资源占有的实际情况，在这种情况下，问题的解决就靠内核来完成。这有点像僵尸进程，进程虽然退出了，资源也都释放了，但内核进程表中仍然有它的记录，此时就需要父进程调用<code>waitpid</code>来解决问题了。<br>&emsp;&emsp;<code>sem_op</code>的值大于<code>0</code>，等于<code>0</code>以及小于<code>0</code>确定了对<code>sem_num</code>指定的信号灯进行的三种操作。<br>&emsp;&emsp;这里需要强调的是<code>semop</code>同时操作多个信号灯，在实际应用中，对应多种资源的申请或释放。<code>semop</code>保证操作的原子性，这一点尤为重要。尤其对于多种资源的申请来说，要么一次性获得所有资源，要么放弃申请，要么在不占有任何资源情况下继续等待，这样，一方面避免了资源的浪费；另一方面，避免了进程之间由于申请共享资源造成死锁。<br>&emsp;&emsp;也许从实际含义上更好理解这些操作：信号灯的当前值记录相应资源目前可用数目；<code>sem_op &gt; 0</code>对应相应进程要释放<code>sem_op</code>数目的共享资源；<code>sem_op = 0</code>可以用于对共享资源是否已用完的测试；<code>sem_op &lt; 0</code>相当于进程要申请<code>-sem_op</code>个共享资源。再联想操作的原子性，更不难理解该系统调用何时正常返回，何时睡眠等待。<br>&emsp;&emsp;调用返回：成功返回<code>0</code>，否则返回<code>-1</code>。</p>
<ul>
<li><code>semctl</code>函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span> <span class="params">( <span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, <span class="keyword">union</span> semun arg )</span></span>;</span><br></pre></td></tr></table></figure>
<p>该系统调用实现对信号灯的各种控制操作，参数<code>semid</code>指定信号灯集；参数<code>cmd</code>指定具体的操作类型；参数<code>semnum</code>指定对哪个信号灯操作，只对几个特殊的<code>cmd</code>操作有意义；<code>arg</code>用于设置或返回信号灯信息。该系统调用详细信息请参见其手册页，这里只给出参数<code>cmd</code>所能指定的操作：</p>
<ol>
<li><code>IPC_STAT</code>：获取信号灯信息，信息由<code>arg.buf</code>返回。</li>
<li><code>IPC_SET</code>：设置信号灯信息，待设置信息保存在<code>arg.buf</code>中。</li>
<li><code>GETALL</code>：返回所有信号灯的值，结果保存在<code>arg.array</code>中，参数<code>sennum</code>被忽略。</li>
<li><code>GETNCNT</code>：返回等待<code>semnum</code>所代表信号灯的值增加的进程数，相当于目前有多少进程在等待<code>semnum</code>代表的信号灯所代表的共享资源。</li>
<li><code>GETPID</code>：返回最后一个对<code>semnum</code>所代表信号灯执行<code>semop</code>操作的进程<code>ID</code>。</li>
<li><code>GETVAL</code>：返回<code>semnum</code>所代表信号灯的值。</li>
<li><code>GETZCNT</code>：返回等待<code>semnum</code>所代表信号灯的值变成<code>0</code>的进程数。</li>
<li><code>SETALL</code>：通过<code>arg.array</code>更新所有信号灯的值，并且更新与本信号集相关的<code>semid_ds</code>结构的<code>sem_ctime</code>成员。</li>
<li><code>SETVAL</code>：设置<code>semnum</code>所代表信号灯的值为<code>arg.val</code>。</li>
</ol>
<p>&emsp;&emsp;调用返回：调用失败返回<code>-1</code>，成功返回与<code>cmd</code>相关：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Cmd</th>
<th>return value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GETNCNT</code></td>
<td><code>Semncnt</code></td>
</tr>
<tr>
<td><code>GETPID</code></td>
<td><code>Sempid</code></td>
</tr>
<tr>
<td><code>GETVAL</code></td>
<td><code>Semval</code></td>
</tr>
<tr>
<td><code>GETZCNT</code></td>
<td><code>Semzcnt</code></td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;4. 信号灯的限制：</p>
<ul>
<li>一次系统调用<code>semop</code>可同时操作的信号灯数目<code>SEMOPM</code>，<code>semop</code>中的参数<code>nsops</code>如果超过了这个数目，将返回<code>E2BIG</code>错误。<code>SEMOPM</code>的大小特定于系统，<code>red hat 8.0</code>为<code>32</code>。</li>
<li>信号灯的最大数目<code>SEMVMX</code>，当设置信号灯值超过这个限制时，会返回<code>ERANGE</code>错误。在<code>red hat 8.0</code>中该值为<code>32767</code>。</li>
<li>系统范围内信号灯集的最大数目<code>SEMMNI</code>以及系统范围内信号灯的最大数目<code>SEMMNS</code>。超过这两个限制将返回<code>ENOSPC</code>错误。<code>red hat 8.0</code>中该值为<code>32000</code>。</li>
<li>每个信号灯集中的最大信号灯数目<code>SEMMSL</code>，<code>red hat 8.0</code>中为<code>250</code>。<code>SEMOPM</code>以及<code>SEMVMX</code>是使用<code>semop</code>调用时应该注意的；<code>SEMMNI</code>以及<code>SEMMNS</code>是调用<code>semget</code>时应该注意的。<code>SEMVMX</code>同时也是<code>semctl</code>调用应该注意的。</li>
</ul>
<p>&emsp;&emsp;5. 竞争问题<br>&emsp;&emsp;第一个创建信号灯的进程同时也初始化信号灯，这样系统调用<code>semget</code>包含了两个步骤：创建信号灯；初始化信号灯。由此可能导致一种竞争状态：第一个创建信号灯的进程在初始化信号灯时，第二个进程又调用<code>semget</code>，并且发现信号灯已经存在，此时第二个进程必须具有判断是否有进程正在对信号灯进行初始化的能力。这里给出了绕过这种竞争状态的方法：当<code>semget</code>创建一个新的信号灯时，信号灯结构<code>semid_ds</code>的<code>sem_otime</code>成员初始化后的值为<code>0</code>。因此，第二个进程在成功调用<code>semget</code>后，可再次以<code>IPC_STAT</code>命令调用<code>semctl</code>，等待<code>sem_otime</code>变为非<code>0</code>值，此时可判断该信号灯已经初始化完毕。下图描述了竞争状态产生及解决方法：</p>
<p><img src="/2019/03/14/Linux系统编程/多进程编程之信号量/3.png"></p>
<p>&emsp;&emsp;实际上，这种解决方法也是基于这样一个假定：第一个创建信号灯的进程必须调用<code>semop</code>，这样<code>sem_otime</code>才能变为非零值。另外，因为第一个进程可能不调用<code>semop</code>，或者<code>semop</code>操作需要很长时间，第二个进程可能无限期等待下去，或者等待很长时间。<br>&emsp;&emsp;信号灯与其它进程间通信方式有所不同，它主要用于进程间同步。通常所说的系统V信号灯实际上是一个信号灯的集合，可用于多种共享资源的进程间同步。每个信号灯都有一个值，可以用来表示当前该信号灯代表的共享资源可用(<code>available</code>)数量，如果一个进程要申请共享资源，那么就从信号灯值中减去要申请的数目，如果当前没有足够的可用资源，进程可以睡眠等待，也可以立即返回。当进程要申请多种共享资源时，<code>linux</code>可以保证操作的原子性，即要么申请到所有的共享资源，要么放弃所有资源，这样能够保证多个进程不会造成互锁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/94/">94</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">934</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
