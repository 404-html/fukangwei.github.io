<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="暴徒">
<meta property="og:url" content="http://fukangwei.gitee.io/page/3/index.html">
<meta property="og:site_name" content="暴徒">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="暴徒">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/3/">





  <title>暴徒</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">暴徒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/18/单片机/AD转换程序的问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/18/单片机/AD转换程序的问题/" itemprop="url">AD转换程序的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-18T18:02:16+08:00">
                2019-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;关于<code>AD</code>转换的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( n = <span class="number">0</span>; n &lt; <span class="number">8</span>; n++ ) &#123;</span><br><span class="line">    dis[<span class="number">2</span>] = ad_data[n] / <span class="number">51</span>; <span class="comment">/* 测得值转换为3位BCD码，最大为5.00V */</span></span><br><span class="line">    dis[<span class="number">4</span>] = ad_data[n] % <span class="number">51</span>; <span class="comment">/* 余数暂存 */</span></span><br><span class="line">    dis[<span class="number">4</span>] = dis[<span class="number">4</span>] * <span class="number">10</span>; <span class="comment">/* 计算小数第一位 */</span></span><br><span class="line">    dis[<span class="number">1</span>] = dis[<span class="number">4</span>] / <span class="number">51</span>;</span><br><span class="line">    dis[<span class="number">4</span>] = dis[<span class="number">4</span>] % <span class="number">51</span>;</span><br><span class="line">    dis[<span class="number">4</span>] = dis[<span class="number">4</span>] * <span class="number">10</span>; <span class="comment">/* 计算小数第二位 */</span></span><br><span class="line">    dis[<span class="number">0</span>] = dis[<span class="number">4</span>] / <span class="number">51</span>;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>ad_data</code>是<code>AD</code>转换后的数据，<code>dis</code>是要显示的内容。关于这段代码的解释如下：<br>&emsp;&emsp;<code>AD</code>转换一般是将外接的<code>0</code>至<code>5V</code>的电压变换成为<code>8</code>位二进制数，即<code>0</code>至<code>255</code>。如果想要将这些数字转换成<code>0.00</code>至<code>5.00V</code>，需要除以<code>51</code>。假设外接的电压是<code>3.29V</code>，经过<code>AD</code>转换后，送到单片机的数据将是<code>168</code>。由这个数字变换成<code>329</code>的运算步骤如下：</p>
<p><img src="/2019/03/18/单片机/AD转换程序的问题/1.jpg"></p>
<p>&emsp;&emsp;计算步骤如下：</p>
<ol>
<li><code>168</code>除以<code>51</code>，整数部分是<code>3</code>，余数部分是<code>15</code>。</li>
<li><code>15</code>后面添上<code>0</code>，即余数部分乘以<code>10</code>。</li>
<li><code>150</code>除以<code>51</code>，整数部分是<code>2</code>，余数部分是<code>48</code>。</li>
<li><code>48</code>后面添上<code>0</code>，即余数部分乘以<code>10</code>。</li>
<li><code>480</code>除以<code>51</code>，整数部分是<code>9</code>，余数部分是<code>21</code>。</li>
</ol>
<p>此时就得到了<code>329</code>，如果要求精度较高，可以继续除下去。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/18/Qt语法详解/Qt之QPainter/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/18/Qt语法详解/Qt之QPainter/" itemprop="url">Qt之QPainter</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-18T16:59:06+08:00">
                2019-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>&emsp;&emsp;<code>Qt</code>中提供了强大的<code>2D</code>绘图系统，可以使用相同的<code>API</code>在屏幕和绘图设备上进行绘制，它主要基于<code>QPainter</code>、<code>QPaintDevice</code>和<code>QPaintEngine</code>这三个类。<br>&emsp;&emsp;<code>QPainter</code>用来执行绘图操作，其提供的<code>API</code>在<code>GUI</code>或<code>QImage</code>、<code>QOpenGLPaintDevice</code>、<code>QWidget</code>和<code>QPaintDevice</code>显示图形(线、形状、渐变等)、文本和图像。<code>QPaintDevice</code>不直接绘制物理显示画面，而利用逻辑界面的中间媒介。例如绘制矩形图形时，为了将对象绘制到<code>QWidget</code>、<code>QGLPixelBuffer</code>、<code>QImage</code>、<code>QPixmap</code>、<code>QPicture</code>等多种界面中间，必须使用<code>QPaintDevice</code>。<code>QPaintEngine</code>提供了一些接口，可以用于<code>QPainter</code>在不同的设备上进行绘制。下图给出了这三个类之间的层次结构：</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QPainter/1.png"></p>
<p>&emsp;&emsp;这种实现的主要好处是，所有的绘制都遵循着同一种绘制流程，这样可以很方便地添加新的特性，也可以为不支持的功能添加一个默认的实现方式。另外需要说明一点，<code>Qt</code>提供了一个独立的<code>QtOpenGL</code>模块，可以让你在<code>Qt</code>的应用程序中使用<code>OpenGL</code>功能。该模块提供了一个<code>OpenGL</code>的模块，可以像其他的<code>Qt</code>组件一样的使用。它的不同之处在于，它是使用<code>OpenGL</code>作为显示技术，使用<code>OpenGL</code>函数进行绘制。<br>&emsp;&emsp;绘图系统由<code>QPainter</code>完成具体的绘制操作，<code>QPainter</code>类提供了大量高度优化的函数来完成<code>GUI</code>编程所需要的大部分绘制工作。它可以绘制一切想要的图形，从最简单的一条直线到其他任何复杂的图形，例如饼图、弧形等，还可以用来绘制文本和图片。<code>QPainter</code>可以在继承自<code>QPaintDevice</code>类的任何对象上进行绘制操作。<br>&emsp;&emsp;<code>QPainter</code>一般在部件的绘图事件<code>paintEvent</code>中进行绘制，首先创建<code>QPainter</code>对象，然后进行图形的绘制，最后记得销毁<code>QPainter</code>对象。当窗口程序需要升级或者重新绘制时，调用此成员函数。使用<code>repaint</code>和<code>update</code>后，调用函数<code>paintEvent</code>。</p>
<h3 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h3><p>&emsp;&emsp;效果如下：</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QPainter/2.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::paintEvent ( QPaintEvent *event ) &#123;</span><br><span class="line">    Q_UNUSED ( event );</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span> <span class="params">( <span class="keyword">this</span> )</span></span>;</span><br><span class="line">    painter.setRenderHint ( QPainter::Antialiasing, <span class="literal">true</span> ); <span class="comment">/* 反走样 */</span></span><br><span class="line">    painter.setPen ( QColor ( <span class="number">0</span>, <span class="number">160</span>, <span class="number">230</span> ) ); <span class="comment">/* 设置画笔颜色 */</span></span><br><span class="line">    <span class="comment">/* 绘制直线 */</span></span><br><span class="line">    painter.drawLine ( QPointF ( <span class="number">0</span>, height() ), QPointF ( width() / <span class="number">2</span>, height() / <span class="number">2</span> ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过<code>setRenderHint</code>来设置反走样，否则绘制出来的线条会出现锯齿；调用<code>setPen</code>来设置画笔颜色(淡蓝色)。最后调用<code>drawLine</code>来实现直线的绘制，其中<code>QPointF(0, height())</code>是指直线的起点坐标，<code>QPointF(width() / 2, height() / 2)</code>是指直线的终点坐标。</p>
<h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><p>&emsp;&emsp;效果如下：</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QPainter/3.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::paintEvent ( QPaintEvent *event ) &#123;</span><br><span class="line">    Q_UNUSED ( event );</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span> <span class="params">( <span class="keyword">this</span> )</span></span>;</span><br><span class="line">    painter.setRenderHint ( QPainter::Antialiasing, <span class="literal">true</span> ); <span class="comment">/* 反走样 */</span></span><br><span class="line">    painter.setPen ( QPen ( QColor ( <span class="number">0</span>, <span class="number">160</span>, <span class="number">230</span> ), <span class="number">2</span> ) ); <span class="comment">/* 设置画笔颜色、宽度 */</span></span><br><span class="line">    painter.setBrush ( QColor ( <span class="number">255</span>, <span class="number">160</span>, <span class="number">90</span> ) ); <span class="comment">/* 设置画刷颜色 */</span></span><br><span class="line">    painter.drawRect ( <span class="number">50</span>, <span class="number">50</span>, <span class="number">160</span>, <span class="number">100</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先使用<code>setPen</code>来设置画笔颜色(淡蓝色)、宽度(<code>2</code>像素)，用来设置矩形区域的边框。然后使用<code>setBrush</code>来设置画刷颜色(这里为橙色)，用来填充矩形区域，最后调用<code>drawRect</code>来实现矩形的绘制，其中参数依次顺序为<code>x</code>、<code>y</code>、<code>w</code>、<code>h</code>，是指区域从<code>x</code>为<code>50</code>、<code>y</code>为<code>50</code>的坐标点起，宽度为<code>160</code>，高度为<code>100</code>的矩形。</p>
<h3 id="绘制弧线"><a href="#绘制弧线" class="headerlink" title="绘制弧线"></a>绘制弧线</h3><p>&emsp;&emsp;效果如下：</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QPainter/4.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::paintEvent ( QPaintEvent *event ) &#123;</span><br><span class="line">    Q_UNUSED ( event );</span><br><span class="line">    <span class="function">QRectF <span class="title">rect</span> <span class="params">( <span class="number">90.0</span>, <span class="number">90.0</span>, <span class="number">80.0</span>, <span class="number">90.0</span> )</span></span>; <span class="comment">/* 矩形 */</span></span><br><span class="line">    <span class="keyword">int</span> startAngle = <span class="number">30</span> * <span class="number">16</span>; <span class="comment">/* 起始角度 */</span></span><br><span class="line">    <span class="keyword">int</span> spanAngle = <span class="number">120</span> * <span class="number">16</span>; <span class="comment">/* 跨越度数 */</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span> <span class="params">( <span class="keyword">this</span> )</span></span>;</span><br><span class="line">    painter.setRenderHint ( QPainter::Antialiasing, <span class="literal">true</span> ); <span class="comment">/* 反走样 */</span></span><br><span class="line">    painter.setPen ( QPen ( QColor ( <span class="number">0</span>, <span class="number">160</span>, <span class="number">230</span> ), <span class="number">2</span> ) ); <span class="comment">/* 设置画笔颜色、宽度 */</span></span><br><span class="line">    painter.drawArc ( rect, startAngle, spanAngle ); <span class="comment">/* 绘制弧线 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>画弧线时，角度被分成了十六分之一，就是说如果需要画出要<code>30</code>度，就是<code>30 * 16</code>。它有起始角度和跨度，还有位置矩形，所以要想画出自己想要的弧线，就需要大概估算出各个参数的预估值。</p>
<h3 id="绘制椭圆"><a href="#绘制椭圆" class="headerlink" title="绘制椭圆"></a>绘制椭圆</h3><p>&emsp;&emsp;效果如下：</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QPainter/5.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::paintEvent ( QPaintEvent *event ) &#123;</span><br><span class="line">    Q_UNUSED ( event );</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span> <span class="params">( <span class="keyword">this</span> )</span></span>;</span><br><span class="line">    painter.setRenderHint ( QPainter::Antialiasing, <span class="literal">true</span> ); <span class="comment">/* 反走样 */</span></span><br><span class="line">    painter.setPen ( QPen ( QColor ( <span class="number">0</span>, <span class="number">160</span>, <span class="number">230</span> ), <span class="number">2</span> ) ); <span class="comment">/* 设置画笔颜色、宽度 */</span></span><br><span class="line">    painter.drawEllipse ( QPointF ( <span class="number">120</span>, <span class="number">60</span> ), <span class="number">50</span>, <span class="number">20</span> ); <span class="comment">/* 绘制椭圆 */</span></span><br><span class="line">    painter.setBrush ( QColor ( <span class="number">255</span>, <span class="number">160</span>, <span class="number">90</span> ) ); <span class="comment">/* 设置画刷颜色 */</span></span><br><span class="line">    painter.drawEllipse ( QPointF ( <span class="number">120</span>, <span class="number">140</span> ), <span class="number">40</span>, <span class="number">40</span> ); <span class="comment">/* 绘制椭圆 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里绘制了一个椭圆和一个圆形，都是调用<code>drawEllipse</code>接口。我们可以很轻易地发现，如果为椭圆的时候，后面两个参数不一样，圆形则相同。第一个参数<code>QPointF</code>是指椭圆的中心点相对当前窗体<code>QPoint(0, 0)</code>点的位置，后面的参数指椭圆的<code>x</code>轴及<code>y</code>轴的半径。</p>
<h3 id="绘制多边形"><a href="#绘制多边形" class="headerlink" title="绘制多边形"></a>绘制多边形</h3><p>&emsp;&emsp;效果如下：</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QPainter/6.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::paintEvent ( QPaintEvent *event ) &#123;</span><br><span class="line">    Q_UNUSED ( event );</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span> <span class="params">( <span class="keyword">this</span> )</span></span>;</span><br><span class="line">    painter.setRenderHint ( QPainter::Antialiasing, <span class="literal">true</span> ); <span class="comment">/* 反走样 */</span></span><br><span class="line">    painter.setPen ( QColor ( <span class="number">0</span>, <span class="number">160</span>, <span class="number">230</span> ) ); <span class="comment">/* 设置画笔颜色 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> QPointF points[<span class="number">4</span>] = &#123; <span class="comment">/* 各个点的坐标 */</span></span><br><span class="line">        QPointF ( <span class="number">30</span>, <span class="number">40</span> ), QPointF ( <span class="number">60</span>, <span class="number">150</span> ),</span><br><span class="line">        QPointF ( <span class="number">150</span>, <span class="number">160</span> ), QPointF ( <span class="number">220</span>, <span class="number">100</span> ) &#125;;</span><br><span class="line">    painter.drawPolygon ( points, <span class="number">4</span> ); <span class="comment">/* 绘制多边形 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先指定坐标点的位置，这里有四个点，分别为<code>QPointF(30, 40)</code>、<code>QPointF(60, 150)</code>、<code>QPointF(150, 160)</code>、<code>QPointF(220, 100)</code>，然后调用<code>drawPolygon</code>将各个点连接起来，绘制为多边形。</p>
<h3 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h3><p>&emsp;&emsp;效果如下：</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QPainter/7.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::paintEvent ( QPaintEvent *event ) &#123;</span><br><span class="line">    Q_UNUSED ( event );</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span> <span class="params">( <span class="keyword">this</span> )</span></span>;</span><br><span class="line">    painter.setRenderHint ( QPainter::Antialiasing, <span class="literal">true</span> ); <span class="comment">/* 反走样 */</span></span><br><span class="line">    painter.drawPixmap ( rect(), QPixmap ( <span class="string">":/Images/logo"</span> ) ); <span class="comment">/* 绘制图标 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>drawPixmap</code>来绘制图片，我们可以指定图片绘制的区域<code>QRect</code>，这里为整个界面的区域。当界面伸缩的时候，图片也会跟着伸缩。<br>&emsp;&emsp;<code>QPainter</code>有很多以<code>draw</code>开头的函数，它们用于各种图形的绘制，比如<code>drawLine</code>、<code>drawRect</code>和和<code>drawEllipse</code>等。下图给出了<code>QPainter</code>的<code>draw</code>函数的实例：</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QPainter/8.png" height="306" width="254"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/18/Qt语法详解/Qt之QMainWindow/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/18/Qt语法详解/Qt之QMainWindow/" itemprop="url">Qt之QMainWindow</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-18T15:59:28+08:00">
                2019-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="主窗口简介"><a href="#主窗口简介" class="headerlink" title="主窗口简介"></a>主窗口简介</h3><p>&emsp;&emsp;<code>QT</code>中直接支持主窗口，<code>QMainWindow</code>是<code>QT</code>中主窗口的基类，是继承于<code>QWidget</code>类的容器型组件。<code>QMainWindow</code>内部封装了菜单栏、工具栏、中心组件、停靠组件、状态栏等。<code>QMainWindow</code>内置了布局管理器，基本的组件布局如下：</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QMainWindow/1.png"></p>
<h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><p>&emsp;&emsp;<code>QT</code>中提供了预定义的与菜单相关的类组件，例如菜单栏<code>QMenuBar</code>、下拉菜单<code>QMenu</code>和菜单项<code>QAction</code>。</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QMainWindow/2.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QMenuBar *mb = menuBar();</span><br><span class="line">QMenu *menu = <span class="keyword">new</span> QMenu ( <span class="string">"File(&amp;F)"</span> );</span><br><span class="line">QAction *action = <span class="keyword">new</span> QAction ( text, <span class="literal">NULL</span> );</span><br><span class="line">menu-&gt;addAction ( action );</span><br><span class="line">mb-&gt;addMenu ( menu );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;快捷键设置如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action-&gt;setShortcut ( QKeySequence ( KEY ) );</span><br></pre></td></tr></table></figure>
<h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><p>&emsp;&emsp;工具栏是应用程序中集成各种功能使用快捷方式的区域，不是应用程序必须存在的组件。工具栏的元素可以是各种窗口组件，但通常以图标按钮的方式存在。<code>QT</code>中提供了预定义的工具栏相关组件，工具栏<code>QToolBar</code>和快捷项<code>QAction</code>。</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QMainWindow/3.png"></p>
<p>&emsp;&emsp;工具栏使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QToolBar *tb = addToolBar ( <span class="string">"ToolBar"</span> ); <span class="comment">/* 创建工具栏 */</span></span><br><span class="line">QAction *action = <span class="keyword">new</span> QAction ( <span class="string">""</span>, <span class="literal">NULL</span> ); <span class="comment">/* 创建工具栏选项 */</span></span><br><span class="line">action-&gt;setToolTip ( <span class="string">"Open"</span> );</span><br><span class="line">action-&gt;setIcon ( QIcon ( <span class="string">"/res/pic/ open.png"</span> ) );</span><br><span class="line">tb-&gt;addAction ( action ); <span class="comment">/* 将工具栏选项加入工具栏 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>QToolBar</code>实用函数如下：</p>
<ul>
<li><code>void setFloatable ( bool floatable )</code>：设置工具栏为浮动。</li>
<li><code>void setMovable ( bool movable )</code>：设置工具栏为可移动。</li>
<li><code>void setIconSize ( const QSize &amp;iconSize )</code>：设置工具栏的图标大小。</li>
</ul>
<p>&emsp;&emsp;<code>QTollBar</code>组件中可以加入<code>QT</code>中的任意<code>QWidget</code>组件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">QToolBar *tb = addToolBar ( <span class="string">"Tool Bar"</span> );</span><br><span class="line">QAction *action = <span class="keyword">new</span> QAction ( <span class="string">""</span>, <span class="literal">NULL</span> );</span><br><span class="line">​</span><br><span class="line">tb-&gt;setFloatable ( <span class="literal">false</span> );</span><br><span class="line">tb-&gt;setMovable ( <span class="literal">false</span> );</span><br><span class="line">action-&gt;setToolTip ( <span class="string">"Open"</span> );</span><br><span class="line">action-&gt;setIcon ( QIcon ( <span class="string">":/Res/open.png"</span> ) );</span><br><span class="line">tb-&gt;addAction ( action );</span><br><span class="line">​</span><br><span class="line">QPushButton *b = <span class="keyword">new</span> QPushButton ( <span class="string">"Button"</span> );</span><br><span class="line">QLabel *l = <span class="keyword">new</span> QLabel ( <span class="string">"Label"</span> );</span><br><span class="line">QLineEdit *e = <span class="keyword">new</span> QLineEdit();</span><br><span class="line">​</span><br><span class="line">tb-&gt;addWidget ( b );</span><br><span class="line">tb-&gt;addWidget ( l );</span><br><span class="line">tb-&gt;addWidget ( e );</span><br></pre></td></tr></table></figure>
<h3 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h3><p>&emsp;&emsp;状态栏是应用程序中输出简要信息的区域，一般位于窗口的底部。状态栏显示的消息类型如下：</p>
<ul>
<li>实时消息，例如当前程序状态。</li>
<li>永久消息，例如程序版本，开发机构。</li>
<li>进度消息，用于进度显示。</li>
</ul>
<p>&emsp;&emsp;<code>QT</code>中提供了预定义的状态栏相关组件状态栏<code>QStatusBar</code>，<code>QStatusBar</code>是容器型组件，可以是任意组件<code>QWidget</code>的父组件。</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QMainWindow/4.png"></p>
<p>&emsp;&emsp;<code>QT</code>状态栏的一般设计原则：</p>
<ul>
<li>状态栏左边区域用于输出实时消息。</li>
<li>状态栏右边区域用于输出永久消息。</li>
</ul>
<p>&emsp;&emsp;因此，<code>addWidget</code>函数用于在状态栏左边区域添加组件，<code>addPermanentWidget</code>函数用于在状态栏右边区域添加组件。状态栏使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">QStatusBar *sb = statusBar();</span><br><span class="line">QLabel *label = <span class="keyword">new</span> QLabel ( <span class="string">"CopyRight @ Scorpio Studio 2016"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( label != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    line.setMinimumWidth ( <span class="number">120</span> );</span><br><span class="line">    line.setAlignment ( Qt::AlignCenter );</span><br><span class="line">    line.setText ( <span class="string">"Ln: 1    Col: 1"</span> );</span><br><span class="line">    label-&gt;setMinimumWidth ( <span class="number">160</span> );</span><br><span class="line">    label-&gt;setAlignment ( Qt::AlignCenter );</span><br><span class="line">    sb-&gt;addPermanentWidget ( <span class="keyword">new</span> QLabel() );</span><br><span class="line">    sb-&gt;addPermanentWidget ( &amp;line );</span><br><span class="line">    sb-&gt;addPermanentWidget ( label );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文本编辑组件"><a href="#文本编辑组件" class="headerlink" title="文本编辑组件"></a>文本编辑组件</h3><p>&emsp;&emsp;<code>QT</code>中预定义了三种文本编辑组件，用于满足不同的开发需求。</p>
<ul>
<li><code>QLineEdit</code>：单行文本编辑组件。</li>
<li><code>QTextEdit</code>：多行富文本编辑组件。</li>
<li><code>QPlainTextEdit</code>：多行普通文本编辑组件。</li>
</ul>
<p>&emsp;&emsp;<code>QT</code>文本编辑组件的类继承图如下：</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QMainWindow/5.png" height="252" width="331"></p>
<p>&emsp;&emsp;<code>QT</code>中的文本编辑组件内置了右键弹出和快捷键功能。文本编辑器的使用为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mainEditor.setParent ( <span class="keyword">this</span> ); <span class="comment">/* 设置文本编辑器的父组件 */</span></span><br><span class="line">setCentralWidget ( &amp;mainEditor ); <span class="comment">/* 设置文本编辑器为中央组件 */</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/18/Qt语法详解/Qt之QSplitter/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/18/Qt语法详解/Qt之QSplitter/" itemprop="url">Qt之QSplitter</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-18T15:18:56+08:00">
                2019-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;分割窗口在应用程序中经常用到，它可以灵活分布窗口布局，经常用于类似文件资源管理器的窗口设计中。</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QSplitter/1.png" height="275" width="694"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSplitter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextCodec&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    QTextCodec::setCodecForTr ( QTextCodec::codecForLocale() );</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    <span class="comment">/* 创建主分割窗口，设置方向为水平分割窗口 */</span></span><br><span class="line">    QSplitter *mainSplitter = <span class="keyword">new</span> QSplitter ( Qt::Horizontal, <span class="number">0</span> );</span><br><span class="line">    <span class="comment">/* 创建一个QTextEdit控件，设置其父控件为mainSplitter */</span></span><br><span class="line">    QTextEdit *leftEdit = <span class="keyword">new</span> QTextEdit ( QObject::tr ( <span class="string">"左窗口"</span> ), mainSplitter );</span><br><span class="line">    <span class="comment">/* 设置QTextEdit控件中的文字的对齐方式居中显示 */</span></span><br><span class="line">    leftEdit-&gt;setAlignment ( Qt::AlignCenter );</span><br><span class="line">    <span class="comment">/* 创建右分割窗口，设置其父控件为mainSplitter，设置方向为垂直分割窗口，最后其分割成上下两个窗口 */</span></span><br><span class="line">    QSplitter *rightSplitter = <span class="keyword">new</span> QSplitter ( Qt::Vertical, mainSplitter );</span><br><span class="line">    <span class="comment">/* 设定分割窗口的分割条在拖动时是否为实时更新，true为实时更新，false则在拖动时只显示一条灰色的线条，</span></span><br><span class="line"><span class="comment">       在拖动到位并弹起鼠标后再显示分隔条 */</span></span><br><span class="line">    rightSplitter-&gt;setOpaqueResize ( <span class="literal">false</span> );</span><br><span class="line">    <span class="comment">/* 开始将其分割成上下两个窗口 */</span></span><br><span class="line">    QTextEdit *upEdit = <span class="keyword">new</span> QTextEdit ( QObject::tr ( <span class="string">"上窗口"</span> ), rightSplitter );</span><br><span class="line">    upEdit-&gt;setAlignment ( Qt::AlignCenter );</span><br><span class="line">    QTextEdit *bottomEdit = <span class="keyword">new</span> QTextEdit ( QObject::tr ( <span class="string">"下窗口"</span> ), rightSplitter );</span><br><span class="line">    bottomEdit-&gt;setAlignment ( Qt::AlignCenter );</span><br><span class="line">    <span class="comment">/* 设定可伸缩控件，第一个参数指定控件设置的控件序号，该控件序号按插入的先后次序依次从0开始编号。</span></span><br><span class="line"><span class="comment">       第二个参数大于0表示此控件为伸缩控件，此例中设置右部分割窗口为可伸缩控件 */</span></span><br><span class="line">    mainSplitter-&gt;setStretchFactor ( <span class="number">1</span>, <span class="number">1</span> );</span><br><span class="line">    mainSplitter-&gt;setWindowTitle ( QObject::tr ( <span class="string">"分割窗口"</span> ) );</span><br><span class="line">    mainSplitter-&gt;show();</span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Qt之Splitter分割窗口"><a href="#Qt之Splitter分割窗口" class="headerlink" title="Qt之Splitter分割窗口"></a>Qt之Splitter分割窗口</h3><p>&emsp;&emsp;一个<code>QSplitter</code>控件中可以包含其他控件，这些控件被一个分隔条隔开。托拽这个分隔条，里面的控件的大小可以改变。<code>QSplitter</code>控件经常做为布局管理器使用，给用户提供更多的界面控制。<code>QSplitter</code>控件中的子控件总是按顺序自动并肩排列(或者上下排列)，相邻的控件之间有一个分隔条。下面是创建下图中窗体的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    QTextEdit *editor1 = <span class="keyword">new</span> QTextEdit;</span><br><span class="line">    QTextEdit *editor2 = <span class="keyword">new</span> QTextEdit;</span><br><span class="line">    QTextEdit *editor3 = <span class="keyword">new</span> QTextEdit;</span><br><span class="line">    <span class="function">QSplitter <span class="title">splitter</span> <span class="params">( Qt::Horizontal )</span></span>;</span><br><span class="line">    splitter.addWidget ( editor1 );</span><br><span class="line">    splitter.addWidget ( editor2 );</span><br><span class="line">    splitter.addWidget ( editor3 );</span><br><span class="line">    ...</span><br><span class="line">    splitter.show();</span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/18/Qt语法详解/Qt之QSplitter/2.png"></p>
<p>&emsp;&emsp;这个例子中的窗体有一个<code>QSplitter</code>控件，其中有三个水平排列的<code>QTextEdit</code>控件。和布局管理器不同，<code>QSplitter</code>不但可以排列子控件，还有一个可视的外观，<code>QSplitter</code>控件从<code>QWidget</code>继承，拥有<code>QWidget</code>所有的功能。</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QSplitter/3.png"></p>
<p>&emsp;&emsp;当应用程序启动时，<code>QSplitter</code>根据子控件的初始尺寸或者<code>sizeHint</code>合理分配每一个子控件的大小。在程序中，我们可以调用<code>QSplitter::setSizes</code>改变分隔条的位置。<code>QSplitter</code>还可以保存当前的状态，在程序下一次运行时恢复以前的状态。下面是<code>writeSettings</code>函数，保存当前分隔条的状态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MailClient::writeSettings() &#123;</span><br><span class="line">    <span class="function">QSettings <span class="title">settings</span> <span class="params">( <span class="string">"Software Inc."</span>, <span class="string">"Mail Client"</span> )</span></span>;</span><br><span class="line">    settings.beginGroup ( <span class="string">"mainWindow"</span> );</span><br><span class="line">    settings.setValue ( <span class="string">"size"</span>, size() );</span><br><span class="line">    settings.setValue ( <span class="string">"mainSplitter"</span>, mainSplitter-&gt;saveState() );</span><br><span class="line">    settings.setValue ( <span class="string">"rightSplitter"</span>, rightSplitter-&gt;saveState() );</span><br><span class="line">    settings.endGroup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下面是相应的<code>readSettings</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MailClient::readSettings() &#123;</span><br><span class="line">    <span class="function">QSettings <span class="title">settings</span> <span class="params">( <span class="string">"Software Inc."</span>, <span class="string">"Mail Client"</span> )</span></span>;</span><br><span class="line">    settings.beginGroup ( <span class="string">"mainWindow"</span> );</span><br><span class="line">    resize ( settings.value ( <span class="string">"size"</span>, QSize ( <span class="number">480</span>, <span class="number">360</span> ) ).toSize() );</span><br><span class="line">    mainSplitter-&gt;restoreState ( settings.value ( <span class="string">"mainSplitter"</span> ).toByteArray() );</span><br><span class="line">    rightSplitter-&gt;restoreState ( settings.value ( <span class="string">"rightSplitter"</span> ).toByteArray() );</span><br><span class="line">    settings.endGroup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Qt Designer</code>也支持<code>QSplitter</code>，把子控件放到合适的位置，将他们选中，选择菜单<code>Form|Lay out Horizontally in Splitter</code>或者<code>Form|Lay out Verticallly in Splitter</code>，所选择的子控件就被加入到<code>QSplitter</code>控件中。<br>&emsp;&emsp;对<code>QSplitter</code>进行水平或者垂直嵌套可以实现更加复杂的布局。例如下图所示的<code>MailClient</code>程序中，就是一个垂直方向的<code>QSplitter</code>控件中嵌套了一个水平方向的<code>QSplitter</code>控件。</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QSplitter/4.png" height="286" width="416"></p>
<p>&emsp;&emsp;下面的代码是<code>MailClient</code>程序的主窗口类构造函数代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MailClient::MailClient() &#123;</span><br><span class="line">    ...</span><br><span class="line">    rightSplitter = <span class="keyword">new</span> QSplitter ( Qt::Vertical );</span><br><span class="line">    rightSplitter-&gt;addWidget ( messagesTreeWidget ); <span class="comment">/* 索引0 */</span></span><br><span class="line">    rightSplitter-&gt;addWidget ( textEdit ); <span class="comment">/* 索引1 */</span></span><br><span class="line">    rightSplitter-&gt;setStretchFactor ( <span class="number">1</span>, <span class="number">1</span> ); <span class="comment">/* 指定索引为1的textEdit拉伸 */</span></span><br><span class="line">    mainSplitter = <span class="keyword">new</span> QSplitter ( Qt::Horizontal );</span><br><span class="line">    mainSplitter-&gt;addWidget ( foldersTreeWidget );</span><br><span class="line">    mainSplitter-&gt;addWidget ( rightSplitter );</span><br><span class="line">    mainSplitter-&gt;setStretchFactor ( <span class="number">1</span>, <span class="number">1</span> );</span><br><span class="line">    setCentralWidget ( mainSplitter );</span><br><span class="line">    setWindowTitle ( tr ( <span class="string">"Mail Client"</span> ) );</span><br><span class="line">    readSettings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;创建完我们所需要显示三个控件(<code>messageTreeWidget</code>、<code>textEdit</code>和<code>foldersTreeWidget</code>)后，再创建一个垂直的<code>rightSplitter</code>控件，把<code>messageTreeWidget</code>和<code>textEdit</code>控件加到<code>rightSplitter</code>中。然后创建一个水平的<code>mainSplitter</code>控件，把<code>rightSplitter</code>和<code>foldersTreeWidget</code>加入到<code>mainSplitter</code>中，把<code>mainSplitter</code>做为<code>QMainWindow</code>的中央控件。<br>&emsp;&emsp;当用户改变窗口的大小时，<code>QSplitter</code>通常给所有的子控件一样的空间。在<code>MailClient</code>程序中，我们希望左边的文件树控件(<code>foldersTreeWidget</code>)和消息树控件(<code>messageTreeWidget</code>)保持它们的大小，把其他的空间都分配给<code>QTextEdit</code>，这是由两个<code>setStretchFactor</code>调用实现。第一个参数是<code>0</code>开始的子控件的索引值，第二个参数是设置的拉伸系数，缺省值为<code>0</code>。</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QSplitter/5.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/18/Qt语法详解/Qt之QWizard/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/18/Qt语法详解/Qt之QWizard/" itemprop="url">Qt之QWizard</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-18T09:01:08+08:00">
                2019-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QWizard</code> class provides a framework for wizards.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td>QWizard</td>
<td>QDialog</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QWizard(QWidget * parent = 0, Qt::WindowFlags flags = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QWizard()</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>addPage(QWizardPage * page)</code></td>
</tr>
<tr>
<td><code>QAbstractButton *</code></td>
<td><code>button(WizardButton which) const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>buttonText(WizardButton which) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>currentId() const</code></td>
</tr>
<tr>
<td><code>QWizardPage *</code></td>
<td><code>currentPage() const</code></td>
</tr>
<tr>
<td><code>QVariant</code></td>
<td><code>field(const QString &amp; name) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasVisitedPage(int id) const</code></td>
</tr>
<tr>
<td><code>virtual int</code></td>
<td><code>nextId() const</code></td>
</tr>
<tr>
<td><code>WizardOptions</code></td>
<td><code>options() const</code></td>
</tr>
<tr>
<td><code>QWizardPage *</code></td>
<td><code>page(int id) const</code></td>
</tr>
<tr>
<td><code>QList&lt;int&gt;</code></td>
<td><code>pageIds() const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>pixmap(WizardPixmap which) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removePage(int id)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setButton(WizardButton which, QAbstractButton * button)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setButtonLayout(const QList&lt;WizardButton&gt; &amp; layout)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setButtonText(WizardButton which, const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDefaultProperty(const char * className, const char * property, const char * changedSignal)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setField(const QString &amp; name, const QVariant &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setOption(WizardOption option, bool on = true)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setOptions(WizardOptions options)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPage(int id, QWizardPage * page)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPixmap(WizardPixmap which, const QPixmap &amp; pixmap)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSideWidget(QWidget * widget)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setStartId(int id)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSubTitleFormat(Qt::TextFormat format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTitleFormat(Qt::TextFormat format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setWizardStyle(WizardStyle style)</code></td>
</tr>
<tr>
<td><code>QWidget *</code></td>
<td><code>sideWidget() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>startId() const</code></td>
</tr>
<tr>
<td><code>Qt::TextFormat</code></td>
<td><code>subTitleFormat() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>testOption(WizardOption option) const</code></td>
</tr>
<tr>
<td><code>Qt::TextFormat</code></td>
<td><code>titleFormat() const</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>validateCurrentPage()</code></td>
</tr>
<tr>
<td><code>QList&lt;int&gt;</code></td>
<td><code>visitedPages() const</code></td>
</tr>
<tr>
<td><code>WizardStyle</code></td>
<td><code>wizardStyle() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Public-Functions"><a href="#Reimplemented-Public-Functions" class="headerlink" title="Reimplemented Public Functions"></a>Reimplemented Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual void</code></td>
<td><code>setVisible(bool visible)</code></td>
</tr>
<tr>
<td><code>virtual QSize</code></td>
<td><code>sizeHint() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Slots"><a href="#Public-Slots" class="headerlink" title="Public Slots"></a>Public Slots</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>back()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>next()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>restart()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>currentIdChanged(int id)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>customButtonClicked(int which)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>helpRequested()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>pageAdded(int id)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>pageRemoved(int id)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual void</code></td>
<td><code>cleanupPage(int id)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>initializePage(int id)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Protected-Functions"><a href="#Reimplemented-Protected-Functions" class="headerlink" title="Reimplemented Protected Functions"></a>Reimplemented Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual void</code></td>
<td><code>done(int result)</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>event(QEvent * event)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>paintEvent(QPaintEvent * event)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>resizeEvent(QResizeEvent * event)</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>winEvent(MSG * message, long * result)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QWizard</code> class provides a framework for wizards.<br>&emsp;&emsp;A wizard (also called an assistant on <code>Mac OS X</code>) is a special type of input dialog that consists of a sequence of pages. A wizard’s purpose is to guide the user through a process step by step. Wizards are useful for complex or infrequent tasks that users may find difficult to learn.<br>&emsp;&emsp;<code>QWizard</code> inherits <code>QDialog</code> and represents a wizard. Each page is a <code>QWizardPage</code> (a <code>QWidget</code> subclass). To create your own wizards, you can use these classes directly, or you can subclass them for more control.<br>&emsp;&emsp;Topics: A Trivial Example. The following example illustrates how to create wizard pages and add them to a wizard.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QWizardPage *<span class="title">createIntroPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QWizardPage *page = <span class="keyword">new</span> QWizardPage;</span><br><span class="line">    page-&gt;setTitle ( <span class="string">"Introduction"</span> );</span><br><span class="line">    QLabel *label = <span class="keyword">new</span> QLabel ( <span class="string">"This wizard will help you register your copy "</span></span><br><span class="line">                                 <span class="string">"of Super Product Two."</span> );</span><br><span class="line">    label-&gt;setWordWrap ( <span class="literal">true</span> );</span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    layout-&gt;addWidget ( label );</span><br><span class="line">    page-&gt;setLayout ( layout );</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function">QWizardPage *<span class="title">createRegistrationPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function">QWizardPage *<span class="title">createConclusionPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    QString translatorFileName = QLatin1String ( <span class="string">"qt_"</span> );</span><br><span class="line">    translatorFileName += QLocale::system().name();</span><br><span class="line">    QTranslator *translator = <span class="keyword">new</span> QTranslator ( &amp;app );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( translator-&gt;load ( translatorFileName, QLibraryInfo::location ( QLibraryInfo::TranslationsPath ) ) ) &#123;</span><br><span class="line">        app.installTranslator ( translator );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    QWizard wizard;</span><br><span class="line">    wizard.addPage ( createIntroPage() );</span><br><span class="line">    wizard.addPage ( createRegistrationPage() );</span><br><span class="line">    wizard.addPage ( createConclusionPage() );</span><br><span class="line">    wizard.setWindowTitle ( <span class="string">"Trivial Wizard"</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Q_OS_SYMBIAN</span></span><br><span class="line">    wizard.showMaximized();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    wizard.show();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Wizard-Look-and-Feel"><a href="#Wizard-Look-and-Feel" class="headerlink" title="Wizard Look and Feel"></a>Wizard Look and Feel</h3><p>&emsp;&emsp;<code>QWizard</code> supports four wizard looks:</p>
<ul>
<li><code>ClassicStyle</code></li>
<li><code>ModernStyle</code></li>
<li><code>MacStyle</code></li>
<li><code>AeroStyle</code></li>
</ul>
<p>&emsp;&emsp;You can explicitly set the look to use using <code>setWizardStyle()</code> (e.g., if you want the same look on all platforms).</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QWizard/1.png" height="291" width="540"></p>
<p>&emsp;&emsp;<strong>Note</strong>: <code>AeroStyle</code> has effect only on a <code>Windows Vista system</code> with alpha compositing enabled. <code>ModernStyle</code> is used as a fallback when this condition is not met.<br>&emsp;&emsp;In addition to the wizard style, there are several options that control the look and feel of the wizard. These can be set using <code>setOption()</code> or <code>setOptions()</code>. For example, <code>HaveHelpButton</code> makes <code>QWizard</code> show a Help button along with the other wizard buttons.<br>&emsp;&emsp;You can even change the order of the wizard buttons to any arbitrary order using <code>setButtonLayout()</code>, and you can add up to three custom buttons (e.g., a <code>Print</code> button) to the button row. This is achieved by calling <code>setButton()</code> or <code>setButtonText()</code> with <code>CustomButton1</code>, <code>CustomButton2</code> or <code>CustomButton3</code> to set up the button, and by enabling the <code>HaveCustomButton1</code>, <code>HaveCustomButton2</code> or <code>HaveCustomButton3</code> options. Whenever the user clicks a custom button, <code>customButtonClicked()</code> is emitted. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wizard()-&gt;setButtonText ( QWizard::CustomButton1, tr ( <span class="string">"&amp;Print"</span> ) );</span><br><span class="line">wizard()-&gt;setOption ( QWizard::HaveCustomButton1, <span class="literal">true</span> );</span><br><span class="line">connect ( wizard(), SIGNAL ( customButtonClicked ( <span class="keyword">int</span> ) ), <span class="keyword">this</span>, SLOT ( printButtonClicked() ) );</span><br></pre></td></tr></table></figure>
<h3 id="Elements-of-a-Wizard-Page"><a href="#Elements-of-a-Wizard-Page" class="headerlink" title="Elements of a Wizard Page"></a>Elements of a Wizard Page</h3><p>&emsp;&emsp;Wizards consist of a sequence of <code>QWizardPages</code>. At any time, only one page is shown. A page has the following attributes:</p>
<ul>
<li>A title.</li>
<li>A subTitle.</li>
<li>A set of pixmaps, which may or may not be honored, depending on the wizard’s style:</li>
</ul>
<ol>
<li><code>WatermarkPixmap</code> (used by <code>ClassicStyle</code> and <code>ModernStyle</code>)</li>
<li><code>BannerPixmap</code> (used by <code>ModernStyle</code>)</li>
<li><code>LogoPixmap</code> (used by <code>ClassicStyle</code> and <code>ModernStyle</code>)</li>
<li><code>BackgroundPixmap</code> (used by <code>MacStyle</code>)</li>
</ol>
<p>&emsp;&emsp;The diagram belows shows how <code>QWizard</code> renders these attributes, assuming they are all present and <code>ModernStyle</code> is used:</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QWizard/2.png" height="292" width="455"></p>
<p>&emsp;&emsp;When a <code>subTitle</code> is set, <code>QWizard</code> displays it in a header, in which case it also uses the <code>BannerPixmap</code> and the <code>LogoPixmap</code> to decorate the header. The <code>WatermarkPixmap</code> is displayed on the left side, below the header. At the bottom, there is a row of buttons allowing the user to navigate through the pages.<br>&emsp;&emsp;The page itself (the <code>QWizardPage</code> widget) occupies the area between the header, the watermark, and the button row. Typically, the page is a <code>QWizardPage</code> on which a <code>QGridLayout</code> is installed, with standard child widgets (<code>QLabels</code>, <code>QLineEdits</code>, etc.).<br>&emsp;&emsp;If the wizard’s style is <code>MacStyle</code>, the page looks radically different:</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QWizard/3.png" height="294" width="511"></p>
<p>&emsp;&emsp;The watermark, banner, and logo pixmaps are ignored by the <code>MacStyle</code>. If the <code>BackgroundPixmap</code> is set, it is used as the background for the wizard; otherwise, a default <code>assistant</code> image is used.<br>&emsp;&emsp;The title and subtitle are set by calling <code>QWizardPage::setTitle()</code> and <code>QWizardPage::setSubTitle()</code> on the individual pages. They may be plain text or <code>HTML</code>. The pixmaps can be set globally for the entire wizard using <code>setPixmap()</code>, or on a <code>per-page</code> basis using <code>QWizardPage::setPixmap()</code>.</p>
<h3 id="Registering-and-Using-Fields"><a href="#Registering-and-Using-Fields" class="headerlink" title="Registering and Using Fields"></a>Registering and Using Fields</h3><p>&emsp;&emsp;In many wizards, the contents of a page may affect the default values of the fields of a later page. To make it easy to communicate between pages, <code>QWizard</code> supports a <code>field</code> mechanism that allows you to register a field (e.g., a <code>QLineEdit</code>) on a page and to access its value from any page. It is also possible to specify mandatory fields (i.e., fields that must be filled before the user can advance to the next page).<br>&emsp;&emsp;To register a field, call <code>QWizardPage::registerField()</code> field. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ClassInfoPage::ClassInfoPage ( QWidget *parent ) : QWizardPage ( parent ) &#123;</span><br><span class="line">    ...</span><br><span class="line">    classNameLabel = <span class="keyword">new</span> QLabel ( tr ( <span class="string">"&amp;Class name:"</span> ) );</span><br><span class="line">    classNameLineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">    classNameLabel-&gt;setBuddy ( classNameLineEdit );</span><br><span class="line">    baseClassLabel = <span class="keyword">new</span> QLabel ( tr ( <span class="string">"B&amp;ase class:"</span> ) );</span><br><span class="line">    baseClassLineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">    baseClassLabel-&gt;setBuddy ( baseClassLineEdit );</span><br><span class="line">    qobjectMacroCheckBox = <span class="keyword">new</span> QCheckBox ( tr ( <span class="string">"Generate Q_OBJECT &amp;macro"</span> ) );</span><br><span class="line">    registerField ( <span class="string">"className*"</span>, classNameLineEdit );</span><br><span class="line">    registerField ( <span class="string">"baseClass"</span>, baseClassLineEdit );</span><br><span class="line">    registerField ( <span class="string">"qobjectMacro"</span>, qobjectMacroCheckBox );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The above code registers three fields, <code>className</code>, <code>baseClass</code>, and <code>qobjectMacro</code>, which are associated with three child widgets. The asterisk (<code>*</code>) next to <code>className</code> denotes a mandatory field.<br>&emsp;&emsp;The fields of any page are accessible from any other page. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> OutputFilesPage::initializePage() &#123;</span><br><span class="line">    QString className = field ( <span class="string">"className"</span> ).toString();</span><br><span class="line">    headerLineEdit-&gt;setText ( className.toLower() + <span class="string">".h"</span> );</span><br><span class="line">    implementationLineEdit-&gt;setText ( className.toLower() + <span class="string">".cpp"</span> );</span><br><span class="line">    outputDirLineEdit-&gt;setText ( QDir::convertSeparators ( QDir::tempPath() ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Here, we call <code>QWizardPage::field()</code> to access the contents of the <code>className</code> field (which was defined in the <code>ClassInfoPage</code>) and use it to initialize the <code>OuputFilePage</code>. The field’s contents is returned as a <code>QVariant</code>.<br>&emsp;&emsp;When we create a field using <code>QWizardPage::registerField()</code>, we pass a unique field name and a widget. We can also provide a <code>Qt</code> property name and a <code>changed</code> signal (a signal that is emitted when the property changes) as third and fourth arguments; however, this is not necessary for the most common <code>Qt</code> widgets, such as <code>QLineEdit</code>, <code>QCheckBox</code> and <code>QComboBox</code>, because <code>QWizard</code> knows which properties to look for.<br>&emsp;&emsp;If an asterisk (<code>*</code>) is appended to the name when the property is registered, the field is a mandatory field. When a page has mandatory fields, the <code>Next</code> and/or <code>Finish</code> buttons are enabled only when all mandatory fields are filled.<br>&emsp;&emsp;To consider a field <code>filled</code>, <code>QWizard</code> simply checks that the field’s current value doesn’t equal the original value (the value it had when <code>initializePage()</code> was called). For <code>QLineEdit</code> and <code>QAbstractSpinBox</code> subclasses, <code>QWizard</code> also checks that <code>hasAcceptableInput()</code> returns <code>true</code>, to honor any validator or mask.<br>&emsp;&emsp;<code>QWizard&#39;s</code> mandatory field mechanism is provided for convenience. A more powerful (but also more cumbersome) alternative is to reimplement <code>QWizardPage::isComplete()</code> and to emit the <code>QWizardPage::completeChanged()</code> signal whenever the page becomes complete or incomplete.<br>&emsp;&emsp;The <code>enabled/disabled</code> state of the <code>Next</code> and/or <code>Finish</code> buttons is one way to perform validation on the user input. Another way is to reimplement <code>validateCurrentPage()</code> (or <code>QWizardPage::validatePage()</code>) to perform some <code>last-minute</code> validation (and show an error message if the user has entered incomplete or invalid information). If the function returns <code>true</code>, the next page is shown (or the wizard finishes); otherwise, the current page stays up.</p>
<h3 id="Creating-Linear-Wizards"><a href="#Creating-Linear-Wizards" class="headerlink" title="Creating Linear Wizards"></a>Creating Linear Wizards</h3><p>&emsp;&emsp;Most wizards have a linear structure, with <code>page 1</code> followed by <code>page 2</code> and so on until the last page. The <code>Class Wizard</code> example is such a wizard. With <code>QWizard</code>, linear wizards are created by instantiating the <code>QWizardPages</code> and inserting them using <code>addPage()</code>. By default, the pages are shown in the order in which they were added. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClassWizard::ClassWizard ( QWidget *parent ) : QWizard ( parent ) &#123;</span><br><span class="line">    addPage ( <span class="keyword">new</span> IntroPage );</span><br><span class="line">    addPage ( <span class="keyword">new</span> ClassInfoPage );</span><br><span class="line">    addPage ( <span class="keyword">new</span> CodeStylePage );</span><br><span class="line">    addPage ( <span class="keyword">new</span> OutputFilesPage );</span><br><span class="line">    addPage ( <span class="keyword">new</span> ConclusionPage );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;When a page is about to be shown, <code>QWizard</code> calls <code>initializePage()</code> (which in turn calls <code>QWizardPage::initializePage()</code>) to fill the page with default values. By default, this function does nothing, but it can be reimplemented to initialize the page’s contents based on other pages’ fields.<br>&emsp;&emsp;If the user presses <code>Back</code>, <code>cleanupPage()</code> is called (which in turn calls <code>QWizardPage::cleanupPage()</code>). The default implementation resets the page’s fields to their original values (the values they had before <code>initializePage()</code> was called). If you want the <code>Back</code> button to be <code>non-destructive</code> and keep the values entered by the user, simply enable the <code>IndependentPages</code> option.</p>
<h3 id="Creating-Non-Linear-Wizards"><a href="#Creating-Non-Linear-Wizards" class="headerlink" title="Creating Non-Linear Wizards"></a>Creating Non-Linear Wizards</h3><p>&emsp;&emsp;Some wizards are more complex in that they allow different traversal paths based on the information provided by the user. The <code>License Wizard</code> example illustrates this. It provides five wizard pages; depending on which options are selected, the user can reach different pages.</p>
<p><img src="/2019/03/18/Qt语法详解/Qt之QWizard/4.png" height="297" width="416"></p>
<p>&emsp;&emsp;In complex wizards, pages are identified by <code>IDs</code>. These <code>IDs</code> are typically defined using an enum. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LicenseWizard</span> :</span> <span class="keyword">public</span> QWizard &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">enum</span> &#123; Page_Intro, Page_Evaluate, Page_Register, Page_Details, Page_Conclusion &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The pages are inserted using <code>setPage()</code>, which takes an <code>ID</code> and an instance of <code>QWizardPage</code> (or of a subclass):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LicenseWizard::LicenseWizard ( QWidget *parent ) : QWizard ( parent ) &#123;</span><br><span class="line">    setPage ( Page_Intro, <span class="keyword">new</span> IntroPage );</span><br><span class="line">    setPage ( Page_Evaluate, <span class="keyword">new</span> EvaluatePage );</span><br><span class="line">    setPage ( Page_Register, <span class="keyword">new</span> RegisterPage );</span><br><span class="line">    setPage ( Page_Details, <span class="keyword">new</span> DetailsPage );</span><br><span class="line">    setPage ( Page_Conclusion, <span class="keyword">new</span> ConclusionPage );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;By default, the pages are shown in increasing <code>ID</code> order. To provide a dynamic order that depends on the options chosen by the user, we must reimplement <code>QWizardPage::nextId()</code>. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> IntroPage::nextId() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( evaluateRadioButton-&gt;isChecked() ) &#123;</span><br><span class="line">        <span class="keyword">return</span> LicenseWizard::Page_Evaluate;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LicenseWizard::Page_Register;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">int</span> EvaluatePage::nextId() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> LicenseWizard::Page_Conclusion;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">int</span> RegisterPage::nextId() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( upgradeKeyLineEdit-&gt;text().isEmpty() ) &#123;</span><br><span class="line">        <span class="keyword">return</span> LicenseWizard::Page_Details;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LicenseWizard::Page_Conclusion;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">int</span> DetailsPage::nextId() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> LicenseWizard::Page_Conclusion;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">int</span> ConclusionPage::nextId() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;It would also be possible to put all the logic in one place, in a <code>QWizard::nextId()</code> reimplementation. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> LicenseWizard::nextId() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( currentId() ) &#123;</span><br><span class="line">        <span class="keyword">case</span> Page_Intro:</span><br><span class="line">            <span class="keyword">if</span> ( field ( <span class="string">"intro.evaluate"</span> ).toBool() ) &#123;</span><br><span class="line">                <span class="keyword">return</span> Page_Evaluate;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Page_Register;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> Page_Evaluate:</span><br><span class="line">            <span class="keyword">return</span> Page_Conclusion;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> Page_Register:</span><br><span class="line">            <span class="keyword">if</span> ( field ( <span class="string">"register.upgradeKey"</span> ).toString().isEmpty() ) &#123;</span><br><span class="line">                <span class="keyword">return</span> Page_Details;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Page_Conclusion;</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> Page_Details:</span><br><span class="line">            <span class="keyword">return</span> Page_Conclusion;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">case</span> Page_Conclusion:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;To start at another page than the page with the lowest <code>ID</code>, call <code>setStartId()</code>.<br>&emsp;&emsp;To test whether a page has been visited or not, call <code>hasVisitedPage()</code>s. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ConclusionPage::initializePage() &#123;</span><br><span class="line">    QString licenseText;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( wizard()-&gt;hasVisitedPage ( LicenseWizard::Page_Evaluate ) ) &#123;</span><br><span class="line">        licenseText = tr ( <span class="string">"&lt;u&gt;Evaluation License Agreement:&lt;/u&gt; "</span></span><br><span class="line">                           <span class="string">"You can use this software for 30 days and make one "</span></span><br><span class="line">                           <span class="string">"backup, but you are not allowed to distribute it."</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( wizard()-&gt;hasVisitedPage ( LicenseWizard::Page_Details ) ) &#123;</span><br><span class="line">        licenseText = tr ( <span class="string">"&lt;u&gt;First-Time License Agreement:&lt;/u&gt; "</span></span><br><span class="line">                           <span class="string">"You can use this software subject to the license "</span></span><br><span class="line">                           <span class="string">"you will receive by email."</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        licenseText = tr ( <span class="string">"&lt;u&gt;Upgrade License Agreement:&lt;/u&gt; "</span></span><br><span class="line">                           <span class="string">"This software is licensed under the terms of your "</span></span><br><span class="line">                           <span class="string">"current license."</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    bottomLabel-&gt;setText ( licenseText );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QWizard::WizardButton</code>: This enum specifies the buttons in a wizard.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QWizard::BackButton</code></td>
<td><code>0</code></td>
<td>The <code>Back</code> button (Go <code>Back</code> on <code>Mac OS X</code>)</td>
</tr>
<tr>
<td><code>QWizard::NextButton</code></td>
<td><code>1</code></td>
<td>The <code>Next</code> button (<code>Continue</code> on <code>Mac OS X</code>)</td>
</tr>
<tr>
<td><code>QWizard::CommitButton</code></td>
<td><code>2</code></td>
<td>The <code>Commit</code> button</td>
</tr>
<tr>
<td><code>QWizard::FinishButton</code></td>
<td><code>3</code></td>
<td>The <code>Finish</code> button (<code>Done</code> on <code>Mac OS X</code>)</td>
</tr>
<tr>
<td><code>QWizard::CancelButton</code></td>
<td><code>4</code></td>
<td>The <code>Cancel</code> button</td>
</tr>
<tr>
<td><code>QWizard::HelpButton</code></td>
<td><code>5</code></td>
<td>The <code>Help</code> button</td>
</tr>
<tr>
<td><code>QWizard::CustomButton1</code></td>
<td><code>6</code></td>
<td>The first <code>user-defined</code> button</td>
</tr>
<tr>
<td><code>QWizard::CustomButton2</code></td>
<td><code>7</code></td>
<td>The second <code>user-defined</code> button</td>
</tr>
<tr>
<td><code>QWizard::CustomButton3</code></td>
<td><code>8</code></td>
<td>The third <code>user-defined</code> button</td>
</tr>
</tbody>
</table>
</div>
<p>The following value is only useful when calling <code>setButtonLayout()</code>:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QWizard::Stretch</code></td>
<td><code>9</code></td>
<td>A horizontal stretch in the button layout</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QWizard::WizardOption</code>, flags <code>QWizard::WizardOptions</code>: This enum specifies various options that affect the look and feel of a wizard.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QWizard::IndependentPages</code></td>
<td><code>0x00000001</code></td>
<td>The pages are independent of each other (i.e., they don’t derive values from each other).</td>
</tr>
<tr>
<td><code>QWizard::IgnoreSubTitles</code></td>
<td><code>0x00000002</code></td>
<td>Don’t show any subtitles, even if they are set.</td>
</tr>
<tr>
<td><code>QWizard::ExtendedWatermarkPixmap</code></td>
<td><code>0x00000004</code></td>
<td>Extend any <code>WatermarkPixmap</code> all the way down to the window’s edge.</td>
</tr>
<tr>
<td><code>QWizard::NoDefaultButton</code></td>
<td><code>0x00000008</code></td>
<td>Don’t make the <code>Next</code> or <code>Finish</code> button the dialog’s default button.</td>
</tr>
<tr>
<td><code>QWizard::NoBackButtonOnStartPage</code></td>
<td><code>0x00000010</code></td>
<td>Don’t show the <code>Back</code> button on the start page.</td>
</tr>
<tr>
<td><code>QWizard::NoBackButtonOnLastPage</code></td>
<td><code>0x00000020</code></td>
<td>Don’t show the <code>Back</code> button on the last page.</td>
</tr>
<tr>
<td><code>QWizard::DisabledBackButtonOnLastPage</code></td>
<td><code>0x00000040</code></td>
<td>Disable the <code>Back</code> button on the last page.</td>
</tr>
<tr>
<td><code>QWizard::HaveNextButtonOnLastPage</code></td>
<td><code>0x00000080</code></td>
<td>Show the (disabled) <code>Next</code> button on the last page.</td>
</tr>
<tr>
<td><code>QWizard::HaveFinishButtonOnEarlyPages</code></td>
<td><code>0x00000100</code></td>
<td>Show the (disabled) <code>Finish</code> button on <code>non-final</code> pages.</td>
</tr>
<tr>
<td><code>QWizard::NoCancelButton</code></td>
<td><code>0x00000200</code></td>
<td>Don’t show the <code>Cancel</code> button.</td>
</tr>
<tr>
<td><code>QWizard::CancelButtonOnLeft</code></td>
<td><code>0x00000400</code></td>
<td>Put the <code>Cancel</code> button on the left of <code>Back</code> (rather than on the right of <code>Finish</code> or <code>Next</code>).</td>
</tr>
<tr>
<td><code>QWizard::HaveHelpButton</code></td>
<td><code>0x00000800</code></td>
<td>Show the <code>Help</code> button.</td>
</tr>
<tr>
<td><code>QWizard::HelpButtonOnRight</code></td>
<td><code>0x00001000</code></td>
<td>Put the <code>Help</code> button on the far right of the button layout (rather than on the far left).</td>
</tr>
<tr>
<td><code>QWizard::HaveCustomButton1</code></td>
<td><code>0x00002000</code></td>
<td>Show the first <code>user-defined</code> button (<code>CustomButton1</code>).</td>
</tr>
<tr>
<td><code>QWizard::HaveCustomButton2</code></td>
<td><code>0x00004000</code></td>
<td>Show the second <code>user-defined</code> button (<code>CustomButton2</code>).</td>
</tr>
<tr>
<td><code>QWizard::HaveCustomButton3</code></td>
<td><code>0x00008000</code></td>
<td>Show the third <code>user-defined</code> button (<code>CustomButton3</code>).</td>
</tr>
</tbody>
</table>
</div>
<p>The <code>WizardOptions</code> type is a typedef for <code>QFlags&lt;WizardOption&gt;</code>. It stores an <code>OR</code> combination of <code>WizardOption</code> values.</p>
<ul>
<li>enum <code>QWizard::WizardPixmap</code>: This enum specifies the pixmaps that can be associated with a page.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QWizard::WatermarkPixmap</code></td>
<td><code>0</code></td>
<td>The tall pixmap on the left side of a <code>ClassicStyle</code> or <code>ModernStyle</code> page</td>
</tr>
<tr>
<td><code>QWizard::LogoPixmap</code></td>
<td><code>1</code></td>
<td>The small pixmap on the right side of a <code>ClassicStyle</code> or <code>ModernStyle</code> page header</td>
</tr>
<tr>
<td><code>QWizard::BannerPixmap</code></td>
<td><code>2</code></td>
<td>The pixmap that occupies the background of a <code>ModernStyle</code> page header</td>
</tr>
<tr>
<td><code>QWizard::BackgroundPixmap</code></td>
<td><code>3</code></td>
<td>The pixmap that occupies the background of a <code>MacStyle</code> wizard</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QWizard::WizardStyle</code>: This enum specifies the different looks supported by <code>QWizard</code>.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QWizard::ClassicStyle</code></td>
<td><code>0</code></td>
<td><code>Classic Windows</code> look</td>
</tr>
<tr>
<td><code>QWizard::ModernStyle</code></td>
<td><code>1</code></td>
<td><code>Modern Windows</code> look</td>
</tr>
<tr>
<td><code>QWizard::MacStyle</code></td>
<td><code>2</code></td>
<td><code>Mac OS X</code> look</td>
</tr>
<tr>
<td><code>QWizard::AeroStyle</code></td>
<td><code>3</code></td>
<td><code>Windows Aero</code> look</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Property-Documentation"><a href="#Property-Documentation" class="headerlink" title="Property Documentation"></a>Property Documentation</h3><ul>
<li><code>currentId : const int</code>: This property holds the <code>ID</code> of the current page. This property cannot be set directly. To change the current page, call <code>next()</code>, <code>back()</code> or <code>restart()</code>. By default, this property has a value of <code>-1</code>, indicating that no page is currently shown. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">currentId</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line">Notifier signal:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">currentIdChanged</span> <span class="params">( <span class="keyword">int</span> id )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>options : WizardOptions</code>: This property holds the various options that affect the look and feel of the wizard. By default, the following options are set (depending on the platform):</li>
</ul>
<ol>
<li><code>Windows</code>: <code>HelpButtonOnRight</code></li>
<li><code>Mac OS X</code>: <code>NoDefaultButton</code> and <code>NoCancelButton</code></li>
<li><code>X11</code> and <code>QWS</code> (<code>Qt</code> for <code>Embedded Linux</code>): <code>none</code></li>
</ol>
<p>Access functions:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WizardOptions <span class="title">options</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setOptions</span> <span class="params">( WizardOptions options )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>startId : int</code>: This property holds the <code>ID</code> of the first page. If this property isn’t explicitly set, this property defaults to the lowest page <code>ID</code> in this wizard, or <code>-1</code> if no page has been inserted yet. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startId</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setStartId</span> <span class="params">( <span class="keyword">int</span> id )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>subTitleFormat : Qt::TextFormat</code>: This property holds the text format used by page subtitles. The default format is <code>Qt::AutoText</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Qt::<span class="function">TextFormat <span class="title">subTitleFormat</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSubTitleFormat</span> <span class="params">( Qt::TextFormat format )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>titleFormat : Qt::TextFormat</code>: This property holds the text format used by page titles. The default format is <code>Qt::AutoText</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Qt::<span class="function">TextFormat <span class="title">titleFormat</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTitleFormat</span> <span class="params">( Qt::TextFormat format )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>wizardStyle : WizardStyle</code>: This property holds the look and feel of the wizard. By default, <code>QWizard</code> uses the <code>AeroStyle</code> on a <code>Windows Vista system</code> with alpha compositing enabled, regardless of the current widget style. If this is not the case, the default wizard style depends on the current widget style as follows: <code>MacStyle</code> is the default if the current widget style is <code>QMacStyle</code>, <code>ModernStyle</code> is the default if the current widget style is <code>QWindowsStyle</code>, and <code>ClassicStyle</code> is the default in all other cases. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WizardStyle <span class="title">wizardStyle</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWizardStyle</span> <span class="params">( WizardStyle style )</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QWizard::QWizard(QWidget * parent = 0, Qt::WindowFlags flags = 0)</code>: Constructs a wizard with the given <code>parent</code> and window <code>flags</code>.</li>
<li><code>QWizard::~QWizard()</code>: Destroys the wizard and its pages, releasing any allocated resources.</li>
<li><code>int QWizard::addPage(QWizardPage * page)</code>: Adds the given <code>page</code> to the wizard, and returns the page’s <code>ID</code>. The <code>ID</code> is guaranteed to be larger than any other <code>ID</code> in the <code>QWizard</code> so far.</li>
<li><code>void QWizard::back() [slot]</code>: Goes back to the previous page. This is equivalent to pressing the Back button.</li>
<li><code>QAbstractButton * QWizard::button(WizardButton which) const</code>: Returns the button corresponding to role <code>which</code>.</li>
<li><code>QString QWizard::buttonText(WizardButton which) const</code>: Returns the text on button <code>which</code>. If a text has ben set using <code>setButtonText()</code>, this text is returned. By default, the text on buttons depends on the <code>wizardStyle</code>. For example, on <code>Mac OS X</code>, the <code>Next</code> button is called <code>Continue</code>.</li>
<li><code>void QWizard::cleanupPage(int id) [virtual protected]</code>: This virtual function is called by <code>QWizard</code> to clean up page id just before the user leaves it by clicking <code>Back</code> (unless the <code>QWizard::IndependentPages</code> option is set). The default implementation calls <code>QWizardPage::cleanupPage()</code> on <code>page(id)</code>.</li>
<li><code>QWizardPage * QWizard::currentPage() const</code>: Returns a pointer to the current page, or <code>0</code> if there is no current page (e.g., before the wizard is shown). This is equivalent to calling <code>page(currentId())</code>.</li>
<li><code>void QWizard::customButtonClicked(int which) [signal]</code>: This signal is emitted when the user clicks a custom button. <code>which</code> can be <code>CustomButton1</code>, <code>CustomButton2</code> or <code>CustomButton3</code>. By default, no custom button is shown. Call <code>setOption()</code> with <code>HaveCustomButton1</code>, <code>HaveCustomButton2</code> or <code>HaveCustomButton3</code> to have one, and use <code>setButtonText()</code> or <code>setButton()</code> to configure it.</li>
<li><code>void QWizard::done(int result) [virtual protected]</code>: Reimplemented from <code>QDialog::done()</code>.</li>
<li><code>bool QWizard::event(QEvent * event) [virtual protected]</code>: Reimplemented from <code>QObject::event()</code>.</li>
<li><code>QVariant QWizard::field(const QString &amp; name) const</code>: Returns the value of the field called <code>name</code>. This function can be used to access fields on any page of the wizard.</li>
<li><code>bool QWizard::hasVisitedPage(int id) const</code>: Returns <code>true</code> if the page history contains page <code>id</code>; otherwise, returns <code>false</code>. Pressing <code>Back</code> marks the current page as <code>unvisited</code> again.</li>
<li><code>void QWizard::helpRequested() [signal]</code>: This signal is emitted when the user clicks the <code>Help</code> button. By default, no <code>Help</code> button is shown. Call <code>setOption(HaveHelpButton, true)</code> to have one. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">LicenseWizard::LicenseWizard ( QWidget *parent ) : QWizard ( parent ) &#123;</span><br><span class="line">    ...</span><br><span class="line">    setOption ( HaveHelpButton, <span class="literal">true</span> );</span><br><span class="line">    connect ( <span class="keyword">this</span>, SIGNAL ( helpRequested() ), <span class="keyword">this</span>, SLOT ( showHelp() ) );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> LicenseWizard::showHelp() &#123;</span><br><span class="line">    <span class="keyword">static</span> QString lastHelpMessage;</span><br><span class="line">    QString message;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">switch</span> ( currentId() ) &#123;</span><br><span class="line">        <span class="keyword">case</span> Page_Intro:</span><br><span class="line">            message = tr ( <span class="string">"The decision you make here will affect which page you "</span></span><br><span class="line">                           <span class="string">"get to see next."</span> );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            message = tr ( <span class="string">"This help is likely not to be of any help."</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    QMessageBox::information ( <span class="keyword">this</span>, tr ( <span class="string">"License Wizard Help"</span> ), message );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QWizard::initializePage(int id) [virtual protected]</code>: This virtual function is called by QWizard to prepare page <code>id</code> just before it is shown either as a result of <code>QWizard::restart()</code> being called, or as a result of the user clicking <code>Next</code>. (However, if the <code>QWizard::IndependentPages</code> option is set, this function is only called the first time the page is shown) By reimplementing this function, you can ensure that the page’s fields are properly initialized based on fields from previous pages. The default implementation calls <code>QWizardPage::initializePage()</code> on <code>page(id)</code>.</li>
<li><code>void QWizard::next() [slot]</code>: Advances to the next page. This is equivalent to pressing the Next or <code>Commit</code> button.</li>
<li><code>int QWizard::nextId() const [virtual]</code>: This virtual function is called by <code>QWizard</code> to find out which page to show when the user clicks the <code>Next</code> button. The return value is the <code>ID</code> of the next page, or <code>-1</code> if no page follows. The default implementation calls <code>QWizardPage::nextId()</code> on the <code>currentPage()</code>. By reimplementing this function, you can specify a dynamic page order.</li>
<li><code>QWizardPage * QWizard::page(int id) const</code>: Returns the page with the given <code>id</code>, or <code>0</code> if there is no such page.</li>
<li><code>void QWizard::pageAdded(int id) [signal]</code>: This signal is emitted whenever a page is added to the wizard. The page’s <code>id</code> is passed as parameter.</li>
<li><code>QList&lt;int&gt; QWizard::pageIds() const</code>: Returns the list of page <code>IDs</code>.</li>
<li><code>void QWizard::pageRemoved(int id) [signal]</code>: This signal is emitted whenever a page is removed from the wizard. The page’s <code>id</code> is passed as parameter.</li>
<li><code>void QWizard::paintEvent(QPaintEvent * event) [virtual protected]</code>: Reimplemented from <code>QWidget::paintEvent()</code>.</li>
<li><code>QPixmap QWizard::pixmap(WizardPixmap which) const</code>: Returns the pixmap set for role <code>which</code>. By default, the only pixmap that is set is the <code>BackgroundPixmap</code> on <code>Mac OS X</code>.</li>
<li><code>void QWizard::removePage(int id)</code>: Removes the page with the given <code>id</code>. <code>cleanupPage()</code> will be called if necessary. <strong>Note</strong>: Removing a page may influence the value of the <code>startId</code> property.</li>
<li><code>void QWizard::resizeEvent(QResizeEvent * event) [virtual protected]</code>: Reimplemented from <code>QWidget::resizeEvent()</code>.</li>
<li><code>void QWizard::restart() [slot]</code>: Restarts the wizard at the start page. This function is called automatically when the wizard is shown.</li>
<li><code>void QWizard::setButton(WizardButton which, QAbstractButton * button)</code>: Sets the button corresponding to role <code>which</code> to <code>button</code>. To add extra buttons to the wizard (e.g., a <code>Print</code> button), one way is to call <code>setButton()</code> with <code>CustomButton1</code> to <code>CustomButton3</code>, and make the buttons visible using the <code>HaveCustomButton1</code> to <code>HaveCustomButton3</code> options.</li>
<li><code>void QWizard::setButtonLayout(const QList&lt;WizardButton&gt; &amp; layout)</code>: Sets the order in which buttons are displayed to <code>layout</code>, where <code>layout</code> is a list of <code>WizardButtons</code>. The default layout depends on the options (e.g., whether <code>HelpButtonOnRight</code>) that are set. You can call this function if you need more control over the buttons’ layout than what options already provides. You can specify horizontal stretches in the layout using Stretch. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyWizard::MyWizard ( QWidget *parent ) : QWizard ( parent ) &#123;</span><br><span class="line">    ...</span><br><span class="line">    QList&lt;QWizard::WizardButton&gt; layout;</span><br><span class="line">    layout &lt;&lt; QWizard::Stretch &lt;&lt; QWizard::BackButton &lt;&lt; QWizard::CancelButton</span><br><span class="line">           &lt;&lt; QWizard::NextButton &lt;&lt; QWizard::FinishButton;</span><br><span class="line">    setButtonLayout ( layout );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QWizard::setButtonText(WizardButton which, const QString &amp; text)</code>: Sets the text on button <code>which</code> to be <code>text</code>. By default, the text on buttons depends on the <code>wizardStyle</code>. For example, on <code>Mac OS X</code>, the <code>Next</code> button is called <code>Continue</code>. To add extra buttons to the wizard (e.g., a <code>Print</code> button), one way is to call <code>setButtonText()</code> with <code>CustomButton1</code>, <code>CustomButton2</code> or <code>CustomButton3</code> to set their text, and make the buttons visible using the <code>HaveCustomButton1</code>, <code>HaveCustomButton2</code> and/or <code>HaveCustomButton3</code> options. Button texts may also be set on a <code>per-page</code> basis using <code>QWizardPage::setButtonText()</code>.</li>
<li><code>void QWizard::setDefaultProperty(const char * className, const char * property, const char * changedSignal)</code>: Sets the default property for <code>className</code> to be <code>property</code>, and the associated change signal to be <code>changedSignal</code>. The default property is used when an instance of <code>className</code> (or of one of its subclasses) is passed to <code>QWizardPage::registerField()</code> and no property is specified. <code>QWizard</code> knows the most common <code>Qt</code> widgets. For these (or their subclasses), you don’t need to specify a property or a <code>changedSignal</code>. The table below lists these widgets:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Widget</th>
<th>Property</th>
<th>Change Notification Signal</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QAbstractButton</code></td>
<td><code>bool checked</code></td>
<td><code>toggled()</code></td>
</tr>
<tr>
<td><code>QAbstractSlider</code></td>
<td><code>int value</code></td>
<td><code>valueChanged()</code></td>
</tr>
<tr>
<td><code>QComboBox</code></td>
<td><code>int currentIndex</code></td>
<td><code>currentIndexChanged()</code></td>
</tr>
<tr>
<td><code>QDateTimeEdit</code></td>
<td><code>QDateTime dateTime</code></td>
<td><code>dateTimeChanged()</code></td>
</tr>
<tr>
<td><code>QLineEdit</code></td>
<td><code>QString text</code></td>
<td><code>textChanged()</code></td>
</tr>
<tr>
<td><code>QListWidget</code></td>
<td><code>int currentRow</code></td>
<td><code>currentRowChanged()</code></td>
</tr>
<tr>
<td><code>QSpinBox</code></td>
<td><code>int value</code></td>
<td><code>valueChanged()</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>void QWizard::setField(const QString &amp; name, const QVariant &amp; value)</code>: Sets the value of the field called <code>name</code> to <code>value</code>. This function can be used to set fields on any page of the wizard.</li>
<li><code>void QWizard::setOption(WizardOption option, bool on = true)</code>: Sets the given <code>option</code> to be enabled if <code>on</code> is <code>true</code>; otherwise, clears the given option.</li>
<li><code>void QWizard::setPage(int id, QWizardPage * page)</code>: Adds the given <code>page</code> to the wizard with the given <code>id</code>. <strong>Note</strong>: Adding a page may influence the value of the <code>startId</code> property in case it was not set explicitly.</li>
<li><code>void QWizard::setPixmap(WizardPixmap which, const QPixmap &amp; pixmap)</code>: Sets the pixmap for role <code>which</code> to <code>pixmap</code>. The pixmaps are used by <code>QWizard</code> when displaying a page. Which pixmaps are actually used depend on the wizard style. Pixmaps can also be set for a specific page using <code>QWizardPage::setPixmap()</code>.</li>
<li><code>void QWizard::setSideWidget(QWidget * widget)</code>: Sets the given <code>widget</code> to be shown on the left side of the wizard. For styles which use the <code>WatermarkPixmap</code> (<code>ClassicStyle</code> and <code>ModernStyle</code>) the side widget is displayed on top of the watermark, for other styles or when the watermark is not provided the side widget is displayed on the left side of the wizard. Passing <code>0</code> shows no side widget. When the widget is not <code>0</code> the wizard reparents it. Any previous side widget is hidden. You may call <code>setSideWidget()</code> with the same widget at different times. All widgets set here will be deleted by the wizard when it is destroyed unless you separately reparent the widget after setting some other side widget (or <code>0</code>). By default, no side widget is present.</li>
<li><code>void QWizard::setVisible(bool visible) [virtual]</code>: Reimplemented from <code>QWidget::setVisible()</code>.</li>
<li><code>QWidget * QWizard::sideWidget() const</code>: Returns the widget on the left side of the wizard or <code>0</code>. By default, no side widget is present.</li>
<li><code>QSize QWizard::sizeHint() const [virtual]</code>: Reimplemented from <code>QWidget::sizeHint()</code>.</li>
<li><code>bool QWizard::testOption(WizardOption option) const</code>: Returns <code>true</code> if the given option is enabled; otherwise, returns <code>false</code>.</li>
<li><code>bool QWizard::validateCurrentPage() [virtual]</code>: This virtual function is called by <code>QWizard</code> when the user clicks <code>Next</code> or <code>Finish</code> to perform some <code>last-minute</code> validation. If it returns true, the next page is shown (or the wizard finishes); otherwise, the current page stays up. The default implementation calls <code>QWizardPage::validatePage()</code> on the <code>currentPage()</code>. When possible, it is usually better style to disable the <code>Next</code> or <code>Finish</code> button (by specifying mandatory fields or by reimplementing <code>QWizardPage::isComplete()</code>) than to reimplement <code>validateCurrentPage()</code>.</li>
<li><code>QList&lt;int&gt; QWizard::visitedPages() const</code>: Returns the list of <code>IDs</code> of visited pages, in the order in which the pages were visited. Pressing <code>Back</code> marks the current page as <code>unvisited</code> again.</li>
<li><code>bool QWizard::winEvent(MSG * message, long * result) [virtual protected]</code>: Reimplemented from <code>QWidget::winEvent()</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/17/Qt语法详解/Qt之QListWidget/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/17/Qt语法详解/Qt之QListWidget/" itemprop="url">Qt之QListWidget</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-17T20:00:33+08:00">
                2019-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>QListWidget</code>可以显示一个清单，清单中的每个项目是<code>QListWidgetItem</code>的一个实例，每个项目可以通过<code>QListWidgetItem</code>来操作。可以通过<code>QListWidgetItem</code>来设置每个项目的图像与文字。<br>&emsp;&emsp;示例<code>1</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QListWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QListWidgetItem&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    QWidget *widget = <span class="keyword">new</span> QWidget;</span><br><span class="line">    QListWidget *listWidget = <span class="keyword">new</span> QListWidget;</span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    QListWidgetItem *lst1 = <span class="keyword">new</span> QListWidgetItem ( <span class="string">"data"</span>, listWidget );</span><br><span class="line">    QListWidgetItem *lst2 = <span class="keyword">new</span> QListWidgetItem ( <span class="string">"decision"</span>, listWidget );</span><br><span class="line">    QListWidgetItem *lst3 = <span class="keyword">new</span> QListWidgetItem ( <span class="string">"document"</span>, listWidget );</span><br><span class="line">    QListWidgetItem *lst4 = <span class="keyword">new</span> QListWidgetItem ( <span class="string">"process"</span>, listWidget );</span><br><span class="line">    QListWidgetItem *lst5 = <span class="keyword">new</span> QListWidgetItem ( <span class="string">"printer"</span>, listWidget );</span><br><span class="line">    listWidget-&gt;insertItem ( <span class="number">1</span>, lst1 );</span><br><span class="line">    listWidget-&gt;insertItem ( <span class="number">2</span>, lst2 );</span><br><span class="line">    listWidget-&gt;insertItem ( <span class="number">3</span>, lst3 );</span><br><span class="line">    listWidget-&gt;insertItem ( <span class="number">4</span>, lst4 );</span><br><span class="line">    listWidget-&gt;insertItem ( <span class="number">5</span>, lst5 );</span><br><span class="line">    listWidget-&gt;show();</span><br><span class="line">    layout-&gt;addWidget ( listWidget );</span><br><span class="line">    widget-&gt;setLayout ( layout );</span><br><span class="line">    widget-&gt;show();</span><br><span class="line">    app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/17/Qt语法详解/Qt之QListWidget/1.png"></p>
<p>&emsp;&emsp;示例<code>2</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QListWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QListWidgetItem&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    QWidget *widget = <span class="keyword">new</span> QWidget;</span><br><span class="line">    QListWidget *listWidget = <span class="keyword">new</span> QListWidget;</span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    QListWidgetItem *lst1 = <span class="keyword">new</span> QListWidgetItem ( QIcon ( <span class="string">"images/data.png"</span> ), <span class="string">"data"</span>, listWidget );</span><br><span class="line">    QListWidgetItem *lst2 = <span class="keyword">new</span> QListWidgetItem ( QIcon ( <span class="string">"images/decision.png"</span> ), <span class="string">"decision"</span>, listWidget );</span><br><span class="line">    QListWidgetItem *lst3 = <span class="keyword">new</span> QListWidgetItem ( QIcon ( <span class="string">"images/document.png"</span> ), <span class="string">"document"</span>, listWidget );</span><br><span class="line">    QListWidgetItem *lst4 = <span class="keyword">new</span> QListWidgetItem ( QIcon ( <span class="string">"images/process.png"</span> ), <span class="string">"process"</span>, listWidget );</span><br><span class="line">    QListWidgetItem *lst5 = <span class="keyword">new</span> QListWidgetItem ( QIcon ( <span class="string">"images/printer.png"</span> ), <span class="string">"printer"</span>, listWidget );</span><br><span class="line">    listWidget-&gt;insertItem ( <span class="number">1</span>, lst1 );</span><br><span class="line">    listWidget-&gt;insertItem ( <span class="number">2</span>, lst2 );</span><br><span class="line">    listWidget-&gt;insertItem ( <span class="number">3</span>, lst3 );</span><br><span class="line">    listWidget-&gt;insertItem ( <span class="number">4</span>, lst4 );</span><br><span class="line">    listWidget-&gt;insertItem ( <span class="number">5</span>, lst5 );</span><br><span class="line">    listWidget-&gt;show();</span><br><span class="line">    layout-&gt;addWidget ( listWidget );</span><br><span class="line">    widget-&gt;setLayout ( layout );</span><br><span class="line">    widget-&gt;show();</span><br><span class="line">    app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/17/Qt语法详解/Qt之QListWidget/2.png"></p>
<p>&emsp;&emsp;示例<code>3</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QListWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QListWidgetItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    QWidget *widget = <span class="keyword">new</span> QWidget;</span><br><span class="line">    QListWidget *listWidget = <span class="keyword">new</span> QListWidget;</span><br><span class="line">    QHBoxLayout *layout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    QLabel *label = <span class="keyword">new</span> QLabel;</span><br><span class="line">    label-&gt;setFixedWidth ( <span class="number">100</span> );</span><br><span class="line">    QListWidgetItem *lst1 = <span class="keyword">new</span> QListWidgetItem ( QIcon ( <span class="string">"images/data.png"</span> ), <span class="string">"data"</span>, listWidget );</span><br><span class="line">    QListWidgetItem *lst2 = <span class="keyword">new</span> QListWidgetItem ( QIcon ( <span class="string">"images/decision.png"</span> ), <span class="string">"decision"</span>, listWidget );</span><br><span class="line">    QListWidgetItem *lst3 = <span class="keyword">new</span> QListWidgetItem ( QIcon ( <span class="string">"images/document.png"</span> ), <span class="string">"document"</span>, listWidget );</span><br><span class="line">    QListWidgetItem *lst4 = <span class="keyword">new</span> QListWidgetItem ( QIcon ( <span class="string">"images/process.png"</span> ), <span class="string">"process"</span>, listWidget );</span><br><span class="line">    QListWidgetItem *lst5 = <span class="keyword">new</span> QListWidgetItem ( QIcon ( <span class="string">"images/printer.png"</span> ), <span class="string">"printer"</span>, listWidget );</span><br><span class="line">    listWidget-&gt;insertItem ( <span class="number">1</span>, lst1 );</span><br><span class="line">    listWidget-&gt;insertItem ( <span class="number">2</span>, lst2 );</span><br><span class="line">    listWidget-&gt;insertItem ( <span class="number">3</span>, lst3 );</span><br><span class="line">    listWidget-&gt;insertItem ( <span class="number">4</span>, lst4 );</span><br><span class="line">    listWidget-&gt;insertItem ( <span class="number">5</span>, lst5 );</span><br><span class="line">    QObject::connect (</span><br><span class="line">        listWidget, SIGNAL ( currentTextChanged ( <span class="keyword">const</span> QString &amp; ) ),</span><br><span class="line">        label, SLOT ( setText ( <span class="keyword">const</span> QString &amp; ) ) );</span><br><span class="line">    listWidget-&gt;show();</span><br><span class="line">    layout-&gt;addWidget ( listWidget );</span><br><span class="line">    layout-&gt;addWidget ( label );</span><br><span class="line">    widget-&gt;setLayout ( layout );</span><br><span class="line">    widget-&gt;show();</span><br><span class="line">    app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/17/Qt语法详解/Qt之QListWidget/3.png"></p>
<hr>
<p>&emsp;&emsp;<code>QListWidget</code>为我们展示一个<code>List</code>列表的视图。<br>&emsp;&emsp;<code>listwidget.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LISTWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTWIDGET_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtGui&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListWidget</span> :</span> <span class="keyword">public</span> QWidget &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListWidget();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLabel *label;</span><br><span class="line">    QListWidget *<span class="built_in">list</span>;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LISTWIDGET_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>listwidget.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"listwidget.h"</span></span></span><br><span class="line">​</span><br><span class="line">ListWidget::ListWidget() &#123;</span><br><span class="line">    label = <span class="keyword">new</span> QLabel;</span><br><span class="line">    label-&gt;setFixedWidth ( <span class="number">70</span> );</span><br><span class="line">    <span class="built_in">list</span> = <span class="keyword">new</span> QListWidget;</span><br><span class="line">    <span class="built_in">list</span>-&gt;addItem ( <span class="keyword">new</span> QListWidgetItem ( QIcon ( <span class="string">":/images/line.PNG"</span> ), tr ( <span class="string">"Line"</span> ) ) );</span><br><span class="line">    <span class="built_in">list</span>-&gt;addItem ( <span class="keyword">new</span> QListWidgetItem ( QIcon ( <span class="string">":/images/rect.PNG"</span> ), tr ( <span class="string">"Rectangle"</span> ) ) );</span><br><span class="line">    <span class="built_in">list</span>-&gt;addItem ( <span class="keyword">new</span> QListWidgetItem ( QIcon ( <span class="string">":/images/oval.PNG"</span> ), tr ( <span class="string">"Oval"</span> ) ) );</span><br><span class="line">    <span class="built_in">list</span>-&gt;addItem ( <span class="keyword">new</span> QListWidgetItem ( QIcon ( <span class="string">":/images/tri.PNG"</span> ), tr ( <span class="string">"Triangle"</span> ) ) );</span><br><span class="line">    QHBoxLayout *layout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    layout-&gt;addWidget ( label );</span><br><span class="line">    layout-&gt;addWidget ( <span class="built_in">list</span> );</span><br><span class="line">    setLayout ( layout );</span><br><span class="line">    connect ( <span class="built_in">list</span>, SIGNAL ( currentTextChanged ( QString ) ), label, SLOT ( setText ( QString ) ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>main.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtGui&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"listwidget.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    ListWidget lw;</span><br><span class="line">    lw.resize ( <span class="number">400</span>, <span class="number">200</span> );</span><br><span class="line">    lw.show();</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ListWidget</code>类中包含一个<code>QLabel</code>对象和一个<code>QListWidget</code>对象。创建这个<code>QListWidget</code>对象很简单，只需要使用<code>new</code>运算符创建出来，然后调用<code>addItem</code>函数即可将<code>item</code>添加到这个对象中。我们添加的对象是<code>QListWidgetItem</code>的指针，<code>addItem</code>有四个重载的函数，我们使用的是其中的一个：它接受两个参数，第一个是<code>QIcon</code>引用类型，作为<code>item</code>的图标；第二个是<code>QString</code>类型，作为这个<code>item</code>后面的文字说明。当然也可以使用<code>insertItem</code>函数在特定的位置动态地增加<code>item</code>。最后将这个<code>QListWidget</code>的<code>currentTextChanged</code>信号同<code>QLabel</code>的<code>setText</code>连接起来，这样在点击<code>item</code>时，<code>label</code>的文字就可以改变了。</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QListWidget/4.png"></p>
<p>我们还可以设置<code>viewModel</code>这个参数，来使用不同的视图进行显示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>-&gt;setViewMode ( QListView::IconMode );</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/17/Qt语法详解/Qt之QListWidget/5.png"></p>
<hr>
<h3 id="QListWidget控件的使用"><a href="#QListWidget控件的使用" class="headerlink" title="QListWidget控件的使用"></a>QListWidget控件的使用</h3><p>&emsp;&emsp;<code>Qt</code>提供了<code>QListWidget</code>类列表框控件，用来加载并显示多个列表项。<code>QListWidgetItem</code>类就是列表项类，一般列表框控件中的列表项有两种加载方式：一种是由用户手动添加的列表项，比如音乐播放器中加载音乐文件的文件列表，每一个音乐文件都是一个列表项。对于这种列表项，用户可以进行增加、删除、单击以及双击等操作。一种是由程序员事先编写好，写在程序中供用户选择的列表项，比如餐厅的电子菜单，每一道菜对应一个列表项。对于这种列表项，用户可以进行单机和双击操作(增加和删除操作也是可以进行的，但是一般的点菜系统会屏蔽掉这种功能)。<br>&emsp;&emsp;<code>QListWidget</code>类列表框控件支持两种列表项显示方式，即<code>QListView::IconMode</code>和<code>QListView::ListMode</code>。</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QListWidget/6.png" height="261" width="337"></p>
<p>&emsp;&emsp;<code>main.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtGui/QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextCodec&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    <span class="comment">/* Qt文本的国际化显示 */</span></span><br><span class="line">    QTextCodec::setCodecForTr ( QTextCodec::codecForName ( <span class="string">"GB18030"</span> ) );</span><br><span class="line">    QTextCodec::setCodecForLocale ( QTextCodec::codecForName ( <span class="string">"GB18030"</span> ) );</span><br><span class="line">    QTextCodec::setCodecForCStrings ( QTextCodec::codecForName ( <span class="string">"GB18030"</span> ) );</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.show();</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mainwindow.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QListWidgetItem&gt; /* 列表框空间头文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFileDialog&gt; /* 文件对话框控件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QStringList&gt; /* 字符串容器 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDir&gt; /* 目录类头文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QString&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span> <span class="params">( QWidget *parent = <span class="number">0</span> )</span></span>;</span><br><span class="line">    ~MainWindow();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addbtn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deletebtn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delallbtn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addallbtn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">singleclicked</span> <span class="params">( QListWidgetItem *item )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doubleclicked</span> <span class="params">( QListWidgetItem *item )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mainwindow.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_mainwindow.h"</span></span></span><br><span class="line">​</span><br><span class="line">MainWindow::MainWindow ( QWidget *parent ) : QMainWindow ( parent ), ui ( <span class="keyword">new</span> Ui::MainWindow ) &#123;</span><br><span class="line">    ui-&gt;setupUi ( <span class="keyword">this</span> );</span><br><span class="line">    <span class="keyword">this</span>-&gt;setWindowTitle ( tr ( <span class="string">"listWidget学习"</span> ) ); <span class="comment">/* 设置标题框文本 */</span></span><br><span class="line">    ui-&gt;listWidget-&gt;setViewMode ( QListView::IconMode ); <span class="comment">/* 设置显示模式为图标模式 */</span></span><br><span class="line">    <span class="comment">// ui-&gt;listWidget-&gt;setViewMode ( QListView::ListMode ); /* 设置显示模式为列表模式 */</span></span><br><span class="line">    QObject::connect ( ui-&gt;AddButton, SIGNAL ( clicked() ), <span class="keyword">this</span>, SLOT ( addbtn() ) );</span><br><span class="line">    QObject::connect ( ui-&gt;lineEdit, SIGNAL ( returnPressed() ), <span class="keyword">this</span>, SLOT ( addbtn() ) );</span><br><span class="line">    QObject::connect ( ui-&gt;DeleteButton, SIGNAL ( clicked() ), <span class="keyword">this</span>, SLOT ( deletebtn() ) );</span><br><span class="line">    QObject::connect ( ui-&gt;DelAllButton, SIGNAL ( clicked() ), <span class="keyword">this</span>, SLOT ( delallbtn() ) );</span><br><span class="line">    QObject::connect ( ui-&gt;ShowDirButton, SIGNAL ( clicked() ), <span class="keyword">this</span>, SLOT ( addallbtn() ) );</span><br><span class="line">    QObject::connect (</span><br><span class="line">        ui-&gt;listWidget, SIGNAL ( itemDoubleClicked ( QListWidgetItem * ) ),</span><br><span class="line">        <span class="keyword">this</span>, SLOT ( doubleclicked ( QListWidgetItem * ) ) );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">MainWindow::~MainWindow() &#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MainWindow::addbtn() &#123; <span class="comment">/* 添加单个列表项 */</span></span><br><span class="line">    QString str = ui-&gt;lineEdit-&gt;text(); <span class="comment">/* 获取行编辑框文本 */</span></span><br><span class="line">    QListWidgetItem *item = <span class="keyword">new</span> QListWidgetItem;</span><br><span class="line">    item-&gt;setText ( str ); <span class="comment">/* 设置列表项的文本 */</span></span><br><span class="line">    ui-&gt;listWidget-&gt;addItem ( item ); <span class="comment">/* 加载列表项到列表框 */</span></span><br><span class="line">    <span class="comment">// delete item; /* 此处若解除注释，将无法添加到列表框 */</span></span><br><span class="line">    <span class="comment">// item = NULL;</span></span><br><span class="line">    ui-&gt;lineEdit-&gt;clear(); <span class="comment">/* 清空行编辑框 */</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MainWindow::deletebtn() &#123; <span class="comment">/* 删除单个列表项 */</span></span><br><span class="line">    <span class="comment">/* 获取列表项的指针 */</span></span><br><span class="line">    QListWidgetItem *item = ui-&gt;listWidget-&gt;takeItem ( ui-&gt;listWidget-&gt;currentRow() );</span><br><span class="line">    <span class="keyword">delete</span> item; <span class="comment">/* 释放指针所指向的列表项 */</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MainWindow::delallbtn() &#123; <span class="comment">/* 删除多个列表项 */</span></span><br><span class="line">    <span class="keyword">int</span> num = ui-&gt;listWidget-&gt;count(); <span class="comment">/* 获取列表项的总数目 */</span></span><br><span class="line">    <span class="comment">/* 将光标设置到列表框上，若注释该语句，则删除时，要手动将焦点设置到列表框，即点击列表项 */</span></span><br><span class="line">    ui-&gt;listWidget-&gt;setFocus();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++ ) &#123; <span class="comment">/* 逐个获取列表项的指针，并删除 */</span></span><br><span class="line">        QListWidgetItem *item = ui-&gt;listWidget-&gt;takeItem ( ui-&gt;listWidget-&gt;currentRow() );</span><br><span class="line">        <span class="keyword">delete</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MainWindow::addallbtn() &#123; <span class="comment">/* 添加多个列表项 */</span></span><br><span class="line">    QStringList FileNames = QFileDialog::getOpenFileNames (</span><br><span class="line">        <span class="keyword">this</span>, <span class="string">"打开"</span>, QDir::currentPath(), <span class="string">"所有文件(*.*);;文本文档(*.txt)"</span> );</span><br><span class="line">    <span class="comment">//ui-&gt;listWidget-&gt;addItems ( FileNames ); /* 方法1：整体添加 */</span></span><br><span class="line">    <span class="comment">/* 方法2：逐个添加 */</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    count = FileNames.count(); <span class="comment">/* 获取打开文件的总数目 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="comment">// for(index = 0; index &lt; count; index++) /* 这样会报错，无法先取出栈底元素 */</span></span><br><span class="line">    <span class="keyword">for</span> ( index = count - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index-- ) &#123; <span class="comment">/* QList&lt;QString&gt;的数据结构是栈，只能从栈顶取元素 */</span></span><br><span class="line">        QListWidgetItem *item = <span class="keyword">new</span> QListWidgetItem;</span><br><span class="line">        item-&gt;setText ( FileNames.takeAt ( index ) ); <span class="comment">/* 逐个设置列表项的文本 */</span></span><br><span class="line">        <span class="comment">// qDebug() &lt;&lt; FileNames.takeAt( index );</span></span><br><span class="line">        ui-&gt;listWidget-&gt;addItem ( item ); <span class="comment">/* 加载列表项到列表框 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MainWindow::singleclicked ( QListWidgetItem *item ) &#123; <span class="comment">/* 列表项单击操作 */</span></span><br><span class="line">    QMessageBox::information ( <span class="keyword">this</span>, <span class="string">"单击消息"</span>, <span class="string">"单击"</span> + item-&gt;text() );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MainWindow::doubleclicked ( QListWidgetItem *item ) &#123; <span class="comment">/* 列表项双击操作 */</span></span><br><span class="line">    QMessageBox::information ( <span class="keyword">this</span>, <span class="string">"双击消息"</span>, <span class="string">"双击"</span> + item-&gt;text() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h3><p>&emsp;&emsp;添加操作又可以分为单列表项操作和多列表项操作。</p>
<ul>
<li><code>void QListWidget::addItems ( const QStringList &amp; labels )</code>：该函数用来将字符串列表中的全部字符串作为列表项添加到列表框中。</li>
<li><code>void QListWidget::addItem ( QListWidgetItem * item )</code>：该函数用来将一个列表项添加到列表框当中。注意，一个列表项只能被添加到列表框中一次，如果多次添加同一个列表项到列表框中，将导致不可预期的结果。</li>
<li><code>void QListWidget::addItem ( const QString &amp; label )</code>：重载函数，用来将参数<code>label</code>所引用的字符串作为一个列表项，添加到列表框中。</li>
<li><code>int QList::count ()const and int QList::size () const</code>：上述两个函数的功能等价，都是用来返回列表中存储的对象元素的个数。</li>
<li><code>T QList::takeAt ( int i )</code>：该函数按照参数i指定的索引位置，将存储在列表中对应的对象元素移除并返回。返回类型为模板类型，由存储的数据的类型决定。索引值的大小范围为<code>0 &lt;= i &lt;= size()</code>。</li>
</ul>
<p>注意，<code>QList&lt;QString&gt;</code>的数据结构是栈，只能从栈顶取元素。</p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>&emsp;&emsp;删除操作又可以分为单文件操作和多文件操作。删除单个列表项(删除列表框中的单个列表项)：</p>
<ul>
<li><code>QListWidgetItem *QListWidget::takeItem ( int row )</code>：该函数用来将索引号为<code>row</code>的列表项从列表框移除，并返回该列表项的指针。</li>
<li><code>int currentRow() const</code>：该常成员函数用来获取当前列表项的索引号，并返回它。</li>
</ul>
<hr>
<p>&emsp;&emsp;The <code>QListWidget</code> class provides an <code>item-based</code> list widget.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QListWidget</code></td>
<td><code>QListView</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QListWidget(QWidget * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QListWidget()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addItem(const QString &amp; label)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addItem(QListWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addItems(const QStringList &amp; labels)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>closePersistentEditor(QListWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count() const</code></td>
</tr>
<tr>
<td><code>QListWidgetItem *</code></td>
<td><code>currentItem() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>currentRow() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>editItem(QListWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>QList&lt;QListWidgetItem *&gt;</code></td>
<td><code>findItems(const QString &amp; text, Qt::MatchFlags flags) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertItem(int row, QListWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertItem(int row, const QString &amp; label)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertItems(int row, const QStringList &amp; labels)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isSortingEnabled() const</code></td>
</tr>
<tr>
<td><code>QListWidgetItem *</code></td>
<td><code>item(int row) const</code></td>
</tr>
<tr>
<td><code>QListWidgetItem *</code></td>
<td><code>itemAt(const QPoint &amp; p) const</code></td>
</tr>
<tr>
<td><code>QListWidgetItem *</code></td>
<td><code>itemAt(int x, int y) const</code></td>
</tr>
<tr>
<td><code>QWidget *</code></td>
<td><code>itemWidget(QListWidgetItem * item) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>openPersistentEditor(QListWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeItemWidget(QListWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>row(const QListWidgetItem * item) const</code></td>
</tr>
<tr>
<td><code>QList&lt;QListWidgetItem *&gt;</code></td>
<td><code>selectedItems() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentItem(QListWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentItem(QListWidgetItem * item, QItemSelectionModel::SelectionFlags command)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentRow(int row)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentRow(int row, QItemSelectionModel::SelectionFlags command)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setItemWidget(QListWidgetItem * item, QWidget * widget)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSortingEnabled(bool enable)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>sortItems(Qt::SortOrder order = Qt::AscendingOrder)</code></td>
</tr>
<tr>
<td><code>QListWidgetItem *</code></td>
<td><code>takeItem(int row)</code></td>
</tr>
<tr>
<td><code>QRect</code></td>
<td><code>visualItemRect(const QListWidgetItem * item) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Public-Functions"><a href="#Reimplemented-Public-Functions" class="headerlink" title="Reimplemented Public Functions"></a>Reimplemented Public Functions</h3><ul>
<li><code>virtual void dropEvent(QDropEvent * event)</code></li>
</ul>
<h3 id="Public-Slots"><a href="#Public-Slots" class="headerlink" title="Public Slots"></a>Public Slots</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>scrollToItem(const QListWidgetItem * item, QAbstractItemView::ScrollHint hint = EnsureVisible)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>currentItemChanged(QListWidgetItem * current, QListWidgetItem * previous)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>currentRowChanged(int currentRow)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>currentTextChanged(const QString &amp; currentText)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemActivated(QListWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemChanged(QListWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemClicked(QListWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemDoubleClicked(QListWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemEntered(QListWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemPressed(QListWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemSelectionChanged()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual bool</code></td>
<td><code>dropMimeData(int index, const QMimeData * data, Qt::DropAction action)</code></td>
</tr>
<tr>
<td><code>QModelIndex</code></td>
<td><code>indexFromItem(QListWidgetItem * item) const</code></td>
</tr>
<tr>
<td><code>QListWidgetItem *</code></td>
<td><code>itemFromIndex(const QModelIndex &amp; index) const</code></td>
</tr>
<tr>
<td><code>QList&lt;QListWidgetItem *&gt;</code></td>
<td><code>items(const QMimeData * data) const</code></td>
</tr>
<tr>
<td><code>virtual QMimeData *</code></td>
<td><code>mimeData(const QList&lt;QListWidgetItem *&gt; items) const</code></td>
</tr>
<tr>
<td><code>virtual QStringList</code></td>
<td><code>mimeTypes() const</code></td>
</tr>
<tr>
<td><code>virtual Qt::DropActions</code></td>
<td><code>supportedDropActions() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Protected-Functions"><a href="#Reimplemented-Protected-Functions" class="headerlink" title="Reimplemented Protected Functions"></a>Reimplemented Protected Functions</h3><ul>
<li><code>virtual bool event(QEvent * e)</code></li>
</ul>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QListWidget</code> class provides an <code>item-based</code> list widget.<br>&emsp;&emsp;<code>QListWidget</code> is a convenience class that provides a list view similar to the one supplied by <code>QListView</code>, but with a classic <code>item-based</code> interface for adding and removing items. <code>QListWidget</code> uses an internal model to manage each <code>QListWidgetItem</code> in the list.<br>&emsp;&emsp;For a more flexible list view widget, use the <code>QListView</code> class with a standard model.<br>&emsp;&emsp;List widgets are constructed in the same way as other widgets:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QListWidget *listWidget = <span class="keyword">new</span> QListWidget ( <span class="keyword">this</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>selectionMode()</code> of a list widget determines how many of the items in the list can be selected at the same time, and whether complex selections of items can be created. This can be set with the <code>setSelectionMode()</code> function.<br>&emsp;&emsp;There are two ways to add items to the list: they can be constructed with the list widget as their parent widget, or they can be constructed with no parent widget and added to the list later. If a list widget already exists when the items are constructed, the first method is easier to use:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> QListWidgetItem ( tr ( <span class="string">"Oak"</span> ), listWidget );</span><br><span class="line"><span class="keyword">new</span> QListWidgetItem ( tr ( <span class="string">"Fir"</span> ), listWidget );</span><br><span class="line"><span class="keyword">new</span> QListWidgetItem ( tr ( <span class="string">"Pine"</span> ), listWidget );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If you need to insert a new item into the list at a particular position, then it should be constructed without a parent widget. The <code>insertItem()</code> function should then be used to place it within the list. The list widget will take ownership of the item.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QListWidgetItem *newItem = <span class="keyword">new</span> QListWidgetItem;</span><br><span class="line">newItem-&gt;setText ( itemText );</span><br><span class="line">listWidget-&gt;insertItem ( row, newItem );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;For multiple items, <code>insertItems()</code> can be used instead. The number of items in the list is found with the <code>count()</code> function. To remove items from the list, use <code>takeItem()</code>.<br>&emsp;&emsp;The current item in the list can be found with <code>currentItem()</code>, and changed with <code>setCurrentItem()</code>. The user can also change the current item by navigating with the keyboard or clicking on a different item. When the current item changes, the <code>currentItemChanged()</code> signal is emitted with the new current item and the item that was previously current.</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QListWidget/7.png"></p>
<h3 id="Property-Documentation"><a href="#Property-Documentation" class="headerlink" title="Property Documentation"></a>Property Documentation</h3><ul>
<li><code>count : const int</code>: This property holds the number of items in the list including any hidden items. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>currentRow : int</code>: This property holds the row of the current item. Depending on the current selection mode, the row may also be selected. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">currentRow</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCurrentRow</span> <span class="params">( <span class="keyword">int</span> row )</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCurrentRow</span> <span class="params">( <span class="keyword">int</span> row, QItemSelectionModel::SelectionFlags command )</span></span></span><br></pre></td></tr></table></figure>
<p>Notifier signal:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">currentRowChanged</span> <span class="params">( <span class="keyword">int</span> currentRow )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>sortingEnabled : bool</code>: This property holds whether sorting is enabled. If this property is <code>true</code>, sorting is enabled for the list; if the property is <code>false</code>, sorting is not enabled. The default value is <code>false</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSortingEnabled</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSortingEnabled</span> <span class="params">( <span class="keyword">bool</span> enable )</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QListWidget::QListWidget(QWidget * parent = 0)</code>: Constructs an empty <code>QListWidget</code> with the given <code>parent</code>.</li>
<li><code>QListWidget::~QListWidget()</code>: Destroys the list widget and all its items.</li>
<li><code>void QListWidget::addItem(const QString &amp; label)</code>: Inserts an item with the text <code>label</code> at the end of the list widget.</li>
<li><code>void QListWidget::addItem(QListWidgetItem * item)</code>: Inserts the <code>item</code> at the end of the list widget. <strong>Warning</strong>: A <code>QListWidgetItem</code> can only be added to a <code>QListWidget</code> once. Adding the same <code>QListWidgetItem</code> multiple times to a <code>QListWidget</code> will result in undefined behavior.</li>
<li><code>void QListWidget::addItems(const QStringList &amp; labels)</code>: Inserts items with the text <code>labels</code> at the end of the list widget.</li>
<li><code>void QListWidget::clear() [slot]</code>: Removes all items and selections in the view. <strong>Warning</strong>: All items will be permanently deleted.</li>
<li><code>void QListWidget::closePersistentEditor(QListWidgetItem * item)</code>: Closes the persistent editor for the given <code>item</code>.</li>
<li><code>QListWidgetItem * QListWidget::currentItem() const</code>: Returns the current item.</li>
<li><code>void QListWidget::currentItemChanged(QListWidgetItem * current, QListWidgetItem * previous) [signal]</code>: This signal is emitted whenever the <code>current</code> item changes. <code>previous</code> is the item that previously had the focus; <code>current</code> is the new current item.</li>
<li><code>void QListWidget::currentTextChanged(const QString &amp; currentText) [signal]</code>: This signal is emitted whenever the current item changes. <code>currentText</code> is the text data in the current item. If there is no current item, the <code>currentText</code> is invalid.</li>
<li><code>void QListWidget::dropEvent(QDropEvent * event) [virtual]</code>: Reimplemented from <code>QWidget::dropEvent()</code>.</li>
<li><code>bool QListWidget::dropMimeData(int index, const QMimeData * data, Qt::DropAction action) [virtual protected]</code>: Handles <code>data</code> supplied by an external drag and drop operation that ended with the given <code>action</code> in the given <code>index</code>. Returns <code>true</code> if <code>data</code> and <code>action</code> can be handled by the model; otherwise returns <code>false</code>.</li>
<li><code>void QListWidget::editItem(QListWidgetItem * item)</code>: Starts editing the <code>item</code> if it is editable.</li>
<li><code>bool QListWidget::event(QEvent * e) [virtual protected]</code>: Reimplemented from <code>QObject::event()</code>.</li>
<li><code>QList&lt;QListWidgetItem *&gt; QListWidget::findItems(const QString &amp; text, Qt::MatchFlags flags) const</code>: Finds items with the <code>text</code> that matches the string text using the given <code>flags</code>.</li>
<li><code>QModelIndex QListWidget::indexFromItem(QListWidgetItem * item) const [protected]</code>: Returns the <code>QModelIndex</code> assocated with the given <code>item</code>.</li>
<li><code>void QListWidget::insertItem(int row, QListWidgetItem * item)</code>: Inserts the <code>item</code> at the position in the list given by <code>row</code>.</li>
<li><code>void QListWidget::insertItem(int row, const QString &amp; label)</code>: Inserts an item with the text <code>label</code> in the list widget at the position given by <code>row</code>.</li>
<li><code>void QListWidget::insertItems(int row, const QStringList &amp; labels)</code>: Inserts items from the list of <code>labels</code> into the list, starting at the given <code>row</code>.</li>
<li><code>QListWidgetItem * QListWidget::item(int row) const</code>: Returns the item that occupies the given <code>row</code> in the list if one has been set; otherwise returns <code>0</code>.</li>
<li><code>void QListWidget::itemActivated(QListWidgetItem * item) [signal]</code>: This signal is emitted when the <code>item</code> is activated. The item is activated when the user clicks or double clicks on it, depending on the system configuration. It is also activated when the user presses the activation key (on <code>Windows</code> and <code>X11</code> this is the <code>Return</code> key, on <code>Mac OS X</code> it is <code>Ctrl + 0</code>).</li>
<li><code>QListWidgetItem * QListWidget::itemAt(const QPoint &amp; p) const</code>: Returns a pointer to the item at the coordinates <code>p</code>. The coordinates are relative to the list widget’s <code>viewport()</code>.</li>
<li><code>QListWidgetItem * QListWidget::itemAt(int x, int y) const</code>: This is an overloaded function. Returns a pointer to the item at the coordinates <code>(x, y)</code>. The coordinates are relative to the list widget’s <code>viewport()</code>.</li>
<li><code>void QListWidget::itemChanged(QListWidgetItem * item) [signal]</code>: This signal is emitted whenever the data of <code>item</code> has changed.</li>
<li><code>void QListWidget::itemClicked(QListWidgetItem * item) [signal]</code>: This signal is emitted with the specified <code>item</code> when a mouse button is clicked on an item in the widget.</li>
<li><code>void QListWidget::itemDoubleClicked(QListWidgetItem * item) [signal]</code>: This signal is emitted with the specified <code>item</code> when a mouse button is double clicked on an item in the widget.</li>
<li><code>void QListWidget::itemEntered(QListWidgetItem * item) [signal]</code>: This signal is emitted when the mouse cursor enters an <code>item</code>. The <code>item</code> is the item entered. This signal is only emitted when <code>mouseTracking</code> is turned on, or when a mouse button is pressed while moving into an item.</li>
<li><code>QListWidgetItem * QListWidget::itemFromIndex(const QModelIndex &amp; index) const [protected]</code>: Returns a pointer to the <code>QListWidgetItem</code> assocated with the given <code>index</code>.</li>
<li><code>void QListWidget::itemPressed(QListWidgetItem * item) [signal]</code>: This signal is emitted with the specified <code>item</code> when a mouse button is pressed on an item in the widget.</li>
<li><code>void QListWidget::itemSelectionChanged() [signal]</code>: This signal is emitted whenever the selection changes.</li>
<li><code>QWidget * QListWidget::itemWidget(QListWidgetItem * item) const</code>: Returns the widget displayed in the given <code>item</code>.</li>
<li><code>QList&lt;QListWidgetItem *&gt; QListWidget::items(const QMimeData * data) const [protected]</code>: Returns a list of pointers to the items contained in the <code>data</code> object. If the object was not created by a <code>QListWidget</code> in the same process, the list is empty.</li>
<li><code>QMimeData * QListWidget::mimeData(const QList&lt;QListWidgetItem *&gt; items) const [virtual protected]</code>: Returns an object that contains a serialized description of the specified <code>items</code>. The format used to describe the items is obtained from the <code>mimeTypes()</code> function. If the list of <code>items</code> is empty, <code>0</code> is returned instead of a serialized empty list.</li>
<li><code>QStringList QListWidget::mimeTypes() const [virtual protected]</code>: Returns a list of <code>MIME</code> types that can be used to describe a list of listwidget items.</li>
<li><code>void QListWidget::openPersistentEditor(QListWidgetItem * item)</code>: Opens an editor for the given <code>item</code>. The editor remains open after editing.</li>
<li><code>void QListWidget::removeItemWidget(QListWidgetItem * item)</code>: Removes the widget set on the given <code>item</code>.</li>
<li><code>int QListWidget::row(const QListWidgetItem * item) const</code>: Returns the row containing the given <code>item</code>.</li>
<li><code>void QListWidget::scrollToItem(const QListWidgetItem * item, QAbstractItemView::ScrollHint hint = EnsureVisible) [slot]</code>: Scrolls the view if necessary to ensure that the <code>item</code> is visible. <code>hint</code> specifies where the item should be located after the operation.</li>
<li><code>QList&lt;QListWidgetItem *&gt; QListWidget::selectedItems() const</code>: Returns a list of all selected items in the list widget.</li>
<li><code>void QListWidget::setCurrentItem(QListWidgetItem * item)</code>: Sets the current item to <code>item</code>. Unless the selection mode is <code>NoSelection</code>, the <code>item</code> is also be selected.</li>
<li><code>void QListWidget::setCurrentItem(QListWidgetItem * item, QItemSelectionModel::SelectionFlags command)</code>: Set the current item to <code>item</code>, using the given <code>command</code>.</li>
<li><code>void QListWidget::setItemWidget(QListWidgetItem * item, QWidget * widget)</code>: Sets the <code>widget</code> to be displayed in the give <code>item</code>. This function should only be used to display static content in the place of a list widget item. If you want to display custom dynamic content or implement a custom editor widget, use <code>QListView</code> and subclass <code>QItemDelegate</code> instead.</li>
<li><code>void QListWidget::sortItems(Qt::SortOrder order = Qt::AscendingOrder)</code>: Sorts all the items in the list widget according to the specified <code>order</code>.</li>
<li><code>Qt::DropActions QListWidget::supportedDropActions() const [virtual protected]</code>: Returns the drop actions supported by this view.</li>
<li><code>QListWidgetItem * QListWidget::takeItem(int row)</code>: Removes and returns the item from the given <code>row</code> in the list widget; otherwise returns <code>0</code>. Items removed from a list widget will not be managed by <code>Qt</code>, and will need to be deleted manually.</li>
<li><code>QRect QListWidget::visualItemRect(const QListWidgetItem * item) const</code>: Returns the rectangle on the viewport occupied by the item at <code>item</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/17/Qt语法详解/Qt之QMessageBox/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/17/Qt语法详解/Qt之QMessageBox/" itemprop="url">Qt之QMessageBox</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-17T19:44:36+08:00">
                2019-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;先来看一下最熟悉的<code>QMessageBox::information</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox::information ( <span class="literal">NULL</span>, <span class="string">"Title"</span>, <span class="string">"Content"</span>, QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes );</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/17/Qt语法详解/Qt之QMessageBox/1.png"></p>
<p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> StandardButton QMessageBox::information (</span><br><span class="line">    QWidget *parent, <span class="keyword">const</span> QString &amp;title, <span class="keyword">const</span> QString &amp;text,</span><br><span class="line">    StandardButtons buttons = Ok, StandardButton defaultButton = NoButton );</span><br></pre></td></tr></table></figure>
<p>参数<code>parent</code>是说明它的父组件；参数<code>title</code>是对话框的标题；参数<code>text</code>是对话框显示的内容；参数<code>buttons</code>用于声明对话框放置的按钮，默认只放置一个<code>OK</code>按钮，这个参数可以使用或运算，例如我们希望有一个<code>Yes</code>和一个<code>No</code>的按钮，可以使用<code>QMessageBox::Yes | QMessageBox::No</code>。所有的按钮类型可以在<code>QMessageBox</code>的<code>StandarButton</code>枚举中找到；参数<code>defaultButton</code>就是默认选中的按钮，默认值是<code>NoButton</code>，也就是哪个按钮都不选中。<br>&emsp;&emsp;<code>Qt</code>提供了五个类似的接口，用于显示类似的窗口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox::critical ( <span class="literal">NULL</span>, <span class="string">"critical"</span>, <span class="string">"Content"</span>, QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes );</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/17/Qt语法详解/Qt之QMessageBox/2.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox::warning ( <span class="literal">NULL</span>, <span class="string">"warning"</span>, <span class="string">"Content"</span>, QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes );</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/17/Qt语法详解/Qt之QMessageBox/3.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox::question ( <span class="literal">NULL</span>, <span class="string">"question"</span>, <span class="string">"Content"</span>, QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes );</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/17/Qt语法详解/Qt之QMessageBox/4.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox::about ( <span class="literal">NULL</span>, <span class="string">"About"</span>, <span class="string">"About this application"</span> );</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/17/Qt语法详解/Qt之QMessageBox/5.png"></p>
<p>&emsp;&emsp;<code>QMessageBox</code>对话框的文本信息可以支持<code>HTML</code>标签：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox::about ( <span class="literal">NULL</span>, <span class="string">"About"</span>, <span class="string">"About this &lt;font color='red'&gt;application&lt;/font&gt;"</span> );</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/17/Qt语法详解/Qt之QMessageBox/6.png"></p>
<p>&emsp;&emsp;如果想自定义图片的话，需要我们自定义一个<code>QMessagebox</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMessageBox <span class="title">message</span> <span class="params">( QMessageBox::NoIcon, <span class="string">"Title"</span>, <span class="string">"Content with icon."</span> )</span></span>;</span><br><span class="line">message.setIconPixmap ( QPixmap ( <span class="string">"icon.png"</span> ) );</span><br><span class="line">message.exec();</span><br></pre></td></tr></table></figure>
<p>这里使用的是<code>exec</code>函数，而不是<code>show</code>，因为这是一个模态对话框，需要有它自己的事件循环，否则对话框会一闪而过。</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QMessageBox/7.png"></p>
<p>&emsp;&emsp;还有一点要注意，我们使用的是<code>png</code>格式的图片，因为<code>Qt</code>内置的处理图片格式是<code>png</code>，所以这不会引起很大的麻烦。如果你要使用<code>jpeg</code>格式的图片，<code>Qt</code>是以插件的形式支持的。在开发时没有什么问题，不过如果要部署的话，需要注意这一点。<br>&emsp;&emsp;最后来说一下怎么处理对话框的交互。我们使用<code>QMessageBox</code>类的时候有两种方式，一是使用<code>static</code>函数，另外是使用构造函数。首先来说一下<code>static</code>函数的方式。注意，<code>static</code>函数都是要返回一个<code>StandardButton</code>，我们可以通过判断这个返回值来对用户的操作做出响应：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox::StandardButton rb = QMessageBox::question (</span><br><span class="line">    <span class="literal">NULL</span>, <span class="string">"Show Qt"</span>, <span class="string">"Do you want to show Qt dialog?"</span>,</span><br><span class="line">    QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( rb == QMessageBox::Yes ) &#123;</span><br><span class="line">    QMessageBox::aboutQt ( <span class="literal">NULL</span>, <span class="string">"About Qt"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要使用构造函数的方式，那么就要自己判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMessageBox <span class="title">message</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    QMessageBox::NoIcon, <span class="string">"Show Qt"</span>, <span class="string">"Do you want to show Qt dialog?"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    QMessageBox::Yes | QMessageBox::No, <span class="literal">NULL</span> )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( message.exec() == QMessageBox::Yes ) &#123;</span><br><span class="line">    QMessageBox::aboutQt ( <span class="literal">NULL</span>, <span class="string">"About Qt"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret1 = QMessageBox::question ( <span class="comment">/* 问题对话框(参数：父窗口、标题栏、显示信息、拥有的按钮) */</span></span><br><span class="line">    <span class="keyword">this</span>, tr ( <span class="string">"问题对话框"</span> ), tr ( <span class="string">"你了解Qt吗？"</span> ),</span><br><span class="line">    QMessageBox::Yes, QMessageBox::No );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ret1 == QMessageBox::Yes ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; tr ( <span class="string">"问题！"</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">int</span> ret2 = QMessageBox::information ( <span class="comment">/* 提示对话框 */</span></span><br><span class="line">    <span class="keyword">this</span>, tr ( <span class="string">"提示对话框"</span> ), tr ( <span class="string">"这是Qt书籍！"</span> ), QMessageBox::Ok );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ret2 == QMessageBox::Ok ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; tr ( <span class="string">"提示！"</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">int</span> ret3 = QMessageBox::warning ( <span class="comment">/* 警告对话框 */</span></span><br><span class="line">    <span class="keyword">this</span>, tr ( <span class="string">"警告对话框"</span> ), tr ( <span class="string">"不能提前结束！"</span> ), QMessageBox::Abort );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ret3 == QMessageBox::Abort ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; tr ( <span class="string">"警告！"</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">int</span> ret4 = QMessageBox::critical ( <span class="comment">/* 错误对话框 */</span></span><br><span class="line">    <span class="keyword">this</span>, tr ( <span class="string">"严重错误对话框"</span> ),</span><br><span class="line">    tr ( <span class="string">"发现一个严重错误！现在要关闭所有文件！"</span> ), QMessageBox::YesAll );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( ret4 == QMessageBox::YesAll ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; tr ( <span class="string">"错误"</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">QMessageBox::about ( <span class="comment">/* 关于对话框 */</span></span><br><span class="line">    <span class="keyword">this</span>, tr ( <span class="string">"关于对话框"</span> ),</span><br><span class="line">    tr ( <span class="string">"yafeilinux.com致力于Qt及Qt Creator的普及工作！"</span> ) );</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="QMessageBox典型用法"><a href="#QMessageBox典型用法" class="headerlink" title="QMessageBox典型用法"></a>QMessageBox典型用法</h3><p>&emsp;&emsp;弹出消息对话框在许多应用中是必需的。它可以提示用户，防止用户因为不小心而犯下错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox msgBox;</span><br><span class="line">msgBox.setText ( <span class="string">"The document has been modified."</span> );</span><br><span class="line">msgBox.setInformativeText ( <span class="string">"Do you want to save your changes?"</span> );</span><br><span class="line">msgBox.setStandardButtons ( QMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel );</span><br><span class="line">msgBox.setDefaultButton ( QMessageBox::Save );</span><br><span class="line"><span class="keyword">int</span> ret = msgBox.exec();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">switch</span> ( ret ) &#123;</span><br><span class="line">    <span class="keyword">case</span> QMessageBox::Save: <span class="comment">/* Save was clicked */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">case</span> QMessageBox::Discard: <span class="comment">/* Don't Save was clicked */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">case</span> QMessageBox::Cancel: <span class="comment">/* Cancel was clicked */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* should never be reached */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在<code>QMessageBox</code>中添加按钮，判断哪一个按钮被按下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox msgBox;</span><br><span class="line">QPushButton *connectButton = msgBox.addButton ( tr ( <span class="string">"Connect"</span> ), QMessageBox::ActionRole );</span><br><span class="line">QPushButton *abortButton = msgBox.addButton ( QMessageBox::Abort );</span><br><span class="line">​</span><br><span class="line">msgBox.exec();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( msgBox.clickedButton() == connectButton ) &#123;</span><br><span class="line">    <span class="comment">/* connect */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( msgBox.clickedButton() == abortButton ) &#123;</span><br><span class="line">    <span class="comment">/* abort */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/17/Qt语法详解/Qt之QTableWidget/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/17/Qt语法详解/Qt之QTableWidget/" itemprop="url">Qt之QTableWidget</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-17T18:37:12+08:00">
                2019-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTableWidget&gt;</span></span></span><br><span class="line"><span class="comment">/* 构造一个QTableWidget类的实体对象tableWidget */</span></span><br><span class="line">tableWidget = <span class="keyword">new</span> QTableWidget ( ui-&gt;textBrowser );</span><br><span class="line">tableWidget-&gt;setRowCount ( <span class="number">7</span> ); <span class="comment">/* 设置行数为7 */</span></span><br><span class="line">tableWidget-&gt;setColumnCount ( <span class="number">5</span> ); <span class="comment">/* 设置列数为5 */</span></span><br><span class="line">tableWidget-&gt;setGeometry ( QRect ( <span class="number">0</span>, <span class="number">0</span>, <span class="number">401</span>, <span class="number">241</span> ) ); <span class="comment">/* 设置tableWidget的大小 */</span></span><br><span class="line">tableWidget-&gt;setItem ( <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> QTableWidgetItem ( <span class="string">"abc"</span> ) ); <span class="comment">/* 第一行第一列的内容设置为“abc” */</span></span><br><span class="line">tableWidget-&gt;setItem ( <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">new</span> QTableWidgetItem ( <span class="string">"def"</span> ) ); <span class="comment">/* 第二行第一列的内容设置为“abc” */</span></span><br><span class="line"><span class="comment">/* 40, 110, 100, 60, 85 */</span></span><br><span class="line">tableWidget-&gt;setColumnWidth ( <span class="number">0</span>, <span class="number">40</span> ); <span class="comment">/* 设置第一列的列宽 */</span></span><br><span class="line">tableWidget-&gt;setColumnWidth ( <span class="number">1</span>, <span class="number">110</span> ); <span class="comment">/* 设置第二列的列宽 */</span></span><br><span class="line">tableWidget-&gt;setColumnWidth ( <span class="number">2</span>, <span class="number">100</span> ); <span class="comment">/* 设置第三列的列宽 */</span></span><br><span class="line">tableWidget-&gt;setColumnWidth ( <span class="number">3</span>, <span class="number">60</span> ); <span class="comment">/* 设置第四列的列宽 */</span></span><br><span class="line">tableWidget-&gt;setColumnWidth ( <span class="number">4</span>, <span class="number">85</span> ); <span class="comment">/* 设置第五列的列宽 */</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 列表的标题为：车次、车牌、支付卡、金额、累计金额 */</span></span><br><span class="line">tableWidget-&gt;setHorizontalHeaderLabels (</span><br><span class="line">    QStringList() &lt;&lt; tr ( <span class="string">"车次"</span> ) &lt;&lt; tr ( <span class="string">"车牌"</span> ) \</span><br><span class="line">                  &lt;&lt; tr ( <span class="string">"支付卡"</span> ) &lt;&lt; tr ( <span class="string">"金额"</span> ) &lt;&lt; tr ( <span class="string">"累计金额"</span> ) );</span><br><span class="line">tableWidget-&gt;setFont ( QFont ( <span class="string">"wenquanyi"</span>, <span class="number">12</span>, <span class="number">3</span> ) ); <span class="comment">/* 设置字体 */</span></span><br><span class="line">QHeaderView *headerView = tableWidget-&gt;verticalHeader();</span><br><span class="line">headerView-&gt;setHidden ( <span class="literal">true</span> ); <span class="comment">/* 行名隐藏 */</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/17/Qt语法详解/Qt之QTableWidget/1.png"></p>
<hr>
<p>&emsp;&emsp;表格是<code>GUI</code>中常用的控件，<code>Qt</code>中常用的表格类是<code>QTableWidget</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">QTableWidget *table = <span class="keyword">new</span> QTableWidget ( <span class="number">4</span>, <span class="number">2</span> ); <span class="comment">/* 新建一4行2列的表格 */</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 设置表格行标题 */</span></span><br><span class="line">QStringList headerLabels;</span><br><span class="line">headerLabels &lt;&lt; <span class="string">"C1"</span> &lt;&lt; <span class="string">"C2"</span>;</span><br><span class="line">table-&gt;setHorizontalHeaderLabels ( headerLabels );</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 设置表格行标题的对齐方式 */</span></span><br><span class="line">table-&gt;horizontalHeader()-&gt;setDefaultAlignment ( Qt::AlignLeft );</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 设置行表题 */</span></span><br><span class="line">QStringList rowLabels;</span><br><span class="line">rowLabels &lt;&lt; <span class="string">"Line1"</span> &lt;&lt; <span class="string">"Line2"</span> &lt;&lt; <span class="string">"Line3"</span> &lt;&lt; <span class="string">"Line4"</span>;</span><br><span class="line">table-&gt;setVerticalHeaderLabels ( rowLabels );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ ) &#123; <span class="comment">/* 设置每一行的高度 */</span></span><br><span class="line">    table-&gt;setRowHeight ( i, <span class="number">22</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 自动调整最后一列的宽度使它和表格的右边界对齐 */</span></span><br><span class="line">table-&gt;horizontalHeader()-&gt;setStretchLastSection ( <span class="literal">true</span> );</span><br><span class="line"><span class="comment">/* 设置表格的选择方式 */</span></span><br><span class="line">table-&gt;setSelectionBehavior ( QAbstractItemView::SelectItems );</span><br><span class="line"><span class="comment">/* 设置编辑方式 */</span></span><br><span class="line">table-&gt;setEditTriggers ( QAbstractItemView::DoubleClicked );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">4</span>; ++row ) &#123; <span class="comment">/* 设置表格的内容 */</span></span><br><span class="line">    QTableWidgetItem *item0, *item1;</span><br><span class="line">    item0 = <span class="keyword">new</span> QTableWidgetItem;</span><br><span class="line">    item1 = <span class="keyword">new</span> QTableWidgetItem;</span><br><span class="line">    QString txt = QString ( <span class="string">"%1"</span> ).arg ( row + <span class="number">1</span> );</span><br><span class="line">    item0-&gt;setText ( txt );</span><br><span class="line">    table-&gt;setItem ( row, <span class="number">0</span>, item0 );</span><br><span class="line">    txt = QString ( <span class="string">"%1"</span> ).arg ( ( row + <span class="number">1</span> ) * <span class="number">2</span> );</span><br><span class="line">    item1-&gt;setText ( txt );</span><br><span class="line">    table-&gt;setItem ( row, <span class="number">1</span>, item1 );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 增加一行 */</span></span><br><span class="line">table-&gt;setRowCount ( <span class="number">5</span> );</span><br><span class="line">QTableWidgetItem *vHeader5 = <span class="keyword">new</span> QTableWidgetItem ( <span class="string">"Line5"</span> );</span><br><span class="line">table-&gt;setVerticalHeaderItem ( <span class="number">4</span>, vHeader5 );</span><br><span class="line">QTableWidgetItem *item5_0, *item5_1;</span><br><span class="line">item5_0 = <span class="keyword">new</span> QTableWidgetItem;</span><br><span class="line">item5_1 = <span class="keyword">new</span> QTableWidgetItem;</span><br><span class="line">item5_0-&gt;setText ( QString ( <span class="string">"%1"</span> ).arg ( <span class="number">5</span> ) );</span><br><span class="line">item5_1-&gt;setText ( QString ( <span class="string">"%1"</span> ).arg ( <span class="number">5</span> * <span class="number">2</span> ) );</span><br><span class="line">table-&gt;setItem ( <span class="number">4</span>, <span class="number">0</span>, item5_0 );</span><br><span class="line">table-&gt;setItem ( <span class="number">4</span>, <span class="number">1</span>, item5_1 );</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/17/Qt语法详解/Qt之QTableWidget/2.png"></p>
<hr>
<p>&emsp;&emsp;The <code>QTableWidget</code> class provides an <code>item-based</code> table view with a default model.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTableWidget</code></td>
<td><code>QTableView</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTableWidget(QWidget * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTableWidget(int rows, int columns, QWidget * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QTableWidget()</code></td>
</tr>
<tr>
<td><code>QWidget *</code></td>
<td><code>cellWidget(int row, int column) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>closePersistentEditor(QTableWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>column(const QTableWidgetItem * item) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>columnCount() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>currentColumn() const</code></td>
</tr>
<tr>
<td><code>QTableWidgetItem *</code></td>
<td><code>currentItem() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>currentRow() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>editItem(QTableWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>QList&lt;QTableWidgetItem *&gt;</code></td>
<td><code>findItems(const QString &amp; text, Qt::MatchFlags flags) const</code></td>
</tr>
<tr>
<td><code>QTableWidgetItem *</code></td>
<td><code>horizontalHeaderItem(int column) const</code></td>
</tr>
<tr>
<td><code>QTableWidgetItem *</code></td>
<td><code>item(int row, int column) const</code></td>
</tr>
<tr>
<td><code>QTableWidgetItem *</code></td>
<td><code>itemAt(const QPoint &amp; point) const</code></td>
</tr>
<tr>
<td><code>QTableWidgetItem *</code></td>
<td><code>itemAt(int ax, int ay) const</code></td>
</tr>
<tr>
<td><code>const QTableWidgetItem *</code></td>
<td><code>itemPrototype() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>openPersistentEditor(QTableWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeCellWidget(int row, int column)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>row(const QTableWidgetItem * item) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>rowCount() const</code></td>
</tr>
<tr>
<td><code>QList&lt;QTableWidgetItem *&gt;</code></td>
<td><code>selectedItems()</code></td>
</tr>
<tr>
<td><code>QList&lt;QTableWidgetSelectionRange&gt;</code></td>
<td><code>selectedRanges() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCellWidget(int row, int column, QWidget * widget)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setColumnCount(int columns)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentCell(int row, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentCell(int row, int column, QItemSelectionModel::SelectionFlags command)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentItem(QTableWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentItem(QTableWidgetItem * item, QItemSelectionModel::SelectionFlags command)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHorizontalHeaderItem(int column, QTableWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHorizontalHeaderLabels(const QStringList &amp; labels)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setItem(int row, int column, QTableWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setItemPrototype(const QTableWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setRangeSelected(const QTableWidgetSelectionRange &amp; range, bool select)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setRowCount(int rows)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setVerticalHeaderItem(int row, QTableWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setVerticalHeaderLabels(const QStringList &amp; labels)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>sortItems(int column, Qt::SortOrder order = Qt::AscendingOrder)</code></td>
</tr>
<tr>
<td><code>QTableWidgetItem *</code></td>
<td><code>takeHorizontalHeaderItem(int column)</code></td>
</tr>
<tr>
<td><code>QTableWidgetItem *</code></td>
<td><code>takeItem(int row, int column)</code></td>
</tr>
<tr>
<td><code>QTableWidgetItem *</code></td>
<td><code>stakeVerticalHeaderItem(int row)</code></td>
</tr>
<tr>
<td><code>QTableWidgetItem *</code></td>
<td><code>verticalHeaderItem(int row) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>visualColumn(int logicalColumn) const</code></td>
</tr>
<tr>
<td><code>QRect</code></td>
<td><code>visualItemRect(const QTableWidgetItem * item) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>visualRow(int logicalRow) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Slots"><a href="#Public-Slots" class="headerlink" title="Public Slots"></a>Public Slots</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clearContents()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertColumn(int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertRow(int row)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeColumn(int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeRow(int row)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>scrollToItem(const QTableWidgetItem * item, QAbstractItemView::ScrollHint hint = EnsureVisible)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>cellActivated(int row, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>cellChanged(int row, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>cellClicked(int row, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>cellDoubleClicked(int row, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>cellEntered(int row, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>cellPressed(int row, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>currentCellChanged(int currentRow, int currentColumn, int previousRow, int previousColumn)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>currentItemChanged(QTableWidgetItem * current, QTableWidgetItem * previous)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemActivated(QTableWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemChanged(QTableWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemClicked(QTableWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemDoubleClicked(QTableWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemEntered(QTableWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemPressed(QTableWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemSelectionChanged()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual bool</code></td>
<td><code>dropMimeData(int row, int column, const QMimeData * data, Qt::DropAction action)</code></td>
</tr>
<tr>
<td><code>QModelIndex</code></td>
<td><code>indexFromItem(QTableWidgetItem * item) const</code></td>
</tr>
<tr>
<td><code>QTableWidgetItem *</code></td>
<td><code>itemFromIndex(const QModelIndex &amp; index) const</code></td>
</tr>
<tr>
<td><code>QList&lt;QTableWidgetItem *&gt;</code></td>
<td><code>items(const QMimeData * data) const</code></td>
</tr>
<tr>
<td><code>virtual QMimeData *</code></td>
<td><code>mimeData(const QList&lt;QTableWidgetItem *&gt; items) const</code></td>
</tr>
<tr>
<td><code>virtual QStringList</code></td>
<td><code>mimeTypes() const</code></td>
</tr>
<tr>
<td><code>virtual Qt::DropActions</code></td>
<td><code>supportedDropActions() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Protected-Functions"><a href="#Reimplemented-Protected-Functions" class="headerlink" title="Reimplemented Protected Functions"></a>Reimplemented Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual void</code></td>
<td><code>dropEvent(QDropEvent * event)</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>event(QEvent * e)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTableWidget</code> class provides an <code>item-based</code> table view with a default model.<br>&emsp;&emsp;Table widgets provide standard table display facilities for applications. The items in a <code>QTableWidget</code> are provided by <code>QTableWidgetItem</code>.<br>&emsp;&emsp;If you want a table that uses your own data model you should use <code>QTableView</code> rather than this class.<br>&emsp;&emsp;Table widgets can be constructed with the required numbers of rows and columns:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableWidget = <span class="keyword">new</span> QTableWidget ( <span class="number">12</span>, <span class="number">3</span>, <span class="keyword">this</span> );</span><br></pre></td></tr></table></figure>
<p>Alternatively, tables can be constructed without a given size and resized later:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tableWidget = <span class="keyword">new</span> QTableWidget ( <span class="keyword">this</span> );</span><br><span class="line">tableWidget-&gt;setRowCount ( <span class="number">10</span> );</span><br><span class="line">tableWidget-&gt;setColumnCount ( <span class="number">5</span> );</span><br></pre></td></tr></table></figure>
<p>Items are created ouside the table (with no parent widget) and inserted into the table with <code>setItem()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QTableWidgetItem *newItem = <span class="keyword">new</span> QTableWidgetItem ( tr ( <span class="string">"%1"</span> ).arg ( ( row + <span class="number">1</span> ) * ( column + <span class="number">1</span> ) ) );</span><br><span class="line">tableWidget-&gt;setItem ( row, column, newItem );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If you want to enable sorting in your table widget, do so after you have populated it with items, otherwise sorting may interfere with the insertion order.<br>&emsp;&emsp;Tables can be given both horizontal and vertical headers. The simplest way to create the headers is to supply a list of strings to the <code>setHorizontalHeaderLabels()</code> and <code>setVerticalHeaderLabels()</code> functions. These will provide simple textual headers for the table’s columns and rows. More sophisticated headers can be created from existing table items that are usually constructed outside the table. For example, we can construct a table item with an icon and aligned text, and use it as the header for a particular column:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QTableWidgetItem *cubesHeaderItem = <span class="keyword">new</span> QTableWidgetItem ( tr ( <span class="string">"Cubes"</span> ) );</span><br><span class="line">cubesHeaderItem-&gt;setIcon ( QIcon ( QPixmap ( <span class="string">":/Images/cubed.png"</span> ) ) );</span><br><span class="line">cubesHeaderItem-&gt;setTextAlignment ( Qt::AlignVCenter );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The number of rows in the table can be found with <code>rowCount()</code>, and the number of columns with <code>columnCount()</code>. The table can be cleared with the <code>clear()</code> function.</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QTableWidget/3.png"></p>
<h3 id="Property-Documentation"><a href="#Property-Documentation" class="headerlink" title="Property Documentation"></a>Property Documentation</h3><ul>
<li><code>columnCount : int</code>: This property holds the number of columns in the table. By default, for a table constructed without row and column counts, this property contains a value of <code>0</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">columnCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setColumnCount</span> <span class="params">( <span class="keyword">int</span> columns )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>rowCount : int</code>: This property holds the number of rows in the table. By default, for a table constructed without row and column counts, this property contains a value of <code>0</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rowCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setRowCount</span> <span class="params">( <span class="keyword">int</span> rows )</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTableWidget::QTableWidget(QWidget * parent = 0)</code>: Creates a new table view with the given <code>parent</code>.</li>
<li><code>QTableWidget::QTableWidget(int rows, int columns, QWidget * parent = 0)</code>: Creates a new table view with the given <code>rows</code> and <code>columns</code>, and with the given <code>parent</code>.</li>
<li><code>QTableWidget::~QTableWidget()</code>: Destroys this QTableWidget.</li>
<li><code>void QTableWidget::cellActivated(int row, int column) [signal]</code>: This signal is emitted when the cell specified by <code>row</code> and <code>column</code> has been activated.</li>
<li><code>void QTableWidget::cellChanged(int row, int column) [signal]</code>: This signal is emitted whenever the data of the item in the cell specified by <code>row</code> and <code>column</code> has changed.</li>
<li><code>void QTableWidget::cellClicked(int row, int column) [signal]</code>: This signal is emitted whenever a cell in the table is clicked. The <code>row</code> and <code>column</code> specified is the cell that was clicked.</li>
<li><code>void QTableWidget::cellDoubleClicked(int row, int column) [signal]</code>: This signal is emitted whenever a cell in the table is double clicked. The <code>row</code> and <code>column</code> specified is the cell that was double clicked.</li>
<li><code>void QTableWidget::cellEntered(int row, int column) [signal]</code>: This signal is emitted when the mouse cursor enters a cell. The cell is specified by <code>row</code> and <code>column</code>. This signal is only emitted when mouseTracking is turned on, or when a mouse button is pressed while moving into an item.</li>
<li><code>void QTableWidget::cellPressed(int row, int column) [signal]</code>: This signal is emitted whenever a cell in the table is pressed. The <code>row</code> and <code>column</code> specified is the cell that was pressed.</li>
<li><code>QWidget * QTableWidget::cellWidget(int row, int column) const</code>: Returns the widget displayed in the cell in the given <code>row</code> and <code>column</code>. <strong>Note</strong>: The table takes ownership of the widget.</li>
<li><code>void QTableWidget::clear() [slot]</code>: Removes all items in the view. This will also remove all selections. The table dimensions stay the same.</li>
<li><code>void QTableWidget::clearContents() [slot]</code>: Removes all items not in the headers from the view. This will also remove all selections. The table dimensions stay the same.</li>
<li><code>void QTableWidget::closePersistentEditor(QTableWidgetItem * item)</code>: Closes the persistent editor for <code>item</code>.</li>
<li><code>int QTableWidget::column(const QTableWidgetItem * item) const</code>: Returns the column for the <code>item</code>.</li>
<li><code>void QTableWidget::currentCellChanged(int currentRow, int currentColumn, int previousRow, int previousColumn) [signal]</code>: This signal is emitted whenever the current cell changes. The cell specified by <code>previousRow</code> and <code>previousColumn</code> is the cell that previously had the focus, the cell specified by <code>currentRow</code> and <code>currentColumn</code> is the new current cell.</li>
<li><code>int QTableWidget::currentColumn() const</code>: Returns the column of the current item.</li>
<li><code>QTableWidgetItem * QTableWidget::currentItem() const</code>: Returns the current item.</li>
<li><code>void QTableWidget::currentItemChanged(QTableWidgetItem * current, QTableWidgetItem * previous) [signal]</code>: This signal is emitted whenever the <code>current</code> item changes. The <code>previous</code> item is the item that previously had the focus, <code>current</code> is the new current item.</li>
<li><code>int QTableWidget::currentRow() const</code>: Returns the row of the current item.</li>
<li><code>void QTableWidget::dropEvent(QDropEvent * event) [virtual protected]</code>: Reimplemented from <code>QWidget::dropEvent()</code>.</li>
<li><code>bool QTableWidget::dropMimeData(int row, int column, const QMimeData * data, Qt::DropAction action) [virtual protected]</code>: Handles the <code>data</code> supplied by a drag and drop operation that ended with the given <code>action</code> in the given <code>row</code> and <code>column</code>. Returns <code>true</code> if the <code>data</code> and <code>action</code> can be handled by the model; otherwise returns <code>false</code>.</li>
<li><code>void QTableWidget::editItem(QTableWidgetItem * item)</code>: Starts editing the <code>item</code> if it is editable.</li>
<li><code>bool QTableWidget::event(QEvent * e) [virtual protected]</code>: Reimplemented from <code>QObject::event()</code>.</li>
<li><code>QList&lt;QTableWidgetItem *&gt; QTableWidget::findItems(const QString &amp; text, Qt::MatchFlags flags) const</code>: Finds items that matches the <code>text</code> using the given <code>flags</code>.</li>
<li><code>QTableWidgetItem * QTableWidget::horizontalHeaderItem(int column) const</code>: Returns the horizontal header item for <code>column</code>, if one has been set; otherwise returns <code>0</code>.</li>
<li><code>QModelIndex QTableWidget::indexFromItem(QTableWidgetItem * item) const [protected]</code>: Returns the <code>QModelIndex</code> assocated with the given <code>item</code>.</li>
<li><code>void QTableWidget::insertColumn(int column) [slot]</code>: Inserts an empty column into the table at <code>column</code>.</li>
<li><code>void QTableWidget::insertRow(int row) [slot]</code>: Inserts an empty row into the table at <code>row</code>.</li>
<li><code>QTableWidgetItem * QTableWidget::item(int row, int column) const</code>: Returns the item for the given <code>row</code> and <code>column</code> if one has been set; otherwise returns <code>0</code>.</li>
<li><code>void QTableWidget::itemActivated(QTableWidgetItem * item) [signal]</code>: This signal is emitted when the specified <code>item</code> has been activated.</li>
<li><code>QTableWidgetItem * QTableWidget::itemAt(const QPoint &amp; point) const</code>: Returns a pointer to the item at the given <code>point</code>, or returns <code>0</code> if <code>point</code> is not covered by an item in the table widget.</li>
<li><code>QTableWidgetItem * QTableWidget::itemAt(int ax, int ay) const</code>: Returns the item at the position equivalent to <code>QPoint(ax, ay)</code> in the table widget’s coordinate system, or returns <code>0</code> if the specified point is not covered by an item in the table widget.</li>
<li><code>void QTableWidget::itemChanged(QTableWidgetItem * item) [signal]</code>: This signal is emitted whenever the data of <code>item</code> has changed.</li>
<li><code>void QTableWidget::itemClicked(QTableWidgetItem * item) [signal]</code>: This signal is emitted whenever an item in the table is clicked. The <code>item</code> specified is the item that was clicked.</li>
<li><code>void QTableWidget::itemDoubleClicked(QTableWidgetItem * item) [signal]</code>: This signal is emitted whenever an item in the table is double clicked. The <code>item</code> specified is the item that was double clicked.</li>
<li><code>void QTableWidget::itemEntered(QTableWidgetItem * item) [signal]</code>: This signal is emitted when the mouse cursor enters an item. The <code>item</code> is the item entered. This signal is only emitted when <code>mouseTracking</code> is turned on, or when a mouse button is pressed while moving into an item.</li>
<li><code>QTableWidgetItem * QTableWidget::itemFromIndex(const QModelIndex &amp; index) const [protected]</code>: Returns a pointer to the QTableWidgetItem assocated with the given <code>index</code>.</li>
<li><code>void QTableWidget::itemPressed(QTableWidgetItem * item) [signal]</code>: This signal is emitted whenever an item in the table is pressed. The <code>item</code> specified is the item that was pressed.</li>
<li><code>const QTableWidgetItem * QTableWidget::itemPrototype() const</code>: Returns the item prototype used by the table.</li>
<li><code>void QTableWidget::itemSelectionChanged() [signal]</code>: This signal is emitted whenever the selection changes.</li>
<li><code>QList&lt;QTableWidgetItem *&gt; QTableWidget::items(const QMimeData * data) const [protected]</code>: Returns a list of pointers to the items contained in the <code>data</code> object. If the object was not created by a <code>QTreeWidget</code> in the same process, the list is empty.</li>
<li><code>QMimeData * QTableWidget::mimeData(const QList&lt;QTableWidgetItem *&gt; items) const [virtual protected]</code>: Returns an object that contains a serialized description of the specified <code>items</code>. The format used to describe the <code>items</code> is obtained from the <code>mimeTypes()</code> function. If the list of <code>items</code> is empty, <code>0</code> is returned rather than a serialized empty list.</li>
<li><code>QStringList QTableWidget::mimeTypes() const [virtual protected]</code>: Returns a list of <code>MIME</code> types that can be used to describe a list of tablewidget items.</li>
<li><code>void QTableWidget::openPersistentEditor(QTableWidgetItem * item)</code>: Opens an editor for the give <code>item</code>. The editor remains open after editing.</li>
<li><code>void QTableWidget::removeCellWidget(int row, int column)</code>: Removes the widget set on the cell indicated by <code>row</code> and <code>column</code>.</li>
<li><code>void QTableWidget::removeColumn(int column) [slot]</code>: Removes the <code>column</code> and all its items from the table.</li>
<li><code>void QTableWidget::removeRow(int row) [slot]</code>: Removes the <code>row</code> and all its items from the table.</li>
<li><code>int QTableWidget::row(const QTableWidgetItem * item) const</code>: Returns the row for the <code>item</code>.</li>
<li><code>void QTableWidget::scrollToItem(const QTableWidgetItem * item, QAbstractItemView::ScrollHint hint = EnsureVisible) [slot]</code>: Scrolls the view if necessary to ensure that the <code>item</code> is visible. The <code>hint</code> parameter specifies more precisely where the <code>item</code> should be located after the operation.</li>
<li><code>QList&lt;QTableWidgetItem *&gt; QTableWidget::selectedItems()</code>: Returns a list of all selected items. This function returns a list of pointers to the contents of the selected cells. Use the <code>selectedIndexes()</code> function to retrieve the complete selection including empty cells.</li>
<li><code>QList&lt;QTableWidgetSelectionRange&gt; QTableWidget::selectedRanges() const</code>: Returns a list of all selected ranges.</li>
<li><code>void QTableWidget::setCellWidget(int row, int column, QWidget * widget)</code>: Sets the given <code>widget</code> to be displayed in the cell in the given <code>row</code> and <code>column</code>, passing the ownership of the widget to the table. If <code>cell widget A</code> is replaced with <code>cell widget B</code>, <code>cell widget A</code> will be deleted. For example, in the code snippet below, the <code>QLineEdit</code> object will be deleted.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setCellWidget ( index, <span class="keyword">new</span> QLineEdit );</span><br><span class="line">...</span><br><span class="line">setCellWidget ( index, <span class="keyword">new</span> QTextEdit );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QTableWidget::setCurrentCell(int row, int column)</code>: Sets the current cell to be the cell at position <code>(row, column)</code>. Depending on the current selection mode, the cell may also be selected.</li>
<li><code>void QTableWidget::setCurrentCell(int row, int column, QItemSelectionModel::SelectionFlags command)</code>: Sets the current cell to be the cell at position <code>(row, column)</code>, using the given <code>command</code>.</li>
<li><code>void QTableWidget::setCurrentItem(QTableWidgetItem * item)</code>: Sets the current item to <code>item</code>. Unless the selection mode is <code>NoSelection</code>, the <code>item</code> is also be selected.</li>
<li><code>void QTableWidget::setCurrentItem(QTableWidgetItem * item, QItemSelectionModel::SelectionFlags command)</code>: Sets the current item to be <code>item</code>, using the given <code>command</code>.</li>
<li><code>void QTableWidget::setHorizontalHeaderItem(int column, QTableWidgetItem * item)</code>: Sets the horizontal header item for <code>column</code> to <code>item</code>.</li>
<li><code>void QTableWidget::setHorizontalHeaderLabels(const QStringList &amp; labels)</code>: Sets the horizontal header labels using <code>labels</code>.</li>
<li><code>void QTableWidget::setItem(int row, int column, QTableWidgetItem * item)</code>: Sets the item for the given <code>row</code> and <code>column</code> to <code>item</code>. The table takes ownership of the item. Note that if sorting is enabled and <code>column</code> is the current sort column, the <code>row</code> will be moved to the sorted position determined by <code>item</code>. If you want to set several items of a particular <code>row</code> (say, by calling <code>setItem()</code> in a loop), you may want to turn off sorting before doing so, and turn it back on afterwards; this will allow you to use the same <code>row</code> argument for all items in the same <code>row</code> (i.e. <code>setItem()</code> will not move the <code>row</code>).</li>
<li><code>void QTableWidget::setItemPrototype(const QTableWidgetItem * item)</code>: Sets the item prototype for the table to the specified <code>item</code>. The table widget will use the item prototype clone function when it needs to create a new table item. For example when the user is editing in an empty cell. This is useful when you have a <code>QTableWidgetItem</code> subclass and want to make sure that <code>QTableWidget</code> creates instances of your subclass. The table takes ownership of the prototype.</li>
<li><code>void QTableWidget::setRangeSelected(const QTableWidgetSelectionRange &amp; range, bool select)</code>: Selects or deselects the <code>range</code> depending on <code>select</code>.</li>
<li><code>void QTableWidget::setVerticalHeaderItem(int row, QTableWidgetItem * item)</code>: Sets the vertical header item for <code>row</code> to <code>item</code>.</li>
<li><code>void QTableWidget::setVerticalHeaderLabels(const QStringList &amp; labels)</code>: Sets the vertical header labels using <code>labels</code>.</li>
<li><code>void QTableWidget::sortItems(int column, Qt::SortOrder order = Qt::AscendingOrder)</code>: Sorts all the rows in the table widget based on <code>column</code> and <code>order</code>.</li>
<li><code>Qt::DropActions QTableWidget::supportedDropActions() const [virtual protected]</code>: Returns the drop actions supported by this view.</li>
<li><code>QTableWidgetItem * QTableWidget::takeHorizontalHeaderItem(int column)</code>: Removes the horizontal header item at <code>column</code> from the header without deleting it.</li>
<li><code>QTableWidgetItem * QTableWidget::takeItem(int row, int column)</code>: Removes the item at <code>row</code> and <code>column</code> from the table without deleting it.</li>
<li><code>QTableWidgetItem * QTableWidget::takeVerticalHeaderItem(int row)</code>: Removes the vertical header item at <code>row</code> from the header without deleting it.</li>
<li><code>QTableWidgetItem * QTableWidget::verticalHeaderItem(int row) const</code>: Returns the vertical header item for <code>row</code>.</li>
<li><code>int QTableWidget::visualColumn(int logicalColumn) const</code>: Returns the visual column of the given <code>logicalColumn</code>.</li>
<li><code>QRect QTableWidget::visualItemRect(const QTableWidgetItem * item) const</code>: Returns the rectangle on the viewport occupied by the item at <code>item</code>.</li>
<li><code>int QTableWidget::visualRow(int logicalRow) const</code>: Returns the visual row of the given <code>logicalRow</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/17/Qt语法详解/Qt之QFile/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/17/Qt语法详解/Qt之QFile/" itemprop="url">Qt之QFile</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-17T18:04:17+08:00">
                2019-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;基础代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtCore/QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFileInfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextCodec&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QStringList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDateTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    QTextCodec::setCodecForTr ( QTextCodec::codecForLocale() );</span><br><span class="line">    <span class="function">QFile <span class="title">file</span> <span class="params">( <span class="string">"myfile.txt"</span> )</span></span>; <span class="comment">/* 以只写方式打开，如果文件不存在，那么会创建该文件 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !file.open ( QIODevice::WriteOnly  | QIODevice::Text ) ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; file.errorString();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    file.write ( <span class="string">"helloQt!\nyafeilinux"</span> );</span><br><span class="line">    file.close();</span><br><span class="line">    <span class="function">QFileInfo <span class="title">info</span> <span class="params">( file )</span></span>; <span class="comment">/* 获取文件信息 */</span></span><br><span class="line">    qDebug() &lt;&lt; QObject::tr ( <span class="string">"绝对路径："</span> ) &lt;&lt; info.absoluteFilePath() &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">             &lt;&lt; QObject::tr ( <span class="string">"文件名："</span> ) &lt;&lt; info.fileName() &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">             &lt;&lt; QObject::tr ( <span class="string">"基本名称："</span> ) &lt;&lt; info.baseName() &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">             &lt;&lt; QObject::tr ( <span class="string">"后缀："</span> ) &lt;&lt; info.suffix() &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">             &lt;&lt; QObject::tr ( <span class="string">"创建时间："</span> ) &lt;&lt; info.created() &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">             &lt;&lt; QObject::tr ( <span class="string">"大小："</span> ) &lt;&lt; info.size();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !file.open ( QIODevice::ReadOnly | QIODevice::Text ) ) &#123; <span class="comment">/* 以只读方式打开 */</span></span><br><span class="line">        qDebug() &lt;&lt; file.errorString();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    qDebug() &lt;&lt; QObject::tr ( <span class="string">"文件内容："</span> ) &lt;&lt; <span class="built_in">endl</span> &lt;&lt; file.readAll();</span><br><span class="line">    qDebug() &lt;&lt; QObject::tr ( <span class="string">"当前位置："</span> ) &lt;&lt; file.pos();</span><br><span class="line">    file.seek ( <span class="number">0</span> );</span><br><span class="line">    QByteArray <span class="built_in">array</span>;</span><br><span class="line">    <span class="built_in">array</span> = file.read ( <span class="number">5</span> );</span><br><span class="line">    qDebug() &lt;&lt; QObject::tr ( <span class="string">"前5个字符："</span> ) &lt;&lt; <span class="built_in">array</span></span><br><span class="line">             &lt;&lt; QObject::tr ( <span class="string">"当前位置："</span> ) &lt;&lt; file.pos();</span><br><span class="line">    file.seek ( <span class="number">15</span> );</span><br><span class="line">    <span class="built_in">array</span> = file.read ( <span class="number">5</span> );</span><br><span class="line">    qDebug() &lt;&lt; QObject::tr ( <span class="string">"第16-20个字符："</span> ) &lt;&lt; <span class="built_in">array</span>;</span><br><span class="line">    file.close();</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>&emsp;&emsp;<code>Qt</code>作为一个通用开发库，提供了跨平台的文件操作能力。<code>Qt</code>通过<code>QIODevice</code>提供了对<code>I/O</code>设备的抽象，这些设备具有读写字节块的能力。下面是<code>I/O</code>设备的类图(左图为<code>Qt4</code>的，右图为<code>Qt5</code>的)：</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QFile/1.png"></p>
<p>&emsp;&emsp;从上面的类图可以看出，<code>Qt4</code>和<code>Qt5</code>在<code>I/O</code>设备部分大同小异，只不过<code>Qt5</code>新增加了一个<code>QFileDevice</code>类。图中所涉及的类及其用途如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QIODevice</code></td>
<td>所有<code>I/O</code>设备类的父类，提供了字节块读写的通用操作以及基本接口</td>
</tr>
<tr>
<td><code>QFlie</code></td>
<td>访问本地文件或者嵌入资源</td>
</tr>
<tr>
<td><code>QTemporaryFile</code></td>
<td>创建和访问本地文件系统的临时文件</td>
</tr>
<tr>
<td><code>QBuffer</code></td>
<td>读写<code>QByteArray</code></td>
</tr>
<tr>
<td><code>QProcess</code></td>
<td>运行外部程序，处理进程间通讯</td>
</tr>
<tr>
<td><code>QAbstractSocket</code></td>
<td>所有套接字类的父类</td>
</tr>
<tr>
<td><code>QTcpSocket</code></td>
<td><code>TCP</code>协议网络数据传输</td>
</tr>
<tr>
<td><code>QUdpSocket</code></td>
<td>传输<code>UDP</code>报文</td>
</tr>
<tr>
<td><code>QSslSocket</code></td>
<td>使用<code>SSL/TLS</code>传输数据</td>
</tr>
<tr>
<td><code>QFileDevice</code></td>
<td><code>Qt5</code>新增加的类，提供了有关文件操作的通用实现</td>
</tr>
</tbody>
</table>
</div>
<p><code>QProcess</code>、<code>QTcpSocket</code>、<code>QUdpSoctet</code>和<code>QSslSocket</code>是顺序访问设备。所谓<code>顺序访问</code>，是指它们的数据只能访问一遍：从头走到尾，从第一个字节开始访问，直到最后一个字节，中途不能返回去读取上一个字节；<code>QFile</code>、<code>QTemporaryFile</code>和<code>QBuffer</code>是随机访问设备，可以访问任意位置任意次数，还可以使用<code>QIODevice::seek</code>函数来重新定位文件访问位置指针。<br>&emsp;&emsp;在所有的<code>I/O</code>设备中，文件<code>I/O</code>是最重要的部分之一，因为大多数的程序依旧需要首先访问本地文件。<code>QFile</code>提供了从文件中读取和写入数据的能力，<code>Qt5</code>新加入的<code>QFileDevice</code>类，则将这部分公共操作放到了这个单独的类中。显然这部分代码在<code>Qt4</code>中位于<code>QFile</code>类。这样看来，<code>Qt5</code>的代码结构更为清晰，层次更好。<br>&emsp;&emsp;通常会将文件路径作为参数传给<code>QFile</code>的构造函数，不过也可以在创建好对象之后，使用<code>setFileName</code>来修改。<code>QFile</code>需要使用<code>/</code>作为文件分隔符，不过它会自动将其转换成操作系统所需要的形式。例如<code>C:/windows</code>这样的路径在<code>Windows</code>平台下同样是可以的。<br>&emsp;&emsp;<code>QFile</code>主要提供了有关文件的各种操作，比如打开文件、关闭文件、刷新文件等。可以使用<code>QDataStream</code>或<code>QTextStream</code>类来读写文件，也可以使用<code>QIODevice</code>类提供的<code>read</code>、<code>readLine</code>、<code>readAll</code>以及<code>write</code>这样的函数。值得注意的是，有关文件本身的信息，比如文件名、文件所在目录的名字等，则是通过<code>QFileInfo</code>获取。下面使用一段代码来看看<code>QFile</code>的有关操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span> <span class="params">( <span class="string">"in.txt"</span> )</span></span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !file.open ( QIODevice::ReadOnly | QIODevice::Text ) ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"Open file failed."</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( !file.atEnd() ) &#123;</span><br><span class="line">            qDebug() &lt;&lt; file.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function">QFileInfo <span class="title">info</span> <span class="params">( file )</span></span>;</span><br><span class="line">    qDebug() &lt;&lt; info.isDir();</span><br><span class="line">    qDebug() &lt;&lt; info.isExecutable();</span><br><span class="line">    qDebug() &lt;&lt; info.baseName();</span><br><span class="line">    qDebug() &lt;&lt; info.completeBaseName();</span><br><span class="line">    qDebug() &lt;&lt; info.suffix();</span><br><span class="line">    qDebug() &lt;&lt; info.completeSuffix();</span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Qt学习之二进制文件读写"><a href="#Qt学习之二进制文件读写" class="headerlink" title="Qt学习之二进制文件读写"></a>Qt学习之二进制文件读写</h3><p>&emsp;&emsp;<code>Qt</code>还提供了更高一级的操作：用于二进制的流<code>QDataStream</code>和用于文本流的<code>QTextStream</code>。<br>&emsp;&emsp;<code>QDataStream</code>提供了基于<code>QIODevice</code>的二进制数据的序列化。数据流是一种二进制流，这种流完全不依赖于底层操作系统、<code>CPU</code>或者字节顺序(大端或小端)。例如，在安装了<code>Windows</code>平台的<code>PC</code>上面写入的一个数据流，可以不经过任何处理，直接拿到运行了<code>Solaris</code>的<code>SPARC</code>机器上读取。由于数据流就是二进制流，因此也可以直接读写没有编码的二进制数据，例如图像、视频、音频等。<code>QDataStream</code>既能够存取<code>C++</code>基本类型，如<code>int</code>、<code>char</code>、<code>short</code>等，也可以存取复杂的数据类型，例如自定义的类。实际上，<code>QDataStream</code>对于类的存储，是将复杂的类分割为很多基本单元实现的。<br>&emsp;&emsp;结合<code>QIODevice</code>，<code>QDataStream</code>可以很方便地对文件、网络套接字等进行读写操作。我们从代码开始看起：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span> <span class="params">( <span class="string">"file.dat"</span> )</span></span>;</span><br><span class="line">file.open ( QIODevice::WriteOnly );</span><br><span class="line"><span class="function">QDataStream <span class="title">out</span> <span class="params">( &amp;file )</span></span>;</span><br><span class="line">out &lt;&lt; QString ( <span class="string">"the answer is"</span> );</span><br><span class="line">out &lt;&lt; ( qint32 ) <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们首先打开一个名为<code>file.dat</code>的文件(注意，我们为简单起见，并没有检查文件打开是否成功，这在正式程序中是不允许的)。然后，我们将刚刚创建的<code>file</code>对象的指针传递给一个<code>QDataStream</code>实例<code>out</code>。类似于<code>std::cout</code>标准输出流，<code>QDataStream</code>也重载了输出重定向<code>&lt;&lt;</code>运算符。后面的代码就很简单了：将<code>the answer is</code>和数字<code>42</code>输出到数据流。由于我们的<code>out</code>对象建立在<code>file</code>之上，因此相当于将答案写入<code>file</code>。<br>&emsp;&emsp;需要指出一点，最好使用<code>Qt</code>整型来进行读写，比如程序中的<code>qint32</code>，这保证了在任意平台和任意编译器都能够有相同的行为。<br>&emsp;&emsp;我们通过一个例子来看看<code>Qt</code>是如何存储数据的。例如<code>char *</code>字符串在存储时，会首先存储该字符串包括<code>\0</code>结束符的长度(<code>32</code>位整型)，然后是字符串的内容以及结束符<code>\0</code>。在读取时，先以<code>32</code>位整型读出整个的长度，然后按照这个长度取出整个字符串的内容。但是，如果你直接运行这段代码，你会得到一个空白的<code>file.dat</code>，并没有写入任何数据，这是因为我们的<code>file</code>没有正常关闭。为性能起见，数据只有在文件关闭时才会真正写入。因此，我们必须在最后添加一行代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.close(); <span class="comment">/* 如果不想关闭文件，可以使用file.flush */</span></span><br></pre></td></tr></table></figure>
<p>重新运行一下程序，就可以了。下面要将这个答案读取出来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span> <span class="params">( <span class="string">"file.dat"</span> )</span></span>;</span><br><span class="line">file.open ( QIODevice::ReadOnly );</span><br><span class="line"><span class="function">QDataStream <span class="title">in</span> <span class="params">( &amp;file )</span></span>;</span><br><span class="line">QString str;</span><br><span class="line">qint32 a;</span><br><span class="line">in &gt;&gt; str &gt;&gt; a;</span><br></pre></td></tr></table></figure>
<p>这段代码没什么好说的。唯一需要注意的是，你必须按照写入的顺序将数据读取出来。也就是说，程序数据写入的顺序必须预先定义好。在这个例子中，我们首先写入字符串，然后写入数字，那么就首先读出来的就是字符串，然后才是数字。顺序颠倒的话，程序行为是不确定的，严重时会直接造成程序崩溃。<br>&emsp;&emsp;由于二进制流是纯粹的字节数据，带来的问题是，如果程序不同版本之间按照不同的方式读取(前面说过，<code>Qt</code>保证读写内容的一致，但是并不能保证不同<code>Qt</code>版本之间的一致)，数据就会出现错误。因此，我们必须提供一种机制来确保不同版本之间的一致性。通常，我们会使用如下的代码写入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span> <span class="params">( <span class="string">"file.dat"</span> )</span></span>;</span><br><span class="line">file.open ( QIODevice::WriteOnly );</span><br><span class="line"><span class="function">QDataStream <span class="title">out</span> <span class="params">( &amp;file )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 写入魔术数字和版本 */</span></span><br><span class="line">out &lt;&lt; ( quint32 ) <span class="number">0xA0B0C0D0</span>;</span><br><span class="line">out &lt;&lt; ( qint32 ) <span class="number">123</span>;</span><br><span class="line">​</span><br><span class="line">out.setVersion ( QDataStream::Qt_4_0 );</span><br><span class="line">out &lt;&lt; lots_of_interesting_data; <span class="comment">/* 写入数据 */</span></span><br></pre></td></tr></table></figure>
<p>这里增加了如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out &lt;&lt; ( quint32 ) <span class="number">0xA0B0C0D0</span>;</span><br></pre></td></tr></table></figure>
<p>用于写入魔术数字。所谓魔术数字，是二进制输出中经常使用的一种技术。二进制格式是人不可读的，并且通常具有相同的后缀名(比如<code>dat</code>之类)，因此我们没有办法区分两个二进制文件哪个是合法的。所以，我们定义的二进制格式通常具有一个魔术数字，用于标识文件的合法性。在本例中，我们在文件最开始写入<code>0xA0B0C0D0</code>，在读取的时候首先检查这个数字是不是<code>0xA0B0C0D0</code>。如果不是的话，说明这个文件不是可识别格式，因此根本不需要去继续读取。一般二进制文件都会有这么一个魔术数字，例如<code>Java</code>的<code>class</code>文件的魔术数字就是<code>0xCAFEBABE</code>，使用二进制查看器就可以查看。魔术数字是一个<code>32</code>位的无符号整型，因此我们使用<code>quint32</code>来得到一个平台无关的<code>32</code>位无符号整型。接下来的一行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out &lt;&lt; ( qint32 ) <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>是标识文件的版本。我们用魔术数字标识文件的类型，从而判断文件是不是合法的。但是，文件的不同版本之间也可能存在差异：我们可能在第一版保存整型，第二版可能保存字符串。为了标识不同的版本，我们只能将版本写入文件。比如，现在我们的版本是<code>123</code>。下面一行还是有关版本的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out.setVersion ( QDataStream::Qt_4_8 );</span><br></pre></td></tr></table></figure>
<p>上面一句是文件的版本号，但是<code>Qt</code>不同版本之间的读取方式可能也不一样。这样，我们就需要指定<code>Qt</code>按照哪个版本去读。在这里我们指定以<code>Qt 4.8</code>格式去读取内容。<br>&emsp;&emsp;当我们这样写入文件之后，我们在读取的时候就需要增加一系列的判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span> <span class="params">( <span class="string">"file.dat"</span> )</span></span>;</span><br><span class="line">file.open ( QIODevice::ReadOnly );</span><br><span class="line"><span class="function">QDataStream <span class="title">in</span> <span class="params">( &amp;file )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 检查魔术数字 */</span></span><br><span class="line">quint32 magic;</span><br><span class="line">in &gt;&gt; magic;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( magic != <span class="number">0xA0B0C0D0</span> ) &#123;</span><br><span class="line">    <span class="keyword">return</span> BAD_FILE_FORMAT;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 检查版本 */</span></span><br><span class="line">qint32 version;</span><br><span class="line">in &gt;&gt; version;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( version &lt; <span class="number">100</span> ) &#123;</span><br><span class="line">    <span class="keyword">return</span> BAD_FILE_TOO_OLD;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( version &gt; <span class="number">123</span> ) &#123;</span><br><span class="line">    <span class="keyword">return</span> BAD_FILE_TOO_NEW;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( version &lt;= <span class="number">110</span> ) &#123;</span><br><span class="line">    in.setVersion ( QDataStream::Qt_3_2 );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    in.setVersion ( QDataStream::Qt_4_0 );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 读取数据 */</span></span><br><span class="line">in &gt;&gt; lots_of_interesting_data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( version &gt;= <span class="number">120</span> ) &#123;</span><br><span class="line">    in &gt;&gt; data_new_in_version_1_2;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">in &gt;&gt; other_interesting_data;</span><br></pre></td></tr></table></figure>
<p>这段代码就是按照前面的解释进行的。首先读取魔术数字，检查文件是否合法。如果合法，读取文件版本：小于<code>100</code>或者大于<code>123</code>都是不支持的。如果在支持的版本范围内(<code>100 &lt;= version &lt;= 123</code>)，则当小于等于<code>110</code>的时候，按照<code>Qt_3_2</code>的格式读取，否则按照<code>Qt_4_0</code>的格式读取。当设置完这些参数之后，开始读取数据。<br>&emsp;&emsp;至此，我们介绍了有关<code>QDataStream</code>的相关内容。那么，既然<code>QIODevice</code>提供了<code>read</code>、<code>readLine</code>之类的函数，为什么还要有<code>QDataStream</code>呢？<code>QDataStream</code>同<code>QIODevice</code>有什么区别？区别在于，<code>QDataStream</code>提供流的形式，性能上一般比直接调用原始<code>API</code>更好一些。我们通过下面一段代码看看什么是流的形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span> <span class="params">( <span class="string">"file.dat"</span> )</span></span>;</span><br><span class="line">file.open ( QIODevice::ReadWrite );</span><br><span class="line">​</span><br><span class="line"><span class="function">QDataStream <span class="title">stream</span> <span class="params">( &amp;file )</span></span>;</span><br><span class="line">QString str = <span class="string">"the answer is 42"</span>;</span><br><span class="line">QString strout;</span><br><span class="line">​</span><br><span class="line">stream &lt;&lt; str;</span><br><span class="line">file.flush();</span><br><span class="line">stream &gt;&gt; strout;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们首先向文件中写入数据，紧接着把数据读出来。有什么问题吗？运行之后你会发现，<code>strout</code>实际是空的。为什么没有读取出来？我们不是已经添加了<code>file.flush();</code>语句吗？原因并不在于文件有没有写入，而是在于我们使用的是<code>流</code>。所谓流，就像水流一样，它的游标会随着输出向后移动。当使用<code>&lt;&lt;</code>操作符输出之后，流的游标已经到了最后，此时你再去读，当然什么也读不到了。所以你需要在输出之后重新把游标设置为<code>0</code>的位置才能够继续读取。具体代码片段如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream &lt;&lt; str;</span><br><span class="line">stream.device()-&gt;seek ( <span class="number">0</span> );</span><br><span class="line">stream &gt;&gt; strout;</span><br></pre></td></tr></table></figure>
<h3 id="QT学习之文本文件读写"><a href="#QT学习之文本文件读写" class="headerlink" title="QT学习之文本文件读写"></a>QT学习之文本文件读写</h3><p>&emsp;&emsp;二进制文件比较小巧，却不是人可读的格式。而文本文件是一种人可读的文件。为了操作这种文件，我们需要使用<code>QTextStream</code>类。<code>QTextStream</code>和<code>QDataStream</code>的使用类似，只不过它是操作纯文本文件的。另外，像<code>XML</code>、<code>HTML</code>这种，虽然也是文本文件，可以由<code>QTextStream</code>生成，但<code>Qt</code>提供了更方便的<code>XML</code>操作类，这里就不包括这部分内容了。<br>&emsp;&emsp;<code>QTextStream</code>会自动将<code>Unicode</code>编码同操作系统的编码进行转换，这一操作对开发人员是透明的。它也会将换行符进行转换，同样不需要自己处理。<code>QTextStream</code>使用<code>16</code>位的<code>QChar</code>作为基础的数据存储单位，同样，它也支持<code>C++</code>标准类型，如<code>int</code>等。实际上，这是将这种标准类型与字符串进行了相互转换。<br>&emsp;&emsp;<code>QTextStream</code>同<code>QDataStream</code>的使用基本一致，例如下面的代码将把<code>The answer is 42</code>写入到<code>file.txt</code>文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">data</span> <span class="params">( <span class="string">"file.txt"</span> )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( data.open ( QFile::WriteOnly | QIODevice::Truncate ) ) &#123;</span><br><span class="line">    <span class="function">QTextStream <span class="title">out</span> <span class="params">( &amp;data )</span></span>;</span><br><span class="line">    out &lt;&lt; <span class="string">"The answer is "</span> &lt;&lt; <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在<code>open</code>函数中增加了<code>QIODevice::Truncate</code>打开方式，可以从下表看到这些打开方式的区别：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>枚举值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QIODevice::NotOpen</code></td>
<td>未打开</td>
</tr>
<tr>
<td><code>QIODevice::ReadOnly</code></td>
<td>以只读方式打开</td>
</tr>
<tr>
<td><code>QIODevice::WriteOnly</code></td>
<td>以只写方式打开</td>
</tr>
<tr>
<td><code>QIODevice::ReadWrite</code></td>
<td>以读写方式打开</td>
</tr>
<tr>
<td><code>QIODevice::Append</code></td>
<td>以追加的方式打开，新增加的内容将被追加到文件末尾</td>
</tr>
<tr>
<td><code>QIODevice::Truncate</code></td>
<td>以重写的方式打开，在写入新的数</td>
</tr>
<tr>
<td><code>QIODevice::Text</code></td>
<td>在读取时，将行结束符转换成<code>\n</code>；在写入时，将行结束符转换成本地格式，例如<code>Win32</code>平台上是<code>\r\n</code></td>
</tr>
<tr>
<td><code>QIODevice::Unbuffered</code></td>
<td>忽略缓存</td>
</tr>
</tbody>
</table>
</div>
<p>在这里使用了<code>QFile::WriteOnly | QIODevice::Truncate</code>，也就是以只写并且覆盖已有内容的形式操作文件。注意，<code>QIODevice::Truncate</code>会直接将文件内容清空。</p>
<hr>
<h3 id="QTextStream读取文件内容"><a href="#QTextStream读取文件内容" class="headerlink" title="QTextStream读取文件内容"></a>QTextStream读取文件内容</h3><p>&emsp;&emsp;基础代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span> <span class="params">( <span class="string">"file.txt"</span> )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( !file.open ( QIODevice::ReadOnly | QIODevice::Text ) ) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function">QTextStream <span class="title">in</span> <span class="params">( &amp;file )</span></span>;</span><br><span class="line">QString QTextStream::read ( qint64 maxlen ) -- 读取txt文件maxlen个字符：</span><br><span class="line">QString line1 = in.read ( <span class="number">1</span> ); <span class="comment">/* 读取一个字符 */</span></span><br><span class="line">QString line2 = in.read ( <span class="number">1</span> ); <span class="comment">/* 自动读取下一个字符 */</span></span><br><span class="line">QString line1 = in.read ( <span class="number">20</span> ); <span class="comment">/* 读取20个字符，归为一个字符串 */</span></span><br><span class="line">QString QTextStream::readLine ( qint64 maxlen = <span class="number">0</span> )：</span><br><span class="line">QString line1 = in.readLine ( <span class="number">0</span> ); <span class="comment">/* 读取第0行文档 */</span></span><br><span class="line">QString line2 = in.readLine ( <span class="number">5</span> ); <span class="comment">/* 读取第0行5个文档 */</span></span><br><span class="line">QString line1 = in.readLine(); <span class="comment">/* 读取第0行文档 */</span></span><br><span class="line">QString line2 = in.readLine(); <span class="comment">/* 自动读取第1行文档 */</span></span><br><span class="line">QString QTextStream::readAll ()：</span><br><span class="line">QString line1 = in.readAll(); <span class="comment">/* 读取全部txt文档，并归为一个字符串 */</span></span><br><span class="line"><span class="keyword">bool</span> QTextStream::seek ( qint64 pos )：</span><br><span class="line"><span class="keyword">bool</span> a = in.seek ( <span class="number">6</span> ); <span class="comment">/* 定位文本中的第6个位置 */</span></span><br><span class="line">QString line2 = in.read ( <span class="number">1</span> ) ; <span class="comment">/* 读取该位的1字符 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读取<code>txt</code>文本全部内容的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 两种方法读取txt文档 */</span></span><br><span class="line"><span class="keyword">while</span> ( !in.atEnd() ) &#123;</span><br><span class="line">    QString line = in.readLine();</span><br><span class="line">    qDebug() &lt;&lt; line;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------------------------*/</span></span><br><span class="line">QString line3 = in.readLine();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( !line3.isNull() ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; line3;</span><br><span class="line">    line3 = in.readLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="QFileInfo的简单用法"><a href="#QFileInfo的简单用法" class="headerlink" title="QFileInfo的简单用法"></a>QFileInfo的简单用法</h3><p>&emsp;&emsp;<code>QFileInfo</code>的几个构造函数：</p>
<ul>
<li><code>QFileInfo();</code></li>
<li><code>QFileInfo( const QString &amp; file );</code></li>
<li><code>QFileInfo( const QFile &amp; file );</code></li>
<li><code>QFileInfo( const QDir &amp; dir, const QString &amp; file );</code></li>
<li><code>QFileInfo( const QFileInfo &amp; fileinfo );</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFileInfo <span class="title">fileInfo</span> <span class="params">( path )</span></span>;</span><br><span class="line"><span class="comment">/* or */</span></span><br><span class="line">QFileInfo fileInfo;</span><br><span class="line">fileInfo.setFile ( path );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>bool exists();</code>：判断文件是否存在，若存在返回<code>true</code>。</li>
<li><code>qint64 size();</code>：获取文件大小，返回<code>bytes</code>。</li>
</ul>
<p>&emsp;&emsp;路径和文件名相关：</p>
<ul>
<li><code>QString path();</code>：返回文件路径，不包含文件名。</li>
<li><code>QString filePath();</code>：返回文件路径，包含文件名。</li>
<li><code>QString fileName();</code>：返回文件名称。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFileInfo <span class="title">fileInfo</span> <span class="params">( <span class="string">"/home/dipper/xyz.tar.gz"</span> )</span></span>;</span><br><span class="line">fileInfo.path();             <span class="comment">/* returns "/home/dipper" */</span></span><br><span class="line">fileInfo.fileName();         <span class="comment">/* returns "xyz.tar.gz" */</span></span><br><span class="line">fileInfo.baseName();         <span class="comment">/* returns "xyz" */</span></span><br><span class="line">fileInfo.completeBaseName(); <span class="comment">/* returns "xyz.tar" */</span></span><br><span class="line">fileInfo.suffix();           <span class="comment">/* returns "gz" */</span></span><br><span class="line">fileInfo.completeSuffix();   <span class="comment">/* returns "tar.gz" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;类型：</p>
<ul>
<li><code>bool isFile();</code>：判断是否为文件。</li>
<li><code>bool isDir();</code>：判断是否为路径。</li>
<li><code>bool isSymLink();</code>：判断是否为符号链接。<code>symLinkTarget</code>返回符号链接的文件。</li>
</ul>
<p>&emsp;&emsp;日期相关：</p>
<ul>
<li><code>QDateTime created();</code>：创建时间。</li>
<li><code>QDateTime lastModified();</code>：最近修改时间。</li>
<li><code>QDateTime lastRead();</code>：最近读时间。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/17/Qt语法详解/Qt之QBoxLayout、QHBoxLayout和QVBoxLayout/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/17/Qt语法详解/Qt之QBoxLayout、QHBoxLayout和QVBoxLayout/" itemprop="url">Qt之QBoxLayout、QHBoxLayout和QVBoxLayout</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-17T17:43:03+08:00">
                2019-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>&emsp;&emsp;<code>QBoxLayout</code>可以在水平方向或垂直方向上排列控件，由<code>QHBoxLayout</code>、<code>QVBoxLayout</code>所继承。</p>
<ul>
<li><code>QHBoxLayout</code>：水平布局，在水平方向上排列控件，即左右排列。</li>
<li><code>QVBoxLayout</code>：垂直布局，在垂直方向上排列控件，即上下排列。</li>
</ul>
<p>&emsp;&emsp;通过查看源码可以发现，水平布局、垂直布局除了构造时的方向(<code>LeftToRight</code>、<code>TopToBottom</code>)不同外，其它均相同。下面以<code>QHBoxLayout</code>为例，来讲解<code>QBoxLayout</code>的常用功能。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>&emsp;&emsp;下面介绍下水平布局的基本使用。</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QBoxLayout、QHBoxLayout和QVBoxLayout/1.png"></p>
<p>&emsp;&emsp;下面创建<code>5</code>个按钮，然后添加至水平不居中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *pButton1 = <span class="keyword">new</span> QPushButton ( <span class="string">"One"</span> );</span><br><span class="line">QPushButton *pButton2 = <span class="keyword">new</span> QPushButton ( <span class="string">"Two"</span> );</span><br><span class="line">QPushButton *pButton3 = <span class="keyword">new</span> QPushButton ( <span class="string">"Three"</span> );</span><br><span class="line">QPushButton *pButton4 = <span class="keyword">new</span> QPushButton ( <span class="string">"Four"</span> );</span><br><span class="line">QPushButton *pButton5 = <span class="keyword">new</span> QPushButton ( <span class="string">"Five"</span> );</span><br><span class="line">​</span><br><span class="line">QHBoxLayout *pHLayout = <span class="keyword">new</span> QHBoxLayout();</span><br><span class="line">pHLayout-&gt;addWidget ( pButton1 );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton2 );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton3 );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton4 );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton5 );</span><br><span class="line">​</span><br><span class="line">setLayout ( pHLayout );</span><br></pre></td></tr></table></figure>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><p>&emsp;&emsp;默认的外边距为<code>0</code>，为了美观性，可以设置<code>Margin</code>：</p>
<ul>
<li><code>setMargin(int);</code></li>
<li><code>setContentsMargins(int left, int top, int right, int bottom);</code></li>
<li><code>setContentsMargins(const QMargins &amp;margins);</code></li>
</ul>
<p>&emsp;&emsp;<code>setMargin</code>可以设置左、上、右、下的外边距，设置之后，它们的外边距是相同的。<code>setContentsMargins</code>与其功能相同，但是可以将左、上、右、下的外边距设置为不同的值。这里我使用<code>setMargin(10)</code>将外边距设置为<code>10</code>：</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QBoxLayout、QHBoxLayout和QVBoxLayout/2.png"></p>
<p>&emsp;&emsp;<code>setSpacing(int)</code>的作用是设置间距。一般情况下，界面会有一个默认间距值。为了保持所有布局的统一性或者需要一个更合适的间距值，则需要手动设置。这里使用<code>setSpacing(0)</code>将间距设置为<code>0</code>：</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QBoxLayout、QHBoxLayout和QVBoxLayout/3.png"></p>
<p>&emsp;&emsp;<code>addStretch</code>的作用是添加了一个伸缩空间(<code>QSpacerItem</code>)。居右效果如下：</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QBoxLayout、QHBoxLayout和QVBoxLayout/4.png"></p>
<p>&emsp;&emsp;在第一个控件之前添加伸缩，这样所有的控件就会居右显示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QHBoxLayout *pHLayout = <span class="keyword">new</span> QHBoxLayout();</span><br><span class="line">pHLayout-&gt;addStretch(); <span class="comment">/* 添加伸缩 */</span></span><br><span class="line">pHLayout-&gt;addWidget ( pButton1 );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton2 );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton3 );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton4 );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton5 );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;居左效果如下：</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QBoxLayout、QHBoxLayout和QVBoxLayout/5.png"></p>
<p>&emsp;&emsp;在最后一个控件之后添加伸缩，这样所有的控件就会居左显示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QHBoxLayout *pHLayout = <span class="keyword">new</span> QHBoxLayout();</span><br><span class="line">pHLayout-&gt;addWidget ( pButton1 );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton2 );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton3 );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton4 );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton5 );</span><br><span class="line">pHLayout-&gt;addStretch(); <span class="comment">/* 添加伸缩 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;居中效果如下：</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QBoxLayout、QHBoxLayout和QVBoxLayout/6.png"></p>
<p>&emsp;&emsp;在第一个控件之前、最后一个控件之后添加伸缩，这样所有的控件就会居中显示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QHBoxLayout *pHLayout = <span class="keyword">new</span> QHBoxLayout();</span><br><span class="line">pHLayout-&gt;addStretch(); <span class="comment">/* 第一个控件之前添加伸缩 */</span></span><br><span class="line">pHLayout-&gt;addWidget ( pButton1 );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton2 );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton3 );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton4 );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton5 );</span><br><span class="line">pHLayout-&gt;addStretch(); <span class="comment">/* 最后一个控件之后添加伸缩 */</span></span><br><span class="line">pHLayout-&gt;setSpacing ( <span class="number">10</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;均分效果如下：</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QBoxLayout、QHBoxLayout和QVBoxLayout/7.png"></p>
<p>&emsp;&emsp;在每一个控件之间都添加伸缩，这样所有的控件之间的间距都会相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">QHBoxLayout *pHLayout = <span class="keyword">new</span> QHBoxLayout();</span><br><span class="line">pHLayout-&gt;addStretch();</span><br><span class="line">pHLayout-&gt;addWidget ( pButton1 );</span><br><span class="line">pHLayout-&gt;addStretch();</span><br><span class="line">pHLayout-&gt;addWidget ( pButton2 );</span><br><span class="line">pHLayout-&gt;addStretch();</span><br><span class="line">pHLayout-&gt;addWidget ( pButton3 );</span><br><span class="line">pHLayout-&gt;addStretch();</span><br><span class="line">pHLayout-&gt;addWidget ( pButton4 );</span><br><span class="line">pHLayout-&gt;addStretch();</span><br><span class="line">pHLayout-&gt;addWidget ( pButton5 );</span><br><span class="line">pHLayout-&gt;addStretch();</span><br><span class="line">pHLayout-&gt;setSpacing ( <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p><code>addWidget</code>的作用是添加控件，其函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addWidget ( QWidget *, <span class="keyword">int</span> stretch = <span class="number">0</span>, Qt::Alignment alignment = <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;默认情况下，我们添加控件至水平布局中，默认都是垂直方向居中对齐的：</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QBoxLayout、QHBoxLayout和QVBoxLayout/8.png"></p>
<p>&emsp;&emsp;当存在控件大小不相同的时候，就会看得很明显了。如果需要将其中的某些控件居上、居下显示，那么可以使用对齐方式<code>Qt::Alignment</code>。下面使用向上、向下对齐来设置其它控件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QHBoxLayout *pHLayout = <span class="keyword">new</span> QHBoxLayout();</span><br><span class="line">pHLayout-&gt;addStretch();</span><br><span class="line"><span class="comment">/* 水平居左，垂直居上 */</span></span><br><span class="line">pHLayout-&gt;addWidget ( pButton1, <span class="number">0</span> , Qt::AlignLeft | Qt::AlignTop );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton2, <span class="number">0</span> , Qt::AlignLeft | Qt::AlignTop );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton3 );</span><br><span class="line"><span class="comment">/* 水平居左，垂直居下 */</span></span><br><span class="line">pHLayout-&gt;addWidget ( pButton4, <span class="number">0</span> , Qt::AlignLeft | Qt::AlignBottom );</span><br><span class="line">pHLayout-&gt;addWidget ( pButton5, <span class="number">0</span> , Qt::AlignLeft | Qt::AlignBottom );</span><br><span class="line">pHLayout-&gt;setSpacing ( <span class="number">10</span> );</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/17/Qt语法详解/Qt之QBoxLayout、QHBoxLayout和QVBoxLayout/9.png"></p>
<p>&emsp;&emsp;<code>setDirection(Direction)</code>的作用是设置布局方向，可以设置从左到右、从右到左、从上到下、从下到上等。<br>&emsp;&emsp;<code>setDirection(QBoxLayout::RightToLeft)</code>的效果如下：</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QBoxLayout、QHBoxLayout和QVBoxLayout/10.png"></p>
<p>&emsp;&emsp;<code>setDirection(QBoxLayout::TopToBottom)</code>的效果如下：</p>
<p><img src="/2019/03/17/Qt语法详解/Qt之QBoxLayout、QHBoxLayout和QVBoxLayout/11.png"></p>
<p>&emsp;&emsp;既然使用了<code>QHBoxLayout</code>，一般就不建议使用<code>TopToBottom</code>或者<code>BottomToTop</code>，如果实在确定不了方向，或者方向可以随意变化，那么建议使用<code>QBoxLayout</code>。<br>&emsp;&emsp;<code>setStretchFactor</code>可以用来设置控件、布局的拉伸系数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setStretchFactor( QWidget *w, <span class="keyword">int</span> stretch );</span><br><span class="line">setStretchFactor( QLayout *l, <span class="keyword">int</span> stretch );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当窗体大小变化时，控件会根据拉伸系数来做相应的调整：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setStretchFactor ( pButton1, <span class="number">1</span> );</span><br><span class="line">setStretchFactor ( pButton2, <span class="number">2</span> );</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/17/Qt语法详解/Qt之QBoxLayout、QHBoxLayout和QVBoxLayout/12.png"></p>
<p>设置<code>pButton1</code>的拉伸系数为<code>1</code>，<code>pButton2</code>拉伸系数为<code>2</code>，当窗体变大时，会优先将<code>pButton2</code>进行拉伸；当达到一定程度时，再拉伸<code>pButton1</code>，<code>pButton1</code>与<code>pButton2</code>的宽度比例为<code>1:2</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/94/">94</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">934</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
