<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="暴徒">
<meta property="og:url" content="http://fukangwei.gitee.io/page/49/index.html">
<meta property="og:site_name" content="暴徒">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="暴徒">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/49/">





  <title>暴徒</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">暴徒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/23/Qt语法详解/Qt之QPoint/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/23/Qt语法详解/Qt之QPoint/" itemprop="url">Qt之QPoint</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-23T19:45:45+08:00">
                2019-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QPoint</code> class defines a point in the plane using integer precision. The header file is <code>QPoint</code>.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QPoint()</code></td>
</tr>
<tr>
<td></td>
<td><code>QPoint(int x, int y)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isNull() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>manhattanLength() const</code></td>
</tr>
<tr>
<td><code>int &amp;</code></td>
<td><code>rx()</code></td>
</tr>
<tr>
<td><code>int &amp;</code></td>
<td><code>ry()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setX(int x)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setY(int y)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>x() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>y() const</code></td>
</tr>
<tr>
<td><code>QPoint &amp;</code></td>
<td><code>operator*=(float factor)</code></td>
</tr>
<tr>
<td><code>QPoint &amp;</code></td>
<td><code>operator*=(double factor)</code></td>
</tr>
<tr>
<td><code>QPoint &amp;</code></td>
<td><code>operator*=(int factor)</code></td>
</tr>
<tr>
<td><code>QPoint &amp;</code></td>
<td><code>operator+=(const QPoint &amp; point)</code></td>
</tr>
<tr>
<td><code>QPoint &amp;</code></td>
<td><code>operator-=(const QPoint &amp; point)</code></td>
</tr>
<tr>
<td><code>QPoint &amp;</code></td>
<td><code>operator/=(qreal divisor)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QPoint &amp; p1, const QPoint &amp; p2)</code></td>
</tr>
<tr>
<td><code>const QPoint</code></td>
<td><code>operator*(const QPoint &amp; point, float factor)</code></td>
</tr>
<tr>
<td><code>const QPoint</code></td>
<td><code>operator*(float factor, const QPoint &amp; point)</code></td>
</tr>
<tr>
<td><code>const QPoint</code></td>
<td><code>operator*(double factor, const QPoint &amp; point)</code></td>
</tr>
<tr>
<td><code>const QPoint</code></td>
<td><code>operator*(int factor, const QPoint &amp; point)</code></td>
</tr>
<tr>
<td><code>const QPoint</code></td>
<td><code>operator*(const QPoint &amp; point, double factor)</code></td>
</tr>
<tr>
<td><code>const QPoint</code></td>
<td><code>operator*(const QPoint &amp; point, int factor)</code></td>
</tr>
<tr>
<td><code>const QPoint</code></td>
<td><code>operator+(const QPoint &amp; p1, const QPoint &amp; p2)</code></td>
</tr>
<tr>
<td><code>const QPoint</code></td>
<td><code>operator-(const QPoint &amp; p1, const QPoint &amp; p2)</code></td>
</tr>
<tr>
<td><code>const QPoint</code></td>
<td><code>operator-(const QPoint &amp; point)</code></td>
</tr>
<tr>
<td><code>const QPoint</code></td>
<td><code>operator/(const QPoint &amp; point, qreal divisor)</code></td>
</tr>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&lt;&lt;(QDataStream &amp; stream, const QPoint &amp; point)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QPoint &amp; p1, const QPoint &amp; p2)</code></td>
</tr>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&gt;&gt;(QDataStream &amp; stream, QPoint &amp; point)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QPoint</code> class defines a point in the plane using integer precision.<br>&emsp;&emsp;A point is specified by a <code>x</code> coordinate and an <code>y</code> coordinate which can be accessed using the <code>x()</code> and <code>y()</code> functions. The <code>isNull()</code> function returns <code>true</code> if both <code>x</code> and <code>y</code> are set to <code>0</code>. The coordinates can be set (or altered) using the <code>setX()</code> and <code>setY()</code> functions, or alternatively the <code>rx()</code> and <code>ry()</code> functions which return references to the coordinates (allowing direct manipulation).<br>&emsp;&emsp;Given a point <code>p</code>, the following statements are all equivalent:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QPoint p;</span><br><span class="line"></span><br><span class="line">p.setX(p.x() + <span class="number">1</span>);</span><br><span class="line">p += QPoint(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">p.rx()++;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;A <code>QPoint</code> object can also be used as a vector: Addition and subtraction are defined as for vectors (each component is added separately). A <code>QPoint</code> object can also be divided or multiplied by an int or a qreal.<br>&emsp;&emsp;In addition, the <code>QPoint</code> class provides the <code>manhattanLength()</code> function which gives an inexpensive approximation of the length of the <code>QPoint</code> object interpreted as a vector. Finally, <code>QPoint</code> objects can be streamed as well as compared.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QPoint::QPoint()</code>: Constructs a null point, i.e. with coordinates <code>(0, 0)</code>.</li>
<li><code>QPoint::QPoint(int x, int y)</code>: Constructs a point with the given coordinates <code>(x, y)</code>.</li>
<li><code>bool QPoint::isNull() const</code>: Returns <code>true</code> if both the <code>x</code> and <code>y</code> coordinates are set to <code>0</code>, otherwise returns <code>false</code>.</li>
<li><code>int QPoint::manhattanLength() const</code>: Returns the sum of the absolute values of <code>x()</code> and <code>y()</code>, traditionally known as the <code>Manhattan length</code> of the vector from the origin to the point. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QPoint oldPosition;</span><br><span class="line">​</span><br><span class="line">MyWidget::mouseMoveEvent ( QMouseEvent *event ) &#123;</span><br><span class="line">    QPoint point = event-&gt;pos() - oldPosition;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( point.manhattanLength() &gt; <span class="number">3</span> )</span><br><span class="line">        <span class="comment">// the mouse has moved more than 3 pixels since the oldPosition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is a useful, and quick to calculate, approximation to the true length:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> trueLength = <span class="built_in">sqrt</span> ( <span class="built_in">pow</span> ( x(), <span class="number">2</span> ) + <span class="built_in">pow</span> ( y(), <span class="number">2</span> ) );</span><br></pre></td></tr></table></figure>
<p>The tradition of <code>Manhattan length</code> arises because such distances apply to travelers who can only travel on a rectangular grid, like the streets of <code>Manhattan</code>.</p>
<ul>
<li><code>int &amp; QPoint::rx()</code>: Returns a reference to the <code>x</code> coordinate of this point. Using a reference makes it possible to directly manipulate <code>x</code>. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">p</span> <span class="params">( <span class="number">1</span>, <span class="number">2</span> )</span></span>;</span><br><span class="line">p.rx()--; <span class="comment">/* p becomes (0, 2) */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>int &amp; QPoint::ry()</code>: Returns a reference to the <code>y</code> coordinate of this point. Using a reference makes it possible to directly manipulate <code>y</code>. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">p</span> <span class="params">( <span class="number">1</span>, <span class="number">2</span> )</span></span>;</span><br><span class="line">p.ry()++; <span class="comment">/* p becomes (1, 3) */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QPoint::setX(int x)</code>: Sets the <code>x</code> coordinate of this point to the given <code>x</code> coordinate.</li>
<li><code>void QPoint::setY(int y)</code>: Sets the <code>y</code> coordinate of this point to the given <code>y</code> coordinate.</li>
<li><code>int QPoint::x() const</code>: Returns the <code>x</code> coordinate of this point.</li>
<li><code>int QPoint::y() const</code>: Returns the <code>y</code> coordinate of this point.</li>
<li><code>QPoint &amp; QPoint::operator*=(float factor)</code>: Multiplies this point’s coordinates by the given <code>factor</code>, and returns a reference to this point. Note that the result is rounded to the nearest integer as points are held as integers. Use <code>QPointF</code> for floating point accuracy.</li>
<li><code>QPoint &amp; QPoint::operator*=(double factor)</code>: Multiplies this point’s coordinates by the given <code>factor</code>, and returns a reference to this point. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">p</span> <span class="params">( <span class="number">-1</span>, <span class="number">4</span> )</span></span>;</span><br><span class="line">p *= <span class="number">2.5</span>; <span class="comment">/* p becomes (-3, 10) */</span></span><br></pre></td></tr></table></figure>
<p>Note that the result is rounded to the nearest integer as points are held as integers. Use <code>QPointF</code> for floating point accuracy.</p>
<ul>
<li><code>QPoint &amp; QPoint::operator*=(int factor)</code>: Multiplies this point’s coordinates by the given <code>factor</code>, and returns a reference to this point.</li>
<li><code>QPoint &amp; QPoint::operator+=(const QPoint &amp; point)</code>: Adds the given <code>point</code> to this <code>point</code> and returns a reference to this <code>point</code>. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">p</span> <span class="params">( <span class="number">3</span>, <span class="number">7</span> )</span></span>;</span><br><span class="line"><span class="function">QPoint <span class="title">q</span> <span class="params">( <span class="number">-1</span>, <span class="number">4</span> )</span></span>;</span><br><span class="line">p += q; <span class="comment">/* p becomes (2, 11) */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>QPoint &amp; QPoint::operator-=(const QPoint &amp; point)</code>: Subtracts the given <code>point</code> from this <code>point</code> and returns a reference to this <code>point</code>. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">p</span> <span class="params">( <span class="number">3</span>, <span class="number">7</span> )</span></span>;</span><br><span class="line"><span class="function">QPoint <span class="title">q</span> <span class="params">( <span class="number">-1</span>, <span class="number">4</span> )</span></span>;</span><br><span class="line">p -= q; <span class="comment">/* p becomes (4, 3) */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>QPoint &amp; QPoint::operator/=(qreal divisor)</code>: This is an overloaded function. Divides both <code>x</code> and <code>y</code> by the given <code>divisor</code>, and returns a reference to this point. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">p</span> <span class="params">( <span class="number">-3</span>, <span class="number">10</span> )</span></span>;</span><br><span class="line">p /= <span class="number">2.5</span>; <span class="comment">/* p becomes (-1, 4) */</span></span><br></pre></td></tr></table></figure>
<p>Note that the result is rounded to the nearest integer as points are held as integers. Use <code>QPointF</code> for floating point accuracy.</p>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>bool operator!=(const QPoint &amp; p1, const QPoint &amp; p2)</code>: Returns <code>true</code> if <code>p1</code> and <code>p2</code> are not equal; otherwise returns <code>false</code>.</li>
<li><code>const QPoint operator*(const QPoint &amp; point, float factor)</code>: Returns a copy of the given <code>point</code> multiplied by the given <code>factor</code>. Note that the result is rounded to the nearest integer as points are held as integers. Use <code>QPointF</code> for floating <code>point</code> accuracy.</li>
<li><code>const QPoint operator*(float factor, const QPoint &amp; point)</code>: This is an overloaded function. Returns a copy of the given <code>point</code> multiplied by the given <code>factor</code>.</li>
<li><code>const QPoint operator*(double factor, const QPoint &amp; point)</code>: This is an overloaded function. Returns a copy of the given <code>point</code> multiplied by the given <code>factor</code>.</li>
<li><code>const QPoint operator*(int factor, const QPoint &amp; point)</code>: This is an overloaded function. Returns a copy of the given <code>point</code> multiplied by the given <code>factor</code>.</li>
<li><code>const QPoint operator*(const QPoint &amp; point, double factor)</code>: Returns a copy of the given <code>point</code> multiplied by the given <code>factor</code>. Note that the result is rounded to the nearest integer as points are held as integers. Use <code>QPointF</code> for floating point accuracy.</li>
<li><code>const QPoint operator*(const QPoint &amp; point, int factor)</code>: Returns a copy of the given <code>point</code> multiplied by the given <code>factor</code>.</li>
<li><code>const QPoint operator+(const QPoint &amp; p1, const QPoint &amp; p2)</code>: Returns a <code>QPoint</code> object that is the sum of the given points, <code>p1</code> and <code>p2</code>; each component is added separately.</li>
<li><code>const QPoint operator-(const QPoint &amp; p1, const QPoint &amp; p2)</code>: Returns a <code>QPoint</code> object that is formed by subtracting <code>p2</code> from <code>p1</code>; each component is subtracted separately.</li>
<li><code>const QPoint operator-(const QPoint &amp; point)</code>: This is an overloaded function. Returns a <code>QPoint</code> object that is formed by changing the sign of both components of the given <code>point</code>. Equivalent to <code>QPoint(0,0) - point</code>.</li>
<li><code>const QPoint operator/(const QPoint &amp; point, qreal divisor)</code>: Returns the <code>QPoint</code> formed by dividing both components of the given <code>point</code> by the given <code>divisor</code>. Note that the result is rounded to the nearest integer as points are held as integers. Use <code>QPointF</code> for floating point accuracy.</li>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; stream, const QPoint &amp; point)</code>: Writes the given <code>point</code> to the given <code>stream</code> and returns a reference to the <code>stream</code>.</li>
<li><code>bool operator==(const QPoint &amp; p1, const QPoint &amp; p2)</code>: Returns <code>true</code> if <code>p1</code> and <code>p2</code> are equal; otherwise returns <code>false</code>.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; stream, QPoint &amp; point)</code>: Reads a <code>point</code> from the given <code>stream</code> into the given <code>point</code> and returns a reference to the <code>stream</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/23/Qt语法详解/Qt之QThread/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/23/Qt语法详解/Qt之QThread/" itemprop="url">Qt之QThread</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-23T17:16:21+08:00">
                2019-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>&emsp;&emsp;<code>QThread</code>类提供了与系统无关的线程，其代表在程序中一个单独的线程控制。线程在<code>run</code>中开始执行，默认情况下，<code>run</code>通过调用<code>exec</code>启动事件循环并在线程里运行一个<code>Qt</code>的事件循环。<br>&emsp;&emsp;当线程<code>started</code>和<code>finished</code>时，<code>QThread</code>会通过一个信号通知你，可以使用<code>isFinished</code>和<code>isRunning</code>来查询线程的状态。你可以通过调用<code>exit</code>或<code>quit</code>来停止线程。在极端情况下，可能要强行<code>terminate</code>一个执行线程，但是这样做很危险。从<code>Qt 4.8</code>起，可以释放运行刚刚结束的线程对象，通过连接<code>finished</code>信号到<code>QObject::deleteLater</code>槽。使用<code>wait</code>来阻塞调用的线程，直到其它线程执行完毕(或者直到指定的时间过去)。<br>&emsp;&emsp;<code>QThread</code>还提供了静态的、平台独立的休眠函数：<code>sleep</code>、<code>msleep</code>、<code>usleep</code>，允许秒、毫秒和微秒来区分，这些函数在<code>Qt 5.0</code>中被设为<code>public</code>。一般情况下不需要<code>wait</code>和<code>sleep</code>函数，因为<code>Qt</code>是一个事件驱动型框架。考虑监听<code>finished</code>信号来取代<code>wait</code>，使用<code>QTimer</code>来取代<code>sleep</code>。<br>&emsp;&emsp;静态函数<code>currentThreadId</code>和<code>currentThread</code>返回标识当前正在执行的线程。前者返回该线程平台特定的<code>ID</code>，后者返回一个线程指针。<br>&emsp;&emsp;要设置线程的名称，可以在启动线程之前调用<code>setObjectName</code>。如果不调用<code>setObjectName</code>，线程的名称将是线程对象的运行时类型(<code>QThread</code>子类的类名)。</p>
<h3 id="线程启动"><a href="#线程启动" class="headerlink" title="线程启动"></a>线程启动</h3><p>&emsp;&emsp;<code>start</code>函数原型如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void start ( Priority priority = InheritPriority ) [slot]</span><br></pre></td></tr></table></figure>
<p>调用后会执行<code>run</code>函数，但在<code>run</code>函数执行前会发射信号<code>started</code>，操作系统将根据优先级参数调度线程。如果线程已经在运行，那么这个函数什么也不做。优先级参数的效果取决于操作系统的调度策略，那些不支持线程优先级的系统优先级将会被忽略。</p>
<h3 id="线程执行"><a href="#线程执行" class="headerlink" title="线程执行"></a>线程执行</h3><p>&emsp;&emsp;<code>exec</code>函数原型如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int exec() [protected]</span><br></pre></td></tr></table></figure>
<p>进入事件循环并等待直到调用<code>exit</code>，返回值是通过调用<code>exit</code>来获得，如果调用成功则返回<code>0</code>。<br>&emsp;&emsp;<code>run</code>函数原型如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void run() [virtual protected]</span><br></pre></td></tr></table></figure>
<p>这是线程的起点，在调用<code>start</code>之后，新创建的线程就会调用这个函数。大多数情况下需要重新实现这个函数，便于管理自己的线程。该方法返回时，该线程的执行将结束。</p>
<h3 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h3><p>&emsp;&emsp;<code>quit</code>函数原型如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void quit() [slot]</span><br></pre></td></tr></table></figure>
<p>告诉线程事件循环退出，返回<code>0</code>表示成功，相当于调用了<code>QThread::exit(0)</code>。<br>&emsp;&emsp;<code>exit</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span> <span class="params">( <span class="keyword">int</span> returnCode = <span class="number">0</span> )</span></span></span><br></pre></td></tr></table></figure>
<p>告诉线程事件循环退出。调用这个函数后，线程离开事件循环后返回，<code>QEventLoop::exec</code>返回<code>returnCode</code>。按照惯例，<code>0</code>表示成功，任何非<code>0</code>值表示失败。<br>&emsp;&emsp;<code>terminate</code>函数原型如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void terminate() [slot]</span><br></pre></td></tr></table></figure>
<p>终止线程，线程可能会立即被终止也可能不会，这取决于操作系统的调度策略。使用<code>terminate</code>之后再使用<code>QThread::wait</code>，以确保万无一失。当线程被终止后，所有等待中的线程将会被唤醒。此函数比较危险，不鼓励使用。线程可以在代码执行的任何点被终止，尤其可能在更新数据时被终止，从而没有机会来清理资源或者解锁等。总之，只有在绝对必要时才使用此函数。<br>&emsp;&emsp;<code>requestInterruption</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">requestInterruption</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>请求线程的中断。此函数不停止线程上运行的任何事件循环，并且在任何情况下都不会终止它。</p>
<h3 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h3><p>&emsp;&emsp;函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 强制当前线程睡眠msecs毫秒 */</span></span><br><span class="line">void msleep ( unsigned long msecs ) [static]</span><br><span class="line"><span class="comment">/* 强制当前线程睡眠secs秒 */</span></span><br><span class="line">void sleep ( unsigned long secs ) [static]</span><br><span class="line"><span class="comment">/* 强制当前线程睡眠usecs微秒 */</span></span><br><span class="line">void usleep ( unsigned long usecs ) [static]</span><br><span class="line"><span class="comment">/* 线程将会被阻塞，等待time毫秒。和sleep不同的是，如果线程退出，wait会返回 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wait</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">long</span> time = ULONG_MAX )</span></span></span><br></pre></td></tr></table></figure>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>&emsp;&emsp;<code>isFinished</code>和<code>isRunning</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFinished</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">/* 线程是否结束 */</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRunning</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">/* 线程是否正在运行 */</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>isInterruptionRequested</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInterruptionRequested</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<p>如果线程上的任务运行应该停止，则返回<code>true</code>。可以使用<code>requestInterruption</code>请求中断。此函数可用于使长时间运行的任务干净地中断。注意，不要过于频繁调用，以保持较低的开销。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">long_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    forever &#123;</span><br><span class="line">        <span class="keyword">if</span> ( QThread::currentThread()-&gt;isInterruptionRequested() ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>&emsp;&emsp;<code>setPriority</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(Priority priority)</span></span></span><br></pre></td></tr></table></figure>
<p>设置正在运行线程的优先级。如果线程没有运行，此函数不执行任何操作并立即返回。使用的<code>start</code>来启动一个线程具有特定的优先级。优先级参数可以是<code>QThread::Priority</code>枚举除了<code>InheritPriortyd</code>的任何值。枚举量<code>QThread::Priority</code>如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QThread::IdlePriority</code></td>
<td><code>0</code></td>
<td>没有其它线程运行时才调度</td>
</tr>
<tr>
<td><code>QThread::LowestPriority</code></td>
<td><code>1</code></td>
<td>比<code>LowPriority</code>调度频率低</td>
</tr>
<tr>
<td><code>QThread::LowPriority</code></td>
<td><code>2</code></td>
<td>比<code>NormalPriority</code>调度频率低</td>
</tr>
<tr>
<td><code>QThread::NormalPriority</code></td>
<td><code>3</code></td>
<td>操作系统的默认优先级</td>
</tr>
<tr>
<td><code>QThread::HighPriority</code></td>
<td><code>4</code></td>
<td>比<code>NormalPriority</code>调度频繁</td>
</tr>
<tr>
<td><code>QThread::HighestPriority</code></td>
<td><code>5</code></td>
<td>比<code>HighPriority</code>调度频繁</td>
</tr>
<tr>
<td><code>QThread::TimeCriticalPriority</code></td>
<td><code>6</code></td>
<td>尽可能频繁的调度</td>
</tr>
<tr>
<td><code>QThread::InheritPriority</code></td>
<td><code>7</code></td>
<td>使用和创建线程同样的优先级，这是默认值</td>
</tr>
</tbody>
</table>
</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/23/Qt语法详解/Qt之QNetworkInterface/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/23/Qt语法详解/Qt之QNetworkInterface/" itemprop="url">Qt之QNetworkInterface</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-23T16:56:20+08:00">
                2019-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>&emsp;&emsp;<code>QNetworkInterface</code>类负责提供主机的<code>IP</code>地址和网络接口的列表，它表示了当前程序正在运行时与主机绑定的一个网络接口。每个网络接口可能包含<code>0</code>个或多个<code>IP</code>地址，每个<code>IP</code>地址都可选择性地与一个子网掩码<code>和/或</code>一个广播地址相关联。这样的列表可以通过<code>addressEntries</code>方法获得。当子网掩码或者广播地址不必要时，可以使用<code>allAddresses</code>函数来仅仅获得<code>IP</code>地址。<code>QNetworkInterface</code>使用<code>hardwareAddress</code>方法获取接口的硬件地址。</p>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><p>&emsp;&emsp;枚举值为<code>QNetworkInterface::InterfaceFlag</code>，标识为<code>QNetworkInterface::InterfaceFlags</code>。它用于指定网络接口相关的标识，可能的值为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QNetworkInterface::IsUp</code></td>
<td><code>0x1</code></td>
<td>网络接口处于活动状态</td>
</tr>
<tr>
<td><code>QNetworkInterface::IsRunning</code></td>
<td><code>0x2</code></td>
<td>网络接口已分配资源</td>
</tr>
<tr>
<td><code>QNetworkInterface::CanBroadcast</code></td>
<td><code>0x4</code></td>
<td>网络接口工作在广播模式</td>
</tr>
<tr>
<td><code>QNetworkInterface::IsLoopBack</code></td>
<td><code>0x8</code></td>
<td>网络接口是环回接口</td>
</tr>
<tr>
<td><code>QNetworkInterface::IsPointToPoint</code></td>
<td><code>0x10</code></td>
<td>网络接口是一个点对点接口</td>
</tr>
<tr>
<td><code>QNetworkInterface::CanMulticast</code></td>
<td><code>0x20</code></td>
<td>网络接口支持多播</td>
</tr>
</tbody>
</table>
</div>
<p>注意，一个网络接口不能既是<code>broadcast-based</code>又是<code>point-to-point</code>。<code>InterfaceFlags</code>类型是一个<code>QFlags</code>类型定义，它存储一个或<code>InterfaceFlag</code>的组合值。</p>
<ul>
<li><code>QList&lt;QHostAddress&gt; allAddresses() [static]</code>: 函数返回主机上面发现的所有<code>IP</code>地址，相当于<code>allInterfaces</code>。返回的所有对象调用<code>addressEntries</code>来获取<code>QHostAddress</code>对象列表，然后对每一个对象调用<code>QHostAddress::ip</code>方法。</li>
<li><code>QList&lt;QNetworkInterface&gt; allInterfaces() [static]</code>: 返回主机上找到的所有的网络接口的列表。在失败情况下，它会返回一个空列表。</li>
<li><code>QList&lt;QNetworkAddressEntry&gt; addressEntries() const</code>: 返回<code>IP</code>地址列表，这个列表具备与其<code>IP</code>地址相关的网络掩码和广播地址。如果不需要子网掩码或广播地址的信息，可以调用<code>allAddresses</code>函数来只获取<code>IP</code>地址。</li>
<li><code>InterfaceFlags flags() const</code>: 返回与此网络接口关联的标志。</li>
<li><code>QString hardwareAddress() const</code>: 返回此接口的底层硬件地址。在以太网接口上，这是表示<code>MAC</code>地址的字符串，用冒号分隔。</li>
<li><code>QString humanReadableName() const</code>: 如果名称可确定，在<code>Windows</code>上返回网络接口的人类可读的名称，例如<code>本地连接</code>；如果不能，这个函数返回值与<code>name</code>相同。用户可以在<code>Windows</code>控制面板中修改人类可读的名称，因此它可以在程序的执行过程中变化。在<code>Unix</code>上，此函数目前返回值总是和<code>name</code>相同，因为<code>Unix</code>系统不存储人类可读的名称的配置。</li>
<li><code>bool isValid() const</code>: 如果此<code>QNetworkInterface</code>对象包含一个的有效的网络接口，则返回<code>true</code>。</li>
<li><code>QString QNetworkInterface::name() const</code>: 返回网络接口的名称。在<code>Unix</code>系统中，这是一个包含接口的类型和任选的序列号的字符串，例如<code>eth0</code>、<code>lo</code>或者<code>pcn0</code>；在<code>Windows</code>中，这是一个内部<code>ID</code>，用户不能更改。</li>
</ul>
<h3 id="获取所有IP地址"><a href="#获取所有IP地址" class="headerlink" title="获取所有IP地址"></a>获取所有IP地址</h3><p>&emsp;&emsp;静态函数<code>allAddresses</code>可以返回一个<code>QHostAddress</code>地址列表(只能获取<code>IP</code>地址，没有子网掩码和广播地址的信息)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QHostAddress&gt; <span class="built_in">list</span> = QNetworkInterface::allAddresses();</span><br><span class="line">​</span><br><span class="line">foreach ( QHostAddress address, <span class="built_in">list</span> ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !address.isNull() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"Address: "</span> &lt;&lt; address.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Address: <span class="string">"fe80::550c:ab19:fb48:1c9%15"</span></span><br><span class="line">Address: <span class="string">"169.254.1.201"</span></span><br><span class="line">Address: <span class="string">"fe80::d086:8566:6065:8954%11"</span></span><br><span class="line">Address: <span class="string">"172.18.4.165"</span></span><br><span class="line">Address: <span class="string">"fe80::f864:a962:7219:f98e%16"</span></span><br><span class="line">Address: <span class="string">"192.168.17.1"</span></span><br><span class="line">Address: <span class="string">"fe80::8169:691f:148e:d3cb%17"</span></span><br><span class="line">Address: <span class="string">"192.168.178.1"</span></span><br><span class="line">Address: <span class="string">"fe80::5996:27a3:83b5:2ae7%18"</span></span><br><span class="line">Address: <span class="string">"192.168.56.1"</span></span><br><span class="line">Address: <span class="string">"::1"</span></span><br><span class="line">Address: <span class="string">"127.0.0.1"</span></span><br></pre></td></tr></table></figure>
<h3 id="获取网络接口列表"><a href="#获取网络接口列表" class="headerlink" title="获取网络接口列表"></a>获取网络接口列表</h3><p>&emsp;&emsp;静态函数<code>allInterfaces</code>可以返回一个<code>QNetworkInterface</code>网络接口列表(通过<code>QNetworkAddressEntry</code>，可以获取<code>IP</code>地址、子网掩码和广播地址等信息)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QNetworkInterface&gt; <span class="built_in">list</span> = QNetworkInterface::allInterfaces();</span><br><span class="line">​</span><br><span class="line">foreach ( QNetworkInterface netInterface, <span class="built_in">list</span> ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !netInterface.isValid() ) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    QNetworkInterface::InterfaceFlags flags = netInterface.flags();</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 网络接口处于活动状态 */</span></span><br><span class="line">    <span class="keyword">if</span> ( flags.testFlag ( QNetworkInterface::IsRunning ) &amp;&amp; !flags.testFlag ( QNetworkInterface::IsLoopBack ) ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"Device: "</span> &lt;&lt; netInterface.name(); <span class="comment">/* 设备名 */</span></span><br><span class="line">        <span class="comment">/* 硬件地址 */</span></span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"HardwareAddress: "</span> &lt;&lt; netInterface.hardwareAddress();</span><br><span class="line">        <span class="comment">/* 人类可读的名字 */</span></span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"Human Readable Name: "</span> &lt;&lt; netInterface.humanReadableName();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    QList&lt;QNetworkAddressEntry&gt; entryList = netInterface.addressEntries();</span><br><span class="line">​</span><br><span class="line">    foreach ( QNetworkAddressEntry entry, entryList ) &#123; <span class="comment">/* 遍历每一个IP地址 */</span></span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"IP Address: "</span> &lt;&lt; entry.ip().toString(); <span class="comment">/* IP地址 */</span></span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"Netmask: "</span> &lt;&lt; entry.netmask().toString(); <span class="comment">/* 子网掩码 */</span></span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"Broadcast: "</span> &lt;&lt; entry.broadcast().toString(); <span class="comment">/* 广播地址 */</span></span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Device: <span class="string">"&#123;BE9972CD-860E-4E15-8CE2-3F25EF0A7A24&#125;"</span></span><br><span class="line">HardwareAddress: <span class="string">"94:DE:80:21:92:17"</span></span><br><span class="line">Human Readable Name: <span class="string">"本地连接"</span></span><br><span class="line"></span><br><span class="line">Device: <span class="string">"&#123;29F85058-E757-4F60-BF7B-47F6227C8CBC&#125;"</span></span><br><span class="line">HardwareAddress: <span class="string">"00:50:56:C0:00:01"</span></span><br><span class="line">Human Readable Name: <span class="string">"VMware Network Adapter VMnet1"</span></span><br><span class="line">​</span><br><span class="line">Device: <span class="string">"&#123;A297491C-D43C-4F85-A674-88368F8D4FC1&#125;"</span></span><br><span class="line">HardwareAddress: <span class="string">"00:50:56:C0:00:08"</span></span><br><span class="line">Human Readable Name: <span class="string">"VMware Network Adapter VMnet8"</span></span><br><span class="line">​</span><br><span class="line">Device: <span class="string">"&#123;1AE5F6FC-478A-4EAB-B4D2-86201A6B2090&#125;"</span></span><br><span class="line">HardwareAddress: <span class="string">"0A:00:27:00:00:12"</span></span><br><span class="line">Human Readable Name: <span class="string">"VirtualBox Host-Only Network"</span></span><br></pre></td></tr></table></figure>
<p>通过<code>flags</code>函数，可以获取到当前网络接口的标识；利用<code>testFlag</code>进行过滤，就可以获取我们想要的内容(设备名、硬件地址、名字)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/23/Qt语法详解/Qt之QUrlInfo/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/23/Qt语法详解/Qt之QUrlInfo/" itemprop="url">Qt之QUrlInfo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-23T13:52:53+08:00">
                2019-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QUrlInfo</code> class stores information about <code>URLs</code>. The header file is <code>QUrlInfo</code>.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QUrlInfo()</code></td>
</tr>
<tr>
<td></td>
<td><code>QUrlInfo(const QUrlInfo &amp; ui)</code></td>
</tr>
<tr>
<td></td>
<td><code>QUrlInfo(const QString &amp; name, int permissions, const QString &amp; owner, const QString &amp; group, qint64 size, const QDateTime &amp; lastModified, const QDateTime &amp; lastRead, bool isDir, bool isFile, bool isSymLink, bool isWritable, bool isReadable, bool isExecutable)</code></td>
</tr>
<tr>
<td></td>
<td><code>QUrlInfo(const QUrl &amp; url, int permissions, const QString &amp; owner, const QString &amp; group, qint64 size, const QDateTime &amp; lastModified, const QDateTime &amp; lastRead, bool isDir, bool isFile, bool isSymLink, bool isWritable, bool isReadable, bool isExecutable)</code></td>
</tr>
<tr>
<td><code>virtual</code></td>
<td><code>~QUrlInfo()</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>group() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isDir() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isExecutable() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isFile() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isReadable() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isSymLink() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isValid() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isWritable() const</code></td>
</tr>
<tr>
<td><code>QDateTime</code></td>
<td><code>lastModified() const</code></td>
</tr>
<tr>
<td><code>QDateTime</code></td>
<td><code>lastRead() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>name() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>owner() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>permissions() const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>setDir(bool b)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>setFile(bool b)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>setGroup(const QString &amp; s)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>setLastModified(const QDateTime &amp; dt)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setLastRead(const QDateTime &amp; dt)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>setName(const QString &amp; name)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>setOwner(const QString &amp; s)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>setPermissions(int p)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>setReadable(bool b)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>setSize(qint64 size)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>setSymLink(bool b)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>setWritable(bool b)</code></td>
</tr>
<tr>
<td><code>qint64</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QUrlInfo &amp; other) const</code></td>
</tr>
<tr>
<td><code>QUrlInfo &amp;</code></td>
<td><code>operator=(const QUrlInfo &amp; ui)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QUrlInfo &amp; other) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Static-Public-Members"><a href="#Static-Public-Members" class="headerlink" title="Static Public Members"></a>Static Public Members</h3><ul>
<li><code>bool equal(const QUrlInfo &amp; i1, const QUrlInfo &amp; i2, int sortBy)</code></li>
<li><code>bool greaterThan(const QUrlInfo &amp; i1, const QUrlInfo &amp; i2, int sortBy)</code></li>
<li><code>bool lessThan(const QUrlInfo &amp; i1, const QUrlInfo &amp; i2, int sortBy)</code></li>
</ul>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QUrlInfo</code> class stores information about <code>URLs</code>.<br>&emsp;&emsp;The information about a URL that can be retrieved includes <code>name()</code>, <code>permissions()</code>, <code>owner()</code>, <code>group()</code>, <code>size()</code>, <code>lastModified()</code>, <code>lastRead()</code>, <code>isDir()</code>, <code>isFile()</code>, <code>isSymLink()</code>, <code>isWritable()</code>, <code>isReadable()</code> and <code>isExecutable()</code>.<br>&emsp;&emsp;You can create your own <code>QUrlInfo</code> objects passing in all the relevant information in the constructor, and you can modify a <code>QUrlInfo</code>; for each getter mentioned above there is an equivalent setter. Note that setting values does not affect the underlying resource that the <code>QUrlInfo</code> provides information about; for example if you call <code>setWritable(true)</code> on a <code>read-only</code> resource the only thing changed is the <code>QUrlInfo</code> object, not the resource.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QUrlInfo::PermissionSpec</code>: This enum is used by the <code>permissions()</code> function to report the permissions of a file.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QUrlInfo::ReadOwner</code></td>
<td><code>00400</code></td>
<td>The file is readable by the owner of the file.</td>
</tr>
<tr>
<td><code>QUrlInfo::WriteOwner</code></td>
<td><code>00200</code></td>
<td>The file is writable by the owner of the file.</td>
</tr>
<tr>
<td><code>QUrlInfo::ExeOwner</code></td>
<td><code>00100</code></td>
<td>The file is executable by the owner of the file.</td>
</tr>
<tr>
<td><code>QUrlInfo::ReadGroup</code></td>
<td><code>00040</code></td>
<td>The file is readable by the group.</td>
</tr>
<tr>
<td><code>QUrlInfo::WriteGroup</code></td>
<td><code>00020</code></td>
<td>The file is writable by the group.</td>
</tr>
<tr>
<td><code>QUrlInfo::ExeGroup</code></td>
<td><code>00010</code></td>
<td>The file is executable by the group.</td>
</tr>
<tr>
<td><code>QUrlInfo::ReadOther</code></td>
<td><code>00004</code></td>
<td>The file is readable by anyone.</td>
</tr>
<tr>
<td><code>QUrlInfo::WriteOther</code></td>
<td><code>00002</code></td>
<td>The file is writable by anyone.</td>
</tr>
<tr>
<td><code>QUrlInfo::ExeOther</code></td>
<td><code>00001</code></td>
<td>The file is executable by anyone.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QUrlInfo::QUrlInfo()</code>: Constructs an invalid <code>QUrlInfo</code> object with default values.</li>
<li><code>QUrlInfo::QUrlInfo(const QUrlInfo &amp; ui)</code>: Copy constructor, copies ui to this <code>URL</code> info object.</li>
<li><code>QUrlInfo::QUrlInfo(const QString &amp; name, int permissions, const QString &amp; owner, const QString &amp; group, qint64 size, const QDateTime &amp; lastModified, const QDateTime &amp; lastRead, bool isDir, bool isFile, bool isSymLink, bool isWritable, bool isReadable, bool isExecutable)</code>: Constructs a <code>QUrlInfo</code> object by specifying all the <code>URL&#39;s</code> information. The information that is passed is the name, file permissions, owner and group and the file’s size. Also passed is the <code>lastModified date/time</code> and the <code>lastRead date/time</code>. Flags are also passed, specifically, <code>isDir</code>, <code>isFile</code>, <code>isSymLink</code>, <code>isWritable</code>, <code>isReadable</code> and <code>isExecutable</code>.</li>
<li><code>QUrlInfo::QUrlInfo(const QUrl &amp; url, int permissions, const QString &amp; owner, const QString &amp; group, qint64 size, const QDateTime &amp; lastModified, const QDateTime &amp; lastRead, bool isDir, bool isFile, bool isSymLink, bool isWritable, bool isReadable, bool isExecutable)</code>: Constructs a <code>QUrlInfo</code> object by specifying all the <code>URL&#39;s</code> information. The information that is passed is the url, file permissions, owner and group and the file’s size. Also passed is the <code>lastModified date/time</code> and the <code>lastRead date/time</code>. Flags are also passed, specifically, <code>isDir</code>, <code>isFile</code>, <code>isSymLink</code>, <code>isWritable</code>, <code>isReadable</code> and <code>isExecutable</code>.</li>
<li><code>QUrlInfo::~QUrlInfo() [virtual]</code>: Destroys the <code>URL</code> info object.</li>
<li><code>bool QUrlInfo::equal(const QUrlInfo &amp; i1, const QUrlInfo &amp; i2, int sortBy) [static]</code>: Returns <code>true</code> if <code>i1</code> equals to <code>i2</code>; otherwise returns <code>false</code>. The objects are compared by the value, which is specified by <code>sortBy</code>. This must be one of <code>QDir::Name</code>, <code>QDir::Time</code> or <code>QDir::Size</code>.</li>
<li><code>bool QUrlInfo::greaterThan(const QUrlInfo &amp; i1, const QUrlInfo &amp; i2, int sortBy) [static]</code>: Returns <code>true</code> if <code>i1</code> is greater than <code>i2</code>; otherwise returns <code>false</code>. The objects are compared by the value, which is specified by <code>sortBy</code>. This must be one of <code>QDir::Name</code>, <code>QDir::Time</code> or <code>QDir::Size</code>.</li>
<li><code>QString QUrlInfo::group() const</code>: Returns the group of the <code>URL</code>.</li>
<li><code>bool QUrlInfo::isDir() const</code>: Returns <code>true</code> if the <code>URL</code> is a directory; otherwise returns <code>false</code>.</li>
<li><code>bool QUrlInfo::isExecutable() const</code>: Returns <code>true</code> if the <code>URL</code> is executable; otherwise returns false.</li>
<li><code>bool QUrlInfo::isFile() const</code>: Returns <code>true</code> if the <code>URL</code> is a file; otherwise returns <code>false</code>.</li>
<li><code>bool QUrlInfo::isReadable() const</code>: Returns <code>true</code> if the <code>URL</code> is readable; otherwise returns <code>false</code>.</li>
<li><code>bool QUrlInfo::isSymLink() const</code>: Returns <code>true</code> if the <code>URL</code> is a symbolic link; otherwise returns <code>false</code>.</li>
<li><code>bool QUrlInfo::isValid() const</code>: Returns <code>true</code> if the <code>URL</code> info is valid; otherwise returns <code>false</code>. Valid means that the <code>QUrlInfo</code> contains real information. You should always check if the <code>URL</code> info is valid before relying on the values.</li>
<li><code>bool QUrlInfo::isWritable() const</code>: Returns <code>true</code> if the <code>URL</code> is writable; otherwise returns <code>false</code>.</li>
<li><code>QDateTime QUrlInfo::lastModified() const</code>: Returns the last modification date of the <code>URL</code>.</li>
<li><code>QDateTime QUrlInfo::lastRead() const</code>: Returns the date when the URL was last read.</li>
<li><code>bool QUrlInfo::lessThan(const QUrlInfo &amp; i1, const QUrlInfo &amp; i2, int sortBy) [static]</code>: Returns <code>true</code> if <code>i1</code> is less than <code>i2</code>; otherwise returns <code>false</code>. The objects are compared by the value, which is specified by <code>sortBy</code>. This must be one of <code>QDir::Name</code>, <code>QDir::Time</code> or <code>QDir::Size</code>.</li>
<li><code>QString QUrlInfo::name() const</code>: Returns the file name of the <code>URL</code>.</li>
<li><code>QString QUrlInfo::owner() const</code>: Returns the owner of the <code>URL</code>.</li>
<li><code>int QUrlInfo::permissions() const</code>: Returns the permissions of the <code>URL</code>. You can use the <code>PermissionSpec</code> flags to test for certain permissions.</li>
<li><code>void QUrlInfo::setDir(bool b) [virtual]</code>: If <code>b</code> is <code>true</code> then the <code>URL</code> is set to be a directory; if <code>b</code> is <code>false</code> then the <code>URL</code> is set not to be a directory (which normally means it is a file). (Note that a <code>URL</code> can refer to both a file and a directory even though most file systems do not support this.) If you call this function for an invalid <code>URL</code> info, this function turns it into a valid one.</li>
<li><code>void QUrlInfo::setFile(bool b) [virtual]</code>: If <code>b</code> is <code>true</code> then the <code>URL</code> is set to be a file; if is false then the <code>URL</code> is set not to be a file (which normally means it is a directory). (Note that a <code>URL</code> can refer to both a file and a directory even though most file systems do not support this.) If you call this function for an invalid <code>URL</code> info, this function turns it into a valid one.</li>
<li><code>void QUrlInfo::setGroup(const QString &amp; s) [virtual]</code>: Specifies that the owning group of the <code>URL</code> is called <code>s</code>. If you call this function for an invalid <code>URL</code> info, this function turns it into a valid one.</li>
<li><code>void QUrlInfo::setLastModified(const QDateTime &amp; dt) [virtual]</code>: Specifies that the object the <code>URL</code> refers to was last modified at <code>dt</code>. If you call this function for an invalid <code>URL</code> info, this function turns it into a valid one.</li>
<li><code>void QUrlInfo::setLastRead(const QDateTime &amp; dt)</code>: Specifies that the object the <code>URL</code> refers to was last read at <code>dt</code>. If you call this function for an invalid <code>URL</code> info, this function turns it into a valid one.</li>
<li><code>void QUrlInfo::setName(const QString &amp; name) [virtual]</code>: Sets the name of the <code>URL</code> to name. The name is the full text, for example, <code>http://qt.nokia.com/doc/qurlinfo.html</code>. If you call this function for an invalid <code>URL</code> info, this function turns it into a valid one.</li>
<li><code>void QUrlInfo::setOwner(const QString &amp; s) [virtual]</code>: Specifies that the owner of the <code>URL</code> is called <code>s</code>. If you call this function for an invalid <code>URL</code> info, this function turns it into a valid one.</li>
<li><code>void QUrlInfo::setPermissions(int p) [virtual]</code>: Specifies that the <code>URL</code> has access permissions <code>p</code>. If you call this function for an invalid <code>URL</code> info, this function turns it into a valid one.</li>
<li><code>void QUrlInfo::setReadable(bool b) [virtual]</code>: Specifies that the <code>URL</code> is readable if <code>b</code> is <code>true</code> and not readable if <code>b</code> is <code>false</code>. If you call this function for an invalid <code>URL</code> info, this function turns it into a valid one.</li>
<li><code>void QUrlInfo::setSize(qint64 size) [virtual]</code>: Specifies the <code>size</code> of the <code>URL</code>. If you call this function for an invalid <code>URL</code> info, this function turns it into a valid one.</li>
<li><code>void QUrlInfo::setSymLink(bool b) [virtual]</code>: Specifies that the <code>URL</code> refers to a symbolic link if <code>b</code> is <code>true</code> and that it does not if <code>b</code> is <code>false</code>. If you call this function for an invalid <code>URL</code> info, this function turns it into a valid one.</li>
<li><code>void QUrlInfo::setWritable(bool b) [virtual]</code>: Specifies that the <code>URL</code> is writable if <code>b</code> is <code>true</code> and not writable if <code>b</code> is <code>false</code>. If you call this function for an invalid <code>URL</code> info, this function turns it into a valid one.</li>
<li><code>qint64 QUrlInfo::size() const</code>: Returns the <code>size</code> of the <code>URL</code>.</li>
<li><code>bool QUrlInfo::operator!=(const QUrlInfo &amp; other) const</code>: Returns <code>true</code> if this <code>QUrlInfo</code> is not equal to other; otherwise returns <code>false</code>.</li>
<li><code>QUrlInfo &amp; QUrlInfo::operator=(const QUrlInfo &amp; ui)</code>: Assigns the values of <code>ui</code> to this <code>QUrlInfo</code> object.</li>
<li><code>bool QUrlInfo::operator==(const QUrlInfo &amp; other) const</code>: Returns <code>true</code> if this <code>QUrlInfo</code> is equal to other; otherwise returns <code>false</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/23/Qt语法详解/Qt之QTcpServer/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/23/Qt语法详解/Qt之QTcpServer/" itemprop="url">Qt之QTcpServer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-23T13:09:25+08:00">
                2019-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTcpServer</code> class provides a <code>TCP-based</code> server.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTcpServer</code></td>
<td><code>QObject</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<p>Public Functions</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTcpServer(QObject * parent = 0)</code></td>
</tr>
<tr>
<td><code>virtual</code></td>
<td><code>~QTcpServer()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>close()</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>errorString() const</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>hasPendingConnections() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isListening() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>listen(const QHostAddress &amp; address = QHostAddress::Any, quint16 port = 0)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>maxPendingConnections() const</code></td>
</tr>
<tr>
<td><code>virtual QTcpSocket *</code></td>
<td><code>nextPendingConnection()</code></td>
</tr>
<tr>
<td><code>QNetworkProxy</code></td>
<td><code>proxy() const</code></td>
</tr>
<tr>
<td><code>QHostAddress</code></td>
<td><code>serverAddress() const</code></td>
</tr>
<tr>
<td><code>QAbstractSocket::SocketError</code></td>
<td><code>serverError() const</code></td>
</tr>
<tr>
<td><code>quint16</code></td>
<td><code>serverPort() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMaxPendingConnections(int numConnections)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setProxy(const QNetworkProxy &amp; networkProxy)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>setSocketDescriptor(int socketDescriptor)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>socketDescriptor() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>waitForNewConnection(int msec = 0, bool * timedOut = 0)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><ul>
<li><code>void newConnection()</code></li>
</ul>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><ul>
<li><code>void addPendingConnection(QTcpSocket * socket)</code></li>
<li><code>virtual void incomingConnection(int socketDescriptor)</code></li>
</ul>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTcpServer</code> class provides a <code>TCP-based</code> server.<br>&emsp;&emsp;This class makes it possible to accept incoming <code>TCP</code> connections. You can specify the port or have <code>QTcpServer</code> pick one automatically. You can listen on a specific address or on all the machine’s addresses.<br>&emsp;&emsp;Call <code>listen()</code> to have the server listen for incoming connections. The <code>newConnection()</code> signal is then emitted each time a client connects to the server.<br>&emsp;&emsp;Call <code>nextPendingConnection()</code> to accept the pending connection as a connected <code>QTcpSocket</code>. The function returns a pointer to a <code>QTcpSocket</code> in <code>QAbstractSocket::ConnectedState</code> that you can use for communicating with the client.<br>&emsp;&emsp;If an error occurs, <code>serverError()</code> returns the type of error, and <code>errorString()</code> can be called to get a human readable description of what happened.<br>&emsp;&emsp;When listening for connections, the address and port on which the server is listening are available as <code>serverAddress()</code> and <code>serverPort()</code>.<br>&emsp;&emsp;Calling <code>close()</code> makes <code>QTcpServer</code> stop listening for incoming connections.<br>&emsp;&emsp;Although <code>QTcpServer</code> is mostly designed for use with an event loop, it’s possible to use it without one. In that case, you must use <code>waitForNewConnection()</code>, which blocks until either a connection is available or a timeout expires.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTcpServer::QTcpServer(QObject * parent = 0)</code>: Constructs a <code>QTcpServer</code> object. parent is passed to the <code>QObject</code> constructor.</li>
<li><code>QTcpServer::~QTcpServer() [virtual]</code>: Destroys the <code>QTcpServer</code> object. If the server is listening for connections, the socket is automatically closed. Any client <code>QTcpSockets</code> that are still connected must either disconnect or be reparented before the server is deleted.</li>
<li><code>void QTcpServer::addPendingConnection(QTcpSocket * socket) [protected]</code>: This function is called by <code>QTcpServer::incomingConnection()</code> to add the <code>socket</code> to the list of pending incoming connections. <strong>Note</strong>: Don’t forget to call this member from reimplemented <code>incomingConnection()</code> if you do not want to break the Pending Connections mechanism.</li>
<li><code>void QTcpServer::close()</code>: Closes the server. The server will no longer listen for incoming connections.</li>
<li><code>QString QTcpServer::errorString() const</code>: Returns a human readable description of the last error that occurred.</li>
<li><code>bool QTcpServer::hasPendingConnections() const [virtual]</code>: Returns <code>true</code> if the server has a pending connection; otherwise returns <code>false</code>.</li>
<li><code>void QTcpServer::incomingConnection(int socketDescriptor) [virtual protected]</code>: This virtual function is called by <code>QTcpServer</code> when a new connection is available. The <code>socketDescriptor</code> argument is the native socket descriptor for the accepted connection. The base implementation creates a <code>QTcpSocket</code>, sets the socket descriptor and then stores the <code>QTcpSocket</code> in an internal list of pending connections. Finally <code>newConnection()</code> is emitted. Reimplement this function to alter the server’s behavior when a connection is available. If this server is using <code>QNetworkProxy</code> then the <code>socketDescriptor</code> may not be usable with native socket functions, and should only be used with <code>QTcpSocket::setSocketDescriptor()</code>. <strong>Note</strong>: If you want to handle an incoming connection as a new <code>QTcpSocket</code> object in another thread you have to pass the <code>socketDescriptor</code> to the other thread and create the <code>QTcpSocket</code> object there and use its <code>setSocketDescriptor()</code> method.</li>
<li><code>bool QTcpServer::isListening() const</code>: Returns <code>true</code> if the server is currently listening for incoming connections; otherwise returns <code>false</code>.</li>
<li><code>bool QTcpServer::listen(const QHostAddress &amp; address = QHostAddress::Any, quint16 port = 0)</code>: Tells the server to listen for incoming connections on <code>address</code> and <code>port</code>. If <code>port</code> is <code>0</code>, a <code>port</code> is chosen automatically. If <code>address</code> is <code>QHostAddress::Any</code>, the server will listen on all network interfaces. Returns <code>true</code> on success; otherwise returns <code>false</code>.</li>
<li><code>int QTcpServer::maxPendingConnections() const</code>: Returns the maximum number of pending accepted connections. The default is <code>30</code>.</li>
<li><code>void QTcpServer::newConnection() [signal]</code>: This <code>signal</code> is emitted every time a new connection is available.</li>
<li><code>QTcpSocket * QTcpServer::nextPendingConnection() [virtual]</code>: Returns the next pending connection as a connected <code>QTcpSocket</code> object. The socket is created as a child of the server, which means that it is automatically deleted when the <code>QTcpServer</code> object is destroyed. It is still a good idea to delete the object explicitly when you are done with it, to avoid wasting memory. <code>0</code> is returned if this function is called when there are no pending connections. <strong>Note</strong>: The returned <code>QTcpSocket</code> object cannot be used from another thread. If you want to use an incoming connection from another thread, you need to override <code>incomingConnection()</code>.</li>
<li><code>QNetworkProxy QTcpServer::proxy() const</code>: Returns the network proxy for this socket. By default <code>QNetworkProxy::DefaultProxy</code> is used.</li>
<li><code>QHostAddress QTcpServer::serverAddress() const</code>: Returns the server’s address if the server is listening for connections; otherwise returns <code>QHostAddress::Null</code>.</li>
<li><code>QAbstractSocket::SocketError QTcpServer::serverError() const</code>: Returns an error code for the last error that occurred.</li>
<li><code>quint16 QTcpServer::serverPort() const</code>: Returns the server’s port if the server is listening for connections; otherwise returns <code>0</code>.</li>
<li><code>void QTcpServer::setMaxPendingConnections(int numConnections)</code>: Sets the maximum number of pending accepted connections to <code>numConnections</code>. <code>QTcpServer</code> will accept no more than <code>numConnections</code> incoming connections before <code>nextPendingConnection()</code> is called. By default, the limit is <code>30</code> pending connections. Clients may still able to connect after the server has reached its maximum number of pending connections (i.e., <code>QTcpSocket</code> can still emit the <code>connected()</code> signal). <code>QTcpServer</code> will stop accepting the new connections, but the operating system may still keep them in queue.</li>
<li><code>void QTcpServer::setProxy(const QNetworkProxy &amp; networkProxy)</code>: Sets the explicit network proxy for this socket to <code>networkProxy</code>. To disable the use of a proxy for this socket, use the <code>QNetworkProxy::NoProxy</code> proxy type:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server-&gt;setProxy ( QNetworkProxy::NoProxy );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>bool QTcpServer::setSocketDescriptor(int socketDescriptor)</code>: Sets the socket descriptor this server should use when listening for incoming connections to <code>socketDescriptor</code>. Returns <code>true</code> if the socket is set successfully; otherwise returns <code>false</code>. The socket is assumed to be in listening state.</li>
<li><code>int QTcpServer::socketDescriptor() const</code>: Returns the native socket descriptor the server uses to listen for incoming instructions, or <code>-1</code> if the server is not listening. If the server is using <code>QNetworkProxy</code>, the returned descriptor may not be usable with native socket functions.</li>
<li><code>bool QTcpServer::waitForNewConnection(int msec = 0, bool * timedOut = 0)</code>: Waits for at most <code>msec</code> milliseconds or until an incoming connection is available. Returns <code>true</code> if a connection is available; otherwise returns <code>false</code>. If the operation timed out and <code>timedOut</code> is not <code>0</code>, <code>*timedOut</code> will be set to <code>true</code>. This is a blocking function call. Its use is disadvised in a <code>single-threaded</code> <code>GUI</code> application, since the whole application will stop responding until the function returns. <code>waitForNewConnection()</code> is mostly useful when there is no event loop available. The <code>non-blocking</code> alternative is to connect to the <code>newConnection()</code> signal. If <code>msec</code> is <code>-1</code>, this function will not time out.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/23/Qt语法详解/Qt之QTextBlockFormat/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/23/Qt语法详解/Qt之QTextBlockFormat/" itemprop="url">Qt之QTextBlockFormat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-23T10:19:56+08:00">
                2019-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTextBlockFormat</code> class provides formatting information for blocks of text in a <code>QTextDocument</code>.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextBlockFormat</code></td>
<td><code>QTextFormat</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextBlockFormat()</code></td>
</tr>
<tr>
<td><code>Qt::Alignment</code></td>
<td><code>alignment() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>bottomMargin() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>indent() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isValid() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>leftMargin() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>lineHeight(qreal scriptLineHeight, qreal scaling) const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>lineHeight() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lineHeightType() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>nonBreakableLines() const</code></td>
</tr>
<tr>
<td><code>PageBreakFlags</code></td>
<td><code>pageBreakPolicy() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>rightMargin() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setAlignment(Qt::Alignment alignment)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBottomMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setIndent(int indentation)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setLeftMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setLineHeight(qreal height, int heightType)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setNonBreakableLines(bool b)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPageBreakPolicy(PageBreakFlags policy)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setRightMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTabPositions(const QList&lt;QTextOption::Tab&gt; &amp; tabs)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTextIndent(qreal indent)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTopMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>QList&lt;QTextOption::Tab&gt;</code></td>
<td><code>tabPositions() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>textIndent() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>topMargin() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextBlockFormat</code> class provides formatting information for blocks of text in a <code>QTextDocument</code>.<br>&emsp;&emsp;A document is composed of a list of blocks, represented by <code>QTextBlock</code> objects. Each block can contain an item of some kind, such as a paragraph of text, a table, a list, or an image. Every block has an associated <code>QTextBlockFormat</code> that specifies its characteristics.<br>&emsp;&emsp;To cater for <code>left-to-right</code> and <code>right-to-left</code> languages you can set a block’s direction with <code>setDirection()</code>. Paragraph alignment is set with <code>setAlignment()</code>. Margins are controlled by <code>setTopMargin()</code>, <code>setBottomMargin()</code>, <code>setLeftMargin()</code>, <code>setRightMargin()</code>. Overall indentation is set with <code>setIndent()</code>, the indentation of the first line with <code>setTextIndent()</code>.<br>&emsp;&emsp;Line spacing is set with <code>setLineHeight()</code> and retrieved via <code>lineHeight()</code> and <code>lineHeightType()</code>. The types of line spacing available are in the <code>LineHeightTypes</code> enum.<br>&emsp;&emsp;Line breaking can be enabled and disabled with <code>setNonBreakableLines()</code>.<br>&emsp;&emsp;The brush used to paint the paragraph’s background is set with <code>setBackground()</code>, and other aspects of the text’s appearance can be customized by using the <code>setProperty()</code> function with the <code>OutlinePen</code>, <code>ForegroundBrush</code>, and <code>BackgroundBrush</code> <code>QTextFormat::Property</code> values.<br>&emsp;&emsp;If a text block is part of a list, it can also have a list format that is accessible with the <code>listFormat()</code> function.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><p>&emsp;&emsp;enum <code>QTextBlockFormat::LineHeightTypes</code>: This enum describes the various types of line spacing support paragraphs can have.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextBlockFormat::SingleHeight</code></td>
<td><code>0</code></td>
<td>This is the default line height: single spacing.</td>
</tr>
<tr>
<td><code>QTextBlockFormat::ProportionalHeight</code></td>
<td><code>1</code></td>
<td>This sets the spacing proportional to the line (in percentage). For example, set to <code>200</code> for double spacing.</td>
</tr>
<tr>
<td><code>QTextBlockFormat::FixedHeight</code></td>
<td><code>2</code></td>
<td>This sets the line height to a fixed line height (in pixels).</td>
</tr>
<tr>
<td><code>QTextBlockFormat::MinimumHeight</code></td>
<td><code>3</code></td>
<td>This sets the minimum line height (in pixels).</td>
</tr>
<tr>
<td><code>QTextBlockFormat::LineDistanceHeight</code></td>
<td><code>4</code></td>
<td>This adds the specified height between lines (in pixels).</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextBlockFormat::QTextBlockFormat()</code>: Constructs a new <code>QTextBlockFormat</code>.</li>
<li><code>Qt::Alignment QTextBlockFormat::alignment() const</code>: Returns the paragraph’s alignment.</li>
<li><code>qreal QTextBlockFormat::bottomMargin() const</code>: Returns the paragraph’s bottom margin.</li>
<li><code>int QTextBlockFormat::indent() const</code>: Returns the paragraph’s indent.</li>
<li><code>bool QTextBlockFormat::isValid() const</code>: Returns <code>true</code> if this block format is valid; otherwise returns <code>false</code>.</li>
<li><code>qreal QTextBlockFormat::leftMargin() const</code>: Returns the paragraph’s left margin.</li>
<li><code>qreal QTextBlockFormat::lineHeight(qreal scriptLineHeight, qreal scaling) const</code>: Returns the height of the lines in the paragraph based on the height of the script line given by <code>scriptLineHeight</code> and the specified <code>scaling</code> factor. The value that is returned is also dependent on the given <code>LineHeightType</code> of the paragraph as well as the <code>LineHeight</code> setting that has been set for the paragraph. The scaling is needed for heights that include a fixed number of pixels, to scale them appropriately for printing.</li>
<li><code>qreal QTextBlockFormat::lineHeight() const</code>: This returns the <code>LineHeight</code> property for the paragraph.</li>
<li><code>int QTextBlockFormat::lineHeightType() const</code>: This returns the <code>LineHeightType</code> property of the paragraph.</li>
<li><code>bool QTextBlockFormat::nonBreakableLines() const</code>: Returns <code>true</code> if the lines in the paragraph are <code>non-breakable</code>; otherwise returns <code>false</code>.</li>
<li><code>PageBreakFlags QTextBlockFormat::pageBreakPolicy() const</code>: Returns the currently set page break policy for the paragraph. The default is <code>QTextFormat::PageBreak_Auto</code>.</li>
<li><code>qreal QTextBlockFormat::rightMargin() const</code>: Returns the paragraph’s right margin.</li>
<li><code>void QTextBlockFormat::setAlignment(Qt::Alignment alignment)</code>: Sets the paragraph’s <code>alignment</code>.</li>
<li><code>void QTextBlockFormat::setBottomMargin(qreal margin)</code>: Sets the paragraph’s bottom <code>margin</code>.</li>
<li><code>void QTextBlockFormat::setIndent(int indentation)</code>: Sets the paragraph’s <code>indentation</code>. Margins are set independently of <code>indentation</code> with <code>setLeftMargin()</code> and <code>setTextIndent()</code>. The <code>indentation</code> is an integer that is multiplied with the <code>document-wide</code> standard indent, resulting in the actual indent of the paragraph.</li>
<li><code>void QTextBlockFormat::setLeftMargin(qreal margin)</code>: Sets the paragraph’s left <code>margin</code>. Indentation can be applied separately with <code>setIndent()</code>.</li>
<li><code>void QTextBlockFormat::setLineHeight(qreal height, int heightType)</code>: Sets the line <code>height</code> for the paragraph to the value given by <code>height</code> which is dependent on <code>heightType</code> in the way described by the <code>LineHeightTypes</code> enum.</li>
<li><code>void QTextBlockFormat::setNonBreakableLines(bool b)</code>: If <code>b</code> is <code>true</code>, the lines in the paragraph are treated as <code>non-breakable</code>; otherwise they are breakable.</li>
<li><code>void QTextBlockFormat::setPageBreakPolicy(PageBreakFlags policy)</code> — Sets the page break <code>policy</code> for the paragraph to <code>policy</code>.</li>
<li><code>void QTextBlockFormat::setRightMargin(qreal margin)</code>: Sets the paragraph’s right <code>margin</code>.</li>
<li><code>void QTextBlockFormat::setTabPositions(const QList&lt;QTextOption::Tab&gt; &amp; tabs)</code>: Sets the tab positions for the text block to those specified by <code>tabs</code>.</li>
<li><code>void QTextBlockFormat::setTextIndent(qreal indent)</code>: Sets the <code>indent</code> for the first line in the block. This allows the first line of a paragraph to be indented differently to the other lines, enhancing the readability of the text.</li>
<li><code>void QTextBlockFormat::setTopMargin(qreal margin)</code>: Sets the paragraph’s top <code>margin</code>.</li>
<li><code>QList&lt;QTextOption::Tab&gt; QTextBlockFormat::tabPositions() const</code>: Returns a list of tab positions defined for the text block.</li>
<li><code>qreal QTextBlockFormat::textIndent() const</code>: Returns the paragraph’s text indent.</li>
<li><code>qreal QTextBlockFormat::topMargin() const</code>: Returns the paragraph’s top margin.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/22/Qt语法详解/Qt之QDrag/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/22/Qt语法详解/Qt之QDrag/" itemprop="url">Qt之QDrag</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-22T18:17:51+08:00">
                2019-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QDrag</code> class provides support for <code>MIME-based</code> drag and drop data transfer.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QDrag</code></td>
<td><code>QObject</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QDrag(QWidget * dragSource)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QDrag()</code></td>
</tr>
<tr>
<td><code>Qt::DropAction</code></td>
<td><code>exec(Qt::DropActions supportedActions = Qt::MoveAction)</code></td>
</tr>
<tr>
<td><code>Qt::DropAction</code></td>
<td><code>exec(Qt::DropActions supportedActions, Qt::DropAction defaultDropAction)</code></td>
</tr>
<tr>
<td><code>QPoint</code></td>
<td><code>hotSpot() const</code></td>
</tr>
<tr>
<td><code>QMimeData *</code></td>
<td><code>mimeData() const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>pixmap() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDragCursor(const QPixmap &amp; cursor, Qt::DropAction action)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHotSpot(const QPoint &amp; hotspot)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMimeData(QMimeData * data)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPixmap(const QPixmap &amp; pixmap)</code></td>
</tr>
<tr>
<td><code>QWidget *</code></td>
<td><code>source() const</code></td>
</tr>
<tr>
<td><code>QWidget *</code></td>
<td><code>target() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><ul>
<li><code>void actionChanged(Qt::DropAction action)</code></li>
<li><code>void targetChanged(QWidget * newTarget)</code></li>
</ul>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QDrag</code> class provides support for <code>MIME-based</code> drag and drop data transfer.<br>&emsp;&emsp;<code>Drag</code> and drop is an intuitive way for users to copy or move data around in an application, and is used in many desktop environments as a mechanism for copying data between applications. <code>Drag</code> and drop support in <code>Qt</code> is centered around the <code>QDrag</code> class that handles most of the details of a drag and drop operation.<br>&emsp;&emsp;The data to be transferred by the drag and drop operation is contained in a <code>QMimeData</code> object. This is specified with the <code>setMimeData()</code> function in the following way:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QDrag *drag = <span class="keyword">new</span> QDrag ( <span class="keyword">this</span> );</span><br><span class="line">QMimeData *mimeData = <span class="keyword">new</span> QMimeData;</span><br><span class="line">​</span><br><span class="line">mimeData-&gt;setText ( commentEdit-&gt;toPlainText() );</span><br><span class="line">drag-&gt;setMimeData ( mimeData );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Note that <code>setMimeData()</code> assigns ownership of the <code>QMimeData</code> object to the <code>QDrag</code> object. The <code>QDrag</code> must be constructed on the heap with a parent <code>QWidget</code> to ensure that <code>Qt</code> can clean up after the drag and drop operation has been completed.<br>&emsp;&emsp;A pixmap can be used to represent the data while the drag is in progress, and will move with the cursor to the drop target. This pixmap typically shows an icon that represents the <code>MIME</code> type of the data being transferred, but any pixmap can be set with <code>setPixmap()</code>. The cursor’s hot spot can be given a position relative to the <code>top-left</code> corner of the pixmap with the <code>setHotSpot()</code> function. The following code positions the pixmap so that the cursor’s hot spot points to the center of its bottom edge:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drag-&gt;setHotSpot ( QPoint ( drag-&gt;pixmap().width() / <span class="number">2</span>, drag-&gt;pixmap().height() ) );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>Note</strong>: On <code>X11</code>, the pixmap may not be able to keep up with the mouse movements if the hot spot causes the pixmap to be displayed directly under the cursor.<br>&emsp;&emsp;The source and target widgets can be found with <code>source()</code> and <code>target()</code>. These functions are often used to determine whether drag and drop operations started and finished at the same widget, so that special behavior can be implemented.<br>&emsp;&emsp;<code>QDrag</code> only deals with the drag and drop operation itself. It is up to the developer to decide when a drag operation begins, and how a <code>QDrag</code> object should be constructed and used. For a given widget, it is often necessary to reimplement <code>mousePressEvent()</code> to determine whether the user has pressed a mouse button, and reimplement <code>mouseMoveEvent()</code> to check whether a <code>QDrag</code> is required.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QDrag::QDrag(QWidget * dragSource)</code>: Constructs a new drag object for the widget specified by <code>dragSource</code>.</li>
<li><code>QDrag::~QDrag()</code>: Destroys the drag object.</li>
<li><code>void QDrag::actionChanged(Qt::DropAction action) [signal]</code>: This <code>signal</code> is emitted when the <code>action</code> associated with the drag changes.</li>
<li><code>Qt::DropAction QDrag::exec(Qt::DropActions supportedActions = Qt::MoveAction)</code>: Starts the drag and drop operation and returns a value indicating the requested drop action when it is completed. The drop actions that the user can choose from are specified in <code>supportedActions</code>. The default proposed action will be selected among the allowed actions in the following order: <code>Move</code>, <code>Copy</code> and <code>Link</code>. <strong>Note</strong>: On <code>Linux</code> and <code>Mac OS X</code>, the drag and drop operation can take some time, but this function does not block the event loop. Other events are still delivered to the application while the operation is performed. On <code>Windows</code>, the <code>Qt</code> event loop is blocked while during the operation.</li>
<li><code>Qt::DropAction QDrag::exec(Qt::DropActions supportedActions, Qt::DropAction defaultDropAction)</code>: Starts the drag and drop operation and returns a value indicating the requested drop action when it is completed. The drop actions that the user can choose from are specified in <code>supportedActions</code>. The <code>defaultDropAction</code> determines which action will be proposed when the user performs a drag without using modifier keys. <strong>Note</strong>: On <code>Linux</code> and <code>Mac OS X</code>, the drag and drop operation can take some time, but this function does not block the event loop. Other events are still delivered to the application while the operation is performed. On <code>Windows</code>, the <code>Qt</code> event loop is blocked during the operation. However, <code>QDrag::exec()</code> on <code>Windows</code> causes <code>processEvents()</code> to be called frequently to keep the <code>GUI</code> responsive. If any loops or operations are called while a drag operation is active, it will block the drag operation.</li>
<li><code>QPoint QDrag::hotSpot() const</code>: Returns the position of the hot spot relative to the <code>top-left</code> corner of the cursor.</li>
<li><code>QMimeData * QDrag::mimeData() const</code>: Returns the <code>MIME</code> data that is encapsulated by the drag object.</li>
<li><code>QPixmap QDrag::pixmap() const</code>: Returns the pixmap used to represent the data in a drag and drop operation.</li>
<li><code>void QDrag::setDragCursor(const QPixmap &amp; cursor, Qt::DropAction action)</code>: Sets the drag <code>cursor</code> for the <code>action</code>. This allows you to override the default native cursors. To revert to using the native <code>cursor</code> for <code>action</code> pass in a null <code>QPixmap</code> as <code>cursor</code>. The <code>action</code> can only be <code>CopyAction</code>, <code>MoveAction</code> or <code>LinkAction</code>. All other values of <code>DropAction</code> are ignored.</li>
<li><code>void QDrag::setHotSpot(const QPoint &amp; hotspot)</code>: Sets the position of the hot spot relative to the <code>top-left</code> corner of the pixmap used to the point specified by <code>hotspot</code>. <strong>Note</strong>: on <code>X11</code>, the pixmap may not be able to keep up with the mouse movements if the hot spot causes the pixmap to be displayed directly under the cursor.</li>
<li><code>void QDrag::setMimeData(QMimeData * data)</code>: Sets the <code>data</code> to be sent to the given <code>MIME</code> data. Ownership of the data is transferred to the <code>QDrag</code> object.</li>
<li><code>void QDrag::setPixmap(const QPixmap &amp; pixmap)</code>: Sets <code>pixmap</code> as the <code>pixmap</code> used to represent the data in a drag and drop operation. You can only set a <code>pixmap</code> before the drag is started.</li>
<li><code>QWidget * QDrag::source() const</code>: Returns the source of the drag object. This is the widget where the drag and drop operation originated.</li>
<li><code>QWidget * QDrag::target() const</code>: Returns the target of the drag and drop operation. This is the widget where the drag object was dropped.</li>
<li><code>void QDrag::targetChanged(QWidget * newTarget) [signal]</code>: This <code>signal</code> is emitted when the target of the drag and drop operation changes, with <code>newTarget</code> the new target.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/22/Qt语法详解/Qt之QButtonGroup/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/22/Qt语法详解/Qt之QButtonGroup/" itemprop="url">Qt之QButtonGroup</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-22T17:30:34+08:00">
                2019-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QButtonGroup</code> class provides a container to organize groups of button widgets.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QButtonGroup</code></td>
<td><code>QObject</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QButtonGroup(QObject * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QButtonGroup()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addButton(QAbstractButton * button)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addButton(QAbstractButton * button, int id)</code></td>
</tr>
<tr>
<td><code>QAbstractButton *</code></td>
<td><code>button(int id) const</code></td>
</tr>
<tr>
<td><code>QList&lt;QAbstractButton *&gt;</code></td>
<td><code>buttons() const</code></td>
</tr>
<tr>
<td><code>QAbstractButton *</code></td>
<td><code>checkedButton() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>checkedId() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>exclusive() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>id(QAbstractButton * button) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeButton(QAbstractButton * button)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setExclusive(bool)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setId(QAbstractButton * button, int id)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><ul>
<li><code>void buttonClicked ( QAbstractButton *button );</code></li>
<li><code>void buttonClicked ( int id );</code></li>
<li><code>void buttonPressed ( QAbstractButton *button );</code></li>
<li><code>void buttonPressed ( int id );</code></li>
<li><code>void buttonReleased ( QAbstractButton *button );</code></li>
<li><code>void buttonReleased ( int id );</code></li>
</ul>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QButtonGroup</code> class provides a container to organize groups of button widgets.<br>&emsp;&emsp;<code>QButtonGroup</code> provides an abstract container into which button widgets can be placed. It does not provide a visual representation of this container (see <code>QGroupBox</code> for a container widget), but instead manages the states of each of the buttons in the group.<br>&emsp;&emsp;An exclusive button group switches off all checkable (toggle) buttons except the one that was clicked. By default, a button group is exclusive. The buttons in a button group are usually checkable <code>QPushButton&#39;s</code>, <code>QCheckBoxes</code> (normally for <code>non-exclusive</code> button groups), or <code>QRadioButtons</code>. If you create an exclusive button group, you should ensure that one of the buttons in the group is initially checked; otherwise, the group will initially be in a state where no buttons are checked.<br>&emsp;&emsp;A button is added to the group with <code>addButton()</code>. It can be removed from the group with <code>removeButton()</code>. If the group is exclusive, the currently checked button is available as <code>checkedButton()</code>. If a button is clicked the <code>buttonClicked()</code> signal is emitted. For a checkable button in an exclusive group this means that the button was checked. The list of buttons in the group is returned by <code>buttons()</code>.<br>&emsp;&emsp;In addition, <code>QButtonGroup</code> can map between integers and buttons. You can assign an integer id to a button with <code>setId()</code>, and retrieve it with <code>id()</code>. The id of the currently checked button is available with <code>checkedId()</code>, and there is an overloaded signal <code>buttonClicked()</code> which emits the id of the button. The id <code>-1</code> is reserved by <code>QButtonGroup</code> to mean <code>no such button</code>. The purpose of the mapping mechanism is to simplify the representation of enum values in a user interface.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QButtonGroup::QButtonGroup(QObject * parent = 0)</code>: Constructs a new, empty button group with the given <code>parent</code>.</li>
<li><code>QButtonGroup::~QButtonGroup()</code>: Destroys the button group.</li>
<li><code>void QButtonGroup::addButton(QAbstractButton * button)</code>: Adds the given <code>button</code> to the end of the group’s internal list of buttons. An id will be assigned to the <code>button</code> by this QButtonGroup. Automatically assigned ids are guaranteed to be negative, starting with <code>-2</code>. If you are also assigning your own ids, use positive values to avoid conflicts.</li>
<li><code>void QButtonGroup::addButton(QAbstractButton * button, int id)</code>: Adds the given <code>button</code> to the <code>button</code> group, with the given <code>id</code>. It is recommended to assign only positive ids.</li>
<li><code>QAbstractButton * QButtonGroup::button(int id) const</code>: Returns the button with the specified <code>id</code>, or <code>0</code> if no such button exists.</li>
<li><code>void QButtonGroup::buttonClicked(QAbstractButton * button) [signal]</code>: This <code>signal</code> is emitted when the given <code>button</code> is clicked. A <code>button</code> is clicked when it is first pressed and then released, when its shortcut key is typed, or programmatically when <code>QAbstractButton::click()</code> or <code>QAbstractButton::animateClick()</code> is called. <strong>Note</strong>: <code>Signal</code> buttonClicked is overloaded in this class. To connect to this one using the function pointer syntax, you must specify the <code>signal</code> type in a static cast, as shown in this example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect ( buttonGroup, <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> ( QButtonGroup::* ) ( QAbstractButton * ) &gt; \</span><br><span class="line">        ( &amp;QButtonGroup::buttonClicked ), [ = ] ( QAbstractButton *button ) &#123; <span class="comment">/* ... */</span> &#125; );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QButtonGroup::buttonClicked(int id) [signal]</code>: This <code>signal</code> is emitted when a button with the given <code>id</code> is clicked. <strong>Note</strong>: <code>Signal</code> buttonClicked is overloaded in this class. To connect to this one using the function pointer syntax, you must specify the <code>signal</code> type in a static cast, as shown in this example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect ( buttonGroup, <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> ( QButtonGroup::* ) ( <span class="keyword">int</span> ) &gt; \</span><br><span class="line">        ( &amp;QButtonGroup::buttonClicked ), [ = ] ( <span class="keyword">int</span> id ) &#123; <span class="comment">/* ... */</span> &#125; );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QButtonGroup::buttonPressed(QAbstractButton * button) [signal]</code>: This <code>signal</code> is emitted when the given <code>button</code> is pressed down. <strong>Note</strong>: <code>Signal</code> buttonPressed is overloaded in this class. To connect to this one using the function pointer syntax, you must specify the <code>signal</code> type in a static cast, as shown in this example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect ( buttonGroup, <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> ( QButtonGroup::* ) ( QAbstractButton * ) &gt; \</span><br><span class="line">        ( &amp;QButtonGroup::buttonPressed ), [ = ] ( QAbstractButton *button ) &#123; <span class="comment">/* ... */</span> &#125; );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QButtonGroup::buttonPressed(int id) [signal]</code>: This <code>signal</code> is emitted when a <code>button</code> with the given <code>id</code> is pressed down. <strong>Note</strong>: <code>Signal</code> buttonPressed is overloaded in this class. To connect to this one using the function pointer syntax, you must specify the <code>signal</code> type in a static cast, as shown in this example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect ( buttonGroup, <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> ( QButtonGroup::* ) ( <span class="keyword">int</span> ) &gt; \</span><br><span class="line">        ( &amp;QButtonGroup::buttonPressed ), [ = ] ( <span class="keyword">int</span> id ) &#123; <span class="comment">/* ... */</span> &#125; );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QButtonGroup::buttonReleased(QAbstractButton * button) [signal]</code>: This <code>signal</code> is emitted when the given <code>button</code> is released. <strong>Note</strong>: <code>Signal</code> buttonReleased is overloaded in this class. To connect to this one using the function pointer syntax, you must specify the <code>signal</code> type in a static cast, as shown in this example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect ( buttonGroup, <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> ( QButtonGroup::* ) ( QAbstractButton * ) &gt; \</span><br><span class="line">        ( &amp;QButtonGroup::buttonReleased ), [ = ] ( QAbstractButton *button ) &#123; <span class="comment">/* ... */</span> &#125; );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QButtonGroup::buttonReleased(int id) [signal]</code>: This <code>signal</code> is emitted when a button with the given <code>id</code> is released. <strong>Note</strong>: <code>Signal</code> buttonReleased is overloaded in this class. To connect to this one using the function pointer syntax, you must specify the <code>signal</code> type in a static cast, as shown in this example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect ( buttonGroup, <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> ( QButtonGroup::* ) ( <span class="keyword">int</span> ) &gt; \</span><br><span class="line">        ( &amp;QButtonGroup::buttonReleased ), [ = ] ( <span class="keyword">int</span> id ) &#123; <span class="comment">/* ... */</span> &#125; );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QList&lt;QAbstractButton *&gt; QButtonGroup::buttons() const</code>: Returns the list of this groups’s buttons. This may be empty.</li>
<li><code>QAbstractButton * QButtonGroup::checkedButton() const</code>: Returns the button group’s checked button, or <code>0</code> if no buttons are checked.</li>
<li><code>int QButtonGroup::checkedId() const</code>: Returns the id of the <code>checkedButton()</code>, or <code>-1</code> if no button is checked.</li>
<li><code>int QButtonGroup::id(QAbstractButton * button) const</code>: Returns the id for the specified <code>button</code>, or <code>-1</code> if no such <code>button</code> exists.</li>
<li><code>void QButtonGroup::removeButton(QAbstractButton * button)</code>: Removes the given <code>button</code> from the <code>button</code> group.</li>
<li><code>void QButtonGroup::setId(QAbstractButton * button, int id)</code>: Sets the <code>id</code> for the specified <code>button</code>. Note that <code>id</code> can not be <code>-1</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/22/Qt语法详解/Qt之const_iterator/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/22/Qt语法详解/Qt之const_iterator/" itemprop="url">Qt之const_iterator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-22T15:41:04+08:00">
                2019-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QList::const_iterator</code> class provides an <code>STL-style</code> const iterator for <code>QList</code> and <code>QQueue</code>. The header file is <code>const_iterator</code>.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>const_iterator()</code></td>
</tr>
<tr>
<td></td>
<td><code>const_iterator(const const_iterator &amp; other)</code></td>
</tr>
<tr>
<td></td>
<td><code>const_iterator(const iterator &amp; other)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const const_iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>operator*() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>operator+(int j) const</code></td>
</tr>
<tr>
<td><code>const_iterator &amp;</code></td>
<td><code>operator++()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>operator++(int)</code></td>
</tr>
<tr>
<td><code>const_iterator &amp;</code></td>
<td><code>operator+=(int j)</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>operator-(int j) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>operator-(const_iterator other) const</code></td>
</tr>
<tr>
<td><code>const_iterator &amp;</code></td>
<td><code>operator--()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>operator--(int)</code></td>
</tr>
<tr>
<td><code>const_iterator &amp;</code></td>
<td><code>operator-=(int j)</code></td>
</tr>
<tr>
<td><code>const T *</code></td>
<td><code>operator-&gt;() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&lt;(const const_iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&lt;=(const const_iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const const_iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&gt;(const const_iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&gt;=(const const_iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>operator[](int j) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QList::const_iterator</code> class provides an <code>STL-style</code> const iterator for <code>QList</code> and <code>QQueue</code>.<br>&emsp;&emsp;<code>QList</code> provides both <code>STL-style</code> iterators and <code>Java-style</code> iterators. The <code>STL-style</code> iterators are more <code>low-level</code> and more cumbersome to use; on the other hand, they are slightly faster and, for developers who already know <code>STL</code>, have the advantage of familiarity.<br>&emsp;&emsp;<code>QList&lt;T&gt;::const_iterator</code> allows you to iterate over a <code>QList&lt;T&gt;</code> (or a <code>QQueue&lt;T&gt;</code>). If you want to modify the <code>QList</code> as you iterate over it, use <code>QList::iterator</code> instead. It is generally good practice to use <code>QList::const_iterator</code> on a <code>non-const QList</code> as well, unless you need to change the <code>QList</code> through the iterator. Const iterators are slightly faster, and can improve code readability.<br>&emsp;&emsp;The default <code>QList::const_iterator</code> constructor creates an uninitialized iterator. You must initialize it using a <code>QList</code> function like <code>QList::constBegin()</code>, <code>QList::constEnd()</code>, or <code>QList::insert()</code> before you can start iterating. Here’s a typical loop that prints all the items stored in a list:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span>.append ( <span class="string">"January"</span> );</span><br><span class="line"><span class="built_in">list</span>.append ( <span class="string">"February"</span> );</span><br><span class="line"><span class="built_in">list</span>.append ( <span class="string">"December"</span> );</span><br><span class="line">​</span><br><span class="line">QList&lt;QString&gt;::const_iterator i;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="built_in">list</span>.constBegin(); i != <span class="built_in">list</span>.constEnd(); ++i ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Most <code>QList</code> functions accept an integer index rather than an iterator. For that reason, iterators are rarely useful in connection with <code>QList</code>. One place where <code>STL-style</code> iterators do make sense is as arguments to generic algorithms.<br>&emsp;&emsp;For example, here’s how to delete all the widgets stored in a <code>QList&lt;QWidget *&gt;</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QWidget *&gt; <span class="built_in">list</span>;​</span><br><span class="line">qDeleteAll ( <span class="built_in">list</span>.constBegin(), <span class="built_in">list</span>.constEnd() );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Multiple iterators can be used on the same list. However, be aware that any <code>non-const</code> function call performed on the <code>QList</code> will render all existing iterators undefined. If you need to keep iterators over a long period of time, we recommend that you use <code>QLinkedList</code> rather than <code>QList</code>.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>const_iterator::const_iterator()</code>: Constructs an uninitialized iterator. Functions like <code>operator*()</code> and <code>operator++()</code> should not be called on an uninitialized iterator. Use <code>operator=()</code> to assign a value to it before using it.</li>
<li><code>const_iterator::const_iterator(const const_iterator &amp; other)</code>: Constructs a copy of <code>other</code>.</li>
<li><code>const_iterator::const_iterator(const iterator &amp; other)</code>: Constructs a copy of <code>other</code>.</li>
<li><code>bool const_iterator::operator!=(const const_iterator &amp; other) const</code>: Returns <code>true</code> if <code>other</code> points to a different item than this iterator; otherwise returns false.</li>
<li><code>const T &amp; const_iterator::operator*() const</code>: Returns the current item.</li>
<li><code>const_iterator const_iterator::operator+(int j) const</code>: Returns an iterator to the item at <code>j</code> positions forward from this iterator (If <code>j</code> is negative, the iterator goes backward).</li>
<li><code>const_iterator &amp; const_iterator::operator++()</code>: The prefix <code>++</code> operator (<code>++it</code>) advances the iterator to the next item in the list and returns an iterator to the new current item. Calling this function on <code>QList::end()</code> leads to undefined results.</li>
<li><code>const_iterator const_iterator::operator++(int)</code>: This is an overloaded function. The postfix <code>++</code> operator (<code>it++</code>) advances the iterator to the next item in the list and returns an iterator to the previously current item.</li>
<li><code>const_iterator &amp; const_iterator::operator+=(int j)</code>: Advances the iterator by <code>j</code> items (If <code>j</code> is negative, the iterator goes backward).</li>
<li><code>const_iterator const_iterator::operator-(int j) const</code>: Returns an iterator to the item at <code>j</code> positions backward from this iterator (If <code>j</code> is negative, the iterator goes forward).</li>
<li><code>int const_iterator::operator-(const_iterator other) const</code>: Returns the number of items between the item pointed to by <code>other</code> and the item pointed to by this iterator.</li>
<li><code>const_iterator &amp; const_iterator::operator--()</code>: The prefix <code>--</code> operator (<code>--it</code>) makes the preceding item current and returns an iterator to the new current item. Calling this function on <code>QList::begin()</code> leads to undefined results.</li>
<li><code>const_iterator const_iterator::operator--(int)</code>: This is an overloaded function. The postfix <code>--</code> operator (<code>it--</code>) makes the preceding item current and returns an iterator to the previously current item.</li>
<li><code>const_iterator &amp; const_iterator::operator-=(int j)</code>: Makes the iterator go back by <code>j</code> items (If <code>j</code> is negative, the iterator goes forward).</li>
<li><code>const T * const_iterator::operator-&gt;() const</code>: Returns a pointer to the current item.</li>
<li><code>bool const_iterator::operator&lt;(const const_iterator &amp; other) const</code>: Returns <code>true</code> if the item pointed to by this iterator is less than the item pointed to by the <code>other</code> iterator.</li>
<li><code>bool const_iterator::operator&lt;=(const const_iterator &amp; other) const</code>: Returns <code>true</code> if the item pointed to by this iterator is less than or equal to the item pointed to by the <code>other</code> iterator.</li>
<li><code>bool const_iterator::operator==(const const_iterator &amp; other) const</code>: Returns <code>true</code> if <code>other</code> points to the same item as this iterator; otherwise returns false.</li>
<li><code>bool const_iterator::operator&gt;(const const_iterator &amp; other) const</code>: Returns <code>true</code> if the item pointed to by this iterator is greater than the item pointed to by the <code>other</code> iterator.</li>
<li><code>bool const_iterator::operator&gt;=(const const_iterator &amp; other) const</code>: Returns <code>true</code> if the item pointed to by this iterator is greater than or equal to the item pointed to by the <code>other</code> iterator.</li>
<li><code>const T &amp; const_iterator::operator[](int j) const</code>: Returns the item at position <code>*this + j</code>. This function is provided to make <code>QList</code> iterators behave like <code>C++</code> pointers.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/22/Qt语法详解/Qt之QTableView/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/22/Qt语法详解/Qt之QTableView/" itemprop="url">Qt之QTableView</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-22T15:15:18+08:00">
                2019-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>QTableView</code>常用于实现数据的表格显示。<br>&emsp;&emsp;1. 添加表头：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 准备数据模型 */</span></span><br><span class="line">QStandardItemModel *student_model = <span class="keyword">new</span> QStandardItemModel();</span><br><span class="line">student_model-&gt;setHorizontalHeaderItem ( <span class="number">0</span>, <span class="keyword">new</span> QStandardItem ( QObject::tr ( <span class="string">"Name"</span> ) ) );</span><br><span class="line">student_model-&gt;setHorizontalHeaderItem ( <span class="number">1</span>, <span class="keyword">new</span> QStandardItem ( QObject::tr ( <span class="string">"NO."</span> ) ) );</span><br><span class="line">student_model-&gt;setHorizontalHeaderItem ( <span class="number">2</span>, <span class="keyword">new</span> QStandardItem ( QObject::tr ( <span class="string">"Sex"</span> ) ) );</span><br><span class="line">student_model-&gt;setHorizontalHeaderItem ( <span class="number">3</span>, <span class="keyword">new</span> QStandardItem ( QObject::tr ( <span class="string">"Age"</span> ) ) );</span><br><span class="line">student_model-&gt;setHorizontalHeaderItem ( <span class="number">4</span>, <span class="keyword">new</span> QStandardItem ( QObject::tr ( <span class="string">"College"</span> ) ) );</span><br><span class="line"><span class="comment">/* 利用setModel方法将数据模型与QTableView绑定 */</span></span><br><span class="line">ui-&gt;student_tableview-&gt;setModel ( student_model );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 设置表格属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置列宽不可变动，即不能通过鼠标拖动增加列宽 */</span></span><br><span class="line">ui-&gt;student_tableview-&gt;horizontalHeader()-&gt;setResizeMode ( <span class="number">0</span>, QHeaderView::Fixed );</span><br><span class="line">ui-&gt;student_tableview-&gt;horizontalHeader()-&gt;setResizeMode ( <span class="number">1</span>, QHeaderView::Fixed );</span><br><span class="line">ui-&gt;student_tableview-&gt;horizontalHeader()-&gt;setResizeMode ( <span class="number">2</span>, QHeaderView::Fixed );</span><br><span class="line">ui-&gt;student_tableview-&gt;horizontalHeader()-&gt;setResizeMode ( <span class="number">3</span>, QHeaderView::Fixed );</span><br><span class="line">ui-&gt;student_tableview-&gt;horizontalHeader()-&gt;setResizeMode ( <span class="number">4</span>, QHeaderView::Fixed );</span><br><span class="line"><span class="comment">/* 设置表格的各列的宽度值 */</span></span><br><span class="line">ui-&gt;student_tableview-&gt;setColumnWidth ( <span class="number">0</span>, <span class="number">100</span> );</span><br><span class="line">ui-&gt;student_tableview-&gt;setColumnWidth ( <span class="number">1</span>, <span class="number">100</span> );</span><br><span class="line">ui-&gt;student_tableview-&gt;setColumnWidth ( <span class="number">2</span>, <span class="number">100</span> );</span><br><span class="line">ui-&gt;student_tableview-&gt;setColumnWidth ( <span class="number">3</span>, <span class="number">100</span> );</span><br><span class="line">ui-&gt;student_tableview-&gt;setColumnWidth ( <span class="number">4</span>, <span class="number">100</span> );</span><br><span class="line"><span class="comment">/* 默认显示行头，如果你觉得不美观的话，我们可以将隐藏 */</span></span><br><span class="line">ui-&gt;student_tableview-&gt;verticalHeader()-&gt;hide();</span><br><span class="line"><span class="comment">/* 设置选中时为整行选中 */</span></span><br><span class="line">ui-&gt;student_tableview-&gt;setSelectionBehavior ( QAbstractItemView::SelectRows );</span><br><span class="line"><span class="comment">/* 设置表格的单元为只读属性，即不能编辑 */</span></span><br><span class="line">ui-&gt;student_tableview-&gt;setEditTriggers ( QAbstractItemView::NoEditTriggers );</span><br><span class="line"><span class="comment">/* 如果你用在QTableView中使用右键菜单，需启用该属性 */</span></span><br><span class="line">ui-&gt;tstudent_tableview-&gt;setContextMenuPolicy ( Qt::CustomContextMenu );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3. 动态添加行：在表格中添加行时，我们只需要在<code>model</code>中插入数据即可，一旦<code>model</code>中的数据发生变化，<code>QTabelView</code>显示就会做相应的变动：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在第一行添加学生张三的个人信息(setItem函数的第一个参数</span></span><br><span class="line"><span class="comment">   表示行号，第二个表示列号，第三个为要显示的数据) */</span></span><br><span class="line">student_model-&gt;setItem ( <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> QStandardItem ( <span class="string">"张三"</span> ) );</span><br><span class="line">student_model-&gt;setItem ( <span class="number">0</span>, <span class="number">1</span>, <span class="keyword">new</span> QStandardItem ( <span class="string">"20120202"</span> ) );</span><br><span class="line">student_model-&gt;setItem ( <span class="number">0</span>, <span class="number">2</span>, <span class="keyword">new</span> QStandardItem ( <span class="string">"男"</span> ) );</span><br><span class="line">student_model-&gt;setItem ( <span class="number">0</span>, <span class="number">3</span>, <span class="keyword">new</span> QStandardItem ( <span class="string">"18"</span> ) );</span><br><span class="line">student_model-&gt;setItem ( <span class="number">0</span>, <span class="number">4</span>, <span class="keyword">new</span> QStandardItem ( <span class="string">"土木学院"</span> ) );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;4. 设置数据显示的样式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置单元格文本居中，张三的数据设置为居中显示 */</span></span><br><span class="line">student_model-&gt;item ( <span class="number">0</span>, <span class="number">0</span> )-&gt;setTextAlignment ( Qt::AlignCenter );</span><br><span class="line">student_model-&gt;item ( <span class="number">0</span>, <span class="number">1</span> )-&gt;setTextAlignment ( Qt::AlignCenter );</span><br><span class="line">student_model-&gt;item ( <span class="number">0</span>, <span class="number">2</span> )-&gt;setTextAlignment ( Qt::AlignCenter );</span><br><span class="line">student_model-&gt;item ( <span class="number">0</span>, <span class="number">3</span> )-&gt;setTextAlignment ( Qt::AlignCenter );</span><br><span class="line">student_model-&gt;item ( <span class="number">0</span>, <span class="number">4</span> )-&gt;setTextAlignment ( Qt::AlignCenter );</span><br><span class="line"><span class="comment">/* 设置单元格文本颜色，张三的数据设置为红色 */</span></span><br><span class="line">student_model-&gt;item ( <span class="number">0</span>, <span class="number">0</span> )-&gt;setForeground ( QBrush ( QColor ( <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span> ) ) );</span><br><span class="line">student_model-&gt;item ( <span class="number">0</span>, <span class="number">1</span> )-&gt;setForeground ( QBrush ( QColor ( <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span> ) ) );</span><br><span class="line">student_model-&gt;item ( <span class="number">0</span>, <span class="number">2</span> )-&gt;setForeground ( QBrush ( QColor ( <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span> ) ) );</span><br><span class="line">student_model-&gt;item ( <span class="number">0</span>, <span class="number">3</span> )-&gt;setForeground ( QBrush ( QColor ( <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span> ) ) );</span><br><span class="line">student_model-&gt;item ( <span class="number">0</span>, <span class="number">4</span> )-&gt;setForeground ( QBrush ( QColor ( <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span> ) ) );</span><br><span class="line"><span class="comment">/* 将字体加粗 */</span></span><br><span class="line">student_model-&gt;item ( <span class="number">0</span>, <span class="number">0</span> )-&gt;setFont ( QFont ( <span class="string">"Times"</span>, <span class="number">10</span>, QFont::Black ) );</span><br><span class="line">student_model-&gt;item ( <span class="number">0</span>, <span class="number">1</span> )-&gt;setFont ( QFont ( <span class="string">"Times"</span>, <span class="number">10</span>, QFont::Black ) );</span><br><span class="line">student_model-&gt;item ( <span class="number">0</span>, <span class="number">2</span> )-&gt;setFont ( QFont ( <span class="string">"Times"</span>, <span class="number">10</span>, QFont::Black ) );</span><br><span class="line">student_model-&gt;item ( <span class="number">0</span>, <span class="number">3</span> )-&gt;setFont ( QFont ( <span class="string">"Times"</span>, <span class="number">10</span>, QFont::Black ) );</span><br><span class="line">student_model-&gt;item ( <span class="number">0</span>, <span class="number">4</span> )-&gt;setFont ( QFont ( <span class="string">"Times"</span>, <span class="number">10</span>, QFont::Black ) );</span><br><span class="line"><span class="comment">/* 设置排序方式，按年龄降序显示 */</span></span><br><span class="line">student_model-&gt;sort ( <span class="number">3</span>, Qt::DescendingOrder );</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/48/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><span class="page-number current">49</span><a class="page-number" href="/page/50/">50</a><span class="space">&hellip;</span><a class="page-number" href="/page/94/">94</a><a class="extend next" rel="next" href="/page/50/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">939</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
