<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="暴徒">
<meta property="og:url" content="http://fukangwei.gitee.io/page/18/index.html">
<meta property="og:site_name" content="暴徒">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="暴徒">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/18/">





  <title>暴徒</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">暴徒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/23/Qt应用示例/Qt之自定义信号/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/23/Qt应用示例/Qt之自定义信号/" itemprop="url">Qt之自定义信号</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-23T11:48:15+08:00">
                2019-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>widget.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDGET_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> QWidget &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span> <span class="params">( QWidget *parent = <span class="number">0</span> )</span></span>;</span><br><span class="line">    ~Widget();</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showValue</span> <span class="params">( <span class="keyword">int</span> value )</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mydialog.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYDIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYDIALOG_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDialog&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyDialog</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDialog</span> :</span> <span class="keyword">public</span> QDialog &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyDialog</span> <span class="params">( QWidget *parent = <span class="number">0</span> )</span></span>;</span><br><span class="line">    ~MyDialog();</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_pushButton_clicked</span><span class="params">()</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dlgReturn</span> <span class="params">( <span class="keyword">int</span> )</span></span>; <span class="comment">/* 自定义的信号 */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MyDialog *ui;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYDIALOG_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>widget.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mydialog.h"</span></span></span><br><span class="line">​</span><br><span class="line">Widget::Widget ( QWidget *parent ) : QWidget ( parent ), ui ( <span class="keyword">new</span> Ui::Widget ) &#123;</span><br><span class="line">    ui-&gt;setupUi ( <span class="keyword">this</span> );</span><br><span class="line">    MyDialog *dlg = <span class="keyword">new</span> MyDialog ( <span class="keyword">this</span> ); <span class="comment">/* 创建对话框 */</span></span><br><span class="line">    <span class="comment">/* 将对话框中的自定义信号与主界面中的自定义槽函数进行关联 */</span></span><br><span class="line">    connect ( dlg, SIGNAL ( dlgReturn ( <span class="keyword">int</span> ) ), <span class="keyword">this</span>, SLOT ( showValue ( <span class="keyword">int</span> ) ) );</span><br><span class="line">    dlg-&gt;show(); <span class="comment">/* 显示对话框 */</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">Widget::~Widget() &#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> Widget::showValue ( <span class="keyword">int</span> value ) &#123; <span class="comment">/* 自定义槽函数 */</span></span><br><span class="line">    ui-&gt;label-&gt;setText ( tr ( <span class="string">"获取的值是：%1"</span> ).arg ( value ) );</span><br><span class="line">&#125;</span><br><span class="line">   mydialog.cpp：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mydialog.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_mydialog.h"</span></span></span><br><span class="line">​</span><br><span class="line">MyDialog::MyDialog ( QWidget *parent ) : QDialog ( parent ), ui ( <span class="keyword">new</span> Ui::MyDialog ) &#123;</span><br><span class="line">    ui-&gt;setupUi ( <span class="keyword">this</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">MyDialog::~MyDialog() &#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MyDialog::on_pushButton_clicked() &#123; <span class="comment">/* 确定按钮 */</span></span><br><span class="line">    <span class="keyword">int</span> value = ui-&gt;spinBox-&gt;value(); <span class="comment">/* 获取输入的数值 */</span></span><br><span class="line">    <span class="function">emit <span class="title">dlgReturn</span> <span class="params">( value )</span></span>; <span class="comment">/* 发射信号 */</span></span><br><span class="line">    close(); <span class="comment">/* 关闭对话框 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/23/Qt应用示例/Qt之自定义信号/1.png" height="225" width="557"></p>
<p>&emsp;&emsp;声明一个信号要使用<code>signals</code>关键字，在<code>signals</code>前面不能使用<code>public</code>、<code>private</code>和<code>protected</code>等限定符，因为只有定义该信号的类以及子类才可以发射该信号。而且信号只用声明，不需要也不能对它进行定义实现。信号没有返回值，只能是<code>void</code>类型的。因为只有<code>QObject</code>类以及其子类派生的类才能使用信号和槽机制。使用信号和槽还必须在类声明的最开始处添加<code>Q_OBJECT</code>宏。<br>&emsp;&emsp;声明一个槽需要使用<code>slots</code>关键词。一个槽可以是<code>private</code>、<code>public</code>或者<code>protected</code>类型的，也可以声明为虚函数，这与普通的成员函数是一样的，也可以像调用一个普通函数一样来调用槽。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/23/Qt应用示例/Qt窗口间的相互切换/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/23/Qt应用示例/Qt窗口间的相互切换/" itemprop="url">Qt窗口间的相互切换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-23T11:35:55+08:00">
                2019-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;在用<code>Qt</code>设计<code>GUI</code>时，经常要设计两个窗口之间的相互切换，即以从一个窗口跳转到另一个窗口，然后又从另一个窗口跳转回原窗口。下面来介绍具体的实现方法。<br>&emsp;&emsp;首先建立<code>Qt</code>的<code>Gui</code>应用，项目名是<code>TwoWindowsHandoff</code>，基类选择<code>QMainWindow</code>。然后右击项目，添加<code>Qt</code>设计器界面类，类名取为<code>logindialog</code>。我们在这里假设一个窗口是登录对话框，另一个窗口是主界面；登录对话框有两个按钮，分别更改显示文本为<code>login</code>、<code>exit</code>；主界面也有两个按钮，分别更改显示文本为<code>relogin</code>、<code>quit</code>。我们最终的实现功能是：程序运行时，出现登录对话框，点击<code>login</code>按钮进入主界面且登录对话框消失；在主界面点击<code>relogin</code>按钮回到登录对话框且主界面消失，点击<code>exit</code>按钮或<code>quit</code>按钮都会退出程序。<br>&emsp;&emsp;我们可以通过<code>Qt Designer</code>来在两个窗口上分别添加上述按钮，主要的问题是如何设计信号和槽。我们先设计两个窗口的退出按钮：分别右击<code>exit</code>和<code>quit</code>按钮，转到槽，在槽函数中发射<code>quit</code>信号，然后将信号与<code>QApplication</code>对象的<code>quit</code>槽函数关联，这样就设计好了两个退出按钮的退出操作。对于<code>login</code>按钮，我们在其槽函数中发射<code>showmainwindow</code>信号，隐藏对话框，然后在主窗口类中定义对应的槽函数<code>receivelogin</code>，在该函数中应该显示主窗口。同理，对于<code>relogin</code>窗口，我们在其槽函数中发射<code>dlgshow</code>信号，隐藏主窗口，然后在登录对话框类中定义对应的槽函数<code>receivelshow</code>，在该函数中应该显示登录对话框。具体的程序实现如下：<br>&emsp;&emsp;<code>mainwindow.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOW_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span> <span class="params">( QWidget *parent = <span class="number">0</span> )</span></span>;</span><br><span class="line">    ~MainWindow();</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receivelogin</span><span class="params">()</span></span>; <span class="comment">/* 与login中发射的信号关联的槽函数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_pushButton_clicked</span><span class="params">()</span></span>; <span class="comment">/* 与relogin的click关联的槽函数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_pushButton_2_clicked</span><span class="params">()</span></span>; <span class="comment">/* 与quit的click关联的槽函数 */</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dlgshow</span><span class="params">()</span></span>; <span class="comment">/* 显示登录对话框信号 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span></span>; <span class="comment">/* 退出信号 */</span></span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mydialog.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYDIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYDIALOG_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDialog&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyDialog</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDialog</span> :</span> <span class="keyword">public</span> QDialog &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyDialog</span> <span class="params">( QWidget *parent = <span class="number">0</span> )</span></span>;</span><br><span class="line">    ~MyDialog();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_pushButton_clicked</span><span class="params">()</span></span>; <span class="comment">/* 与login关联的槽函数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receiveshow</span><span class="params">()</span></span>; <span class="comment">/* 与relogin中发射的信号关联的槽函数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_pushButton_2_clicked</span><span class="params">()</span></span>; <span class="comment">/* 与exit关联的槽函数 */</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showmainwindow</span><span class="params">()</span></span>; <span class="comment">/* 显示主窗口信号 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span></span>; <span class="comment">/* 退出信号 */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MyDialog *ui;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYDIALOG_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>main.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtGui/QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mydialog.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    MyDialog dlg;</span><br><span class="line">    dlg.show();</span><br><span class="line">    <span class="comment">/* 信号与槽之间进行关联 */</span></span><br><span class="line">    QObject::connect ( &amp;dlg, SIGNAL ( showmainwindow() ), &amp;w, SLOT ( receivelogin() ) );</span><br><span class="line">    QObject::connect ( &amp;w, SIGNAL ( dlgshow() ), &amp;dlg, SLOT ( receiveshow() ) );</span><br><span class="line">    QObject::connect ( &amp;w, SIGNAL ( quit() ), &amp;a, SLOT ( quit() ) );</span><br><span class="line">    QObject::connect ( &amp;dlg, SIGNAL ( quit() ), &amp;a, SLOT ( quit() ) );</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mainwindow.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line">​</span><br><span class="line">MainWindow::MainWindow ( QWidget *parent ) : QMainWindow ( parent ), ui ( <span class="keyword">new</span> Ui::MainWindow ) &#123;</span><br><span class="line">    ui-&gt;setupUi ( <span class="keyword">this</span> ); <span class="comment">/* 默认是类名 */</span></span><br><span class="line">    setWindowTitle ( tr ( <span class="string">"myMainWindow"</span> ) );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">MainWindow::~MainWindow() &#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MainWindow::receivelogin() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;show(); <span class="comment">/* 显示主窗口 */</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MainWindow::on_pushButton_clicked() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;hide(); <span class="comment">/* 隐藏主窗口 */</span></span><br><span class="line">    <span class="function">emit <span class="title">dlgshow</span><span class="params">()</span></span>; <span class="comment">/* 发射显示登录对话框信号 */</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MainWindow::on_pushButton_2_clicked() &#123;</span><br><span class="line">    <span class="function">emit <span class="title">quit</span><span class="params">()</span></span>; <span class="comment">/* 发射退出信号 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mydialog.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mydialog.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_mydialog.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mainwindow.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line">MyDialog::MyDialog ( QWidget *parent ) :   QDialog ( parent ),  ui ( <span class="keyword">new</span> Ui::MyDialog ) &#123;</span><br><span class="line">    ui-&gt;setupUi ( <span class="keyword">this</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">MyDialog::~MyDialog() &#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MyDialog::on_pushButton_clicked() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;hide(); <span class="comment">/* 隐藏登录对话框 */</span></span><br><span class="line">    <span class="function">emit <span class="title">showmainwindow</span><span class="params">()</span></span>; <span class="comment">/* 显示主窗口 */</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MyDialog::receiveshow() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;show(); <span class="comment">/* 显示登录对话框 */</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MyDialog::on_pushButton_2_clicked() &#123;</span><br><span class="line">    <span class="function">emit <span class="title">quit</span><span class="params">()</span></span>; <span class="comment">/* 发射退出信号 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/23/Qt应用示例/Qt窗口间的相互切换/1.png" height="198" width="492"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/23/Qt语法详解/Qt之LineEdit/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/23/Qt语法详解/Qt之LineEdit/" itemprop="url">Qt之LineEdit</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-23T10:45:35+08:00">
                2019-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="行编辑器"><a href="#行编辑器" class="headerlink" title="行编辑器"></a>行编辑器</h3><p>&emsp;&emsp;<code>mywidget.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYWIDGET_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> :</span> <span class="keyword">public</span> QWidget &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWidget</span> <span class="params">( QWidget *parent = <span class="number">0</span> )</span></span>;</span><br><span class="line">    ~MyWidget();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_lineEdit2_returnPressed</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_lineEdit3_returnPressed</span><span class="params">()</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MyWidget *ui;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYWIDGET_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mywidget.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mywidget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_mywidget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCompleter&gt;</span></span></span><br><span class="line">​</span><br><span class="line">MyWidget::MyWidget ( QWidget *parent ) : QWidget ( parent ), ui ( <span class="keyword">new</span> Ui::MyWidget ) &#123;</span><br><span class="line">    ui-&gt;setupUi ( <span class="keyword">this</span> );</span><br><span class="line">    QValidator *validator = <span class="keyword">new</span> QIntValidator ( <span class="number">100</span>, <span class="number">999</span>, <span class="keyword">this</span> ); <span class="comment">/* 新建验证器，指定范围为100至999 */</span></span><br><span class="line">    ui-&gt;lineEdit3-&gt;setValidator ( validator ); <span class="comment">/* 在行编辑器中使用验证器 */</span></span><br><span class="line">    QStringList wordList;</span><br><span class="line">    wordList &lt;&lt; <span class="string">"Qt"</span> &lt;&lt; <span class="string">"Qt Creator"</span> &lt;&lt; tr ( <span class="string">"你好"</span> );</span><br><span class="line">    QCompleter *completer = <span class="keyword">new</span> QCompleter ( wordList, <span class="keyword">this</span> ); <span class="comment">/* 新建自动完成器 */</span></span><br><span class="line">    completer-&gt;setCaseSensitivity ( Qt::CaseInsensitive ); <span class="comment">/* 设置大小写不敏感 */</span></span><br><span class="line">    ui-&gt;lineEdit4-&gt;setCompleter ( completer );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">MyWidget::~MyWidget() &#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MyWidget::on_lineEdit2_returnPressed() &#123; <span class="comment">/* 回车键按下信号的槽 */</span></span><br><span class="line">    ui-&gt;lineEdit3-&gt;setFocus(); <span class="comment">/* 让lineEdit3获得光标 */</span></span><br><span class="line">    qDebug() &lt;&lt; ui-&gt;lineEdit2-&gt;text(); <span class="comment">/* 输出lineEdit2的内容 */</span></span><br><span class="line">    qDebug() &lt;&lt; ui-&gt;lineEdit2-&gt;displayText(); <span class="comment">/* 输出lineEdit2显示的内容 */</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MyWidget::on_lineEdit3_returnPressed() &#123; <span class="comment">/* 回车键按下信号的槽 */</span></span><br><span class="line">    ui-&gt;lineEdit4-&gt;setFocus();</span><br><span class="line">    qDebug() &lt;&lt; ui-&gt;lineEdit3-&gt;text();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/23/Qt语法详解/Qt之LineEdit/1.png" height="230" width="284"></p>
<hr>
<h3 id="lineEdit-gt-textChanged信号不触发的原因"><a href="#lineEdit-gt-textChanged信号不触发的原因" class="headerlink" title="lineEdit-&gt;textChanged信号不触发的原因"></a>lineEdit-&gt;textChanged信号不触发的原因</h3><p>&emsp;&emsp;项目要求是当<code>lineEdit</code>中的内容发生改变时，激活<code>find</code>按纽。但实际运行结果却不行，发现是自己的<code>connect</code>语句写错了：</p>
<p><img src="/2019/02/23/Qt语法详解/Qt之LineEdit/2.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// connect ( lineEdit, SIGNAL ( textChanged ( QString &amp; ) ), this, SLOT ( enableFindButton ( QString &amp; ) ) ); /* 错误写法 */</span></span><br><span class="line">connect ( lineEdit, SIGNAL ( textChanged ( <span class="keyword">const</span> QString &amp; ) ), <span class="keyword">this</span>, SLOT ( enableFindButton ( <span class="keyword">const</span> QString &amp; ) ) );</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Qt设置密码输入框"><a href="#Qt设置密码输入框" class="headerlink" title="Qt设置密码输入框"></a>Qt设置密码输入框</h3><p>&emsp;&emsp;<code>QLineEdit</code>类自带<code>public function: void setEchoMode(EchoMode)</code>以实现密码输入框效果。<code>EchoMode</code>的枚举值如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QLineEdit::Normal</code></td>
<td><code>0</code></td>
<td>正常显示形式，也就是一边输入一边显示</td>
</tr>
<tr>
<td><code>QLineEdit::NoEcho</code></td>
<td><code>1</code></td>
<td>不会显示任何字符，包括字符串长度</td>
</tr>
<tr>
<td><code>QLineEdit::Password</code></td>
<td><code>2</code></td>
<td>根据平台使用模糊字符代替你实际输入的字符</td>
</tr>
<tr>
<td><code>QLineEdit::PasswordEchoOnEdit</code></td>
<td><code>3</code></td>
<td>当你处于输入状态的时候，是正常显示字符。输入完毕之后使用<code>Password</code>形式隐藏字符</td>
</tr>
</tbody>
</table>
</div>
<p>通过<code>EchoMode</code>提供枚举值有选择的设置<code>setEchoMode(EchoMode)</code>，以达到自己想要的效果。</p>
<hr>
<ul>
<li><code>text()</code>：获得<code>lineEdit</code>中的内容，为<code>QString</code>类型。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/22/Qt语法详解/Qt之QTreeWidget/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/22/Qt语法详解/Qt之QTreeWidget/" itemprop="url">Qt之QTreeWidget</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T13:17:33+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>Qt</code>中实现树形结构可以使用<code>QTreeWidget</code>类，也可以使用<code>QTreeView</code>类，<code>QTreeWidget</code>继承自<code>QTreeView</code>类，其效果如下：</p>
<p><img src="/2019/02/22/Qt语法详解/Qt之QTreeWidget/1.png"></p>
<h3 id="树形结构实现"><a href="#树形结构实现" class="headerlink" title="树形结构实现"></a>树形结构实现</h3><p>&emsp;&emsp;<code>QT</code>的<code>GUI</code>中有<code>treeWidget</code>部件，将该控件在<code>GUI</code>中布局好，假设其对象名为<code>treeWidget</code>。树形结构通过<code>QTreeWidget</code>类和<code>QTreeWidgetItem</code>类实现，<code>QTreeWidgetItem</code>类实现结点的添加。上图代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;treeWidget-&gt;setColumnCount ( <span class="number">1</span> ); <span class="comment">/* 设置列数 */</span></span><br><span class="line">ui-&gt;treeWidget-&gt;setHeaderLabel ( tr ( <span class="string">"图像选择"</span> ) ); <span class="comment">/* 设置头的标题 */</span></span><br><span class="line">​</span><br><span class="line">QTreeWidgetItem *imageItem1 = <span class="keyword">new</span> QTreeWidgetItem ( ui-&gt;treeWidget, QStringList ( QString ( <span class="string">"图像1"</span> ) ) );</span><br><span class="line">imageItem1-&gt;setIcon ( <span class="number">0</span>, QIcon ( <span class="string">"xxx.png"</span> ) );</span><br><span class="line">QTreeWidgetItem *imageItem1_1 = <span class="keyword">new</span> QTreeWidgetItem ( imageItem1, QStringList ( QString ( <span class="string">"Band1"</span> ) ) ); <span class="comment">/* 子节点1 */</span></span><br><span class="line">imageItem1-&gt;addChild ( imageItem1_1 ); <span class="comment">/* 添加子节点 */</span></span><br><span class="line">​</span><br><span class="line">QTreeWidgetItem *imageItem2 = <span class="keyword">new</span> QTreeWidgetItem ( ui-&gt;treeWidget, QStringList ( QString ( <span class="string">"图像2"</span> ) ) );</span><br><span class="line">QTreeWidgetItem *imageItem2_1 = <span class="keyword">new</span> QTreeWidgetItem ( imageItem2, QStringList ( QString ( <span class="string">"Band1"</span> ) ) ); <span class="comment">/* 子节点1 */</span></span><br><span class="line">QTreeWidgetItem *imageItem2_2 = <span class="keyword">new</span> QTreeWidgetItem ( imageItem2, QStringList ( QString ( <span class="string">"Band2"</span> ) ) ); <span class="comment">/* 子节点2 */</span></span><br><span class="line">imageItem2-&gt;addChild ( imageItem2_1 ); <span class="comment">/* 添加子节点 */</span></span><br><span class="line">imageItem2-&gt;addChild ( imageItem2_2 );</span><br><span class="line">​</span><br><span class="line">ui-&gt;treeWidget-&gt;expandAll(); <span class="comment">/* 结点全部展开 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;除了使用上面这种方法之外，还可以使用<code>QList&lt;QTreeWidgetItem *&gt; &amp; items</code>实现结点的添加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QTreeWidgetItem *&gt; rootList;</span><br><span class="line">​</span><br><span class="line">QTreeWidgetItem *imageItem1 = <span class="keyword">new</span> QTreeWidgetItem; <span class="comment">/* 添加第一个父节点 */</span></span><br><span class="line">imageItem1-&gt;setText ( <span class="number">0</span>, tr ( <span class="string">"图像1"</span> ) );</span><br><span class="line">rootList.append ( imageItem1 );</span><br><span class="line">​</span><br><span class="line">QTreeWidgetItem *imageItem1_1 = <span class="keyword">new</span> QTreeWidgetItem ( imageItem1, QStringList ( QString ( <span class="string">"Band1"</span> ) ) ); <span class="comment">/* 添加子节点 */</span></span><br><span class="line">imageItem1-&gt;addChild ( imageItem1_1 );</span><br><span class="line">​</span><br><span class="line">QTreeWidgetItem *imageItem2 = <span class="keyword">new</span> QTreeWidgetItem; <span class="comment">/* 添加第二个父节点 */</span></span><br><span class="line">imageItem2-&gt;setText ( <span class="number">0</span>, tr ( <span class="string">"图像2"</span> ) );</span><br><span class="line">rootList.append ( imageItem2 );</span><br><span class="line">​</span><br><span class="line">QTreeWidgetItem *imageItem2_1 = <span class="keyword">new</span> QTreeWidgetItem ( imageItem2, QStringList ( QString ( <span class="string">"Band1"</span> ) ) ); <span class="comment">/* 添加子节点 */</span></span><br><span class="line">QTreeWidgetItem *imageItem2_2 = <span class="keyword">new</span> QTreeWidgetItem ( imageItem2, QStringList ( QString ( <span class="string">"Band2"</span> ) ) );</span><br><span class="line">imageItem2-&gt;addChild ( imageItem2_1 );</span><br><span class="line">imageItem2-&gt;addChild ( imageItem2_2 );</span><br><span class="line">​</span><br><span class="line">ui-&gt;treeWidget-&gt;insertTopLevelItems ( <span class="number">0</span>, rootList ); <span class="comment">/* 将结点插入部件中 */</span></span><br><span class="line">​</span><br><span class="line">ui-&gt;treeWidget-&gt;expandAll(); <span class="comment">/* 全部展开 */</span></span><br></pre></td></tr></table></figure>
<h3 id="点击节点的事件响应"><a href="#点击节点的事件响应" class="headerlink" title="点击节点的事件响应"></a>点击节点的事件响应</h3><p>&emsp;&emsp;首先想到有没有点击某个节点的信号，查看文档后发现有一个<code>void itemClicked ( QTreeWidgetItem * item, int column )</code>信号，它是双击某个节点的信号。将该信号与某个自定义槽相连，当双击节点时触发槽函数。第一个参数为点击的<code>QTreeWidgetItem</code>类对象，第二个参数为节点所在列号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showSelectedImage</span> <span class="params">( QTreeWidgetItem *item, <span class="keyword">int</span> column )</span></span>; <span class="comment">/* 点击树节点事件 */</span></span><br><span class="line">​</span><br><span class="line">connect ( ui-&gt;treeWidget, SIGNAL ( itemDoubleClicked ( QTreeWidgetItem *, <span class="keyword">int</span> ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SLOT ( showSelectedImage ( QTreeWidgetItem *, <span class="keyword">int</span> ) ) );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MainWindow::showSelectedImage ( QTreeWidgetItem *item, <span class="keyword">int</span> column ) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>&emsp;&emsp;The <code>QTreeWidget</code> class provides a tree view that uses a predefined tree model.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTreeWidget</code></td>
<td><code>QTreeView</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTreeWidget(QWidget * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QTreeWidget()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addTopLevelItem(QTreeWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addTopLevelItems(const QList&lt;QTreeWidgetItem *&gt; &amp; items)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>closePersistentEditor(QTreeWidgetItem * item, int column = 0)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>columnCount() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>currentColumn() const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>currentItem() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>editItem(QTreeWidgetItem * item, int column = 0)</code></td>
</tr>
<tr>
<td><code>QList&lt;QTreeWidgetItem *&gt;</code></td>
<td><code>findItems(const QString &amp; text, Qt::MatchFlags flags, int column = 0) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>headerItem() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>indexOfTopLevelItem(QTreeWidgetItem * item) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertTopLevelItem(int index, QTreeWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertTopLevelItems(int index, const QList&lt;QTreeWidgetItem *&gt; &amp; items)</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>invisibleRootItem() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isFirstItemColumnSpanned(const QTreeWidgetItem * item) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>itemAbove(const QTreeWidgetItem * item) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>itemAt(const QPoint &amp; p) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>itemAt(int x, int y) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>itemBelow(const QTreeWidgetItem * item) const</code></td>
</tr>
<tr>
<td><code>QWidget *</code></td>
<td><code>itemWidget(QTreeWidgetItem * item, int column) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>openPersistentEditor(QTreeWidgetItem * item, int column = 0)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeItemWidget(QTreeWidgetItem * item, int column)</code></td>
</tr>
<tr>
<td><code>QList&lt;QTreeWidgetItem *&gt;</code></td>
<td><code>selectedItems() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setColumnCount(int columns)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentItem(QTreeWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentItem(QTreeWidgetItem * item, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentItem(QTreeWidgetItem * item, int column, QItemSelectionModel::SelectionFlags command)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFirstItemColumnSpanned(const QTreeWidgetItem * item, bool span)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHeaderItem(QTreeWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHeaderLabel(const QString &amp; label)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHeaderLabels(const QStringList &amp; labels)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setItemWidget(QTreeWidgetItem * item, int column, QWidget * widget)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>sortColumn() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>sortItems(int column, Qt::SortOrder order)</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>takeTopLevelItem(int index)</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>topLevelItem(int index) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>topLevelItemCount() const</code></td>
</tr>
<tr>
<td><code>QRect</code></td>
<td><code>visualItemRect(const QTreeWidgetItem * item) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Public-Functions"><a href="#Reimplemented-Public-Functions" class="headerlink" title="Reimplemented Public Functions"></a>Reimplemented Public Functions</h3><ul>
<li><code>virtual void setSelectionModel(QItemSelectionModel * selectionModel)</code></li>
</ul>
<h3 id="Public-Slots"><a href="#Public-Slots" class="headerlink" title="Public Slots"></a>Public Slots</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>collapseItem(const QTreeWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>expandItem(const QTreeWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>scrollToItem(const QTreeWidgetItem * item, QAbstractItemView::ScrollHint hint = EnsureVisible)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>currentItemChanged(QTreeWidgetItem * current, QTreeWidgetItem * previous)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemActivated(QTreeWidgetItem * item, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemChanged(QTreeWidgetItem * item, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemClicked(QTreeWidgetItem * item, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemCollapsed(QTreeWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemDoubleClicked(QTreeWidgetItem * item, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemEntered(QTreeWidgetItem * item, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemExpanded(QTreeWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemPressed(QTreeWidgetItem * item, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemSelectionChanged()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual bool</code></td>
<td><code>dropMimeData(QTreeWidgetItem * parent, int index, const QMimeData * data, Qt::DropAction action)</code></td>
</tr>
<tr>
<td><code>QModelIndex</code></td>
<td><code>indexFromItem(QTreeWidgetItem * item, int column = 0) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>itemFromIndex(const QModelIndex &amp; index) const</code></td>
</tr>
<tr>
<td><code>virtual QMimeData *</code></td>
<td><code>mimeData(const QList&lt;QTreeWidgetItem *&gt; items) const</code></td>
</tr>
<tr>
<td><code>virtual QStringList</code></td>
<td><code>mimeTypes() const</code></td>
</tr>
<tr>
<td><code>virtual Qt::DropActions</code></td>
<td><code>supportedDropActions() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Protected-Functions"><a href="#Reimplemented-Protected-Functions" class="headerlink" title="Reimplemented Protected Functions"></a>Reimplemented Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual void</code></td>
<td><code>dropEvent(QDropEvent * event)</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>event(QEvent * e)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTreeWidget</code> class provides a tree view that uses a predefined tree model.<br>&emsp;&emsp;The <code>QTreeWidget</code> class is a convenience class that provides a standard tree widget with a classic <code>item-based</code> interface similar to that used by the <code>QListView</code> class in <code>Qt 3</code>. This class is based on <code>Qt&#39;s</code> <code>Model/View</code> architecture and uses a default model to hold items, each of which is a <code>QTreeWidgetItem</code>.<br>&emsp;&emsp;Developers who do not need the flexibility of the <code>Model/View</code> framework can use this class to create simple hierarchical lists very easily. A more flexible approach involves combining a <code>QTreeView</code> with a standard item model. This allows the storage of data to be separated from its representation.<br>&emsp;&emsp;In its simplest form, a tree widget can be constructed in the following way:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QTreeWidget *treeWidget = <span class="keyword">new</span> QTreeWidget();</span><br><span class="line">treeWidget-&gt;setColumnCount ( <span class="number">1</span> );</span><br><span class="line">QList&lt;QTreeWidgetItem *&gt; items;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i ) &#123;</span><br><span class="line">    items.append ( <span class="keyword">new</span> QTreeWidgetItem ( ( QTreeWidget * ) <span class="number">0</span>, QStringList ( QString ( <span class="string">"item: %1"</span> ).arg ( i ) ) ) );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">treeWidget-&gt;insertTopLevelItems ( <span class="number">0</span>, items );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Before items can be added to the tree widget, the number of columns must be set with <code>setColumnCount()</code>. This allows each item to have one or more labels or other decorations. The number of columns in use can be found with the <code>columnCount()</code> function.<br>&emsp;&emsp;The tree can have a header that contains a section for each column in the widget. It is easiest to set up the labels for each section by supplying a list of strings with <code>setHeaderLabels()</code>, but a custom header can be constructed with a <code>QTreeWidgetItem</code> and inserted into the tree with the <code>setHeaderItem()</code> function.<br>&emsp;&emsp;The items in the tree can be sorted by column according to a predefined sort order. If sorting is enabled, the user can sort the items by clicking on a column header. Sorting can be enabled or disabled by calling <code>setSortingEnabled()</code>. The <code>isSortingEnabled()</code> function indicates whether sorting is enabled.</p>
<p><img src="/2019/02/22/Qt语法详解/Qt之QTreeWidget/2.png" height="157" width="642"></p>
<h3 id="Property-Documentation"><a href="#Property-Documentation" class="headerlink" title="Property Documentation"></a>Property Documentation</h3><ul>
<li><code>columnCount : int</code>: This property holds the number of columns displayed in the tree widget. By default, this property has a value of <code>1</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">columnCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setColumnCount</span><span class="params">(<span class="keyword">int</span> columns)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>topLevelItemCount : const int</code>: This property holds the number of <code>top-level</code> items. By default, this property has a value of <code>0</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topLevelItemCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTreeWidget::QTreeWidget(QWidget * parent = 0)</code>: Constructs a tree widget with the given <code>parent</code>.</li>
<li><code>QTreeWidget::~QTreeWidget()</code>: Destroys the tree widget and all its items.</li>
<li><code>void QTreeWidget::addTopLevelItem(QTreeWidgetItem * item)</code>: Appends the <code>item</code> as a <code>top-level</code> item in the widget.</li>
<li><code>void QTreeWidget::addTopLevelItems(const QList&lt;QTreeWidgetItem *&gt; &amp; items)</code>: Appends the list of <code>items</code> as a <code>top-level</code> items in the widget.</li>
<li><code>void QTreeWidget::clear() [slot]</code>: Clears the tree widget by removing all of its items and selections. <strong>Note</strong>: Since each item is removed from the tree widget before being deleted, the return value of <code>QTreeWidgetItem::treeWidget()</code> will be invalid when called from an item’s destructor.</li>
<li><code>void QTreeWidget::closePersistentEditor(QTreeWidgetItem * item, int column = 0)</code>: Closes the persistent editor for the <code>item</code> in the given <code>column</code>. This function has no effect if no persistent editor is open for this combination of <code>item</code> and <code>column</code>.</li>
<li><code>void QTreeWidget::collapseItem(const QTreeWidgetItem * item) [slot]</code>: Closes the <code>item</code>. This causes the tree containing the item’s children to be collapsed.</li>
<li><code>int QTreeWidget::currentColumn() const</code>: Returns the current column in the tree widget.</li>
<li><code>QTreeWidgetItem * QTreeWidget::currentItem() const</code>: Returns the current item in the tree widget.</li>
<li><code>void QTreeWidget::currentItemChanged(QTreeWidgetItem * current, QTreeWidgetItem * previous) [signal]</code>: This signal is emitted when the current item changes. The current item is specified by <code>current</code>, and this replaces the <code>previous</code> current item.</li>
<li><code>void QTreeWidget::dropEvent(QDropEvent * event) [virtual protected]</code>: Reimplemented from QWidget::dropEvent().</li>
<li><code>bool QTreeWidget::dropMimeData(QTreeWidgetItem * parent, int index, const QMimeData * data, Qt::DropAction action) [virtual protected]</code>: Handles the <code>data</code> supplied by a drag and drop operation that ended with the given <code>action</code> in the <code>index</code> in the given <code>parent</code> item. The default implementation returns true if the drop was successfully handled by decoding the mime data and inserting it into the model; otherwise it returns false.</li>
<li><code>void QTreeWidget::editItem(QTreeWidgetItem * item, int column = 0)</code>: Starts editing the <code>item</code> in the given <code>column</code> if it is editable.</li>
<li><code>bool QTreeWidget::event(QEvent * e) [virtual protected]</code>: Reimplemented from <code>QObject::event()</code>.</li>
<li><code>void QTreeWidget::expandItem(const QTreeWidgetItem * item) [slot]</code>: Expands the <code>item</code>. This causes the tree containing the item’s children to be expanded.</li>
<li><code>QList&lt;QTreeWidgetItem *&gt; QTreeWidget::findItems(const QString &amp; text, Qt::MatchFlags flags, int column = 0) const</code>: Returns a list of items that match the given <code>text</code>, using the given <code>flags</code>, in the given <code>column</code>.</li>
<li><code>QTreeWidgetItem * QTreeWidget::headerItem() const</code>: Returns the item used for the tree widget’s header.</li>
<li><code>QModelIndex QTreeWidget::indexFromItem(QTreeWidgetItem * item, int column = 0) const [protected]</code>: Returns the QModelIndex assocated with the given <code>item</code> in the given <code>column</code>.</li>
<li><code>int QTreeWidget::indexOfTopLevelItem(QTreeWidgetItem * item) const</code>: Returns the index of the given <code>top-level</code> <code>item</code>, or <code>-1</code> if the <code>item</code> cannot be found.</li>
<li><code>void QTreeWidget::insertTopLevelItem(int index, QTreeWidgetItem * item)</code>: Inserts the <code>item</code> at index in the top level in the view. If the <code>item</code> has already been inserted somewhere else it wont be inserted.</li>
<li><code>void QTreeWidget::insertTopLevelItems(int index, const QList&lt;QTreeWidgetItem *&gt; &amp; items)</code>: Inserts the list of <code>items</code> at index in the top level in the view. Items that have already been inserted somewhere else wont be inserted.</li>
<li><code>QTreeWidgetItem * QTreeWidget::invisibleRootItem() const</code>: Returns the tree widget’s invisible root item. The invisible root item provides access to the tree widget’s <code>top-level</code> items through the <code>QTreeWidgetItem</code> <code>API</code>, making it possible to write functions that can treat <code>top-level</code> items and their children in a uniform way; for example, recursive functions.</li>
<li><code>bool QTreeWidget::isFirstItemColumnSpanned(const QTreeWidgetItem * item) const</code>: Returns true if the given <code>item</code> is set to show only one section over all columns; otherwise returns false.</li>
<li><code>QTreeWidgetItem * QTreeWidget::itemAbove(const QTreeWidgetItem * item) const</code>: Returns the item above the given <code>item</code>.</li>
<li><code>void QTreeWidget::itemActivated(QTreeWidgetItem * item, int column) [signal]</code>: This signal is emitted when the user activates an <code>item</code> by <code>single-</code> or <code>double-clicking</code> (depending on the platform, i.e. on the <code>QStyle::SH_ItemView_ActivateItemOnSingleClick</code> style hint) or pressing a special key (e.g., Enter). The specified <code>item</code> is the item that was clicked, or <code>0</code> if no item was clicked. The <code>column</code> is the item’s column that was clicked, or <code>-1</code> if no item was clicked.</li>
<li><code>QTreeWidgetItem * QTreeWidget::itemAt(const QPoint &amp; p) const</code>: Returns a pointer to the item at the coordinates <code>p</code>. The coordinates are relative to the tree widget’s <code>viewport()</code>.</li>
<li><code>QTreeWidgetItem * QTreeWidget::itemAt(int x, int y) const</code>: This is an overloaded function. Returns a pointer to the item at the coordinates <code>(x, y)</code>. The coordinates are relative to the tree widget’s <code>viewport()</code>.</li>
<li><code>QTreeWidgetItem * QTreeWidget::itemBelow(const QTreeWidgetItem * item) const</code>: Returns the item visually below the given <code>item</code>.</li>
<li><code>void QTreeWidget::itemChanged(QTreeWidgetItem * item, int column) [signal]</code>: This signal is emitted when the contents of the <code>column</code> in the specified <code>item</code> changes.</li>
<li><code>void QTreeWidget::itemClicked(QTreeWidgetItem * item, int column) [signal]</code>: This signal is emitted when the user clicks inside the widget. The specified <code>item</code> is the item that was clicked. The <code>column</code> is the item’s column that was clicked. If no item was clicked, no signal will be emitted.</li>
<li><code>void QTreeWidget::itemCollapsed(QTreeWidgetItem * item) [signal]</code>: This signal is emitted when the specified <code>item</code> is collapsed so that none of its children are displayed. <strong>Note</strong>: This signal will not be emitted if an item changes its state when <code>collapseAll()</code> is invoked.</li>
<li><code>void QTreeWidget::itemDoubleClicked(QTreeWidgetItem * item, int column) [signal]</code>: This signal is emitted when the user double clicks inside the widget. The specified <code>item</code> is the item that was clicked, or 0 if no item was clicked. The <code>column</code> is the item’s column that was clicked. If no item was double clicked, no signal will be emitted.</li>
<li><code>void QTreeWidget::itemEntered(QTreeWidgetItem * item, int column) [signal]</code>: This signal is emitted when the mouse cursor enters an <code>item</code> over the specified <code>column</code>. <code>QTreeWidget</code> mouse tracking needs to be enabled for this feature to work.</li>
<li><code>void QTreeWidget::itemExpanded(QTreeWidgetItem * item) [signal]</code>: This signal is emitted when the specified <code>item</code> is expanded so that all of its children are displayed. <strong>Note</strong>: This signal will not be emitted if an item changes its state when <code>expandAll()</code> is invoked.</li>
<li><code>QTreeWidgetItem * QTreeWidget::itemFromIndex(const QModelIndex &amp; index) const [protected]</code>: Returns a pointer to the <code>QTreeWidgetItem</code> assocated with the given <code>index</code>.</li>
<li><code>void QTreeWidget::itemPressed(QTreeWidgetItem * item, int column) [signal]</code>: This signal is emitted when the user presses a mouse button inside the widget. The specified <code>item</code> is the item that was clicked, or <code>0</code> if no item was clicked. The <code>column</code> is the item’s column that was clicked, or <code>-1</code> if no item was clicked.</li>
<li><code>void QTreeWidget::itemSelectionChanged() [signal]</code>: This signal is emitted when the selection changes in the tree widget. The current selection can be found with <code>selectedItems()</code>.</li>
<li><code>QWidget * QTreeWidget::itemWidget(QTreeWidgetItem * item, int column) const</code>: Returns the widget displayed in the cell specified by <code>item</code> and the given <code>column</code>. <strong>Note</strong>: The tree takes ownership of the widget.</li>
<li><code>QMimeData * QTreeWidget::mimeData(const QList&lt;QTreeWidgetItem *&gt; items) const [virtual protected]</code>: Returns an object that contains a serialized description of the specified <code>items</code>. The format used to describe the items is obtained from the <code>mimeTypes()</code> function. If the list of <code>items</code> is empty, <code>0</code> is returned rather than a serialized empty list.</li>
<li><code>QStringList QTreeWidget::mimeTypes() const [virtual protected]</code>: Returns a list of <code>MIME</code> types that can be used to describe a list of treewidget items.</li>
<li><code>void QTreeWidget::openPersistentEditor(QTreeWidgetItem * item, int column = 0)</code>: Opens a persistent editor for the <code>item</code> in the given <code>column</code>.</li>
<li><code>void QTreeWidget::removeItemWidget(QTreeWidgetItem * item, int column)</code>: Removes the widget set in the given <code>item</code> in the given <code>column</code>.</li>
<li><code>void QTreeWidget::scrollToItem(const QTreeWidgetItem * item, QAbstractItemView::ScrollHint hint = EnsureVisible) [slot]</code>: Ensures that the <code>item</code> is visible, scrolling the view if necessary using the specified <code>hint</code>.</li>
<li><code>QList&lt;QTreeWidgetItem *&gt; QTreeWidget::selectedItems() const</code>: Returns a list of all selected <code>non-hidden</code> items.</li>
<li><code>void QTreeWidget::setCurrentItem(QTreeWidgetItem * item)</code>: Sets the current <code>item</code> in the tree widget. Unless the selection mode is <code>NoSelection</code>, the item is also be selected.</li>
<li><code>void QTreeWidget::setCurrentItem(QTreeWidgetItem * item, int column)</code>: Sets the current <code>item</code> in the tree widget and the current <code>column</code> to column.</li>
<li><code>void QTreeWidget::setCurrentItem(QTreeWidgetItem * item, int column, QItemSelectionModel::SelectionFlags command)</code>: Sets the current <code>item</code> in the tree widget and the current <code>column</code> to column, using the given <code>command</code>.</li>
<li><code>void QTreeWidget::setFirstItemColumnSpanned(const QTreeWidgetItem * item, bool span)</code>: Sets the given <code>item</code> to only show one section for all columns if <code>span</code> is <code>true</code>; otherwise the item will show one section per column.</li>
<li><code>void QTreeWidget::setHeaderItem(QTreeWidgetItem * item)</code>: Sets the header <code>item</code> for the tree widget. The label for each column in the header is supplied by the corresponding label in the item. The tree widget takes ownership of the item.</li>
<li><code>void QTreeWidget::setHeaderLabel(const QString &amp; label)</code>: Same as <code>setHeaderLabels(QStringList(label))</code>.</li>
<li><code>void QTreeWidget::setHeaderLabels(const QStringList &amp; labels)</code>: Adds a column in the header for each item in the <code>labels</code> list, and sets the label for each column. Note that <code>setHeaderLabels()</code> won’t remove existing columns.</li>
<li><code>void QTreeWidget::setItemWidget(QTreeWidgetItem * item, int column, QWidget * widget)</code>: Sets the given <code>widget</code> to be displayed in the cell specified by the given <code>item</code> and <code>column</code>. The given widget’s <code>autoFillBackground</code> property must be set to <code>true</code>, otherwise the widget’s background will be transparent, showing both the model data and the tree widget item. This function should only be used to display static content in the place of a tree widget item. If you want to display custom dynamic content or implement a custom editor widget, use <code>QTreeView</code> and subclass <code>QItemDelegate</code> instead. This function cannot be called before the item hierarchy has been set up, i.e., the <code>QTreeWidgetItem</code> that will hold widget must have been added to the view before widget is set. <strong>Note</strong>: The tree takes ownership of the widget.</li>
<li><code>void QTreeWidget::setSelectionModel(QItemSelectionModel * selectionModel) [virtual]</code>: Reimplemented from <code>QAbstractItemView::setSelectionModel()</code>.</li>
<li><code>int QTreeWidget::sortColumn() const</code>: Returns the column used to sort the contents of the widget.</li>
<li><code>void QTreeWidget::sortItems(int column, Qt::SortOrder order)</code>: Sorts the items in the widget in the specified <code>order</code> by the values in the given <code>column</code>.</li>
<li><code>Qt::DropActions QTreeWidget::supportedDropActions() const [virtual protected]</code>: Returns the drop actions supported by this view.</li>
<li><code>QTreeWidgetItem * QTreeWidget::takeTopLevelItem(int index)</code>: Removes the <code>top-level</code> item at the given <code>index</code> in the tree and returns it, otherwise returns <code>0</code>.</li>
<li><code>QTreeWidgetItem * QTreeWidget::topLevelItem(int index) const</code>: Returns the top level item at the given <code>index</code>, or <code>0</code> if the item does not exist.</li>
<li><code>QRect QTreeWidget::visualItemRect(const QTreeWidgetItem * item) const</code>: Returns the rectangle on the viewport occupied by the <code>item</code> at item.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/22/Qt语法详解/Qt之QTextTableFormat/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/22/Qt语法详解/Qt之QTextTableFormat/" itemprop="url">Qt之QTextTableFormat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T10:35:23+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTextTableFormat</code> class provides formatting information for tables in a <code>QTextDocument</code>.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextTableFormat</code></td>
<td><code>QTextFrameFormat</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextTableFormat()</code></td>
</tr>
<tr>
<td><code>Qt::Alignment</code></td>
<td><code>alignment() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>cellPadding() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>cellSpacing() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clearColumnWidthConstraints()</code></td>
</tr>
<tr>
<td><code>QVector&lt;QTextLength&gt;</code></td>
<td><code>columnWidthConstraints() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>columns() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>headerRowCount() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isValid() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setAlignment(Qt::Alignment alignment)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCellPadding(qreal padding)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCellSpacing(qreal spacing)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setColumnWidthConstraints(const QVector&lt;QTextLength&gt; &amp; constraints)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHeaderRowCount(int count)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextTableFormat</code> class provides formatting information for tables in a <code>QTextDocument</code>.<br>&emsp;&emsp;A table is a group of cells ordered into rows and columns. Each table contains at least one row and one column. Each cell contains a block. Tables in rich text documents are formatted using the properties defined in this class.<br>&emsp;&emsp;Tables are horizontally justified within their parent frame according to the table’s alignment. This can be read with the <code>alignment()</code> function and set with <code>setAlignment()</code>.<br>&emsp;&emsp;Cells within the table are separated by cell spacing. The number of pixels between cells is set with <code>setCellSpacing()</code> and read with <code>cellSpacing()</code>. The contents of each cell is surrounded by cell padding. The number of pixels between each cell edge and its contents is set with <code>setCellPadding()</code> and read with <code>cellPadding()</code>.</p>
<p><img src="/2019/02/22/Qt语法详解/Qt之QTextTableFormat/1.png" height="154" width="219"></p>
<p>&emsp;&emsp;The table’s background color can be read with the <code>background()</code> function, and can be specified with <code>setBackground()</code>. The background color of each cell can be set independently, and will control the color of the cell within the padded area.<br>&emsp;&emsp;The table format also provides a way to constrain the widths of the columns in the table. Columns can be assigned a fixed width, a variable width, or a percentage of the available width. The <code>columns()</code> function returns the number of columns with constraints, and the <code>columnWidthConstraints()</code> function returns the constraints defined for the table. These quantities can also be set by calling <code>setColumnWidthConstraints()</code> with a vector containing new constraints. If no constraints are required, <code>clearColumnWidthConstraints()</code> can be used to remove them.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextTableFormat::QTextTableFormat()</code>: Constructs a new table format object.</li>
<li><code>Qt::Alignment QTextTableFormat::alignment() const</code>: Returns the table’s alignment.</li>
<li><code>qreal QTextTableFormat::cellPadding() const</code>: Returns the table’s cell padding. This describes the distance between the border of a cell and its contents.</li>
<li><code>qreal QTextTableFormat::cellSpacing() const</code>: Returns the table’s cell spacing. This describes the distance between adjacent cells.</li>
<li><code>void QTextTableFormat::clearColumnWidthConstraints()</code>: Clears the column width constraints for the table.</li>
<li><code>QVector&lt;QTextLength&gt; QTextTableFormat::columnWidthConstraints() const</code>: Returns a list of constraints used by this table format to control the appearance of columns in a table.</li>
<li><code>int QTextTableFormat::columns() const</code>: Returns the number of columns specified by the table format.</li>
<li><code>int QTextTableFormat::headerRowCount() const</code>: Returns the number of rows in the table that define the header.</li>
<li><code>bool QTextTableFormat::isValid() const</code>: Returns true if this table format is valid; otherwise returns false.</li>
<li><code>void QTextTableFormat::setAlignment(Qt::Alignment alignment)</code>: Sets the table’s <code>alignment</code>.</li>
<li><code>void QTextTableFormat::setCellPadding(qreal padding)</code>: Sets the cell <code>padding</code> for the table. This determines the distance between the border of a cell and its contents.</li>
<li><code>void QTextTableFormat::setCellSpacing(qreal spacing)</code>: Sets the cell <code>spacing</code> for the table. This determines the distance between adjacent cells.</li>
<li><code>void QTextTableFormat::setColumnWidthConstraints(const QVector&lt;QTextLength&gt; &amp; constraints)</code>: Sets the column width <code>constraints</code> for the table.</li>
<li><code>void QTextTableFormat::setHeaderRowCount(int count)</code>: Declares the first <code>count</code> rows of the table as table header. The table header rows get repeated when a table is broken across a page boundary.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/21/Qt语法详解/Qt之QComboBox/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/21/Qt语法详解/Qt之QComboBox/" itemprop="url">Qt之QComboBox</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-21T16:23:06+08:00">
                2019-02-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>QComboBox</code>提供了下拉列表框的控件，下面简单地介绍几个的方法和属性。<br>&emsp;&emsp;<code>addItems</code>在列表的最后一项添加一个文本内容为<code>text</code>选项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addItem</span> <span class="params">( <span class="keyword">const</span> QString &amp;text, <span class="keyword">const</span> QVariant &amp;userData = QVariant() )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addItem</span> <span class="params">( <span class="keyword">const</span> QIcon &amp;icon, <span class="keyword">const</span> QString &amp;text, <span class="keyword">const</span> QVariant &amp;userData = QVariant() )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>currentText</code>返回下拉列表框中当前选中的文本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">currentText</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>count</code>返回当前列表框中选项数量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>currentIndex</code>返回当前列表框中选中文本的序号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">currentIndex</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QComboBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line">​</span><br><span class="line">Widget::Widget ( QWidget *parent ) : QWidget ( parent ) &#123;</span><br><span class="line">    QComboBox *combobox = <span class="keyword">new</span> QComboBox ( <span class="keyword">this</span> );</span><br><span class="line">    combobox-&gt;addItem ( tr ( <span class="string">"Circle"</span> ) );</span><br><span class="line">    combobox-&gt;addItem ( tr ( <span class="string">"Pology"</span> ) );</span><br><span class="line">    QGridLayout *mainLayout = <span class="keyword">new</span> QGridLayout ( <span class="keyword">this</span> );</span><br><span class="line">    mainLayout-&gt;addWidget ( combobox, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"Now there are "</span> &lt;&lt; combobox-&gt;count() &lt;&lt; <span class="string">"Items"</span>;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"The current item is"</span> &lt;&lt; combobox-&gt;currentText();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">Widget::~Widget() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/21/Qt语法详解/Qt之QComboBox/1.png"></p>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Now there are <span class="number">2</span> Items</span><br><span class="line">The current item is <span class="string">"Circle"</span></span><br></pre></td></tr></table></figure>
<hr>
<p>&emsp;&emsp;The <code>QComboBox</code> widget is a combined button and popup list.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QComboBox</code></td>
<td><code>QWidget</code></td>
<td><code>QFontComboBox</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QComboBox(QWidget * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QComboBox()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addItem(const QString &amp; text, const QVariant &amp; userData = QVariant())</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addItem(const QIcon &amp; icon, const QString &amp; text, const QVariant &amp; userData = QVariant())</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addItems(const QStringList &amp; texts)</code></td>
</tr>
<tr>
<td><code>QCompleter *</code></td>
<td><code>completer() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>currentIndex() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>currentText() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>duplicatesEnabled() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>findData(const QVariant &amp; data, int role = Qt::UserRole, Qt::MatchFlags flags = static_cast<qt::matchflags> ( Qt::MatchExactly &#124; Qt::MatchCaseSensitive )) const<code \=""></code></qt::matchflags></code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>findText(const QString &amp; text, Qt::MatchFlags flags = static_cast<qt::matchflags> ( Qt::MatchExactly &#124; Qt::MatchCaseSensitive )) const<code \=""></code></qt::matchflags></code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasFrame() const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>hidePopup()</code></td>
</tr>
<tr>
<td><code>QSize</code></td>
<td><code>iconSize() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertItem(int index, const QString &amp; text, const QVariant &amp; userData = QVariant())</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertItem(int index, const QIcon &amp; icon, const QString &amp; text, const QVariant &amp; userData = QVariant())</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertItems(int index, const QStringList &amp; list)</code></td>
</tr>
<tr>
<td><code>InsertPolicy</code></td>
<td><code>insertPolicy() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertSeparator(int index)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEditable() const</code></td>
</tr>
<tr>
<td><code>QVariant</code></td>
<td><code>itemData(int index, int role = Qt::UserRole) const</code></td>
</tr>
<tr>
<td><code>QAbstractItemDelegate *</code></td>
<td><code>itemDelegate() const</code></td>
</tr>
<tr>
<td><code>QIcon</code></td>
<td><code>itemIcon(int index) const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>itemText(int index) const</code></td>
</tr>
<tr>
<td><code>QLineEdit *</code></td>
<td><code>lineEdit() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>maxCount() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>maxVisibleItems() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>minimumContentsLength() const</code></td>
</tr>
<tr>
<td><code>QAbstractItemModel *</code></td>
<td><code>model() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>modelColumn() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeItem(int index)</code></td>
</tr>
<tr>
<td><code>QModelIndex</code></td>
<td><code>rootModelIndex() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCompleter(QCompleter * completer)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDuplicatesEnabled(bool enable)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setEditable(bool editable)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFrame(bool)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setIconSize(const QSize &amp; size)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setInsertPolicy(InsertPolicy policy)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setItemData(int index, const QVariant &amp; value, int role = Qt::UserRole)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setItemDelegate(QAbstractItemDelegate * delegate)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setItemIcon(int index, const QIcon &amp; icon)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setItemText(int index, const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setLineEdit(QLineEdit * edit)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMaxCount(int max)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMaxVisibleItems(int maxItems)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMinimumContentsLength(int characters)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setModel(QAbstractItemModel * model)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setModelColumn(int visibleColumn)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setRootModelIndex(const QModelIndex &amp; index)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSizeAdjustPolicy(SizeAdjustPolicy policy)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setValidator(const QValidator * validator)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setView(QAbstractItemView * itemView)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>showPopup()</code></td>
</tr>
<tr>
<td><code>SizeAdjustPolicy</code></td>
<td><code>sizeAdjustPolicy() const</code></td>
</tr>
<tr>
<td><code>const QValidator *</code></td>
<td><code>validator() const</code></td>
</tr>
<tr>
<td><code>QAbstractItemView *</code></td>
<td><code>view() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Public-Functions"><a href="#Reimplemented-Public-Functions" class="headerlink" title="Reimplemented Public Functions"></a>Reimplemented Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual bool</code></td>
<td><code>event(QEvent * event)</code></td>
</tr>
<tr>
<td><code>virtual QSize</code></td>
<td><code>minimumSizeHint() const</code></td>
</tr>
<tr>
<td><code>virtual QSize</code></td>
<td><code>sizeHint() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Slots"><a href="#Public-Slots" class="headerlink" title="Public Slots"></a>Public Slots</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clearEditText()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentIndex(int index)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setEditText(const QString &amp; text)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>activated(int index)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>activated(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>currentIndexChanged(int index)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>currentIndexChanged(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>editTextChanged(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>highlighted(int index)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>highlighted(const QString &amp; text)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><ul>
<li><code>void initStyleOption(QStyleOptionComboBox * option) const</code></li>
</ul>
<h3 id="Reimplemented-Protected-Functions"><a href="#Reimplemented-Protected-Functions" class="headerlink" title="Reimplemented Protected Functions"></a>Reimplemented Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual void</code></td>
<td><code>changeEvent(QEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>contextMenuEvent(QContextMenuEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>focusInEvent(QFocusEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>focusOutEvent(QFocusEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>hideEvent(QHideEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>inputMethodEvent(QInputMethodEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual QVariant</code></td>
<td><code>inputMethodQuery(Qt::InputMethodQuery query) const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>keyPressEvent(QKeyEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>keyReleaseEvent(QKeyEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>mousePressEvent(QMouseEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>mouseReleaseEvent(QMouseEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>paintEvent(QPaintEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>resizeEvent(QResizeEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>showEvent(QShowEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>wheelEvent(QWheelEvent * e)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QComboBox</code> widget is a combined button and popup list.<br>&emsp;&emsp;A <code>QComboBox</code> provides a means of presenting a list of options to the user in a way that takes up the minimum amount of screen space.<br>&emsp;&emsp;A combobox is a selection widget that displays the current item, and can pop up a list of selectable items. A combobox may be editable, allowing the user to modify each item in the list.<br>&emsp;&emsp;Comboboxes can contain pixmaps as well as strings; the <code>insertItem()</code> and <code>setItemText()</code> functions are suitably overloaded. For editable comboboxes, the function <code>clearEditText()</code> is provided, to clear the displayed string without changing the combobox’s contents.<br>&emsp;&emsp;There are two signals emitted if the current item of a combobox changes, <code>currentIndexChanged()</code> and <code>activated()</code>. <code>currentIndexChanged()</code> is always emitted regardless if the change was done programmatically or by user interaction, while <code>activated()</code> is only emitted when the change is caused by user interaction. The <code>highlighted()</code> signal is emitted when the user highlights an item in the combobox popup list. All three signals exist in two versions, one with a <code>QString</code> argument and one with an int argument. If the user selects or highlights a pixmap, only the int signals are emitted. Whenever the text of an editable combobox is changed the <code>editTextChanged()</code> signal is emitted.<br>&emsp;&emsp;When the user enters a new string in an editable combobox, the widget may or may not insert it, and it can insert it in several locations. The default policy is is <code>AtBottom</code> but you can change this using <code>setInsertPolicy()</code>.<br>&emsp;&emsp;It is possible to constrain the input to an editable combobox using <code>QValidator</code>; see <code>setValidator()</code>. By default, any input is accepted.<br>&emsp;&emsp;A combobox can be populated using the insert functions, <code>insertItem()</code> and <code>insertItems()</code> for example. Items can be changed with <code>setItemText()</code>. An item can be removed with <code>removeItem()</code> and all items can be removed with <code>clear()</code>. The text of the current item is returned by <code>currentText()</code>, and the text of a numbered item is returned with <code>text()</code>. The current item can be set with <code>setCurrentIndex()</code>. The number of items in the combobox is returned by <code>count()</code>; the maximum number of items can be set with <code>setMaxCount()</code>. You can allow editing using <code>setEditable()</code>. For editable comboboxes you can set <code>auto-completion</code> using <code>setCompleter()</code> and whether or not the user can add duplicates is set with <code>setDuplicatesEnabled()</code>.<br>&emsp;&emsp;<code>QComboBox</code> uses the <code>model/view</code> framework for its popup list and to store its items. By default a <code>QStandardItemModel</code> stores the items and a <code>QListView</code> subclass displays the popuplist. You can access the model and view directly (with <code>model()</code> and <code>view()</code>), but <code>QComboBox</code> also provides functions to set and get item data (e.g., <code>setItemData()</code> and <code>itemText()</code>). You can also set a new model and view (with <code>setModel()</code> and <code>setView()</code>). For the text and icon in the combobox label, the data in the model that has the <code>Qt::DisplayRole</code> and <code>Qt::DecorationRole</code> is used. Note that you cannot alter the <code>SelectionMode</code> of the <code>view()</code>, e.g., by using <code>setSelectionMode()</code>.</p>
<p><img src="/2019/02/21/Qt语法详解/Qt之QComboBox/2.png"></p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QComboBox::InsertPolicy</code>: This enum specifies what the <code>QComboBox</code> should do when a new string is entered by the user.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QComboBox::NoInsert</code></td>
<td><code>0</code></td>
<td>The string will not be inserted into the combobox.</td>
</tr>
<tr>
<td><code>QComboBox::InsertAtTop</code></td>
<td><code>1</code></td>
<td>The string will be inserted as the first item in the combobox.</td>
</tr>
<tr>
<td><code>QComboBox::InsertAtCurrent</code></td>
<td><code>2</code></td>
<td>The current item will be replaced by the string.</td>
</tr>
<tr>
<td><code>QComboBox::InsertAtBottom</code></td>
<td><code>3</code></td>
<td>The string will be inserted after the last item in the combobox.</td>
</tr>
<tr>
<td><code>QComboBox::InsertAfterCurrent</code></td>
<td><code>4</code></td>
<td>The string is inserted after the current item in the combobox.</td>
</tr>
<tr>
<td><code>QComboBox::InsertBeforeCurrent</code></td>
<td><code>5</code></td>
<td>The string is inserted before the current item in the combobox.</td>
</tr>
<tr>
<td><code>QComboBox::InsertAlphabetically</code></td>
<td><code>6</code></td>
<td>The string is inserted in the alphabetic order in the combobox.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QComboBox::SizeAdjustPolicy</code>: This enum specifies how the size hint of the <code>QComboBox</code> should adjust when new content is added or content changes.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QComboBox::AdjustToContents</code></td>
<td><code>0</code></td>
<td>The combobox will always adjust to the contents</td>
</tr>
<tr>
<td><code>QComboBox::AdjustToContentsOnFirstShow</code></td>
<td><code>1</code></td>
<td>The combobox will adjust to its contents the first time it is shown.</td>
</tr>
<tr>
<td><code>QComboBox::AdjustToMinimumContentsLength</code></td>
<td><code>2</code></td>
<td>Use <code>AdjustToContents</code> or <code>AdjustToContentsOnFirstShow</code> instead.</td>
</tr>
<tr>
<td><code>QComboBox::AdjustToMinimumContentsLengthWithIcon</code></td>
<td><code>3</code></td>
<td>The combobox will adjust to <code>minimumContentsLength</code> plus space for an icon. For performance reasons use this policy on large models.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Property-Documentation"><a href="#Property-Documentation" class="headerlink" title="Property Documentation"></a>Property Documentation</h3><ul>
<li><code>count : const int</code>: This property holds the number of items in the combobox. By default, for an empty combo box, this property has a value of <code>0</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>currentIndex : int</code>: This property holds the index of the current item in the combobox. The current index can change when inserting or removing items. By default, for an empty combo box or a combo box in which no current item is set, this property has a value of <code>-1</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">currentIndex</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCurrentIndex</span> <span class="params">( <span class="keyword">int</span> index )</span></span></span><br></pre></td></tr></table></figure>
<p>Notifier signal:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">currentIndexChanged</span> <span class="params">( <span class="keyword">int</span> index )</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">currentIndexChanged</span> <span class="params">( <span class="keyword">const</span> QString &amp;text )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>currentText : const QString</code>: This property holds the current text. If the combo box is editable, the current text is the value displayed by the line edit. Otherwise, it is the value of the current item or an empty string if the combo box is empty or no current item is set. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">currentText</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>duplicatesEnabled : bool</code>: This property holds whether the user can enter duplicate items into the combobox. Note that it is always possible to programmatically insert duplicate items into the combobox. By default, this property is false (duplicates are not allowed). Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicatesEnabled</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDuplicatesEnabled</span> <span class="params">( <span class="keyword">bool</span> enable )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>editable : bool</code>: This property holds whether the combo box can be edited by the user. By default, this property is false. The effect of editing depends on the insert policy. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEditable</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEditable</span> <span class="params">( <span class="keyword">bool</span> editable )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>frame : bool</code>: This property holds whether the combo box draws itself with a frame. If enabled (the default) the combo box draws itself inside a frame, otherwise the combo box draws itself without any frame. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasFrame</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFrame</span> <span class="params">( <span class="keyword">bool</span> )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>iconSize : QSize</code>: This property holds the size of the icons shown in the combobox. Unless explicitly set this returns the default value of the current style. This size is the maximum size that icons can have; icons of smaller size are not scaled up. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QSize <span class="title">iconSize</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIconSize</span> <span class="params">( <span class="keyword">const</span> QSize &amp;size )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>insertPolicy : InsertPolicy</code>: This property holds the policy used to determine where <code>user-inserted</code> items should appear in the combobox. The default value is <code>AtBottom</code>, indicating that new items will appear at the bottom of the list of items. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InsertPolicy <span class="title">insertPolicy</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInsertPolicy</span> <span class="params">( InsertPolicy policy )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>maxCount : int</code>: This property holds the maximum number of items allowed in the combobox. <strong>Note</strong>: If you set the maximum number to be less then the current amount of items in the combobox, the extra items will be truncated. This also applies if you have set an external model on the combobox. By default, this property’s value is derived from the highest signed integer available (typically <code>2147483647</code>). Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMaxCount</span> <span class="params">( <span class="keyword">int</span> max )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>maxVisibleItems : int</code>: This property holds the maximum allowed size on screen of the combo box, measured in items. By default, this property has a value of <code>10</code>. <strong>Note</strong>: This property is ignored for <code>non-editable</code> comboboxes in styles that returns true for <code>QStyle::SH_ComboBox_Popup</code> such as the <code>Mac</code> style or the <code>Gtk+</code> Style. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxVisibleItems</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMaxVisibleItems</span> <span class="params">( <span class="keyword">int</span> maxItems )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>minimumContentsLength : int</code>: This property holds the minimum number of characters that should fit into the combobox. The default value is <code>0</code>. If this property is set to a positive value, the <code>minimumSizeHint()</code> and <code>sizeHint()</code> take it into account. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumContentsLength</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMinimumContentsLength</span> <span class="params">( <span class="keyword">int</span> characters )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>modelColumn : int</code>: This property holds the column in the model that is visible. If set prior to populating the combo box, the <code>pop-up</code> view will not be affected and will show the first column (using this property’s default value). By default, this property has a value of <code>0</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modelColumn</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setModelColumn</span> <span class="params">( <span class="keyword">int</span> visibleColumn )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>sizeAdjustPolicy : SizeAdjustPolicy</code>: This property holds the policy describing how the size of the combobox changes when the content changes. The default value is <code>AdjustToContentsOnFirstShow</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SizeAdjustPolicy <span class="title">sizeAdjustPolicy</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSizeAdjustPolicy</span> <span class="params">( SizeAdjustPolicy policy )</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QComboBox::QComboBox(QWidget * parent = 0)</code>: Constructs a combobox with the given <code>parent</code>, using the default model <code>QStandardItemModel</code>.</li>
<li><code>QComboBox::~QComboBox()</code>: Destroys the combobox.</li>
<li><code>void QComboBox::activated(int index) [signal]</code>: This signal is sent when the user chooses an item in the combobox. The item’s <code>index</code> is passed. Note that this signal is sent even when the choice is not changed. If you need to know when the choice actually changes, use signal <code>currentIndexChanged()</code>.</li>
<li><code>void QComboBox::activated(const QString &amp; text) [signal]</code>: This signal is sent when the user chooses an item in the combobox. The item’s <code>text</code> is passed. Note that this signal is sent even when the choice is not changed. If you need to know when the choice actually changes, use signal <code>currentIndexChanged()</code>.</li>
<li><code>void QComboBox::addItem(const QString &amp; text, const QVariant &amp; userData = QVariant())</code>: Adds an item to the combobox with the given <code>text</code>, and containing the specified <code>userData</code> (stored in the <code>Qt::UserRole</code>). The item is appended to the list of existing items.</li>
<li><code>void QComboBox::addItem(const QIcon &amp; icon, const QString &amp; text, const QVariant &amp; userData = QVariant())</code>: Adds an item to the combobox with the given <code>icon</code> and <code>text</code>, and containing the specified <code>userData</code> (stored in the <code>Qt::UserRole</code>). The item is appended to the list of existing items.</li>
<li><code>void QComboBox::addItems(const QStringList &amp; texts)</code>: Adds each of the strings in the given <code>texts</code> to the combobox. Each item is appended to the list of existing items in turn.  </li>
<li><code>void QComboBox::changeEvent(QEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::changeEvent()</code>.</li>
<li><code>void QComboBox::clear() [slot]</code>: Clears the combobox, removing all items. <strong>Note</strong>: If you have set an external model on the combobox this model will still be cleared when calling this function.</li>
<li><code>void QComboBox::clearEditText() [slot]</code>: Clears the contents of the line edit used for editing in the combobox.</li>
<li><code>QCompleter * QComboBox::completer() const</code>: Returns the completer that is used to auto complete text input for the combobox.</li>
<li><code>void QComboBox::contextMenuEvent(QContextMenuEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::contextMenuEvent()</code>.</li>
<li><code>void QComboBox::editTextChanged(const QString &amp; text) [signal]</code>: This signal is emitted when the <code>text</code> in the combobox’s line edit widget is changed. The new text is specified by <code>text</code>.</li>
<li><code>bool QComboBox::event(QEvent * event) [virtual]</code>: Reimplemented from <code>QObject::event()</code>.</li>
<li><code>int QComboBox::findData(const QVariant &amp; data, int role = Qt::UserRole, Qt::MatchFlags flags = static_cast&lt;Qt::MatchFlags&gt; ( Qt::MatchExactly | Qt::MatchCaseSensitive )) const</code>: Returns the index of the item containing the given <code>data</code> for the given <code>role</code>; otherwise returns <code>-1</code>. The <code>flags</code> specify how the items in the combobox are searched.</li>
<li><code>int QComboBox::findText(const QString &amp; text, Qt::MatchFlags flags = static_cast&lt;Qt::MatchFlags&gt; ( Qt::MatchExactly | Qt::MatchCaseSensitive )) const</code>: Returns the index of the item containing the given <code>text</code>; otherwise returns <code>-1</code>. The <code>flags</code> specify how the items in the combobox are searched.</li>
<li><code>void QComboBox::focusInEvent(QFocusEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::focusInEvent()</code>.</li>
<li><code>void QComboBox::focusOutEvent(QFocusEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::focusOutEvent()</code>.</li>
<li><code>void QComboBox::hideEvent(QHideEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::hideEvent()</code>.</li>
<li><code>void QComboBox::hidePopup() [virtual]</code>: Hides the list of items in the combobox if it is currently visible and resets the internal state, so that if the custom <code>pop-up</code> was shown inside the reimplemented <code>showPopup()</code>, then you also need to reimplement the <code>hidePopup()</code> function to hide your custom <code>pop-up</code> and call the base class implementation to reset the internal state whenever your custom <code>pop-up</code> widget is hidden.</li>
<li><code>void QComboBox::highlighted(int index) [signal]</code>: This signal is sent when an item in the combobox popup list is highlighted by the user. The item’s <code>index</code> is passed.</li>
<li><code>void QComboBox::highlighted(const QString &amp; text) [signal]</code>: This signal is sent when an item in the combobox popup list is highlighted by the user. The item’s <code>text</code> is passed.</li>
<li><code>void QComboBox::initStyleOption(QStyleOptionComboBox * option) const [protected]</code>:  Initialize <code>option</code> with the values from this <code>QComboBox</code>. This method is useful for subclasses when they need a <code>QStyleOptionComboBox</code>, but don’t want to fill in all the information themselves.</li>
<li><code>void QComboBox::inputMethodEvent(QInputMethodEvent * e) [virtual protected]</code>: Reimplemented from <code>QWidget::inputMethodEvent()</code>.</li>
<li><code>QVariant QComboBox::inputMethodQuery(Qt::InputMethodQuery query) const [virtual protected]</code>: Reimplemented from <code>QWidget::inputMethodQuery()</code>.</li>
<li><code>void QComboBox::insertItem(int index, const QString &amp; text, const QVariant &amp; userData = QVariant())</code>: Inserts the <code>text</code> and <code>userData</code> (stored in the <code>Qt::UserRole</code>) into the combobox at the given <code>index</code>. If the <code>index</code> is equal to or higher than the total number of items, the new item is appended to the list of existing items. If the <code>index</code> is <code>0</code> or negative, the new item is prepended to the list of existing items.</li>
<li><code>void QComboBox::insertItem(int index, const QIcon &amp; icon, const QString &amp; text, const QVariant &amp; userData = QVariant())</code>: Inserts the <code>icon</code>, <code>text</code> and <code>userData</code> (stored in the <code>Qt::UserRole</code>) into the combobox at the given <code>index</code>. If the <code>index</code> is equal to or higher than the total number of items, the new item is appended to the list of existing items. If the <code>index</code> is <code>0</code> or negative, the new item is prepended to the list of existing items.</li>
<li><p><code>void QComboBox::insertItems(int index, const QStringList &amp; list)</code>: Inserts the strings from the <code>list</code> into the combobox as separate items, starting at the <code>index</code> specified. If the <code>index</code> is equal to or higher than the total number of items, the new items are appended to the list of existing items. If the <code>index</code> is <code>0</code> or negative, the new items are prepended to the list of existing items.</p>
</li>
<li><p><code>void QComboBox::insertSeparator(int index)</code>: Inserts a separator item into the combobox at the given index. If the index is equal to or higher than the total number of items, the new item is appended to the list of existing items. If the index is zero or negative, the new item is prepended to the list of existing items.</p>
</li>
<li><code>QVariant QComboBox::itemData(int index, int role = Qt::UserRole) const</code>: Returns the data for the given role in the given index in the combobox, or QVariant::Invalid if there is no data for this role.</li>
<li><code>QAbstractItemDelegate * QComboBox::itemDelegate() const</code>: Returns the item delegate used by the popup list view.</li>
<li><code>QIcon QComboBox::itemIcon(int index) const</code>: Returns the icon for the given index in the combobox.</li>
<li><code>QString QComboBox::itemText(int index) const</code>: Returns the text for the given index in the combobox.</li>
<li><code>void QComboBox::keyPressEvent(QKeyEvent * e) [virtual protected]</code>: Reimplemented from QWidget::keyPressEvent().</li>
<li><code>void QComboBox::keyReleaseEvent(QKeyEvent * e) [virtual protected]</code>: Reimplemented from QWidget::keyReleaseEvent().</li>
<li><code>QLineEdit * QComboBox::lineEdit() const</code>: Returns the line edit used to edit items in the combobox, or 0 if there is no line edit. Only editable combo boxes have a line edit.</li>
<li><code>QSize QComboBox::minimumSizeHint() const [virtual]</code>: Reimplemented from QWidget::minimumSizeHint().</li>
<li><code>QAbstractItemModel * QComboBox::model() const</code>: Returns the model used by the combobox.</li>
<li><code>void QComboBox::mousePressEvent(QMouseEvent * e) [virtual protected]</code>: Reimplemented from QWidget::mousePressEvent().</li>
<li><code>void QComboBox::mouseReleaseEvent(QMouseEvent * e) [virtual protected]</code>: Reimplemented from QWidget::mouseReleaseEvent().</li>
<li><code>void QComboBox::paintEvent(QPaintEvent * e) [virtual protected]</code>: Reimplemented from QWidget::paintEvent().</li>
<li><code>void QComboBox::removeItem(int index)</code>: Removes the item at the given index from the combobox. This will update the current index if the index is removed. This function does nothing if index is out of range.</li>
<li><code>void QComboBox::resizeEvent(QResizeEvent * e) [virtual protected]</code>: Reimplemented from QWidget::resizeEvent().</li>
<li><code>QModelIndex QComboBox::rootModelIndex() const</code>: Returns the root model item index for the items in the combobox.</li>
<li><code>void QComboBox::setCompleter(QCompleter * completer)</code>: Sets the completer to use instead of the current completer. If completer is 0, auto completion is disabled. By default, for an editable combo box, a QCompleter that performs case insensitive inline completion is automatically created.</li>
<li><code>void QComboBox::setEditText(const QString &amp; text) [slot]</code>: Sets the text in the combobox’s text edit.</li>
<li><code>void QComboBox::setItemData(int index, const QVariant &amp; value, int role = Qt::UserRole)</code>: Sets the data role for the item on the given index in the combobox to the specified value.</li>
<li><code>void QComboBox::setItemDelegate(QAbstractItemDelegate * delegate)</code>: Sets the item delegate for the popup list view. The combobox takes ownership of the delegate. Warning: You should not share the same instance of a delegate between comboboxes, widget mappers or views. Doing so can cause incorrect or unintuitive editing behavior since each view connected to a given delegate may receive the closeEditor() signal, and attempt to access, modify or close an editor that has already been closed.</li>
<li><code>void QComboBox::setItemIcon(int index, const QIcon &amp; icon)</code>: Sets the icon for the item on the given index in the combobox.</li>
<li><code>void QComboBox::setItemText(int index, const QString &amp; text)</code>: Sets the text for the item on the given index in the combobox.</li>
<li><code>void QComboBox::setLineEdit(QLineEdit * edit)</code>: Sets the line edit to use instead of the current line edit widget. The combo box takes ownership of the line edit.</li>
<li><code>void QComboBox::setModel(QAbstractItemModel * model)</code>: Sets the model to be model. model must not be 0. If you want to clear the contents of a model, call clear().</li>
<li><code>void QComboBox::setRootModelIndex(const QModelIndex &amp; index)</code>: Sets the root model item index for the items in the combobox.</li>
<li><code>void QComboBox::setValidator(const QValidator * validator)</code>: Sets the validator to use instead of the current validator.</li>
<li><code>void QComboBox::setView(QAbstractItemView * itemView)</code>: Sets the view to be used in the combobox popup to the given itemView. The combobox takes ownership of the view. Note: If you want to use the convenience views (like QListWidget, QTableWidget or QTreeWidget), make sure to call setModel() on the combobox with the convenience widgets model before calling this function.</li>
<li><code>void QComboBox::showEvent(QShowEvent * e) [virtual protected]</code>: Reimplemented from QWidget::showEvent().</li>
<li><code>void QComboBox::showPopup() [virtual]</code>: Displays the list of items in the combobox. If the list is empty then the no items will be shown. If you reimplement this function to show a custom pop-up, make sure you call hidePopup() to reset the internal state.</li>
<li><code>QSize QComboBox::sizeHint() const [virtual]</code>: Reimplemented from QWidget::sizeHint(). This implementation caches the size hint to avoid resizing when the contents change dynamically. To invalidate the cached value change the sizeAdjustPolicy.</li>
<li><code>const QValidator * QComboBox::validator() const</code>: Returns the validator that is used to constrain text input for the combobox.</li>
<li><code>QAbstractItemView * QComboBox::view() const</code>: Returns the list view used for the combobox popup.</li>
<li><code>void QComboBox::wheelEvent(QWheelEvent * e) [virtual protected]</code>: Reimplemented from QWidget::wheelEvent().</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/20/Qt语法详解/Qt之QPixmap/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/20/Qt语法详解/Qt之QPixmap/" itemprop="url">Qt之QPixmap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-20T14:05:57+08:00">
                2019-02-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QPixmap</code> class is an <code>off-screen</code> image representation that can be used as a paint device.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPixmap</code></td>
<td><code>QPaintDevice</code></td>
<td><code>Q3CanvasPixmap</code> and <code>QBitmap</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Retrun</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QPixmap()</code></td>
</tr>
<tr>
<td></td>
<td><code>QPixmap(int width, int height)</code></td>
</tr>
<tr>
<td></td>
<td><code>QPixmap(const QString &amp; fileName, const char * format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor)</code></td>
</tr>
<tr>
<td></td>
<td><code>QPixmap(const char * const[] xpm)</code></td>
</tr>
<tr>
<td></td>
<td><code>QPixmap(const QPixmap &amp; pixmap)</code></td>
</tr>
<tr>
<td></td>
<td><code>QPixmap(const QSize &amp; size)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QPixmap()</code></td>
</tr>
<tr>
<td><code>qint64</code></td>
<td><code>cacheKey() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>convertFromImage(const QImage &amp; image, Qt::ImageConversionFlags flags = Qt::AutoColor)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>copy(const QRect &amp; rectangle = QRect()) const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>copy(int x, int y, int width, int height) const</code></td>
</tr>
<tr>
<td><code>QBitmap</code></td>
<td><code>createHeuristicMask(bool clipTight = true) const</code></td>
</tr>
<tr>
<td><code>QBitmap</code></td>
<td><code>createMaskFromColor(const QColor &amp; maskColor, Qt::MaskMode mode) const</code></td>
</tr>
<tr>
<td><code>QBitmap</code></td>
<td><code>createMaskFromColor(const QColor &amp; maskColor) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>depth() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>detach()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>fill(const QColor &amp; color = Qt::white)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>fill(const QWidget * widget, const QPoint &amp; offset)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>fill(const QWidget * widget, int x, int y)</code></td>
</tr>
<tr>
<td><code>Qt::HANDLE</code></td>
<td><code>handle() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasAlpha() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasAlphaChannel() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>height() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isNull() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isQBitmap() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>load(const QString &amp; fileName, const char * format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>loadFromData(const uchar * data, uint len, const char * format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>loadFromData(const QByteArray &amp; data, const char * format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor)</code></td>
</tr>
<tr>
<td><code>QBitmap</code></td>
<td><code>mask() const</code></td>
</tr>
<tr>
<td><code>QRect</code></td>
<td><code>rect() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>save(const QString &amp; fileName, const char * format = 0, int quality = -1) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>save(QIODevice * device, const char * format = 0, int quality = -1) const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>scaled(const QSize &amp; size, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation) const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>scaled(int width, int height, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation) const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>scaledToHeight(int height, Qt::TransformationMode mode = Qt::FastTransformation) const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>scaledToWidth(int width, Qt::TransformationMode mode = Qt::FastTransformation) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>scroll(int dx, int dy, int x, int y, int width, int height, QRegion * exposed = 0)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>scroll(int dx, int dy, const QRect &amp; rect, QRegion * exposed = 0)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMask(const QBitmap &amp; mask)</code></td>
</tr>
<tr>
<td><code>QSize</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(QPixmap &amp; other)</code></td>
</tr>
<tr>
<td><code>QImage</code></td>
<td><code>toImage() const</code></td>
</tr>
<tr>
<td><code>CGImageRef</code></td>
<td><code>toMacCGImageRef() const</code></td>
</tr>
<tr>
<td><code>HBITMAP</code></td>
<td><code>toWinHBITMAP(HBitmapFormat format = NoAlpha) const</code></td>
</tr>
<tr>
<td><code>HICON</code></td>
<td><code>toWinHICON() const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>transformed(const QTransform &amp; transform, Qt::TransformationMode mode = Qt::FastTransformation) const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>transformed(const QMatrix &amp; matrix, Qt::TransformationMode mode = Qt::FastTransformation) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>width() const</code></td>
</tr>
<tr>
<td><code>const QX11Info &amp;</code></td>
<td><code>x11Info() const</code></td>
</tr>
<tr>
<td><code>Qt::HANDLE</code></td>
<td><code>x11PictureHandle() const</code></td>
</tr>
<tr>
<td></td>
<td><code>operator QVariant() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!() const</code></td>
</tr>
<tr>
<td><code>QPixmap &amp;</code></td>
<td><code>operator=(const QPixmap &amp; pixmap)</code></td>
</tr>
<tr>
<td><code>QPixmap &amp;</code></td>
<td><code>operator=(QPixmap &amp;&amp; other)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Static-Public-Members"><a href="#Static-Public-Members" class="headerlink" title="Static Public Members"></a>Static Public Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td><code>defaultDepth()</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>fromImage(const QImage &amp; image, Qt::ImageConversionFlags flags = Qt::AutoColor)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>fromImageReader(QImageReader * imageReader, Qt::ImageConversionFlags flags = Qt::AutoColor)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>fromMacCGImageRef(CGImageRef image)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>fromWinHBITMAP(HBITMAP bitmap, HBitmapFormat format = NoAlpha)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>fromWinHICON(HICON icon)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>fromX11Pixmap(Qt::HANDLE pixmap, ShareMode mode = ImplicitlyShared)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>grabWidget(QWidget * widget, const QRect &amp; rectangle)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>grabWidget(QWidget * widget, int x = 0, int y = 0, int width = -1, int height = -1)</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>grabWindow(WId window, int x = 0, int y = 0, int width = -1, int height = -1)</code></td>
</tr>
<tr>
<td><code>QTransform</code></td>
<td><code>trueMatrix(const QTransform &amp; matrix, int width, int height)</code></td>
</tr>
<tr>
<td><code>QMatrix</code></td>
<td><code>trueMatrix(const QMatrix &amp; m, int w, int h)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&lt;&lt;(QDataStream &amp; stream, const QPixmap &amp; pixmap)</code></td>
</tr>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&gt;&gt;(QDataStream &amp; stream, QPixmap &amp; pixmap)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QPixmap</code> class is an <code>off-screen</code> image representation that can be used as a paint device.<br>&emsp;&emsp;<code>Qt</code> provides four classes for handling image data: <code>QImage</code>, <code>QPixmap</code>, <code>QBitmap</code> and <code>QPicture</code>. <code>QImage</code> is designed and optimized for <code>I/O</code>, and for direct pixel access and manipulation, while <code>QPixmap</code> is designed and optimized for showing images on screen. <code>QBitmap</code> is only a convenience class that inherits <code>QPixmap</code>, ensuring a depth of <code>1</code>. The <code>isQBitmap()</code> function returns <code>true</code> if a <code>QPixmap</code> object is really a bitmap, otherwise returns <code>false</code>. Finally, the <code>QPicture</code> class is a paint device that records and replays <code>QPainter</code> commands.<br>&emsp;&emsp;A <code>QPixmap</code> can easily be displayed on the screen using <code>QLabel</code> or one of <code>QAbstractButton&#39;s</code> subclasses (such as <code>QPushButton</code> and <code>QToolButton</code>). <code>QLabel</code> has a pixmap property, whereas <code>QAbstractButton</code> has an icon property.<br>&emsp;&emsp;In addition to the ordinary constructors, a <code>QPixmap</code> can be constructed using the static <code>grabWidget()</code> and <code>grabWindow()</code> functions which creates a <code>QPixmap</code> and paints the given widget, or window, into it.<br>&emsp;&emsp;<code>QPixmap</code> objects can be passed around by value since the <code>QPixmap</code> class uses implicit data sharing. <code>QPixmap</code> objects can also be streamed.<br>&emsp;&emsp;Note that the pixel data in a pixmap is internal and is managed by the underlying window system. Because <code>QPixmap</code> is a <code>QPaintDevice</code> subclass, <code>QPainter</code> can be used to draw directly onto pixmaps. Pixels can only be accessed through <code>QPainter</code> functions or by converting the <code>QPixmap</code> to a <code>QImage</code>. However, the <code>fill()</code> function is available for initializing the entire pixmap with a given color.<br>&emsp;&emsp;There are functions to convert between <code>QImage</code> and <code>QPixmap</code>. Typically, the <code>QImage</code> class is used to load an image file, optionally manipulating the image data, before the <code>QImage</code> object is converted into a <code>QPixmap</code> to be shown on screen. Alternatively, if no manipulation is desired, the image file can be loaded directly into a <code>QPixmap</code>. On <code>Windows</code>, the <code>QPixmap</code> class also supports conversion between <code>HBITMAP</code> and <code>QPixmap</code>. On <code>Symbian</code>, the <code>QPixmap</code> class also supports conversion between <code>CFbsBitmap</code> and <code>QPixmap</code>.<br>&emsp;&emsp;<code>QPixmap</code> provides a collection of functions that can be used to obtain a variety of information about the pixmap. In addition, there are several functions that enables transformation of the pixmap.</p>
<h3 id="Reading-and-Writing-Image-Files"><a href="#Reading-and-Writing-Image-Files" class="headerlink" title="Reading and Writing Image Files"></a>Reading and Writing Image Files</h3><p>&emsp;&emsp;<code>QPixmap</code> provides several ways of reading an image file: The file can be loaded when constructing the <code>QPixmap</code> object, or by using the <code>load()</code> or <code>loadFromData()</code> functions later on. When loading an image, the file name can either refer to an actual file on disk or to one of the application’s embedded resources.<br>&emsp;&emsp;Simply call the <code>save()</code> function to save a <code>QPixmap</code> object.<br>&emsp;&emsp;The complete list of supported file formats are available through the <code>QImageReader::supportedImageFormats()</code> and <code>QImageWriter::supportedImageFormats()</code> functions. New file formats can be added as plugins. By default, <code>Qt</code> supports the following formats:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Format</th>
<th>Description</th>
<th>Qt’s support</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BMP</code></td>
<td><code>Windows Bitmap</code></td>
<td><code>Read/write</code></td>
</tr>
<tr>
<td><code>GIF</code></td>
<td><code>Graphic Interchange Format</code></td>
<td><code>Read</code></td>
</tr>
<tr>
<td><code>JPG</code></td>
<td><code>Joint Photographic Experts Group</code></td>
<td><code>Read/write</code></td>
</tr>
<tr>
<td><code>JPEG</code></td>
<td><code>Joint Photographic Experts Group</code></td>
<td><code>Read/write</code></td>
</tr>
<tr>
<td><code>PNG</code></td>
<td><code>Portable Network Graphics</code></td>
<td><code>Read/write</code></td>
</tr>
<tr>
<td><code>PBM</code></td>
<td><code>Portable Bitmap</code></td>
<td><code>Read</code></td>
</tr>
<tr>
<td><code>PGM</code></td>
<td><code>Portable Graymap</code></td>
<td><code>Read</code></td>
</tr>
<tr>
<td><code>PPM</code></td>
<td><code>Portable Pixmap</code></td>
<td><code>Read/write</code></td>
</tr>
<tr>
<td><code>XBM</code></td>
<td><code>X11 Bitmap</code></td>
<td><code>Read/write</code></td>
</tr>
<tr>
<td><code>XPM</code></td>
<td><code>X11 Pixmap</code></td>
<td><code>Read/write</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Pixmap-Information"><a href="#Pixmap-Information" class="headerlink" title="Pixmap Information"></a>Pixmap Information</h3><p>&emsp;&emsp;<code>QPixmap</code> provides a collection of functions that can be used to obtain a variety of information about the pixmap:</p>
<p>&emsp;&emsp;1. <code>Geometry</code>: The <code>size()</code>, <code>width()</code> and <code>height()</code> functions provide information about the pixmap’s size. The <code>rect()</code> function returns the image’s enclosing rectangle.<br>&emsp;&emsp;2. <code>Alpha component</code>: The <code>hasAlphaChannel()</code> returns <code>true</code> if the pixmap has a format that respects the alpha channel, otherwise returns <code>false</code>. The <code>hasAlpha()</code>, <code>setMask()</code> and <code>mask()</code> functions are legacy and should not be used. They are potentially very slow.<br>&emsp;&emsp;The <code>createHeuristicMask()</code> function creates and returns a <code>1-bpp</code> heuristic mask (i.e. a <code>QBitmap</code>) for this pixmap. It works by selecting a color from one of the corners and then chipping away pixels of that color, starting at all the edges. The <code>createMaskFromColor()</code> function creates and returns a mask (i.e. a <code>QBitmap</code>) for the pixmap based on a given color.<br>&emsp;&emsp;3. <code>Low-level information</code>: The <code>depth()</code> function returns the depth of the pixmap. The <code>defaultDepth()</code> function returns the default depth, i.e. the depth used by the application on the given screen.<br>&emsp;&emsp;The <code>cacheKey()</code> function returns a number that uniquely identifies the contents of the <code>QPixmap</code> object.<br>&emsp;&emsp;The <code>x11Info()</code> function returns information about the configuration of the <code>X</code> display used by the screen to which the pixmap currently belongs. The <code>x11PictureHandle()</code> function returns the <code>X11</code> Picture handle of the pixmap for <code>XRender</code> support. Note that the two latter functions are only available on <code>x11</code>.</p>
<h3 id="Pixmap-Conversion"><a href="#Pixmap-Conversion" class="headerlink" title="Pixmap Conversion"></a>Pixmap Conversion</h3><p>&emsp;&emsp;A <code>QPixmap</code> object can be converted into a <code>QImage</code> using the <code>toImage()</code> function. Likewise, a <code>QImage</code> can be converted into a <code>QPixmap</code> using the <code>fromImage()</code>. If this is too expensive an operation, you can use <code>QBitmap::fromImage()</code> instead.<br>&emsp;&emsp;In addition, on <code>Windows</code>, the <code>QPixmap</code> class supports conversion to and from <code>HBITMAP</code>: the <code>toWinHBITMAP()</code> function creates a <code>HBITMAP</code> equivalent to the <code>QPixmap</code>, based on the given <code>HBitmapFormat</code>, and returns the <code>HBITMAP</code> handle. The <code>fromWinHBITMAP()</code> function returns a <code>QPixmap</code> that is equivalent to the given bitmap which has the specified format. The <code>QPixmap</code> class also supports conversion to and from <code>HICON</code>: the <code>toWinHICON()</code> function creates a <code>HICON</code> equivalent to the <code>QPixmap</code>, and returns the <code>HICON</code> handle. The <code>fromWinHICON()</code> function returns a <code>QPixmap</code> that is equivalent to the given icon.</p>
<h3 id="Pixmap-Transformations"><a href="#Pixmap-Transformations" class="headerlink" title="Pixmap Transformations"></a>Pixmap Transformations</h3><p>&emsp;&emsp;<code>QPixmap</code> supports a number of functions for creating a new pixmap that is a transformed version of the original:<br>&emsp;&emsp;The <code>scaled()</code>, <code>scaledToWidth()</code> and <code>scaledToHeight()</code> functions return scaled copies of the pixmap, while the <code>copy()</code> function creates a <code>QPixmap</code> that is a plain copy of the original one.<br>&emsp;&emsp;The <code>transformed()</code> function returns a copy of the pixmap that is transformed with the given transformation matrix and transformation mode: Internally, the transformation matrix is adjusted to compensate for unwanted translation, i.e. <code>transformed()</code> returns the smallest pixmap containing all transformed points of the original pixmap. The static <code>trueMatrix()</code> function returns the actual matrix used for transforming the pixmap.<br>&emsp;&emsp;<strong>Note</strong>: When using the native <code>X11</code> graphics system, the pixmap becomes invalid when the <code>QApplication</code> instance is destroyed.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QPixmap::HBitmapFormat</code>: <code>Win32</code> only: This enum defines how the conversion between <code>HBITMAP</code> and <code>QPixmap</code> is performed. <strong>Warning</strong>: This enum is only available on <code>Windows</code>.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPixmap::NoAlpha</code></td>
<td><code>0</code></td>
<td>The alpha channel is ignored and always treated as being set to fully opaque. This is preferred if the <code>HBITMAP</code> is used with standard <code>GDI</code> calls, such as <code>BitBlt()</code>.</td>
</tr>
<tr>
<td><code>QPixmap::PremultipliedAlpha</code></td>
<td><code>1</code></td>
<td>The <code>HBITMAP</code> is treated as having an alpha channel and premultiplied colors. This is preferred if the <code>HBITMAP</code> is accessed through the <code>AlphaBlend()</code> <code>GDI</code> function.</td>
</tr>
<tr>
<td><code>QPixmap::Alpha</code></td>
<td><code>2</code></td>
<td>The <code>HBITMAP</code> is treated as having a plain alpha channel. This is the preferred format if the <code>HBITMAP</code> is going to be used as an application icon or systray icon.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QPixmap::ShareMode</code>: This enum type defines the share modes that are available when creating a <code>QPixmap</code> object from a raw <code>X11</code> <code>Pixmap</code> handle.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QPixmap::ImplicitlyShared</code></td>
<td><code>0</code></td>
<td>This mode will cause the <code>QPixmap</code> object to create a copy of the internal data before it is modified, thus keeping the original <code>X11</code> pixmap intact.</td>
</tr>
<tr>
<td><code>QPixmap::ExplicitlyShared</code></td>
<td><code>1</code></td>
<td>In this mode, the pixmap data will not be copied before it is modified, which in effect will change the original <code>X11</code> pixmap.</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Warning</strong>: This enum is only used for <code>X11</code> specific functions; using it is <code>non-portable</code>.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QPixmap::QPixmap()</code>: Constructs a null pixmap.</li>
<li><code>QPixmap::QPixmap(int width, int height)</code>: Constructs a pixmap with the given <code>width</code> and <code>height</code>. If either <code>width</code> or <code>height</code> is zero, a null pixmap is constructed. Warning: This will create a <code>QPixmap</code> with uninitialized data. Call <code>fill()</code> to fill the pixmap with an appropriate color before drawing onto it with <code>QPainter</code>.</li>
<li><code>QPixmap::QPixmap(const QString &amp; fileName, const char * format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor)</code>: Constructs a pixmap from the file with the given <code>fileName</code>. If the file does not exist or is of an unknown format, the pixmap becomes a null pixmap. The loader attempts to read the pixmap using the specified <code>format</code>. If the <code>format</code> is not specified (which is the default), the loader probes the file for a header to guess the file format. The file name can either refer to an actual file on disk or to one of the application’s embedded resources. If the image needs to be modified to fit in a <code>lower-resolution</code> result (e.g. converting from <code>32-bit</code> to <code>8-bit</code>), use the <code>flags</code> to control the conversion. The <code>fileName</code>, <code>format</code> and <code>flags</code> parameters are passed on to <code>load()</code>. This means that the data in <code>fileName</code> is not compiled into the binary. If <code>fileName</code> contains a relative path (e.g. the filename only) the relevant file must be found relative to the runtime working directory.</li>
<li><code>QPixmap::QPixmap(const char * const[] xpm)</code>: Constructs a pixmap from the given <code>xpm</code> data, which must be a valid <code>XPM</code> image. Errors are silently ignored. Note that it’s possible to squeeze the <code>XPM</code> variable a little bit by using an unusual declaration:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> start_xpm[]=&#123;</span><br><span class="line">    <span class="string">"16 15 8 1"</span>,</span><br><span class="line">    <span class="string">"a c #cec6bd"</span>,</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>The extra const makes the entire definition <code>read-only</code>, which is slightly more efficient (for example, when the code is in a shared library) and <code>ROMable</code> when the application is to be stored in <code>ROM</code>.</p>
<ul>
<li><code>QPixmap::QPixmap(const QPixmap &amp; pixmap)</code>: Constructs a pixmap that is a copy of the given <code>pixmap</code>.</li>
<li><code>QPixmap::QPixmap(const QSize &amp; size)</code>: This is an overloaded function. Constructs a pixmap of the given <code>size</code>. <strong>Warning</strong>: This will create a <code>QPixmap</code> with uninitialized data. Call <code>fill()</code> to fill the pixmap with an appropriate color before drawing onto it with <code>QPainter</code>.</li>
<li><code>QPixmap::~QPixmap()</code>: Destroys the pixmap.</li>
<li><code>qint64 QPixmap::cacheKey() const</code>: Returns a number that identifies this <code>QPixmap</code>. Distinct <code>QPixmap</code> objects can only have the same cache key if they refer to the same contents. The <code>cacheKey()</code> will change when the pixmap is altered.</li>
<li><code>bool QPixmap::convertFromImage(const QImage &amp; image, Qt::ImageConversionFlags flags = Qt::AutoColor)</code>: Replaces this pixmap’s data with the given <code>image</code> using the specified <code>flags</code> to control the conversion. The <code>flags</code> argument is a <code>bitwise-OR</code> of the <code>Qt::ImageConversionFlags</code>. Passing <code>0</code> for <code>flags</code> sets all the default options. Returns <code>true</code> if the result is that this pixmap is not null. <strong>Note</strong>: this function was part of <code>Qt 3</code> support in <code>Qt 4.6</code> and earlier. It has been promoted to official <code>API</code> status in <code>4.7</code> to support updating the pixmap’s image without creating a new <code>QPixmap</code> as <code>fromImage()</code> would.</li>
<li><code>QPixmap QPixmap::copy(const QRect &amp; rectangle = QRect()) const</code>: Returns a deep copy of the subset of the pixmap that is specified by the given <code>rectangle</code>. If the given <code>rectangle</code> is empty, the whole image is copied.</li>
<li><code>QPixmap QPixmap::copy(int x, int y, int width, int height) const</code>: This is an overloaded function. Returns a deep copy of the subset of the pixmap that is specified by the rectangle <code>QRect(x, y, width, height)</code>.</li>
<li><code>QBitmap QPixmap::createHeuristicMask(bool clipTight = true) const</code>: Creates and returns a heuristic mask for this pixmap. The function works by selecting a color from one of the corners and then chipping away pixels of that color, starting at all the edges. If <code>clipTight</code> is <code>true</code> (the default), the mask is just large enough to cover the pixels; otherwise, the mask is larger than the data pixels. The mask may not be perfect but it should be reasonable, so you can do things such as the following:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPixmap myPixmap;</span><br><span class="line">myPixmap-&gt;setMask ( myPixmap-&gt;createHeuristicMask() );</span><br></pre></td></tr></table></figure>
<p>This function is slow because it involves converting <code>to/from</code> a <code>QImage</code>, and <code>non-trivial</code> computations.</p>
<ul>
<li><code>QBitmap QPixmap::createMaskFromColor(const QColor &amp; maskColor, Qt::MaskMode mode) const</code>: Creates and returns a mask for this pixmap based on the given <code>maskColor</code>. If the <code>mode</code> is <code>Qt::MaskInColor</code>, all pixels matching the <code>maskColor</code> will be transparent. If <code>mode</code> is <code>Qt::MaskOutColor</code>, all pixels matching the <code>maskColor</code> will be opaque. This function is slow because it involves converting <code>to/from</code> a <code>QImage</code>.</li>
<li><code>QBitmap QPixmap::createMaskFromColor(const QColor &amp; maskColor) const</code>: This is an overloaded function. Creates and returns a mask for this pixmap based on the given <code>maskColor</code>. Same as calling <code>createMaskFromColor(maskColor, Qt::MaskInColor)</code>.</li>
<li><code>int QPixmap::defaultDepth() [static]</code>: Returns the default pixmap depth used by the application. On <code>Windows</code> and <code>Mac</code>, the default depth is always <code>32</code>. On <code>X11</code> and embedded, the depth of the screen will be returned by this function.</li>
<li><code>int QPixmap::depth() const</code>: Returns the depth of the pixmap. The pixmap depth is also called <code>bits per pixel</code> (<code>bpp</code>) or bit planes of a pixmap. A null pixmap has depth <code>0</code>.</li>
<li><code>void QPixmap::detach()</code>: Detaches the pixmap from shared pixmap data. A pixmap is automatically detached by <code>Qt</code> whenever its contents are about to change. This is done in almost all <code>QPixmap</code> member functions that modify the pixmap (<code>fill()</code>, <code>fromImage()</code>, <code>load()</code>, etc.), and in <code>QPainter::begin()</code> on a pixmap. There are two exceptions in which <code>detach()</code> must be called explicitly, that is when calling the <code>handle()</code> or the <code>x11PictureHandle()</code> function (only available on <code>X11</code>). Otherwise, any modifications done using system calls, will be performed on the shared data. The <code>detach()</code> function returns immediately if there is just a single reference or if the pixmap has not been initialized yet.</li>
<li><code>void QPixmap::fill(const QColor &amp; color = Qt::white)</code>: Fills the pixmap with the given <code>color</code>. The effect of this function is undefined when the pixmap is being painted on.</li>
<li><code>void QPixmap::fill(const QWidget * widget, const QPoint &amp; offset)</code>: Fills the pixmap with the <code>widget&#39;s</code> background color or pixmap according to the given <code>offset</code>. The <code>QPoint</code> <code>offset</code> defines a point in <code>widget</code> coordinates to which the pixmap’s <code>top-left</code> pixel will be mapped to. This is only significant if the <code>widget</code> has a background pixmap; otherwise the pixmap will simply be filled with the background color of the <code>widget</code>.</li>
<li><code>void QPixmap::fill(const QWidget * widget, int x, int y)</code>: This is an overloaded function. Fills the pixmap with the <code>widget&#39;s</code> background color or pixmap. The given point, <code>(x, y)</code>, defines an offset in <code>widget</code> coordinates to which the pixmap’s <code>top-left</code> pixel will be mapped to.</li>
<li><code>QPixmap QPixmap::fromImage(const QImage &amp; image, Qt::ImageConversionFlags flags = Qt::AutoColor) [static]</code>: Converts the given <code>image</code> to a pixmap using the specified <code>flags</code> to control the conversion. The <code>flags</code> argument is a <code>bitwise-OR</code> of the <code>Qt::ImageConversionFlags</code>. Passing <code>0</code> for <code>flags</code> sets all the default options. In case of monochrome and <code>8-bit</code> images, the <code>image</code> is first converted to a <code>32-bit</code> pixmap and then filled with the colors in the color table. If this is too expensive an operation, you can use <code>QBitmap::fromImage()</code> instead.</li>
<li><code>QPixmap QPixmap::fromImageReader(QImageReader * imageReader, Qt::ImageConversionFlags flags = Qt::AutoColor) [static]</code>: Create a <code>QPixmap</code> from an image read directly from an <code>imageReader</code>. The <code>flags</code> argument is a <code>bitwise-OR</code> of the <code>Qt::ImageConversionFlags</code>. Passing <code>0</code> for <code>flags</code> sets all the default options. On some systems, reading an image directly to <code>QPixmap</code> can use less memory than reading a <code>QImage</code> to convert it to <code>QPixmap</code>.</li>
<li><p><code>QPixmap QPixmap::fromMacCGImageRef(CGImageRef image) [static]</code>: Returns a <code>QPixmap</code> that is equivalent to the given <code>image</code>. <strong>Warning</strong>: This function is only available on <code>Mac OS X</code>.</p>
</li>
<li><p><code>QPixmap QPixmap::fromWinHBITMAP(HBITMAP bitmap, HBitmapFormat format = NoAlpha) [static]</code>: <code>Win32</code> only: Returns a <code>QPixmap</code> that is equivalent to the given <code>bitmap</code>. The conversion is based on the specified <code>format</code>. <strong>Warning</strong>: This function is only available on Windows.</p>
</li>
<li><code>QPixmap QPixmap::fromWinHICON(HICON icon) [static]</code>: <code>Win32</code> only: Returns a <code>QPixmap</code> that is equivalent to the given <code>icon</code>. <strong>Warning</strong>: This function is only available on <code>Windows</code>.</li>
<li><code>QPixmap QPixmap::fromX11Pixmap(Qt::HANDLE pixmap, ShareMode mode = ImplicitlyShared) [static]</code>: Creates a <code>QPixmap</code> from the native <code>X11</code> <code>Pixmap</code> handle <code>pixmap</code>, using mode as the share <code>mode</code>. The default share mode is <code>QPixmap::ImplicitlyShared</code>, which means that a copy of the pixmap is made if someone tries to modify it by e.g. drawing onto it. <code>QPixmap</code> does not take ownership of the pixmap handle, and have to be deleted by the user. <strong>Warning</strong>: This function is <code>X11</code> specific; using it is <code>non-portable</code>.</li>
<li><code>QPixmap QPixmap::grabWidget(QWidget * widget, const QRect &amp; rectangle) [static]</code>: Creates a pixmap and paints the given <code>widget</code>, restricted by the given <code>rectangle</code>, in it. If the <code>widget</code> has any children, then they are also painted in the appropriate positions. If no <code>rectangle</code> is specified (the default) the entire widget is painted. If <code>widget</code> is <code>0</code>, the specified <code>rectangle</code> doesn’t overlap the widget’s rectangle, or an error occurs, the function will return a null <code>QPixmap</code>. If the <code>rectangle</code> is a superset of the given <code>widget</code>, the areas outside the <code>widget</code> are covered with the widget’s background. This function actually asks <code>widget</code> to paint itself (and its children to paint themselves) by calling <code>paintEvent()</code> with painter redirection turned on. But <code>QPixmap</code> also provides the <code>grabWindow()</code> function which is a bit faster by grabbing pixels directly off the screen. In addition, if there are overlaying windows, <code>grabWindow()</code>, unlike <code>grabWidget()</code>, will see them. <strong>Warning</strong>: Do not grab a widget from its <code>QWidget::paintEvent()</code>. However, it is safe to grab a widget from another widget’s <code>paintEvent()</code>.</li>
<li><code>QPixmap QPixmap::grabWidget(QWidget * widget, int x = 0, int y = 0, int width = -1, int height = -1) [static]</code>: This is an overloaded function. Creates a pixmap and paints the given <code>widget</code>, restricted by <code>QRect(x, y, width, height)</code>, in it. <strong>Warning</strong>: Do not grab a widget from its <code>QWidget::paintEvent()</code>. However, it is safe to grab a widget from another widget’s <code>paintEvent()</code>.</li>
<li><code>QPixmap QPixmap::grabWindow(WId window, int x = 0, int y = 0, int width = -1, int height = -1) [static]</code>: Creates and returns a pixmap constructed by grabbing the contents of the given <code>window</code> restricted by <code>QRect(x, y, width, height)</code>. The arguments <code>(x, y)</code> specify the offset in the window, whereas <code>(width, height)</code> specify the area to be copied. If <code>width</code> is negative, the function copies everything to the right border of the window. If <code>height</code> is negative, the function copies everything to the bottom of the window. The <code>window system identifier</code> (<code>WId</code>) can be retrieved using the <code>QWidget::winId()</code> function. The rationale for using a window identifier and not a <code>QWidget</code>, is to enable grabbing of windows that are not part of the application, window system frames, and so on. The <code>grabWindow()</code> function grabs pixels from the screen, not from the window, i.e. if there is another window partially or entirely over the one you grab, you get pixels from the overlying window, too. The mouse cursor is generally not grabbed. Note on <code>X11</code> that if the given <code>window</code> doesn’t have the same depth as the root window, and another window partially or entirely obscures the one you grab, you will not get pixels from the overlying window. The contents of the obscured areas in the pixmap will be undefined and uninitialized. On <code>Windows Vista</code> and above grabbing a layered window, which is created by setting the <code>Qt::WA_TranslucentBackground</code> attribute, will not work. Instead grabbing the desktop widget should work. <strong>Warning</strong>: In general, grabbing an area outside the screen is not safe. This depends on the underlying window system.</li>
<li><code>Qt::HANDLE QPixmap::handle() const</code>: Returns the pixmap’s handle to the device context. Note that, since <code>QPixmap</code> make use of implicit data sharing, the <code>detach()</code> function must be called explicitly to ensure that only this pixmap’s data is modified if the pixmap data is shared. <strong>Warning</strong>: This function is <code>X11</code> specific; using it is <code>non-portable</code>. <strong>Warning</strong>: Since <code>4.8</code>, pixmaps do not have an <code>X11</code> handle unless created with <code>fromX11Pixmap()</code>, or if the native graphics system is explicitly enabled.</li>
<li><code>bool QPixmap::hasAlpha() const</code>: Returns <code>true</code> if this pixmap has an alpha channel, or has a mask, otherwise returns <code>false</code>.</li>
<li><code>bool QPixmap::hasAlphaChannel() const</code>: Returns <code>true</code> if the pixmap has a format that respects the alpha channel, otherwise returns <code>false</code>.</li>
<li><code>int QPixmap::height() const</code>: Returns the height of the pixmap.</li>
<li><code>bool QPixmap::isNull() const</code>: Returns <code>true</code> if this is a null pixmap; otherwise returns <code>false</code>. A null pixmap has zero width, zero height and no contents. You cannot draw in a null pixmap.</li>
<li><code>bool QPixmap::isQBitmap() const</code>: Returns <code>true</code> if this is a <code>QBitmap</code>; otherwise returns <code>false</code>.</li>
<li><p><code>bool QPixmap::load(const QString &amp; fileName, const char * format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor)</code>: Loads a pixmap from the file with the given <code>fileName</code>. Returns <code>true</code> if the pixmap was successfully loaded; otherwise returns <code>false</code>. The loader attempts to read the pixmap using the specified <code>format</code>. If the <code>format</code> is not specified (which is the default), the loader probes the file for a header to guess the file format. The file name can either refer to an actual file on disk or to one of the application’s embedded resources. If the data needs to be modified to fit in a <code>lower-resolution</code> result (e.g. converting from <code>32-bit</code> to <code>8-bit</code>), use the <code>flags</code> to control the conversion. Note that <code>QPixmaps</code> are automatically added to the <code>QPixmapCache</code> when loaded from a file; the key used is internal and can not be acquired.</p>
</li>
<li><p><code>bool QPixmap::loadFromData(const uchar * data, uint len, const char * format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor)</code>: Loads a pixmap from the <code>len</code> first bytes of the given binary <code>data</code>. Returns <code>true</code> if the pixmap was loaded successfully; otherwise returns <code>false</code>. The loader attempts to read the pixmap using the specified <code>format</code>. If the <code>format</code> is not specified (which is the default), the loader probes the file for a header to guess the file format. If the <code>data</code> needs to be modified to fit in a <code>lower-resolution</code> result (e.g. converting from <code>32-bit</code> to <code>8-bit</code>), use the <code>flags</code> to control the conversion.</p>
</li>
<li><code>bool QPixmap::loadFromData(const QByteArray &amp; data, const char * format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor)</code>: This is an overloaded function. Loads a pixmap from the binary <code>data</code> using the specified <code>format</code> and conversion <code>flags</code>.</li>
<li><code>QBitmap QPixmap::mask() const</code>: Extracts a bitmap mask from the pixmap’s alpha channel. <strong>Warning</strong>: This is potentially an expensive operation. The mask of the pixmap is extracted dynamically from the pixeldata.</li>
<li><code>QRect QPixmap::rect() const</code>: Returns the pixmap’s enclosing rectangle.</li>
<li><code>bool QPixmap::save(const QString &amp; fileName, const char * format = 0, int quality = -1) const</code>: Saves the pixmap to the file with the given <code>fileName</code> using the specified image file <code>format</code> and <code>quality</code> factor. Returns <code>true</code> if successful; otherwise returns <code>false</code>. The <code>quality</code> factor must be in the range <code>[0, 100]</code> or <code>-1</code>. Specify <code>0</code> to obtain small compressed files, <code>100</code> for large uncompressed files, and <code>-1</code> to use the default settings. If <code>format</code> is <code>0</code>, an image format will be chosen from <code>fileName&#39;s</code> suffix.</li>
<li><code>bool QPixmap::save(QIODevice * device, const char * format = 0, int quality = -1) const</code>: This is an overloaded function. This function writes a <code>QPixmap</code> to the given <code>device</code> using the specified image file <code>format</code> and <code>quality</code> factor. This can be used, for example, to save a pixmap directly into a <code>QByteArray</code>:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QPixmap pixmap;</span><br><span class="line">QByteArray bytes;</span><br><span class="line"><span class="function">QBuffer <span class="title">buffer</span> <span class="params">( &amp;bytes )</span></span>;</span><br><span class="line">buffer.open ( QIODevice::WriteOnly );</span><br><span class="line"><span class="comment">/* writes pixmap into bytes in PNG format */</span></span><br><span class="line">pixmap.save ( &amp;buffer, <span class="string">"PNG"</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QPixmap QPixmap::scaled(const QSize &amp; size, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation) const</code>: Scales the pixmap to the given <code>size</code>, using the aspect ratio and transformation modes specified by <code>aspectRatioMode</code> and <code>transformMode</code>.</li>
</ul>
<p><img src="/2019/02/20/Qt语法详解/Qt之QPixmap/1.png"></p>
<ol>
<li>If <code>aspectRatioMode</code> is <code>Qt::IgnoreAspectRatio</code>, the pixmap is scaled to <code>size</code>.</li>
<li>If <code>aspectRatioMode</code> is <code>Qt::KeepAspectRatio</code>, the pixmap is scaled to a rectangle as large as possible inside <code>size</code>, preserving the aspect ratio.</li>
<li>If <code>aspectRatioMode</code> is <code>Qt::KeepAspectRatioByExpanding</code>, the pixmap is scaled to a rectangle as small as possible outside <code>size</code>, preserving the aspect ratio.</li>
</ol>
<p>If the given <code>size</code> is empty, this function returns a null pixmap. In some cases it can be more beneficial to draw the pixmap to a painter with a scale set rather than scaling the pixmap. This is the case when the painter is for instance based on <code>OpenGL</code> or when the scale factor changes rapidly.</p>
<ul>
<li><code>QPixmap QPixmap::scaled(int width, int height, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation) const</code>: This is an overloaded function. Returns a copy of the pixmap scaled to a rectangle with the given <code>width</code> and <code>height</code> according to the given <code>aspectRatioMode</code> and <code>transformMode</code>. If either the <code>width</code> or the <code>height</code> is zero or negative, this function returns a null pixmap.</li>
<li><code>QPixmap QPixmap::scaledToHeight(int height, Qt::TransformationMode mode = Qt::FastTransformation) const</code>: Returns a scaled copy of the image. The returned image is scaled to the given <code>height</code> using the specified transformation <code>mode</code>. The width of the pixmap is automatically calculated so that the aspect ratio of the pixmap is preserved. If <code>height</code> is <code>0</code> or negative, a null pixmap is returned.</li>
<li><code>QPixmap QPixmap::scaledToWidth(int width, Qt::TransformationMode mode = Qt::FastTransformation) const</code>: Returns a scaled copy of the image. The returned image is scaled to the given <code>width</code> using the specified transformation <code>mode</code>. The height of the pixmap is automatically calculated so that the aspect ratio of the pixmap is preserved. If <code>width</code> is <code>0</code> or <code>negative</code>, a null pixmap is returned.</li>
<li><code>void QPixmap::scroll(int dx, int dy, int x, int y, int width, int height, QRegion * exposed = 0)</code>: This convenience function is equivalent to calling <code>QPixmap::scroll(dx, dy, QRect(x, y, width, height), exposed)</code>.</li>
<li><code>void QPixmap::scroll(int dx, int dy, const QRect &amp; rect, QRegion * exposed = 0)</code>: Scrolls the area <code>rect</code> of this pixmap by <code>(dx, dy)</code>. The <code>exposed</code> region is left unchanged. You can optionally pass a pointer to an empty <code>QRegion</code> to get the region that is <code>exposed</code> by the scroll operation.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">pixmap</span> <span class="params">( <span class="string">"background.png"</span> )</span></span>;</span><br><span class="line">QRegion exposed;</span><br><span class="line">pixmap.scroll ( <span class="number">10</span>, <span class="number">10</span>, pixmap.rect(), &amp;exposed );</span><br></pre></td></tr></table></figure>
<p>You cannot scroll while there is an active painter on the pixmap.</p>
<ul>
<li><code>void QPixmap::setMask(const QBitmap &amp; mask)</code>: Sets a <code>mask</code> bitmap. This function merges the <code>mask</code> with the pixmap’s alpha channel. A pixel value of <code>1</code> on the <code>mask</code> means the pixmap’s pixel is unchanged; a value of <code>0</code> means the pixel is transparent. The <code>mask</code> must have the same size as this pixmap. Setting a null mask resets the <code>mask</code>, leaving the previously transparent pixels black. The effect of this function is undefined when the pixmap is being painted on. <strong>Warning</strong>: This is potentially an expensive operation.</li>
<li><code>QSize QPixmap::size() const</code>: Returns the size of the pixmap.</li>
<li><code>void QPixmap::swap(QPixmap &amp; other)</code>: Swaps pixmap <code>other</code> with this pixmap. This operation is very fast and never fails.</li>
<li><code>QImage QPixmap::toImage() const</code>: Converts the pixmap to a <code>QImage</code>. Returns a null image if the conversion fails. If the pixmap has <code>1-bit</code> depth, the returned image will also be <code>1</code> bit deep. Images with more bits will be returned in a format closely represents the underlying system. Usually this will be <code>QImage::Format_ARGB32_Premultiplied</code> for pixmaps with an alpha and <code>QImage::Format_RGB32</code> or <code>QImage::Format_RGB16</code> for pixmaps without alpha. Note that for the moment, alpha masks on monochrome images are ignored.</li>
<li><code>CGImageRef QPixmap::toMacCGImageRef() const</code>: Creates a <code>CGImageRef</code> equivalent to the <code>QPixmap</code>. Returns the <code>CGImageRef</code> handle. It is the caller’s responsibility to release the <code>CGImageRef</code> data after use. <strong>Warning</strong>: This function is only available on <code>Mac OS X</code>.</li>
<li><code>HBITMAP QPixmap::toWinHBITMAP(HBitmapFormat format = NoAlpha) const</code>:  <code>Win32</code> only: Creates a <code>HBITMAP</code> equivalent to the <code>QPixmap</code>, based on the given <code>format</code>. Returns the <code>HBITMAP</code> handle. It is the caller’s responsibility to free the <code>HBITMAP</code> data after use. <strong>Warning</strong>: This function is only available on <code>Windows</code>.</li>
<li><code>HICON QPixmap::toWinHICON() const</code>: <code>Win32</code> only: Creates a <code>HICON</code> equivalent to the <code>QPixmap</code>. Returns the <code>HICON</code> handle. It is the caller’s responsibility to free the <code>HICON</code> data after use. <strong>Warning</strong>: This function is only available on <code>Windows</code>.</li>
<li><code>QPixmap QPixmap::transformed(const QTransform &amp; transform, Qt::TransformationMode mode = Qt::FastTransformation) const</code>: Returns a copy of the pixmap that is transformed using the given transformation <code>transform</code> and transformation <code>mode</code>. The original pixmap is not changed. The transformation <code>transform</code> is internally adjusted to compensate for unwanted translation; i.e. the pixmap produced is the smallest pixmap that contains all the transformed points of the original pixmap. Use the <code>trueMatrix()</code> function to retrieve the actual matrix used for transforming the pixmap. This function is slow because it involves transformation to a <code>QImage</code>, <code>non-trivial</code> computations and a transformation back to a <code>QPixmap</code>.</li>
<li><code>QPixmap QPixmap::transformed(const QMatrix &amp; matrix, Qt::TransformationMode mode = Qt::FastTransformation) const</code>: This is an overloaded function. This convenience function loads the <code>matrix</code> into a <code>QTransform</code> and calls the overloaded function.</li>
<li><code>QTransform QPixmap::trueMatrix(const QTransform &amp; matrix, int width, int height) [static]</code>: Returns the actual <code>matrix</code> used for transforming a pixmap with the given <code>width</code>, <code>height</code> and <code>matrix</code>. When transforming a pixmap using the <code>transformed()</code> function, the transformation <code>matrix</code> is internally adjusted to compensate for unwanted translation, i.e. <code>transformed()</code> returns the smallest pixmap containing all transformed points of the original pixmap. This function returns the modified <code>matrix</code>, which maps points correctly from the original pixmap into the new pixmap.</li>
<li><code>QMatrix QPixmap::trueMatrix(const QMatrix &amp; m, int w, int h) [static]</code>: This is an overloaded function. This convenience function loads the matrix <code>m</code> into a <code>QTransform</code> and calls the overloaded function with the <code>QTransform</code> and the width <code>w</code> and the height <code>h</code>.</li>
<li><code>int QPixmap::width() const</code>: Returns the width of the pixmap.</li>
<li><code>const QX11Info &amp; QPixmap::x11Info() const</code>: <code>X11</code> only: Returns information about the configuration of the <code>X</code> display used by the screen to which the pixmap currently belongs. <strong>Warning</strong>: This function is only available on <code>X11</code>.</li>
<li><code>Qt::HANDLE QPixmap::x11PictureHandle() const</code>: <code>X11</code> only: Returns the <code>X11</code> <code>Picture</code> handle of the pixmap for <code>XRender</code> support. This function will return <code>0</code> if <code>XRender</code> support is not compiled into <code>Qt</code>, if the <code>XRender</code> extension is not supported on the <code>X11</code> display, or if the handle could not be created. Use of this function is not portable. <strong>Warning</strong>: This function is only available on <code>X11</code>.</li>
<li><code>QPixmap::operator QVariant() const</code>: Returns the pixmap as a <code>QVariant</code>.</li>
<li><code>bool QPixmap::operator!() const</code>: Returns <code>true</code> if this is a null pixmap; otherwise returns <code>false</code>.</li>
<li><code>QPixmap &amp; QPixmap::operator=(const QPixmap &amp; pixmap)</code>: Assigns the given <code>pixmap</code> to this pixmap and returns a reference to this pixmap.</li>
</ul>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; stream, const QPixmap &amp; pixmap)</code>: Writes the given <code>pixmap</code> to the given <code>stream</code> as a <code>PNG</code> image. Note that writing the stream to a file will not produce a valid image file.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; stream, QPixmap &amp; pixmap)</code>: Reads an image from the given <code>stream</code> into the given <code>pixmap</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/20/Qt语法详解/Qt之QTextFrameFormat/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/20/Qt语法详解/Qt之QTextFrameFormat/" itemprop="url">Qt之QTextFrameFormat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-20T13:00:40+08:00">
                2019-02-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTextFrameFormat</code> class provides formatting information for frames in a <code>QTextDocument</code>.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextFrameFormat</code></td>
<td><code>QTextFormat</code></td>
<td><code>QTextTableFormat</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextFrameFormat()</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>border() const</code></td>
</tr>
<tr>
<td><code>QBrush</code></td>
<td><code>borderBrush() const</code></td>
</tr>
<tr>
<td><code>BorderStyle</code></td>
<td><code>borderStyle() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>bottomMargin() const</code></td>
</tr>
<tr>
<td><code>QTextLength</code></td>
<td><code>height() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isValid() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>leftMargin() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>margin() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>padding() const</code></td>
</tr>
<tr>
<td><code>PageBreakFlags</code></td>
<td><code>pageBreakPolicy() const</code></td>
</tr>
<tr>
<td><code>Position</code></td>
<td><code>position() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>rightMargin() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBorder(qreal width)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBorderBrush(const QBrush &amp; brush)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBorderStyle(BorderStyle style)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBottomMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHeight(const QTextLength &amp; height)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHeight(qreal height)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setLeftMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPadding(qreal width)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPageBreakPolicy(PageBreakFlags policy)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPosition(Position policy)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setRightMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTopMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setWidth(const QTextLength &amp; width)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setWidth(qreal width)</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>topMargin() const</code></td>
</tr>
<tr>
<td><code>QTextLength</code></td>
<td><code>width() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextFrameFormat</code> class provides formatting information for frames in a <code>QTextDocument</code>.<br>&emsp;&emsp;A text frame groups together one or more blocks of text, providing a layer of structure larger than the paragraph. The format of a frame specifies how it is rendered and positioned on the screen. It does not directly specify the behavior of the text formatting within, but provides constraints on the layout of its children.<br>&emsp;&emsp;The frame format defines the <code>width()</code> and <code>height()</code> of the frame on the screen. Each frame can have a <code>border()</code> that surrounds its contents with a rectangular box. The border is surrounded by a <code>margin()</code> around the frame, and the contents of the frame are kept separate from the border by the frame’s <code>padding()</code>. This scheme is similar to the box model used by <code>Cascading Style Sheets</code> for <code>HTML</code> pages.</p>
<p><img src="/2019/02/20/Qt语法详解/Qt之QTextFrameFormat/1.png" height="159" width="246"></p>
<p>&emsp;&emsp;The <code>position()</code> of a frame is set using <code>setPosition()</code> and determines how it is located relative to the surrounding text.<br>&emsp;&emsp;The validity of a <code>QTextFrameFormat</code> object can be determined with the <code>isValid()</code> function.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li><code>enum QTextFrameFormat::BorderStyle</code>: This enum describes different border styles for the text frame.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextFrameFormat::BorderStyle_None</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_Dotted</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_Dashed</code></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_Solid</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_Double</code></td>
<td><code>4</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_DotDash</code></td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_DotDotDash</code></td>
<td><code>6</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_Groove</code></td>
<td><code>7</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_Ridge</code></td>
<td><code>8</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_Inset</code></td>
<td><code>9</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::BorderStyle_Outset</code></td>
<td><code>10</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>enum QTextFrameFormat::Position</code>: This enum describes how a frame is located relative to the surrounding text.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextFrameFormat::InFlow</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::FloatLeft</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>QTextFrameFormat::FloatRight</code></td>
<td><code>2</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextFrameFormat::QTextFrameFormat()</code>: Constructs a text frame format object with the default properties.</li>
<li><code>qreal QTextFrameFormat::border() const</code>: Returns the width of the border in pixels.</li>
<li><code>QBrush QTextFrameFormat::borderBrush() const</code>: Returns the brush used for the frame’s border.</li>
<li><code>BorderStyle QTextFrameFormat::borderStyle() const</code>: Returns the style of the frame’s border.</li>
<li><code>qreal QTextFrameFormat::bottomMargin() const</code>: Returns the width of the frame’s bottom margin in pixels.</li>
<li><code>QTextLength QTextFrameFormat::height() const</code>: Returns the height of the frame’s border rectangle.</li>
<li><code>bool QTextFrameFormat::isValid() const</code>: Returns <code>true</code> if the format description is valid; otherwise returns <code>false</code>.</li>
<li><code>qreal QTextFrameFormat::leftMargin() const</code>: Returns the width of the frame’s left margin in pixels.</li>
<li><code>qreal QTextFrameFormat::margin() const</code>: Returns the width of the frame’s external margin in pixels.</li>
<li><code>qreal QTextFrameFormat::padding() const</code>: Returns the width of the frame’s internal padding in pixels.</li>
<li><code>PageBreakFlags QTextFrameFormat::pageBreakPolicy() const</code>: Returns the currently set page break policy for the <code>frame/table</code>. The default is <code>QTextFormat::PageBreak_Auto</code>.</li>
<li><code>Position QTextFrameFormat::position() const</code>: Returns the positioning policy for frames with this frame format.</li>
<li><code>qreal QTextFrameFormat::rightMargin() const</code>: Returns the width of the frame’s right margin in pixels.</li>
<li><code>void QTextFrameFormat::setBorder(qreal width)</code>: Sets the <code>width</code> (in pixels) of the frame’s border.</li>
<li><code>void QTextFrameFormat::setBorderBrush(const QBrush &amp; brush)</code>: Sets the <code>brush</code> used for the frame’s border.</li>
<li><code>void QTextFrameFormat::setBorderStyle(BorderStyle style)</code>: Sets the <code>style</code> of the frame’s border.</li>
<li><code>void QTextFrameFormat::setBottomMargin(qreal margin)</code>: Sets the frame’s bottom <code>margin</code> in pixels.</li>
<li><code>void QTextFrameFormat::setHeight(const QTextLength &amp; height)</code>: Sets the frame’s <code>height</code>.</li>
<li><code>void QTextFrameFormat::setHeight(qreal height)</code>: This is an overloaded function. Sets the frame’s <code>height</code>.</li>
<li><code>void QTextFrameFormat::setLeftMargin(qreal margin)</code>: Sets the frame’s left <code>margin</code> in pixels.</li>
<li><code>void QTextFrameFormat::setMargin(qreal margin)</code>: Sets the frame’s <code>margin</code> in pixels. This method also sets the left, right, top and bottom margins of the frame to the same value. The individual margins override the general margin.</li>
<li><code>void QTextFrameFormat::setPadding(qreal width)</code>: Sets the <code>width</code> of the frame’s internal padding in pixels.</li>
<li><code>void QTextFrameFormat::setPageBreakPolicy(PageBreakFlags policy)</code>: Sets the page break policy for the <code>frame/table</code> to <code>policy</code>.</li>
<li><code>void QTextFrameFormat::setPosition(Position policy)</code>: Sets the <code>policy</code> for positioning frames with this frame format.</li>
<li><code>void QTextFrameFormat::setRightMargin(qreal margin)</code>: Sets the frame’s right <code>margin</code> in pixels.</li>
<li><code>void QTextFrameFormat::setTopMargin(qreal margin)</code>: Sets the frame’s top <code>margin</code> in pixels.</li>
<li><code>void QTextFrameFormat::setWidth(const QTextLength &amp; width)</code>: Sets the frame’s border rectangle’s <code>width</code>.</li>
<li><code>void QTextFrameFormat::setWidth(qreal width)</code>: This is an overloaded function. Convenience method that sets the <code>width</code> of the frame’s border rectangle’s width to the specified fixed width.</li>
<li><code>qreal QTextFrameFormat::topMargin() const</code>: Returns the width of the frame’s top margin in pixels.</li>
<li><code>QTextLength QTextFrameFormat::width() const</code>: Returns the width of the frame’s border rectangle.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/19/Qt语法详解/Qt之QTextBlock/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/Qt语法详解/Qt之QTextBlock/" itemprop="url">Qt之QTextBlock</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T21:02:01+08:00">
                2019-02-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTextBlock</code> class provides a container for text fragments in a <code>QTextDocument</code>. The header file is <code>QTextBlock</code>. <strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextBlock(const QTextBlock &amp; other)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>QTextBlockFormat</code></td>
<td><code>blockFormat() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>blockFormatIndex() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>blockNumber() const</code></td>
</tr>
<tr>
<td><code>QTextCharFormat</code></td>
<td><code>charFormat() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>charFormatIndex() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clearLayout()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>contains(int position) const</code></td>
</tr>
<tr>
<td><code>const QTextDocument *</code></td>
<td><code>document() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>firstLineNumber() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isValid() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isVisible() const</code></td>
</tr>
<tr>
<td><code>QTextLayout *</code></td>
<td><code>layout() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>length() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lineCount() const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>next() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>position() const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>previous() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>revision() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setLineCount(int count)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setRevision(int rev)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUserData(QTextBlockUserData * data)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUserState(int state)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setVisible(bool visible)</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>text() const</code></td>
</tr>
<tr>
<td><code>Qt::LayoutDirection</code></td>
<td><code>textDirection() const</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>textList() const</code></td>
</tr>
<tr>
<td><code>QTextBlockUserData *</code></td>
<td><code>userData() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>userState() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QTextBlock &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&lt;(const QTextBlock &amp; other) const</code></td>
</tr>
<tr>
<td><code>QTextBlock &amp;</code></td>
<td><code>operator=(const QTextBlock &amp; other)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QTextBlock &amp; other) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextBlock</code> class provides a container for text fragments in a <code>QTextDocument</code>.<br>&emsp;&emsp;A text block encapsulates a block or paragraph of text in a <code>QTextDocument</code>. <code>QTextBlock</code> provides <code>read-only</code> access to the <code>block/paragraph</code> structure of <code>QTextDocuments</code>. It is mainly of use if you want to implement your own layouts for the visual representation of a <code>QTextDocument</code>, or if you want to iterate over a document and write out the contents in your own custom format.<br>&emsp;&emsp;Text blocks are created by their parent documents. If you need to create a new text block, or modify the contents of a document while examining its contents, use the <code>cursor-based</code> interface provided by <code>QTextCursor</code> instead.<br>&emsp;&emsp;Each text block is located at a specific <code>position()</code> in a <code>document()</code>. The contents of the block can be obtained by using the <code>text()</code> function. The <code>length()</code> function determines the block’s size within the document (including formatting characters). The visual properties of the block are determined by its text <code>layout()</code>, its <code>charFormat()</code>, and its <code>blockFormat()</code>.<br>&emsp;&emsp;The <code>next()</code> and <code>previous()</code> functions enable iteration over consecutive valid blocks in a document under the condition that the document is not modified by other means during the iteration process. Note that, although blocks are returned in sequence, adjacent blocks may come from different places in the document structure. The validity of a block can be determined by calling <code>isValid()</code>.<br>&emsp;&emsp;<code>QTextBlock</code> provides comparison operators to make it easier to work with blocks: <code>operator==()</code> compares two block for equality, <code>operator!=()</code> compares two blocks for inequality, and <code>operator&lt;()</code> determines whether a block precedes another in the same document.</p>
<p><img src="/2019/02/19/Qt语法详解/Qt之QTextBlock/1.png" height="156" width="164"></p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li><code>typedef QTextBlock::Iterator</code>: <code>Qt-style</code> synonym for <code>QTextBlock::iterator</code>.</li>
</ul>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextBlock::QTextBlock(const QTextBlock &amp; other)</code>: Copies the <code>other</code> text block’s attributes to this text block.</li>
<li><code>iterator QTextBlock::begin() const</code>: Returns a text block iterator pointing to the beginning of the text block.</li>
<li><code>QTextBlockFormat QTextBlock::blockFormat() const</code>: Returns the QTextBlockFormat that describes <code>block-specific</code> properties.</li>
<li><code>int QTextBlock::blockFormatIndex() const</code>: Returns an index into the document’s internal list of block formats for the text block’s format.</li>
<li><code>int QTextBlock::blockNumber() const</code>: Returns the number of this block, or <code>-1</code> if the block is invalid.</li>
<li><code>QTextCharFormat QTextBlock::charFormat() const</code>: Returns the <code>QTextCharFormat</code> that describes the block’s character format. The block’s character format is used when inserting text into an empty block.</li>
<li><code>int QTextBlock::charFormatIndex() const</code>: Returns an index into the document’s internal list of character formats for the text block’s character format.</li>
<li><code>void QTextBlock::clearLayout()</code>: Clears the <code>QTextLayout</code> that is used to lay out and display the block’s contents.</li>
<li><code>bool QTextBlock::contains(int position) const</code>: Returns <code>true</code> if the given <code>position</code> is located within the text block; otherwise returns <code>false</code>.</li>
<li><code>const QTextDocument * QTextBlock::document() const</code>: Returns the text document this text block belongs to, or <code>0</code> if the text block does not belong to any document.</li>
<li><code>iterator QTextBlock::end() const</code>: Returns a text block iterator pointing to the end of the text block.</li>
<li><code>int QTextBlock::firstLineNumber() const</code>: Returns the first line number of this block, or <code>-1</code> if the block is invalid. Unless the layout supports it, the line number is identical to the block number.</li>
<li><code>bool QTextBlock::isValid() const</code>: Returns <code>true</code> if this text block is valid; otherwise returns <code>false</code>.</li>
<li><code>bool QTextBlock::isVisible() const</code>: Returns <code>true</code> if the block is visible; otherwise returns <code>false</code>.</li>
<li><code>QTextLayout * QTextBlock::layout() const</code>: Returns the <code>QTextLayout</code> that is used to lay out and display the block’s contents. Note that the returned <code>QTextLayout</code> object can only be modified from the <code>documentChanged</code> implementation of a <code>QAbstractTextDocumentLayout</code> subclass. Any changes applied from the outside cause undefined behavior.</li>
<li><code>int QTextBlock::length() const</code>: Returns the length of the block in characters. <strong>Note</strong>: The length returned includes all formatting characters, for example, newline.</li>
<li><code>int QTextBlock::lineCount() const</code>: Returns the line count. Not all document layouts support this feature.</li>
<li><code>QTextBlock QTextBlock::next() const</code>: Returns the text block in the document after this block, or an empty text block if this is the last one. Note that the next block may be in a different frame or table to this block.</li>
<li><code>int QTextBlock::position() const</code>: Returns the index of the block’s first character within the document.</li>
<li><code>QTextBlock QTextBlock::previous() const</code>: Returns the text block in the document before this block, or an empty text block if this is the first one. Note that the next block may be in a different frame or table to this block.</li>
<li><code>int QTextBlock::revision() const</code>: Returns the blocks revision.</li>
<li><code>void QTextBlock::setLineCount(int count)</code>: Sets the line count to <code>count</code>.</li>
<li><code>void QTextBlock::setRevision(int rev)</code>: Sets a blocks revision to <code>rev</code>.</li>
<li><code>void QTextBlock::setUserData(QTextBlockUserData * data)</code>: Attaches the given <code>data</code> object to the text block. <code>QTextBlockUserData</code> can be used to store custom settings. The ownership is passed to the underlying text document, i.e. the provided <code>QTextBlockUserData</code> object will be deleted if the corresponding text block gets deleted. The user data object is not stored in the undo history, so it will not be available after undoing the deletion of a text block. For example, if you write a programming editor in an <code>IDE</code>, you may want to let your user set breakpoints visually in your code for an integrated debugger. In a programming editor a line of text usually corresponds to one <code>QTextBlock</code>. The <code>QTextBlockUserData</code> interface allows the developer to store data for each <code>QTextBlock</code>, like for example in which lines of the source code the user has a breakpoint set. Of course this could also be stored externally, but by storing it inside the <code>QTextDocument</code>, it will for example be automatically deleted when the user deletes the associated line. It’s really just a way to store custom information in the <code>QTextDocument</code> without using custom properties in <code>QTextFormat</code> which would affect the <code>undo/redo</code> stack.</li>
<li><code>void QTextBlock::setUserState(int state)</code>: Stores the specified <code>state</code> integer value in the text block. This may be useful for example in a syntax highlighter to store a text parsing <code>state</code>.</li>
<li><code>void QTextBlock::setVisible(bool visible)</code>: Sets the block’s visibility to <code>visible</code>.</li>
<li><code>QString QTextBlock::text() const</code>: Returns the block’s contents as plain text.</li>
<li><code>Qt::LayoutDirection QTextBlock::textDirection() const</code>: Returns the resolved text direction. If the block has no explicit direction set, it will resolve the direction from the blocks content. Returns either <code>Qt::LeftToRight</code> or <code>Qt::RightToLeft</code>.</li>
<li><code>QTextList * QTextBlock::textList() const</code>: If the block represents a list item, returns the list that the item belongs to; otherwise returns <code>0</code>.</li>
<li><code>QTextBlockUserData * QTextBlock::userData() const</code>: Returns a pointer to a <code>QTextBlockUserData</code> object if previously set with <code>setUserData()</code> or a null pointer.</li>
<li><code>int QTextBlock::userState() const</code>: Returns the integer value previously set with <code>setUserState()</code> or <code>-1</code>.</li>
<li><code>bool QTextBlock::operator!=(const QTextBlock &amp; other) const</code>: Returns <code>true</code> if this text block is different from the <code>other</code> text block.</li>
<li><code>bool QTextBlock::operator&lt;(const QTextBlock &amp; other) const</code>: Returns <code>true</code> if this text block occurs before the <code>other</code> text block in the document.</li>
<li><code>QTextBlock &amp; QTextBlock::operator=(const QTextBlock &amp; other)</code>: Assigns the <code>other</code> text block to this text block.</li>
<li><code>bool QTextBlock::operator==(const QTextBlock &amp; other) const</code>: Returns true if this text block is the same as the <code>other</code> text block.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/19/Qt语法详解/Qt之QGridLayout/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/Qt语法详解/Qt之QGridLayout/" itemprop="url">Qt之QGridLayout</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T17:52:20+08:00">
                2019-02-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>&emsp;&emsp;<code>QGridLayout</code>是格栅布局，也被称作网格布局(多行多列)。栅格布局将位于其中的窗口部件放入一个网状的栅格之中。<code>QGridLayout</code>需要将提供给它的空间划分成的行和列，并把每个窗口部件插入并管理到正确的单元格。<br>&emsp;&emsp;栅格布局是这样工作的：它计算了位于其中的空间，然后将它们合理的划分成若干个行(<code>row</code>)和列(<code>column</code>)，并把每个由它管理的窗口部件放置在合适的单元之中，这里所指的单元(<code>cell</code>)即是指由行和列交叉所划分出来的空间。在栅格布局中，行和列本质上是相同的，只是叫法不同而已。下面将重点讨论列，这些内容当然也适用于行。<br>&emsp;&emsp;在栅格布局中，每个列(以及行)都有一个最小宽度(使用<code>setColumnMinimumWidth</code>设置)以及一个伸缩因子(使用<code>setColumnStretch</code>设置)。最小宽度指的是位于该列中的窗口部件的最小的宽度，而伸缩因子决定了该列内的窗口部件能够获得多少空间。</p>
<h3 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h3><p>&emsp;&emsp;一般情况下我们都是把某个窗口部件放进栅格布局的一个单元中，但窗口部件有时也可能会需要占用多个单元。这时就需要用到<code>addWidget</code>方法的一个重载版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addWidget</span> <span class="params">( QWidget *, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">int</span> rowSpan, <span class="keyword">int</span> columnSpan, Qt::Alignment = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个单元将从<code>row</code>和<code>column</code>开始，扩展到<code>rowSpan</code>和<code>columnSpan</code>指定的倍数的行和列。如果<code>rowSpan</code>或<code>columnSpan</code>的值为<code>-1</code>，则窗口部件将扩展到布局的底部或者右边边缘处。<br>&emsp;&emsp;在创建栅格布局完成后，就可以使用<code>addWidget</code>、<code>addItem</code>或者<code>addLayout</code>方法向其中加入窗口部件，以及其它的布局。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>&emsp;&emsp;下面以登录界面为例，来讲解如何使用<code>QGridLayout</code>：</p>
<p><img src="/2019/02/19/Qt语法详解/Qt之QGridLayout/1.png" height="152" width="255"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构建控件，即头像、用户名、密码输入框等 */</span></span><br><span class="line">QLabel *pImageLabel = <span class="keyword">new</span> QLabel ( <span class="keyword">this</span> );</span><br><span class="line">QLineEdit *pUserLineEdit = <span class="keyword">new</span> QLineEdit ( <span class="keyword">this</span> );</span><br><span class="line">QLineEdit *pPasswordLineEdit = <span class="keyword">new</span> QLineEdit ( <span class="keyword">this</span> );</span><br><span class="line">QCheckBox *pRememberCheckBox = <span class="keyword">new</span> QCheckBox ( <span class="keyword">this</span> );</span><br><span class="line">QCheckBox *pAutoLoginCheckBox = <span class="keyword">new</span> QCheckBox ( <span class="keyword">this</span> );</span><br><span class="line">QPushButton *pLoginButton = <span class="keyword">new</span> QPushButton ( <span class="keyword">this</span> );</span><br><span class="line">QPushButton *pRegisterButton = <span class="keyword">new</span> QPushButton ( <span class="keyword">this</span> );</span><br><span class="line">QPushButton *pForgotButton = <span class="keyword">new</span> QPushButton ( <span class="keyword">this</span> );</span><br><span class="line">​</span><br><span class="line">pLoginButton-&gt;setFixedHeight ( <span class="number">30</span> );</span><br><span class="line">pUserLineEdit-&gt;setFixedWidth ( <span class="number">200</span> );</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 设置头像 */</span></span><br><span class="line"><span class="function">QPixmap <span class="title">pixmap</span> <span class="params">( <span class="string">":/Images/logo"</span> )</span></span>;</span><br><span class="line">pImageLabel-&gt;setFixedSize ( <span class="number">90</span>, <span class="number">90</span> );</span><br><span class="line">pImageLabel-&gt;setPixmap ( pixmap );</span><br><span class="line">pImageLabel-&gt;setScaledContents ( <span class="literal">true</span> );</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* 设置文本 */</span></span><br><span class="line">pUserLineEdit-&gt;setPlaceholderText ( QStringLiteral ( <span class="string">"QQ号码/手机/邮箱"</span> ) );</span><br><span class="line">pPasswordLineEdit-&gt;setPlaceholderText ( QStringLiteral ( <span class="string">"密码"</span> ) );</span><br><span class="line">pPasswordLineEdit-&gt;setEchoMode ( QLineEdit::Password );</span><br><span class="line">pRememberCheckBox-&gt;setText ( QStringLiteral ( <span class="string">"记住密码"</span> ) );</span><br><span class="line">pAutoLoginCheckBox-&gt;setText ( QStringLiteral ( <span class="string">"自动登录"</span> ) );</span><br><span class="line">pLoginButton-&gt;setText ( QStringLiteral ( <span class="string">"登录"</span> ) );</span><br><span class="line">pRegisterButton-&gt;setText ( QStringLiteral ( <span class="string">"注册账号"</span> ) );</span><br><span class="line">pForgotButton-&gt;setText ( QStringLiteral ( <span class="string">"找回密码"</span> ) );</span><br><span class="line">​</span><br><span class="line">QGridLayout *pLayout = <span class="keyword">new</span> QGridLayout();</span><br><span class="line"><span class="comment">/* 头像从第0行第0列开始，占3行1列 */</span></span><br><span class="line">pLayout-&gt;addWidget ( pImageLabel, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span> );</span><br><span class="line"><span class="comment">/* 用户名输入框从第0行，第1列开始，占1行2列 */</span></span><br><span class="line">pLayout-&gt;addWidget ( pUserLineEdit, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span> );</span><br><span class="line">pLayout-&gt;addWidget ( pRegisterButton, <span class="number">0</span>, <span class="number">4</span> );</span><br><span class="line"><span class="comment">/* 密码输入框从第1行，第1列开始，占1行2列 */</span></span><br><span class="line">pLayout-&gt;addWidget ( pPasswordLineEdit, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span> );</span><br><span class="line">pLayout-&gt;addWidget ( pForgotButton, <span class="number">1</span>, <span class="number">4</span> );</span><br><span class="line"><span class="comment">/* 记住密码从第2行第1列开始，占1行1列，水平居左，垂直居中 */</span></span><br><span class="line">pLayout-&gt;addWidget ( pRememberCheckBox, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, Qt::AlignLeft | Qt::AlignVCenter );</span><br><span class="line"><span class="comment">/* 自动登录从第2行第2列开始，占1行1列，水平居右，垂直居中 */</span></span><br><span class="line">pLayout-&gt;addWidget ( pAutoLoginCheckBox, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, Qt::AlignRight | Qt::AlignVCenter );</span><br><span class="line">pLayout-&gt;addWidget ( pLoginButton, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span> ); <span class="comment">/* 登录按钮从第3行第1列开始，占1行2列 */</span></span><br><span class="line">pLayout-&gt;setHorizontalSpacing ( <span class="number">10</span> ); <span class="comment">/* 设置水平间距 */</span></span><br><span class="line">pLayout-&gt;setVerticalSpacing ( <span class="number">10</span> ); <span class="comment">/* 设置垂直间距 */</span></span><br><span class="line">pLayout-&gt;setContentsMargins ( <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span> ); <span class="comment">/* 设置外间距 */</span></span><br><span class="line">setLayout ( pLayout );</span><br></pre></td></tr></table></figure>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><ul>
<li><code>addWidget ( QWidget *, int row, int column, Qt::Alignment = 0 );</code></li>
<li><code>addWidget ( QWidget *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0 );</code></li>
</ul>
<p>添加窗口部件至布局。这个单元将从<code>row</code>和<code>column</code>开始，扩展到<code>rowSpan</code>和<code>columnSpan</code>指定的倍数的行和列。如果<code>rowSpan</code>或<code>columnSpan</code>的值为<code>-1</code>，则窗口部件将扩展到布局的底部或者右边边缘处，<code>Qt::Alignment</code>为对齐方式。</p>
<ul>
<li><code>addLayout ( QLayout *, int row, int column, Qt::Alignment = 0 );</code></li>
<li><code>addLayout ( QLayout *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0 );</code></li>
</ul>
<p>和<code>addWidget</code>类似，这个是添加布局。</p>
<ul>
<li><code>setRowStretch ( int row, int stretch );</code></li>
<li><code>setColumnStretch ( int column, int stretch );</code></li>
</ul>
<p>设置<code>行/列</code>的伸缩空间，和<code>QBoxLayout</code>的<code>addStretch</code>功能类似。</p>
<ul>
<li><code>setSpacing ( int spacing );</code></li>
<li><code>setHorizontalSpacing ( int spacing );</code></li>
<li><code>setVerticalSpacing ( int spacing );</code></li>
</ul>
<p>设置间距。<code>setSpacing</code>可以同时设置水平、垂直间距，设置之后，水平、垂直间距相同。<code>setHorizontalSpacing</code>、<code>setVerticalSpacing</code>可以分别设置水平间距、垂直间距。</p>
<ul>
<li><code>setRowMinimumHeight(int row, int minSize);</code>：设置行最小高度。</li>
<li><code>setColumnMinimumWidth(int column, int minSize);</code>：设置列最小宽度。</li>
<li><code>columnCount();</code>：获取列数。</li>
<li><code>rowCount();</code>：获取行数。</li>
<li><code>setOriginCorner(Qt::Corner);</code>：设置原始方向，和<code>QBoxLayout</code>的<code>setDirection</code>功能类似。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/17/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/94/">94</a><a class="extend next" rel="next" href="/page/19/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">939</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
