<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="泥腿子出身">
<meta property="og:url" content="http://fukangwei.gitee.io/page/66/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="泥腿子出身">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/66/">





  <title>泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/深度学习/Keras之池化层/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/深度学习/Keras之池化层/" itemprop="url">Keras之池化层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T21:31:39+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="MaxPooling1D"><a href="#MaxPooling1D" class="headerlink" title="MaxPooling1D"></a>MaxPooling1D</h3><p>&emsp;&emsp;该函数用于时序数据的最大池化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keras.layers.MaxPooling1D(pool_size=<span class="number">2</span>, strides=<span class="keyword">None</span>, padding=<span class="string">'valid'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pool_size</code>：整数，最大池化的窗口大小。</li>
<li><code>strides</code>：整数或者是<code>None</code>，作为缩小比例的因数，例如<code>2</code>会使得输入张量缩小一半。如果是<code>None</code>，那么默认值是<code>pool_size</code>。</li>
<li><code>padding</code>：<code>valid</code>或者<code>same</code>。</li>
</ul>
<p>&emsp;&emsp;输入尺寸：尺寸是<code>(batch_size, steps, features)</code>的<code>3D</code>张量。<br>&emsp;&emsp;输出尺寸：尺寸是<code>(batch_size, downsampled_steps, features)</code>的<code>3D</code>张量。</p>
<h3 id="MaxPooling2D"><a href="#MaxPooling2D" class="headerlink" title="MaxPooling2D"></a>MaxPooling2D</h3><p>&emsp;&emsp;该函数用于空域数据的最大池化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keras.layers.MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), strides=<span class="keyword">None</span>, padding=<span class="string">'valid'</span>, data_format=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pool_size</code>：整数或者<code>2</code>个整数元组，代表在两个方向<code>(垂直方向, 水平方向)</code>缩小比例的因数。<code>(2, 2)</code>会把输入张量的两个维度都缩小一半。如果只使用一个整数，那么两个维度都会使用同样的窗口长度。</li>
<li><code>strides</code>：整数、整数元组或者是<code>None</code>，步长值。如果是<code>None</code>，那么默认值是<code>pool_size</code>。</li>
<li><code>data_format</code>：一个字符串，<code>channels_last</code>(默认值)或者<code>channels_first</code>，代表图像的通道维的位置。<code>channels_last</code>代表尺寸是<code>(batch, height, width, channels)</code>的输入张量，而<code>channels_first</code>代表尺寸是<code>(batch, channels, height, width)</code>的输入张量。</li>
</ul>
<p>&emsp;&emsp;输入尺寸：</p>
<ul>
<li>如果<code>data_format = &#39;channels_last&#39;</code>，尺寸是<code>(batch_size, rows, cols, channels)</code>的<code>4D</code>张量。</li>
<li>如果<code>data_format = &#39;channels_first&#39;</code>，尺寸是<code>(batch_size, channels, rows, cols)</code>的<code>4D</code>张量。</li>
</ul>
<p>&emsp;&emsp;输出尺寸：</p>
<ul>
<li>如果<code>data_format = &#39;channels_last&#39;</code>，尺寸是<code>(batch_size, pooled_rows, pooled_cols, channels)</code>的<code>4D</code>张量。</li>
<li>如果<code>data_format = &#39;channels_first&#39;</code>，尺寸是<code>(batch_size, channels, pooled_rows, pooled_cols)</code>的<code>4D</code>张量。</li>
</ul>
<h3 id="MaxPooling3D"><a href="#MaxPooling3D" class="headerlink" title="MaxPooling3D"></a>MaxPooling3D</h3><p>&emsp;&emsp;该函数用于3D(空域或时空域)数据的最大池化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keras.layers.MaxPooling3D(pool_size=(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), strides=<span class="keyword">None</span>, padding=<span class="string">'valid'</span>, data_format=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pool_size</code>：<code>3</code>个整数的元组，代表缩小<code>(维度1, 维度2, 维度3)</code>比例的因数。<code>(2, 2, 2)</code>会把<code>3D</code>输入张量的每个维度缩小一半。</li>
<li><code>strides</code>：<code>3</code>个整数的元组或者是<code>None</code>，步长值。</li>
<li><code>data_format</code>：一个字符串，<code>channels_last</code>(默认值)或者<code>channels_first</code>，代表数据的通道维的位置。<code>channels_last</code>代表尺寸是<code>(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)</code>的输入张量，而<code>channels_first</code>代表尺寸是<code>(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)</code>的输入张量。</li>
</ul>
<p>&emsp;&emsp;输入尺寸：</p>
<ul>
<li>如果<code>data_format = &#39;channels_last&#39;</code>，尺寸是<code>(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)</code>的<code>5D</code>张量。</li>
<li>如果<code>data_format = &#39;channels_first&#39;</code>，尺寸是<code>(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)</code>的<code>5D</code>张量。</li>
</ul>
<p>&emsp;&emsp;输出尺寸：</p>
<ul>
<li>如果<code>data_format = &#39;channels_last&#39;</code>，尺寸是<code>(batch_size, pooled_dim1, pooled_dim2, pooled_dim3, channels)</code>的<code>5D</code>张量。</li>
<li>如果<code>data_format = &#39;channels_first&#39;</code>，尺寸是<code>(batch_size, channels, pooled_dim1, pooled_dim2, pooled_dim3)</code>的<code>5D</code>张量。</li>
</ul>
<h3 id="AveragePooling1D"><a href="#AveragePooling1D" class="headerlink" title="AveragePooling1D"></a>AveragePooling1D</h3><p>&emsp;&emsp;该函数用于时序数据的平均池化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keras.layers.AveragePooling1D(pool_size=<span class="number">2</span>, strides=<span class="keyword">None</span>, padding=<span class="string">'valid'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pool_size</code>：整数，平均池化的窗口大小。</li>
<li><code>strides</code>：整数或者是<code>None</code>，作为缩小比例的因数，例如<code>2</code>会使得输入张量缩小一半。如果是<code>None</code>，那么默认值是<code>pool_size</code>。</li>
</ul>
<p>&emsp;&emsp;输入尺寸：尺寸是<code>(batch_size, steps, features)</code>的<code>3D</code>张量。<br>&emsp;&emsp;输出尺寸：尺寸是<code>(batch_size, downsampled_steps, features)</code>的<code>3D</code>张量。</p>
<h3 id="AveragePooling2D"><a href="#AveragePooling2D" class="headerlink" title="AveragePooling2D"></a>AveragePooling2D</h3><p>&emsp;&emsp;该函数用于空域数据的平均池化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keras.layers.AveragePooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), strides=<span class="keyword">None</span>, padding=<span class="string">'valid'</span>, data_format=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pool_size</code>：整数或者<code>2</code>个整数元组，代表在两个方向<code>(垂直方向, 水平方向)</code>缩小比例的因数。<code>(2, 2)</code>会把输入张量的两个维度都缩小一半。如果只使用一个整数，那么两个维度都会使用同样的窗口长度。</li>
<li><code>strides</code>：整数、整数元组或者是<code>None</code>，步长值。如果是<code>None</code>，那么默认值是<code>pool_size</code>。</li>
<li><code>data_format</code>：一个字符串，<code>channels_last</code>(默认值)或者<code>channels_first</code>，输入张量中的维度顺序。<code>channels_last</code>代表尺寸是<code>(batch, height, width, channels)</code>的输入张量，而<code>channels_first</code>代表尺寸是<code>(batch, channels, height, width)</code>的输入张量。</li>
</ul>
<p>&emsp;&emsp;输入尺寸：</p>
<ul>
<li>如果<code>data_format = &#39;channels_last&#39;</code>，尺寸是<code>(batch_size, rows, cols, channels)</code>的<code>4D</code>张量。</li>
<li>如果<code>data_format = &#39;channels_first&#39;</code>，尺寸是<code>(batch_size, channels, rows, cols)</code>的<code>4D</code>张量。</li>
</ul>
<p>&emsp;&emsp;输出尺寸：</p>
<ul>
<li>如果<code>data_format = &#39;channels_last&#39;</code>，尺寸是<code>(batch_size, pooled_rows, pooled_cols, channels)</code>的<code>4D</code>张量。</li>
<li>如果<code>data_format = &#39;channels_first&#39;</code>，尺寸是<code>(batch_size, channels, pooled_rows, pooled_cols)</code>的<code>4D</code>张量。</li>
</ul>
<h3 id="AveragePooling3D"><a href="#AveragePooling3D" class="headerlink" title="AveragePooling3D"></a>AveragePooling3D</h3><p>&emsp;&emsp;该函数用于<code>3D</code>(空域或者时空域)数据的平均池化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keras.layers.AveragePooling3D(pool_size=(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), strides=<span class="keyword">None</span>, padding=<span class="string">'valid'</span>, data_format=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pool_size</code>：<code>3</code>个整数的元组，代表缩小<code>(维度1, 维度2, 维度3)</code>比例的因数。<code>(2, 2, 2)</code>会把<code>3D</code>输入张量的每个维度缩小一半。</li>
<li><code>strides</code>：<code>3</code>个整数的元组或者是<code>None</code>，步长值。</li>
<li><code>data_format</code>：一个字符串，<code>channels_last</code>(默认值)或者<code>channels_first</code>，代表数据的通道维的位置。<code>channels_last</code>代表尺寸是<code>(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)</code>的输入张量，而<code>channels_first</code>代表尺寸是<code>(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)</code>的输入张量。</li>
</ul>
<p>&emsp;&emsp;输入尺寸：</p>
<ul>
<li>如果<code>data_format = &#39;channels_last&#39;</code>，尺寸是<code>(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)</code>的<code>5D</code>张量。</li>
<li>如果<code>data_format = &#39;channels_first&#39;</code>，尺寸是<code>(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)</code>的<code>5D</code>张量。</li>
</ul>
<p>&emsp;&emsp;输出尺寸：</p>
<ul>
<li>如果<code>data_format = &#39;channels_last&#39;</code>，尺寸是<code>(batch_size, pooled_dim1, pooled_dim2, pooled_dim3, channels)</code>的<code>5D</code>张量。</li>
<li>如果<code>data_format = &#39;channels_first&#39;</code>，尺寸是<code>(batch_size, channels, pooled_dim1, pooled_dim2, pooled_dim3)</code>的<code>5D</code>张量。</li>
</ul>
<h3 id="GlobalMaxPooling1D"><a href="#GlobalMaxPooling1D" class="headerlink" title="GlobalMaxPooling1D"></a>GlobalMaxPooling1D</h3><p>&emsp;&emsp;该函数用于时序数据的全局最大池化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keras.layers.GlobalMaxPooling1D()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输入尺寸：尺寸是<code>(batch_size, steps, features)</code>的<code>3D</code>张量。<br>&emsp;&emsp;输出尺寸：尺寸是<code>(batch_size, features)</code>的<code>2D</code>张量。</p>
<h3 id="GlobalAveragePooling1D"><a href="#GlobalAveragePooling1D" class="headerlink" title="GlobalAveragePooling1D"></a>GlobalAveragePooling1D</h3><p>&emsp;&emsp;该函数用于时序数据的全局平均池化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keras.layers.GlobalAveragePooling1D()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输入尺寸：尺寸是<code>(batch_size, steps, features)</code>的<code>3D</code>张量。<br>&emsp;&emsp;输出尺寸：尺寸是<code>(batch_size, features)</code>的<code>2D</code>张量。</p>
<h3 id="GlobalMaxPooling2D"><a href="#GlobalMaxPooling2D" class="headerlink" title="GlobalMaxPooling2D"></a>GlobalMaxPooling2D</h3><p>&emsp;&emsp;该函数用于空域数据的全局最大池化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keras.layers.GlobalMaxPooling2D(data_format=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<p>参数<code>data_format</code>是一个字符串，<code>channels_last</code>(默认值)或者<code>channels_first</code>，代表图像的通道维的位置。<code>channels_last</code>代表尺寸是<code>(batch, height, width, channels)</code>的输入张量，而<code>channels_first</code>代表尺寸是<code>(batch, channels, height, width)</code>的输入张量。<br>&emsp;&emsp;输入尺寸：</p>
<ul>
<li>如果<code>data_format = &#39;channels_last&#39;</code>，尺寸是<code>(batch_size, rows, cols, channels)</code>的<code>4D</code>张量。</li>
<li>如果<code>data_format = &#39;channels_first&#39;</code>，尺寸是<code>(batch_size, channels, rows, cols)</code>的<code>4D</code>张量。</li>
</ul>
<p>&emsp;&emsp;输出尺寸：尺寸是<code>(batch_size, channels)</code>的<code>2D</code>张量。</p>
<h3 id="GlobalAveragePooling2D"><a href="#GlobalAveragePooling2D" class="headerlink" title="GlobalAveragePooling2D"></a>GlobalAveragePooling2D</h3><p>&emsp;&emsp;该函数用于空域数据的全局平均池化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keras.layers.GlobalAveragePooling2D(data_format=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<p>参数<code>data_format</code>是一个字符串，<code>channels_last</code>(默认值)或者<code>channels_first</code>，代表图像的通道维的位置。<code>channels_last</code>代表尺寸是<code>(batch, height, width, channels)</code>的输入张量，而<code>channels_first</code>代表尺寸是<code>(batch, channels, height, width)</code>的输入张量。</p>
<p>&emsp;&emsp;输入尺寸：</p>
<ul>
<li>如果<code>data_format = &#39;channels_last&#39;</code>，尺寸是<code>(batch_size, rows, cols, channels)</code>的<code>4D</code>张量。</li>
<li>如果<code>data_format = &#39;channels_first&#39;</code>，尺寸是<code>(batch_size, channels, rows, cols)</code>的<code>4D</code>张量。</li>
</ul>
<p>&emsp;&emsp;输出尺寸：尺寸是<code>(batch_size, channels)</code>的<code>2D</code>张量。</p>
<p>&emsp;&emsp;<strong>补充说明</strong>：<code>pooling</code>和<code>unpooling</code>对应到神经网络的技术上就是<code>downsampling</code>和<code>unsampling</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/深度学习/Keras之层封装器/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/深度学习/Keras之层封装器/" itemprop="url">Keras之层封装器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T21:20:08+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="TimeDistributed"><a href="#TimeDistributed" class="headerlink" title="TimeDistributed"></a>TimeDistributed</h3><p>&emsp;&emsp;该包装器可以把一个层应用到输入的每一个时间步上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keras.layers.TimeDistributed(layer)</span><br></pre></td></tr></table></figure>
<p>参数<code>layer</code>是一个网络层实例。输入至少为<code>3D</code>，且第一个维度应该是时间所表示的维度。<br>&emsp;&emsp;考虑<code>32</code>个样本的一个<code>batch</code>，其中每个样本是<code>10</code>个<code>16</code>维向量的序列。那么这个<code>batch</code>的输入尺寸为<code>(32, 10, 16)</code>，而<code>input_shape</code>不包含样本数量的维度，为<code>(10, 16)</code>。你可以使用<code>TimeDistributed</code>来将<code>Dense</code>层独立地应用到这<code>10</code>个时间步的每一个：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line"><span class="comment"># 现在“model.output_shape == (None, 10, 8)”</span></span><br><span class="line">model.add(TimeDistributed(Dense(<span class="number">8</span>), input_shape=(<span class="number">10</span>, <span class="number">16</span>)))</span><br></pre></td></tr></table></figure>
<p>输出的尺寸为<code>(32, 10, 8)</code>。在后续的层中，将不再需要<code>input_shape</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现在“model.output_shape == (None, 10, 32)”</span></span><br><span class="line">model.add(TimeDistributed(Dense(<span class="number">32</span>)))</span><br></pre></td></tr></table></figure>
<p>输出的尺寸为<code>(32, 10, 32)</code>。<br>&emsp;&emsp;使用<code>TimeDistributed</code>包装<code>Dense</code>严格等价于<code>layers.TimeDistribuedDense</code>。不同的是，包装器<code>TimeDistribued</code>还可以对别的层进行包装，如这里对<code>Convolution2D</code>包装：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(TimeDistributed(Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>)), input_shape=(<span class="number">10</span>, <span class="number">299</span>, <span class="number">299</span>, <span class="number">3</span>)))</span><br></pre></td></tr></table></figure>
<h3 id="Bidirectional"><a href="#Bidirectional" class="headerlink" title="Bidirectional"></a>Bidirectional</h3><p>&emsp;&emsp;该函数是<code>RNN</code>的双向封装器，对序列进行前向和后向计算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keras.layers.Bidirectional(layer, merge_mode=<span class="string">'concat'</span>, weights=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>layer</code>：<code>Recurrent</code>实例。</li>
<li><code>merge_mode</code>：前向和后向<code>RNN</code>的输出的结合模式，为<code>sum</code>、<code>mul</code>、<code>concat</code>、<code>ave</code>、<code>None</code>其中之一。如果是<code>None</code>，输出不会被结合，而是作为一个列表被返回。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Bidirectional(LSTM(<span class="number">10</span>, return_sequences=<span class="keyword">True</span>), input_shape=(<span class="number">5</span>, <span class="number">10</span>)))</span><br><span class="line">model.add(Bidirectional(LSTM(<span class="number">10</span>)))</span><br><span class="line">model.add(Dense(<span class="number">5</span>))</span><br><span class="line">model.add(Activation(<span class="string">'softmax'</span>))</span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>, optimizer=<span class="string">'rmsprop'</span>)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/深度学习/Keras之正则化和约束/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/深度学习/Keras之正则化和约束/" itemprop="url">Keras之正则化和约束</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T21:04:31+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>&emsp;&emsp;正则项在优化过程中对层的参数或层的激活值添加惩罚项，这些惩罚项将与损失函数一起作为网络的最终优化目标。惩罚项基于层进行惩罚，目前惩罚项的接口与层有关，但<code>Dense</code>、<code>Conv1D</code>、<code>Conv2D</code>和<code>Conv3D</code>具有共同的接口。<br>&emsp;&emsp;这些层有三个关键字参数以施加正则项：</p>
<ul>
<li><code>kernel_regularizer</code>：施加在权重上的正则项，为<code>keras.regularizer.Regularizer</code>对象。</li>
<li><code>bias_regularizer</code>：施加在偏置向量上的正则项，为<code>keras.regularizer.Regularizer</code>对象。</li>
<li><code>activity_regularizer</code>：施加在输出上的正则项，为<code>keras.regularizer.Regularizer</code>对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> regularizers</span><br><span class="line">model.add(</span><br><span class="line">    Dense(</span><br><span class="line">        <span class="number">64</span>, input_dim=<span class="number">64</span>, kernel_regularizer=regularizers.l2(<span class="number">0.01</span>),</span><br><span class="line">        activity_regularizer=regularizers.l1(<span class="number">0.01</span>)</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可用正则项：</p>
<ul>
<li><code>keras.regularizers.l1(0.)</code></li>
<li><code>keras.regularizers.l2(0.)</code></li>
<li><code>keras.regularizers.l1_l2(0.)</code></li>
</ul>
<h4 id="开发新的正则项"><a href="#开发新的正则项" class="headerlink" title="开发新的正则项"></a>开发新的正则项</h4><p>&emsp;&emsp;任何以权重矩阵作为输入并返回单个数值的函数均可以作为正则项：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">l1_reg</span><span class="params">(weight_matrix)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.01</span> * K.sum(K.abs(weight_matrix))</span><br><span class="line">​</span><br><span class="line">model.add(Dense(<span class="number">64</span>, input_dim=<span class="number">64</span>, kernel_regularizer=l1_reg)</span><br></pre></td></tr></table></figure>
<p>另外，你也可以用面向对象的方式来写你的正则化器，例子见<code>https://github.com/keras-team/keras/blob/master/keras/regularizers.py</code>模块。</p>
<hr>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>&emsp;&emsp;来自<code>constraints</code>模块的函数在优化过程中为网络的参数施加约束(例如非负)。惩罚项基于层进行惩罚，目前惩罚项的接口与层有关，但<code>Dense</code>、<code>Conv1D</code>、<code>Conv2D</code>和<code>Conv3D</code>具有共同的接口。这些层通过以下关键字施加约束项：</p>
<ul>
<li><code>kernel_constraint</code>：对主权重矩阵进行约束。</li>
<li><code>bias_constraint</code>：对偏置向量进行约束。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.constraints <span class="keyword">import</span> maxnorm</span><br><span class="line">model.add(Dense(<span class="number">64</span>, kernel_constraint=max_norm(<span class="number">2.</span>)))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;预定义约束项：</p>
<ul>
<li><code>max_norm(m=2)</code>：最大范数约束。</li>
<li><code>non_neg()</code>：非负性约束。</li>
<li><code>unit_norm()</code>：单位范数约束，强制矩阵沿最后一个轴拥有单位范数。</li>
<li><code>min_max_norm(min_value=0.0, max_value=1.0, rate=1.0, axis=0)</code>：最小/最大范数约束。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/深度学习/Keras之激活函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/深度学习/Keras之激活函数/" itemprop="url">Keras之激活函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T20:52:21+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;激活函数可以通过设置单独的激活层实现，也可以在构造层对象时通过传递<code>activation</code>参数实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Activation, Dense</span><br><span class="line"></span><br><span class="line">model.add(Dense(<span class="number">64</span>))</span><br><span class="line">model.add(Activation(<span class="string">'tanh'</span>))</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(Dense(<span class="number">64</span>, activation=<span class="string">'tanh'</span>))</span><br></pre></td></tr></table></figure>
<p>你也可以通过传递一个逐元素运算的<code>Theano/TensorFlow/CNTK</code>函数来作为激活函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"></span><br><span class="line">model.add(Dense(<span class="number">64</span>, activation=K.tanh))</span><br><span class="line">model.add(Activation(K.tanh))</span><br></pre></td></tr></table></figure>
<h3 id="预定义激活函数"><a href="#预定义激活函数" class="headerlink" title="预定义激活函数"></a>预定义激活函数</h3><h4 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h4><p>&emsp;&emsp;该函数是<code>Softmax</code>激活函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">softmax(x, axis=<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<p>参数<code>x</code>是张量，<code>axis</code>是整数，代表<code>softmax</code>所作用的维度。该函数返回<code>softmax</code>变换后的张量。</p>
<h4 id="elu"><a href="#elu" class="headerlink" title="elu"></a>elu</h4><p>&emsp;&emsp;函数原型如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elu(x, alpha=<span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="selu"><a href="#selu" class="headerlink" title="selu"></a>selu</h4><p>&emsp;&emsp;该函数是可伸缩的指数线性单元：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selu(x)</span><br></pre></td></tr></table></figure>
<p>参数<code>x</code>是一个用来用于计算激活函数的张量或变量。该函数返回与<code>x</code>具有相同类型及形状的张量。<br>&emsp;&emsp;<strong>Note</strong>：与<code>lecun_normal</code>初始化方法一起使用；与<code>dropout</code>的变种<code>AlphaDropout</code>一起使用。</p>
<h4 id="softplus"><a href="#softplus" class="headerlink" title="softplus"></a>softplus</h4><p>&emsp;&emsp;函数原型如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">softplus(x)</span><br></pre></td></tr></table></figure>
<h4 id="softsign"><a href="#softsign" class="headerlink" title="softsign"></a>softsign</h4><p>&emsp;&emsp;函数原型如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">softsign(x)</span><br></pre></td></tr></table></figure>
<h4 id="relu"><a href="#relu" class="headerlink" title="relu"></a>relu</h4><p>&emsp;&emsp;函数原型如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">relu(x, alpha=<span class="number">0.0</span>, max_value=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<h4 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h4><p>&emsp;&emsp;函数原型如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tanh(x)</span><br></pre></td></tr></table></figure>
<h4 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h4><p>&emsp;&emsp;函数原型如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sigmoid(x)</span><br></pre></td></tr></table></figure>
<h4 id="hard-sigmoid"><a href="#hard-sigmoid" class="headerlink" title="hard_sigmoid"></a>hard_sigmoid</h4><p>&emsp;&emsp;函数原型如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hard_sigmoid(x)</span><br></pre></td></tr></table></figure>
<h4 id="linear"><a href="#linear" class="headerlink" title="linear"></a>linear</h4><p>&emsp;&emsp;函数原型如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linear(x)</span><br></pre></td></tr></table></figure>
<h3 id="高级激活函数"><a href="#高级激活函数" class="headerlink" title="高级激活函数"></a>高级激活函数</h3><p>&emsp;&emsp;对于<code>Theano/TensorFlow/CNTK</code>不能表达的复杂激活函数，例如含有可学习参数的激活函数，可通过高级激活函数实现，例如<code>PReLU</code>、<code>LeakyReLU</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/opencv和图像处理/RGB转灰度算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/opencv和图像处理/RGB转灰度算法/" itemprop="url">RGB转灰度算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T19:54:48+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/opencv和图像处理/" itemprop="url" rel="index">
                    <span itemprop="name">opencv和图像处理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;对于彩色转灰度，有一个很著名的公式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gray = R * <span class="number">0.299</span> + G * <span class="number">0.587</span> + B * <span class="number">0.114</span></span><br></pre></td></tr></table></figure>
<p>而在实际应用时，希望避免低速的浮点运算，所以需要整数算法。注意到系数都是<code>3</code>位精度，可以将它们缩放<code>1000</code>倍来实现整数运算：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gray = (R * <span class="number">299</span> + G * <span class="number">587</span> + B * <span class="number">114</span> + <span class="number">500</span>) / <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p><code>RGB</code>一般是<code>8</code>位精度，现在缩放<code>1000</code>倍，所以上面的运算是<code>32</code>位整型的运算。注意后面那个除法是整数除法，所以需要加上<code>500</code>来实现四舍五入。该算法的另一个变种可以减少计算量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gray = (R * <span class="number">30</span> + G * <span class="number">59</span> + B * <span class="number">11</span> + <span class="number">50</span>) / <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的整数算法已经很快了，但是仍有一点制约速度，就是最后的那个除法。移位比除法快多了，所以可以将系数缩放成<code>2</code>的整数幂。习惯上使用<code>16</code>位精度，<code>2</code>的<code>16</code>次幂是<code>65536</code>，所以这样计算系数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.299</span> * <span class="number">65536</span> = <span class="number">19595.264</span> ≈ <span class="number">19595</span></span><br><span class="line"><span class="number">0.587</span> * <span class="number">65536</span> + (<span class="number">0.264</span>) = <span class="number">38469.632</span> + <span class="number">0.264</span> = <span class="number">38469.896</span> ≈ <span class="number">38469</span></span><br><span class="line"><span class="number">0.114</span> * <span class="number">65536</span> + (<span class="number">0.896</span>) = <span class="number">7471.104</span> + <span class="number">0.896</span> = <span class="number">7472</span></span><br></pre></td></tr></table></figure>
<p>这里所使用的舍入方式不是四舍五入，因为它会有较大的误差，应该将以前的计算结果误差一起计算进去，舍入方式是<code>去尾法</code>。写成表达式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gray = (R * <span class="number">19595</span> + G * <span class="number">38469</span> + B * <span class="number">7472</span>) &gt;&gt; <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p><code>2</code>至<code>20</code>位精度的系数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Gray = (R * <span class="number">1</span>      + G * <span class="number">2</span>      + B * <span class="number">1</span>     ) &gt;&gt; <span class="number">2</span></span><br><span class="line">Gray = (R * <span class="number">2</span>      + G * <span class="number">5</span>      + B * <span class="number">1</span>     ) &gt;&gt; <span class="number">3</span></span><br><span class="line">Gray = (R * <span class="number">4</span>      + G * <span class="number">10</span>     + B * <span class="number">2</span>     ) &gt;&gt; <span class="number">4</span></span><br><span class="line">Gray = (R * <span class="number">9</span>      + G * <span class="number">19</span>     + B * <span class="number">4</span>     ) &gt;&gt; <span class="number">5</span></span><br><span class="line">Gray = (R * <span class="number">19</span>     + G * <span class="number">37</span>     + B * <span class="number">8</span>     ) &gt;&gt; <span class="number">6</span></span><br><span class="line">Gray = (R * <span class="number">38</span>     + G * <span class="number">75</span>     + B * <span class="number">15</span>    ) &gt;&gt; <span class="number">7</span></span><br><span class="line">Gray = (R * <span class="number">76</span>     + G * <span class="number">150</span>    + B * <span class="number">30</span>    ) &gt;&gt; <span class="number">8</span></span><br><span class="line">Gray = (R * <span class="number">153</span>    + G * <span class="number">300</span>    + B * <span class="number">59</span>    ) &gt;&gt; <span class="number">9</span></span><br><span class="line">Gray = (R * <span class="number">306</span>    + G * <span class="number">601</span>    + B * <span class="number">117</span>   ) &gt;&gt; <span class="number">10</span></span><br><span class="line">Gray = (R * <span class="number">612</span>    + G * <span class="number">1202</span>   + B * <span class="number">234</span>   ) &gt;&gt; <span class="number">11</span></span><br><span class="line">Gray = (R * <span class="number">1224</span>   + G * <span class="number">2405</span>   + B * <span class="number">467</span>   ) &gt;&gt; <span class="number">12</span></span><br><span class="line">Gray = (R * <span class="number">2449</span>   + G * <span class="number">4809</span>   + B * <span class="number">934</span>   ) &gt;&gt; <span class="number">13</span></span><br><span class="line">Gray = (R * <span class="number">4898</span>   + G * <span class="number">9618</span>   + B * <span class="number">1868</span>  ) &gt;&gt; <span class="number">14</span></span><br><span class="line">Gray = (R * <span class="number">9797</span>   + G * <span class="number">19235</span>  + B * <span class="number">3736</span>  ) &gt;&gt; <span class="number">15</span></span><br><span class="line">Gray = (R * <span class="number">19595</span>  + G * <span class="number">38469</span>  + B * <span class="number">7472</span>  ) &gt;&gt; <span class="number">16</span></span><br><span class="line">Gray = (R * <span class="number">39190</span>  + G * <span class="number">76939</span>  + B * <span class="number">14943</span> ) &gt;&gt; <span class="number">17</span></span><br><span class="line">Gray = (R * <span class="number">78381</span>  + G * <span class="number">153878</span> + B * <span class="number">29885</span> ) &gt;&gt; <span class="number">18</span></span><br><span class="line">Gray = (R * <span class="number">156762</span> + G * <span class="number">307757</span> + B * <span class="number">59769</span> ) &gt;&gt; <span class="number">19</span></span><br><span class="line">Gray = (R * <span class="number">313524</span> + G * <span class="number">615514</span> + B * <span class="number">119538</span>) &gt;&gt; <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;一道面试题：写一个函数，将一个<code>32</code>位<code>RGB</code>像素的色值转为灰度，<code>RGB</code>转灰度的公式为<code>Grey = 0.03 * red + 0.59 * green + 0.11 * blue</code>；<code>RGB</code>像素格式(左边最高位，右边最低位)为<code>00000000RRRRRRRRGGGGGGGGBBBBBBBB</code>。答案如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ToGrey</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> rgb )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> blue = ( rgb &amp; <span class="number">0x000000FF</span> ) &gt;&gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> green = ( rgb &amp; <span class="number">0x0000FF00</span> ) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> red = ( rgb &amp; <span class="number">0x00FF0000</span> ) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"\nred = %d, green = %d, blue = %d\n"</span>, red, green, blue );</span><br><span class="line">    <span class="keyword">return</span> ( red * <span class="number">38</span> + green * <span class="number">75</span> + blue * <span class="number">15</span> ) &gt;&gt; <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/opencv和图像处理/随机数生成器RNG/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/opencv和图像处理/随机数生成器RNG/" itemprop="url">随机数生成器RNG</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T18:43:42+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/opencv和图像处理/" itemprop="url" rel="index">
                    <span itemprop="name">opencv和图像处理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>C</code>语言和<code>C++</code>中产生随机数的方法(<code>rand</code>和<code>srand</code>等)在<code>OpenCV</code>中仍可以用。此外，<code>OpenCV</code>还特地编写了<code>C++</code>的随机数类<code>RNG</code>，<code>C</code>的随机数类<code>CvRNG</code>，以及一些相关的函数。注意如下说明：</p>
<ul>
<li>关键字前带<code>cv</code>的都是<code>C</code>语言里的写法，不带<code>cv</code>的是<code>C++</code>里的写法。比如<code>CvRNG</code>和<code>RNG</code>，其本质都是一样的。</li>
<li>计算机产生的随机数都是伪随机数，是根据种子<code>seed</code>和特定算法计算出来的。所以只要种子一定，算法一定，产生的随机数是相同的。</li>
<li>要想产生完全重复的随机数，可以用系统时间做种子。在<code>OpenCV</code>中使用<code>GetTickCount</code>，<code>C</code>语言中用<code>time</code>。</li>
</ul>
<h3 id="RNG"><a href="#RNG" class="headerlink" title="RNG"></a>RNG</h3><p>&emsp;&emsp;<code>RNG</code>类是<code>opencv</code>里<code>C++</code>的随机数产生器。它可产生一个<code>64</code>位的<code>int</code>随机数。目前可按均匀分布和高斯分布产生随机数。随机数的产生采用的是<code>Multiply-With-Carry</code>算法和<code>Ziggurat</code>算法。<br>&emsp;&emsp;<code>RNG</code>可以产生如下随机数：</p>
<ul>
<li><code>RNG(int seed)</code>：使用种子seed产生一个64位随机整数，默认<code>-1</code>。</li>
<li><code>RNG::uniform()</code>：产生一个均匀分布的随机数。</li>
<li><code>RNG::gaussian()</code>：产生一个高斯分布的随机数。</li>
<li><code>RNG::uniform(a,b)</code>：返回一个<code>[a, b)</code>范围的均匀分布的随机数，a和b的数据类型要一致，而且必须是<code>int</code>、<code>float</code>、<code>double</code>中的一种，默认是<code>int</code>。</li>
<li><code>RNG::gaussian(σ)</code>：返回一个均值为<code>0</code>，标准差为<code>σ</code>的随机数。如果要产生均值为<code>λ</code>，标准差为<code>σ</code>的随机数，可以使用<code>λ + RNG::gaussian(σ)</code>。</li>
</ul>
<p>&emsp;&emsp;代码示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RNG rng; <span class="comment">/* 创建RNG对象，使用默认种子“-1” */</span></span><br><span class="line"><span class="keyword">int</span> N1 = rng; <span class="comment">/* 产生64位整数 */</span></span><br><span class="line"><span class="comment">/* 总是得到double类型数据0.000000，因为会调用uniform(int, int)，只会取整数，所以只产生0 */</span></span><br><span class="line"><span class="keyword">double</span> N1a = rng.uniform ( <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line"><span class="comment">/* 产生[0,1)范围内均匀分布的double类型数据 */</span></span><br><span class="line"><span class="keyword">double</span> N1b = rng.uniform ( ( <span class="keyword">double</span> ) <span class="number">0</span>, ( <span class="keyword">double</span> ) <span class="number">1</span> );</span><br><span class="line"><span class="comment">/* 产生[0,1)范围内均匀分布的float类型数据，注意被自动转换为double了 */</span></span><br><span class="line"><span class="keyword">double</span> N1c = rng.uniform ( <span class="number">0.f</span>, <span class="number">1.f</span> );</span><br><span class="line"><span class="comment">/* 产生[0,1)范围内均匀分布的double类型数据 */</span></span><br><span class="line"><span class="keyword">double</span> N1d = rng.uniform ( <span class="number">0.</span>, <span class="number">1.</span> );</span><br><span class="line"><span class="comment">/* 产生符合均值为0，标准差为2的高斯分布的随机数 */</span></span><br><span class="line"><span class="keyword">double</span> N1g = rng.gaussian ( <span class="number">2</span> );</span><br></pre></td></tr></table></figure>
<p>其实<code>rng</code>既是一个<code>RNG</code>对象，也是一个随机整数。</p>
<h3 id="返回下一个随机数"><a href="#返回下一个随机数" class="headerlink" title="返回下一个随机数"></a>返回下一个随机数</h3><p>&emsp;&emsp;上面一次只能返回一个随机数，实际上系统已经生成一个随机数组。如果我们要连续获得随机数，没有必要重新定义一个<code>RNG</code>类，只需要取出随机数组的下一个随机数即可。</p>
<ul>
<li><code>RNG::next</code>：返回下一个<code>64</code>位随机整数。</li>
<li><code>RNG::operator</code>：返回下一个指定类型的随机数。</li>
</ul>
<p>&emsp;&emsp;代码示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RNG rng;</span><br><span class="line"><span class="keyword">int</span> N2 = rng.next(); <span class="comment">/* 返回下一个随机整数，即“N1.next();” */</span></span><br><span class="line"><span class="comment">/* 返回下一个指定类型的随机数 */</span></span><br><span class="line"><span class="keyword">int</span> N2a = rng.<span class="keyword">operator</span> uchar(); <span class="comment">/* 返回下一个无符号字符数 */</span></span><br><span class="line"><span class="keyword">int</span> N2b = rng.<span class="keyword">operator</span> schar(); <span class="comment">/* 返回下一个有符号字符数 */</span></span><br><span class="line"><span class="keyword">int</span> N2c = rng.<span class="keyword">operator</span> ushort(); <span class="comment">/* 返回下一个无符号短型 */</span></span><br><span class="line"><span class="keyword">int</span> N2d = rng.<span class="keyword">operator</span> <span class="keyword">short</span> <span class="keyword">int</span>(); <span class="comment">/* 返回下一个短整型数 */</span></span><br><span class="line"><span class="keyword">int</span> N2e = rng.<span class="keyword">operator</span> <span class="keyword">int</span>(); <span class="comment">/* 返回下一个整型数 */</span></span><br><span class="line"><span class="keyword">int</span> N2f = rng.<span class="keyword">operator</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>(); <span class="comment">/* 返回下一个无符号整型数 */</span></span><br><span class="line"><span class="keyword">int</span> N2g = rng.<span class="keyword">operator</span> <span class="keyword">float</span>(); <span class="comment">/* 返回下一个浮点数 */</span></span><br><span class="line"><span class="keyword">int</span> N2h = rng.<span class="keyword">operator</span> <span class="keyword">double</span>(); <span class="comment">/* 返回下一个double型数 */</span></span><br><span class="line"><span class="keyword">int</span> N2i = rng.<span class="keyword">operator</span> ()(); <span class="comment">/* 和“rng.next()”等价 */</span></span><br><span class="line"><span class="keyword">int</span> N2j = rng.<span class="keyword">operator</span> ()(<span class="number">100</span>); <span class="comment">/* 返回[0, 100)范围内的随机数 */</span></span><br></pre></td></tr></table></figure>
<h3 id="用随机数填充矩阵RNG-fill"><a href="#用随机数填充矩阵RNG-fill" class="headerlink" title="用随机数填充矩阵RNG::fill"></a>用随机数填充矩阵RNG::fill</h3><p>&emsp;&emsp;函数原型如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    InputOutputArray mat, <span class="keyword">int</span> distType, InputArray a,</span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray b, <span class="keyword">bool</span> saturateRange = <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mat</code>：输入输出矩阵，最多支持<code>4</code>通道，超过<code>4</code>通道先用<code>reshape</code>改变结构。</li>
<li><code>distType</code>：<code>UNIFORM</code>或<code>NORMAL</code>，表示均匀分布和高斯分布。</li>
<li><code>a</code>：如果<code>disType</code>是<code>UNIFORM</code>，则<code>a</code>表示为下界(闭区间)；如果<code>disType</code>是<code>NORMAL</code>，则<code>a</code>表示均值。</li>
<li><code>b</code>：如果<code>disType</code>是<code>UNIFORM</code>，则<code>b</code>表示为上界(开区间)；如果<code>disType</code>是<code>NORMAL</code>，则<code>b</code>标准差。</li>
<li><code>saturateRange</code>：只针对均匀分布有效。当为真的时候，会先把产生随机数的范围变换到数据类型的范围，再产生随机数；如果为假，会先产生随机数，再进行截断到数据类型的有效区间。</li>
</ul>
<p>&emsp;&emsp;代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 产生[1, 1000)均匀分布的int随机数填充fillM */</span></span><br><span class="line">Mat_&lt;<span class="keyword">int</span>&gt; fillM ( <span class="number">3</span>, <span class="number">3</span> );</span><br><span class="line">rng.fill ( fillM, RNG::UNIFORM, <span class="number">1</span>, <span class="number">1000</span> );</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"filM = "</span> &lt;&lt; fillM &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">​</span><br><span class="line"><span class="function">Mat <span class="title">fillM1</span> <span class="params">( <span class="number">3</span>, <span class="number">3</span>, CV_8U )</span></span>;</span><br><span class="line">rng.fill ( fillM1, RNG::UNIFORM, <span class="number">1</span>, <span class="number">1000</span>, TRUE );</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"filM1 = "</span> &lt;&lt; fillM1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">​</span><br><span class="line"><span class="function">Mat <span class="title">fillM2</span> <span class="params">( <span class="number">3</span>, <span class="number">3</span>, CV_8U )</span></span>;</span><br><span class="line">rng.fill ( fillM2, RNG::UNIFORM, <span class="number">1</span>, <span class="number">1000</span>, FALSE );</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"filM2 = "</span> &lt;&lt; fillM2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* fillM1产生的数据都在[0, 255)内，且小于255 */</span></span><br><span class="line"><span class="comment">/* fillM2产生的数据虽然也在同样范围内，但是由于用了截断操作，所以很多数据都是255 */</span></span><br><span class="line"><span class="comment">/* 产生均值为1，标准差为3的随机double数填进fillN */</span></span><br><span class="line">Mat_&lt;<span class="keyword">double</span>&gt;fillN ( <span class="number">3</span>, <span class="number">3</span> );</span><br><span class="line">rng.fill ( fillN, RNG::NORMAL, <span class="number">1</span>, <span class="number">3</span> );</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"filN = "</span> &lt;&lt; fillN &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="randu"><a href="#randu" class="headerlink" title="randu"></a>randu</h3><p>&emsp;&emsp;<code>randu</code>的作用是返回均匀分布的随机数，填入数组或矩阵，其函数原型如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randu ( dst, low, high );</span><br></pre></td></tr></table></figure>
<p>参数<code>dst</code>是输出数组或矩阵，<code>low</code>是区间下界(闭区间)，<code>high</code>是区间上界(开区间)。代码示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mat_&lt;<span class="keyword">int</span>&gt; randuM ( <span class="number">3</span>, <span class="number">3</span> );</span><br><span class="line">randu ( randuM, Scalar ( <span class="number">0</span> ), Scalar ( <span class="number">255</span> ) );</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"randuM = "</span> &lt;&lt; randuM &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>其实<code>randu</code>和<code>rng.fill</code>功能是类似的，只不过<code>rng</code>需要先进行定义。</p>
<h3 id="randn"><a href="#randn" class="headerlink" title="randn"></a>randn</h3><p>&emsp;&emsp;<code>randn</code>的作用是返回高斯分布的随机数，填入数组或矩阵，其函数原型如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randn ( dst, mean, stddev );</span><br></pre></td></tr></table></figure>
<p>参数<code>dst</code>是输出数组或矩阵，<code>mean</code>是均值，<code>stddev</code>是标准差。代码示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mat_&lt;<span class="keyword">int</span>&gt; randnM ( <span class="number">3</span>, <span class="number">3</span> );</span><br><span class="line">randn ( randnM, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"randnM = "</span> &lt;&lt; randnM &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="randShuffle"><a href="#randShuffle" class="headerlink" title="randShuffle"></a>randShuffle</h3><p>&emsp;&emsp;<code>randShuffle</code>的作用是将原数组(矩阵)打乱，其函数原型如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randShuffle (InputOutputArray dst, <span class="keyword">double</span> iterFactor = <span class="number">1.</span>, RNG *rng = <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>dst</code>：输入输出数组(一维)。</li>
<li><code>iterFactor</code>：决定交换数值的行列的位置的一个系数。</li>
<li><code>rng</code>：(可选)随机数产生器，它决定了打乱的方法。<code>0</code>表示使用默认的随机数产生器，即<code>seed = -1</code>。</li>
</ul>
<p>&emsp;&emsp;代码示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mat randShufM = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">2</span>, <span class="number">3</span> ) &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> );</span><br><span class="line">randShuffle ( randShufM, <span class="number">7</span>, <span class="number">0</span> );</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"randShufM = "</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; randShufM &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="CvRNG"><a href="#CvRNG" class="headerlink" title="CvRNG"></a>CvRNG</h3><p>&emsp;&emsp;<code>CvRNG</code>的作用是产生<code>64</code>位随机整数，<code>C++</code>版本中的<code>RNG</code>已经代替了<code>CvRNG</code>。</p>
<h3 id="cvRandArr"><a href="#cvRandArr" class="headerlink" title="cvRandArr"></a>cvRandArr</h3><p>&emsp;&emsp;<code>cvRandArr</code>的作用是用<code>CvRNG</code>产生的随机数填充数组(矩阵)，其函数原型如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvRandArr</span> <span class="params">(CvRNG *rng, CvArr *arr, <span class="keyword">int</span> dist_type, CvScalar param1, CvScalar param2)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>rng</code>：被<code>cvRNG</code>初始化的<code>RNG</code>状态。</li>
<li><code>arr</code>：输出数组。</li>
<li><code>dist_type</code>：<code>CV_RAND_UNI</code>或者<code>CV_RAND_NORMAL</code>。</li>
<li><code>param1</code>：如果是均匀分布，则它是随机数范围的闭下边界；如果是正态分布，则它是随机数的平均值。</li>
<li><code>param2</code>：如果是均匀分布，则它是随机数范围的开上边界；如果是正态分布，则它是随机数的标准差。</li>
</ul>
<p>&emsp;&emsp;代码示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CvMat *cvM = cvCreateMat ( <span class="number">3</span>, <span class="number">3</span>, CV_16U ); <span class="comment">/* 创建“3 * 3”的矩阵 */</span></span><br><span class="line"><span class="comment">/* 给cvM赋值，范围是[0, 255) */</span></span><br><span class="line">cvRandArr ( &amp;cvRNG, cvM, CV_RAND_UNI, cvScalarAll ( <span class="number">0</span> ), cvScalarAll ( <span class="number">255</span> ) );</span><br><span class="line">​</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"cvM = "</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ ) &#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ( <span class="keyword">int</span> ) cvGetReal2D ( cvM, i, j ) &lt;&lt; <span class="string">"   "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cvRandInt"><a href="#cvRandInt" class="headerlink" title="cvRandInt"></a>cvRandInt</h3><p>&emsp;&emsp;<code>cvRandInt</code>的函数原型如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">cvRandInt</span> <span class="params">( CvRNG *rng )</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>cvRandInt</code>返回均匀分布的随机<code>32 bit</code>无符号整型值，并更新<code>RNG</code>状态；它和<code>C</code>运行库里面的<code>rand</code>函数十分相似，但是它产生的总是一个<code>32 bit</code>数，而<code>rand</code>返回一个<code>0</code>到<code>RAND_MAX</code>(它是<code>2^16</code>或者<code>2^32</code>，依赖于操作平台)之间的数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cvInt = cvRandInt ( &amp;cvRNG );</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"cvInt = "</span> &lt;&lt; cvInt &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvRandReal"><a href="#cvRandReal" class="headerlink" title="cvRandReal"></a>cvRandReal</h3><p>&emsp;&emsp;<code>cvRandReal</code>的函数原型如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cvRandReal</span> <span class="params">( CvRNG *rng )</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数的作用是返回均匀分布的随机浮点数，范围是<code>[0, 1)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> cvDouble = cvRandReal ( &amp;cvRNG );</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"cvDouble = "</span> &lt;&lt; cvDouble &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>&emsp;&emsp;示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cv.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"highgui.h"</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    RNG rng;</span><br><span class="line">    <span class="keyword">int</span> N1 = rng;</span><br><span class="line">    <span class="keyword">double</span> N1a = rng.uniform ( <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">double</span> N1b = rng.uniform ( ( <span class="keyword">double</span> ) <span class="number">0</span>, ( <span class="keyword">double</span> ) <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">double</span> N1c = rng.uniform ( <span class="number">0.f</span>, <span class="number">1.f</span> );</span><br><span class="line">    <span class="keyword">double</span> N1d = rng.uniform ( <span class="number">0.</span>, <span class="number">1.</span> );</span><br><span class="line">    <span class="keyword">double</span> N1g = rng.gaussian ( <span class="number">2</span> );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N1 = "</span> &lt;&lt; N1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N1a = "</span> &lt;&lt; N1a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N1b = "</span> &lt;&lt; N1b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N1c = "</span> &lt;&lt; N1c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N1d = "</span> &lt;&lt; N1d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N1g = "</span> &lt;&lt; N1g &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> N2 = rng.next();</span><br><span class="line">    <span class="keyword">int</span> N2a = rng.<span class="keyword">operator</span> uchar();</span><br><span class="line">    <span class="keyword">int</span> N2b = rng.<span class="keyword">operator</span> schar();</span><br><span class="line">    <span class="keyword">int</span> N2c = rng.<span class="keyword">operator</span> ushort();</span><br><span class="line">    <span class="keyword">int</span> N2d = rng.<span class="keyword">operator</span> <span class="keyword">short</span> <span class="keyword">int</span>();</span><br><span class="line">    <span class="keyword">int</span> N2e = rng.<span class="keyword">operator</span> <span class="keyword">int</span>();</span><br><span class="line">    <span class="keyword">int</span> N2f = rng.<span class="keyword">operator</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>();</span><br><span class="line">    <span class="keyword">int</span> N2g = rng.<span class="keyword">operator</span> <span class="keyword">float</span>();</span><br><span class="line">    <span class="keyword">int</span> N2h = rng.<span class="keyword">operator</span> <span class="keyword">double</span>();</span><br><span class="line">    <span class="keyword">int</span> N2i = rng.<span class="keyword">operator</span> () (); <span class="comment">/* 和“rng.next()”等价 */</span></span><br><span class="line">    <span class="keyword">int</span> N2j = rng.<span class="keyword">operator</span> () ( <span class="number">100</span> ); <span class="comment">/* 返回[0,100)范围内的随机数 */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N2 = "</span> &lt;&lt; N2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N2a = "</span> &lt;&lt; N2a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N2b = "</span> &lt;&lt; N2b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N2c = "</span> &lt;&lt; N2c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N2d = "</span> &lt;&lt; N2d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N2e = "</span> &lt;&lt; N2e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N2f = "</span> &lt;&lt; N2f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N2g = "</span> &lt;&lt; N2g &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N2h = "</span> &lt;&lt; N2h &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N2i = "</span> &lt;&lt; N2i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"N2j = "</span> &lt;&lt; N2j &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Mat_&lt;<span class="keyword">int</span>&gt;fillM ( <span class="number">3</span>, <span class="number">3</span> );</span><br><span class="line">    rng.fill ( fillM, RNG::UNIFORM, <span class="number">1</span>, <span class="number">1000</span> );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"filM = "</span> &lt;&lt; fillM &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Mat <span class="title">fillM1</span> <span class="params">( <span class="number">3</span>, <span class="number">3</span>, CV_8U )</span></span>;</span><br><span class="line">    rng.fill ( fillM1, RNG::UNIFORM, <span class="number">1</span>, <span class="number">1000</span>, TRUE );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"filM1 = "</span> &lt;&lt; fillM1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Mat <span class="title">fillM2</span> <span class="params">( <span class="number">3</span>, <span class="number">3</span>, CV_8U )</span></span>;</span><br><span class="line">    rng.fill ( fillM2, RNG::UNIFORM, <span class="number">1</span>, <span class="number">1000</span>, FALSE );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"filM2 = "</span> &lt;&lt; fillM2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Mat_&lt;<span class="keyword">double</span>&gt;fillN ( <span class="number">3</span>, <span class="number">3</span> );</span><br><span class="line">    rng.fill ( fillN, RNG::NORMAL, <span class="number">1</span>, <span class="number">3</span> );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"filN = "</span> &lt;&lt; fillN &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Mat_&lt;<span class="keyword">int</span>&gt;randuM ( <span class="number">3</span>, <span class="number">3</span> );</span><br><span class="line">    randu ( randuM, Scalar ( <span class="number">0</span> ), Scalar ( <span class="number">255</span> ) );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"randuM = "</span> &lt;&lt; randuM &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Mat_&lt;<span class="keyword">int</span>&gt;randnM ( <span class="number">3</span>, <span class="number">3</span> );</span><br><span class="line">    randn ( randnM, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"randnM = "</span> &lt;&lt; randnM &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Mat randShufM = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">2</span>, <span class="number">3</span> ) &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> );</span><br><span class="line">    randShuffle ( randShufM, <span class="number">7</span>, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"randShufM = "</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; randShufM &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    CvRNG cvRNG;</span><br><span class="line">    CvMat *cvM = cvCreateMat ( <span class="number">3</span>, <span class="number">3</span>, CV_16U );</span><br><span class="line">    cvRandArr ( &amp;cvRNG, cvM, CV_RAND_UNI, cvScalarAll ( <span class="number">0</span> ), cvScalarAll ( <span class="number">255</span> ) );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"cvM = "</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ ) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ( <span class="keyword">int</span> ) cvGetReal2D ( cvM, i, j ) &lt;&lt; <span class="string">"   "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> cvInt = cvRandInt ( &amp;cvRNG );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"cvInt = "</span> &lt;&lt; cvInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">double</span> cvDouble = cvRandReal ( &amp;cvRNG );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"cvDouble = "</span> &lt;&lt; cvDouble &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"\nrand1 ="</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"%d "</span>, rand() % <span class="number">10</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"\nsrand1 ="</span> );</span><br><span class="line">    srand ( <span class="number">8</span> );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"%d "</span>, rand() % <span class="number">10</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"\nsrand2 ="</span> );</span><br><span class="line">    srand ( ( <span class="keyword">unsigned</span> ) time ( <span class="literal">NULL</span> ) );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"%d "</span>, rand() % <span class="number">10</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"\n"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">N1 = <span class="number">130063606</span></span><br><span class="line">N1a = <span class="number">0</span></span><br><span class="line">N1b = <span class="number">0.901059</span></span><br><span class="line">N1c = <span class="number">0.937133</span></span><br><span class="line">N1d = <span class="number">0.74879</span></span><br><span class="line">N1g = <span class="number">0.610327</span></span><br><span class="line">N2 = <span class="number">-825516420</span></span><br><span class="line">N2a = <span class="number">89</span></span><br><span class="line">N2b = <span class="number">31</span></span><br><span class="line">N2c = <span class="number">63210</span></span><br><span class="line">N2d = <span class="number">-12177</span></span><br><span class="line">N2e = <span class="number">-1825102358</span></span><br><span class="line">N2f = <span class="number">-1445585521</span></span><br><span class="line">N2g = <span class="number">0</span></span><br><span class="line">N2h = <span class="number">0</span></span><br><span class="line">N2i = <span class="number">-1504473379</span></span><br><span class="line">N2j = <span class="number">3</span></span><br><span class="line">​</span><br><span class="line">filM = [<span class="number">206</span>, <span class="number">507</span>, <span class="number">646</span>;</span><br><span class="line">  <span class="number">656</span>, <span class="number">931</span>, <span class="number">673</span>;</span><br><span class="line">  <span class="number">416</span>, <span class="number">656</span>, <span class="number">907</span>]</span><br><span class="line">​</span><br><span class="line">filM1 = [<span class="number">198</span>, <span class="number">192</span>, <span class="number">197</span>;</span><br><span class="line">  <span class="number">41</span>, <span class="number">8</span>, <span class="number">244</span>;</span><br><span class="line">  <span class="number">231</span>, <span class="number">46</span>, <span class="number">7</span>]</span><br><span class="line">​</span><br><span class="line">filM2 = [<span class="number">255</span>, <span class="number">15</span>, <span class="number">255</span>;</span><br><span class="line">  <span class="number">255</span>, <span class="number">77</span>, <span class="number">255</span>;</span><br><span class="line">  <span class="number">175</span>, <span class="number">255</span>, <span class="number">251</span>]</span><br><span class="line">​</span><br><span class="line">filN = [<span class="number">-1.242041528224945</span>, <span class="number">-0.8259760141372681</span>, <span class="number">0.361901268362999</span>;</span><br><span class="line">  <span class="number">4.484118342399597</span>, <span class="number">-4.914619922637939</span>, <span class="number">3.093811929225922</span>;</span><br><span class="line">  <span class="number">0.3505408614873886</span>, <span class="number">1.294025518000126</span>, <span class="number">1.788093090057373</span>]</span><br><span class="line">​</span><br><span class="line">randuM = [<span class="number">91</span>, <span class="number">2</span>, <span class="number">79</span>;</span><br><span class="line">  <span class="number">179</span>, <span class="number">52</span>, <span class="number">205</span>;</span><br><span class="line">  <span class="number">236</span>, <span class="number">8</span>, <span class="number">181</span>]</span><br><span class="line">​</span><br><span class="line">randnM = [<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>;</span><br><span class="line">  <span class="number">1</span>, <span class="number">-2</span>, <span class="number">-2</span>;</span><br><span class="line">  <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">​</span><br><span class="line">randShufM =</span><br><span class="line">[<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">  <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">​</span><br><span class="line">cvM = <span class="number">126</span>   <span class="number">39</span>   <span class="number">3</span></span><br><span class="line"><span class="number">136</span>   <span class="number">46</span>   <span class="number">146</span></span><br><span class="line"><span class="number">241</span>   <span class="number">78</span>   <span class="number">132</span></span><br><span class="line">​</span><br><span class="line">cvInt = <span class="number">526971887</span></span><br><span class="line">cvDouble = <span class="number">0.909635</span></span><br><span class="line">​</span><br><span class="line">rand1 =<span class="number">3</span> <span class="number">6</span> <span class="number">7</span> <span class="number">5</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">9</span> <span class="number">1</span></span><br><span class="line">srand1 =<span class="number">6</span> <span class="number">4</span> <span class="number">2</span> <span class="number">9</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">7</span> <span class="number">3</span></span><br><span class="line">srand2 =<span class="number">9</span> <span class="number">1</span> <span class="number">1</span> <span class="number">9</span> <span class="number">1</span> <span class="number">7</span> <span class="number">9</span> <span class="number">3</span> <span class="number">7</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/opencv和图像处理/cvSeq的用法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/opencv和图像处理/cvSeq的用法/" itemprop="url">cvSeq的用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T18:13:46+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/opencv和图像处理/" itemprop="url" rel="index">
                    <span itemprop="name">opencv和图像处理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="cvCreateSeq"><a href="#cvCreateSeq" class="headerlink" title="cvCreateSeq"></a>cvCreateSeq</h3><p>&emsp;&emsp;该函数的功能是创建一个序列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CvSeq *<span class="title">cvCreateSeq</span> <span class="params">(<span class="keyword">int</span> seq_flags, <span class="keyword">int</span> header_size, <span class="keyword">int</span> elem_size, CvMemStorage *storage)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>seq_flags</code>：它是序列的符号标志。如果序列不会被传递给任何使用特定序列的函数，那么将它设为<code>0</code>，否则从预定义的序列类型中选择一合适的类型。</li>
<li><code>header_size</code>：它是序列头部的大小，其值必须大于或等于<code>sizeof(CvSeq)</code>。如果制定了类型或它的扩展名，则此类型必须适合基类的头部大小。</li>
<li><code>elem_size</code>：它是元素的大小，以字节计算。这个大小必须与序列类型(由<code>seq_flags</code>指定)相一致。例如对于一个点的序列，元素类型<code>CV_SEQ_ELTYPE_POINT</code>应当被指定，参数<code>elem_size</code>必须等同于<code>sizeof(CvPoint)</code>。</li>
<li><code>storage</code>：它指向前面定义的内存存储器。</li>
</ul>
<h3 id="cvCloneSeq"><a href="#cvCloneSeq" class="headerlink" title="cvCloneSeq"></a>cvCloneSeq</h3><p>&emsp;&emsp;该函数的作用是创建序列的一份拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CvSeq *<span class="title">cvCloneSeq</span> <span class="params">( <span class="keyword">const</span> CvSeq *seq, CvMemStorage *storage = <span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqInvert"><a href="#cvSeqInvert" class="headerlink" title="cvSeqInvert"></a>cvSeqInvert</h3><p>&emsp;&emsp;该函数的作用是将序列中的元素进行逆序操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSeqInvert</span> <span class="params">( CvSeq *seq )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqSort"><a href="#cvSeqSort" class="headerlink" title="cvSeqSort"></a>cvSeqSort</h3><p>&emsp;&emsp;该函数的功能是使用特定的比较函数对序列中的元素进行排序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSeqSort</span> <span class="params">( CvSeq *seq, CvCmpFunc func, <span class="keyword">void</span> *userdata = <span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqSearch"><a href="#cvSeqSearch" class="headerlink" title="cvSeqSearch"></a>cvSeqSearch</h3><p>&emsp;&emsp;该函数的功能是查询序列中的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">cvSeqSearch</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    CvSeq *seq, <span class="keyword">const</span> <span class="keyword">void</span> *elem, CvCmpFunc func,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> is_sorted, <span class="keyword">int</span> *elem_idx, <span class="keyword">void</span> *userdata = <span class="literal">NULL</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvClearSeq"><a href="#cvClearSeq" class="headerlink" title="cvClearSeq"></a>cvClearSeq</h3><p>&emsp;&emsp;其函数的功能是清空序列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvClearSeq</span> <span class="params">( CvSeq *seq )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqPush"><a href="#cvSeqPush" class="headerlink" title="cvSeqPush"></a>cvSeqPush</h3><p>&emsp;&emsp;该函数的功能是添加元素到序列的尾部：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">cvSeqPush</span> <span class="params">( CvSeq *seq, <span class="keyword">void</span> *element = <span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqPop"><a href="#cvSeqPop" class="headerlink" title="cvSeqPop"></a>cvSeqPop</h3><p>&emsp;&emsp;该函数的作用是删除序列尾部元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSeqPop</span> <span class="params">( CvSeq *seq, <span class="keyword">void</span> *element = <span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqPushFront"><a href="#cvSeqPushFront" class="headerlink" title="cvSeqPushFront"></a>cvSeqPushFront</h3><p>&emsp;&emsp;该函数的作用是在序列头部添加元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">cvSeqPushFront</span> <span class="params">( CvSeq *seq, <span class="keyword">void</span> *element = <span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqPopFront"><a href="#cvSeqPopFront" class="headerlink" title="cvSeqPopFront"></a>cvSeqPopFront</h3><p>&emsp;&emsp;其函数的作用是删除在序列的头部的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSeqPopFront</span> <span class="params">( CvSeq *seq, <span class="keyword">void</span> *element = <span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqPushMulti"><a href="#cvSeqPushMulti" class="headerlink" title="cvSeqPushMulti"></a>cvSeqPushMulti</h3><p>&emsp;&emsp;其函数的作用是添加多个元素到序列尾部或头部：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSeqPushMulti</span> <span class="params">( CvSeq *seq, <span class="keyword">void</span> *elements, <span class="keyword">int</span> count, <span class="keyword">int</span> in_front = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqPopMulti"><a href="#cvSeqPopMulti" class="headerlink" title="cvSeqPopMulti"></a>cvSeqPopMulti</h3><p>&emsp;&emsp;其函数作用是删除多个序列头部或尾部元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSeqPopMulti</span> <span class="params">( CvSeq *seq, <span class="keyword">void</span> *elements, <span class="keyword">int</span> count, <span class="keyword">int</span> in_front = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqInsert"><a href="#cvSeqInsert" class="headerlink" title="cvSeqInsert"></a>cvSeqInsert</h3><p>&emsp;&emsp;该函数的作用是在序列中的指定位置添加元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">cvSeqInsert</span> <span class="params">( CvSeq *seq, <span class="keyword">int</span> before_index, <span class="keyword">void</span> *element = <span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqRemove"><a href="#cvSeqRemove" class="headerlink" title="cvSeqRemove"></a>cvSeqRemove</h3><p>&emsp;&emsp;其函数的作用是删除序列中的指定位置的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSeqRemove</span> <span class="params">( CvSeq *seq, <span class="keyword">int</span> index )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvGetSeqElem"><a href="#cvGetSeqElem" class="headerlink" title="cvGetSeqElem"></a>cvGetSeqElem</h3><p>&emsp;&emsp;其函数的作用是返回索引所指定的元素指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">cvGetSeqElem</span> <span class="params">( <span class="keyword">const</span> CvSeq *seq, <span class="keyword">int</span> index )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvSeqElemIdx"><a href="#cvSeqElemIdx" class="headerlink" title="cvSeqElemIdx"></a>cvSeqElemIdx</h3><p>&emsp;&emsp;其函数的作用是返回序列中元素的索引：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cvSeqElemIdx</span> <span class="params">( <span class="keyword">const</span> CvSeq *seq, <span class="keyword">const</span> <span class="keyword">void</span> *element, CvSeqBlock **block = <span class="literal">NULL</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvStartAppendToSeq"><a href="#cvStartAppendToSeq" class="headerlink" title="cvStartAppendToSeq"></a>cvStartAppendToSeq</h3><p>&emsp;&emsp;其函数的作用是将数据写入序列中，并初始化该过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvStartAppendToSeq</span> <span class="params">( CvSeq *seq, CvSeqWriter *writer )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvStartWriteSeq"><a href="#cvStartWriteSeq" class="headerlink" title="cvStartWriteSeq"></a>cvStartWriteSeq</h3><p>&emsp;&emsp;其函数的作用是创建新序列，并初始化写入部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvStartWriteSeq</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> seq_flags, <span class="keyword">int</span> header_size, <span class="keyword">int</span> elem_size,</span></span></span><br><span class="line"><span class="function"><span class="params">    CvMemStorage *storage, CvSeqWriter *writer)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvEndWriteSeq"><a href="#cvEndWriteSeq" class="headerlink" title="cvEndWriteSeq"></a>cvEndWriteSeq</h3><p>&emsp;&emsp;其函数的作用是完成写入操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CvSeq *<span class="title">cvEndWriteSeq</span> <span class="params">( CvSeqWriter *writer )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="cvStartReadSeq"><a href="#cvStartReadSeq" class="headerlink" title="cvStartReadSeq"></a>cvStartReadSeq</h3><p>&emsp;&emsp;其函数的作用是初始化序列中的读取过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvStartReadSeq</span> <span class="params">( <span class="keyword">const</span> CvSeq *seq, CvSeqReader *reader, <span class="keyword">int</span> reverse = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>&emsp;&emsp;一直困惑于<code>CvSeq</code>到底是个什么样的东西，因为曾经拿到别人写的一个函数库，其返回值是一个<code>CvSeq</code>指针。我的任务是遍历所有的<code>Sequence</code>，然后删除其中不符合要求的<code>Sequence</code>。由于没有文档，我当时并不知道需要遍历的是<code>Sequence</code>还是<code>Sequence</code>中的<code>Element</code>，于是写下了类似如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CvSeq *pCurSeq = pInputSeq;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( pCurSeq = pCurSeq-&gt;h_next ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( process ( pCurSeq ) ) &#123;</span><br><span class="line">        pCurSeq = pCurSeq-&gt;h_prev; <span class="comment">/* 这里为了简单，不考虑是否为列表头 */</span></span><br><span class="line">        cvSeqRemove ( pInputSeq, index );</span><br><span class="line">        --index;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    ++index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实证明这段代码是错误的，而且返回的错误信息是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; OpenCV ERROR: One of arguments<span class="string">' values is out of range (Invalid index)</span></span><br><span class="line"><span class="string">&gt; in function cvSeqRemove, cxdatastructs.cpp(1587)</span></span><br></pre></td></tr></table></figure>
<p>为什么会有这样的错误呢？看一下<code>CvSeq</code>的源代码就清楚了。下面是<code>OpenCV 1.0</code>版本有关<code>CvSeq</code>的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CV_TREE_NODE_FIELDS(node_type)                       \</span></span><br><span class="line">    <span class="keyword">int</span>    flags;             <span class="comment">/* micsellaneous flags */</span>      \</span><br><span class="line">    <span class="keyword">int</span>    header_size;       <span class="comment">/* size of sequence header */</span>  \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_type</span>* <span class="title">h_prev</span>;</span> <span class="comment">/* previous sequence */</span>        \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_type</span>* <span class="title">h_next</span>;</span> <span class="comment">/* next sequence */</span>            \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_type</span>* <span class="title">v_prev</span>;</span> <span class="comment">/* 2nd previous sequence */</span>    \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_type</span>* <span class="title">v_next</span>  /* 2<span class="title">nd</span> <span class="title">next</span> <span class="title">sequence</span> */</span></span><br><span class="line"><span class="class">​</span></span><br><span class="line"><span class="class">/*</span></span><br><span class="line"><span class="class">   <span class="title">Read</span>/<span class="title">Write</span> <span class="title">sequence</span>.</span></span><br><span class="line"><span class="class">   <span class="title">Elements</span> <span class="title">can</span> <span class="title">be</span> <span class="title">dynamically</span> <span class="title">inserted</span> <span class="title">to</span> <span class="title">or</span> <span class="title">deleted</span> <span class="title">from</span> <span class="title">the</span> <span class="title">sequence</span>.</span></span><br><span class="line"><span class="class">*/</span></span><br><span class="line"><span class="class">#<span class="title">define</span> <span class="title">CV_SEQUENCE_FIELDS</span>()                                   \</span></span><br><span class="line"><span class="class">    <span class="title">CV_TREE_NODE_FIELDS</span>(<span class="title">CvSeq</span>);</span>                                \</span><br><span class="line">    <span class="keyword">int</span>   total;       <span class="comment">/* total number of elements */</span>          \</span><br><span class="line">    <span class="keyword">int</span>   elem_size;   <span class="comment">/* size of sequence element in bytes */</span> \</span><br><span class="line">    <span class="keyword">char</span>* block_max;   <span class="comment">/* maximal bound of the last block */</span>   \</span><br><span class="line">    <span class="keyword">char</span>* ptr;         <span class="comment">/* current write pointer */</span>             \</span><br><span class="line">    <span class="keyword">int</span>   delta_elems; <span class="comment">/* how many elements allocated when the seq grows */</span>  \</span><br><span class="line">    CvMemStorage* storage;   <span class="comment">/* where the seq is stored */</span>                   \</span><br><span class="line">    CvSeqBlock* free_blocks; <span class="comment">/* free blocks list */</span>                          \</span><br><span class="line">    CvSeqBlock* first; <span class="comment">/* pointer to the first sequence block */</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CvSeq</span> &#123;</span></span><br><span class="line">    CV_SEQUENCE_FIELDS()</span><br><span class="line">&#125; CvSeq;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;原来<code>CvSeq</code>本身就是一个可增长的序列，<code>CvSeq::total</code>是指序列内部有效元素的个数；而<code>h_next</code>和<code>h_prev</code>并不是指向<code>CvSeq</code>内部元素的指针，它们是指向其它<code>CvSeq</code>的。再回到最初的代码，可以看到该代码具有逻辑上的错误，首先<code>while</code>语句遍历的是所有的<code>CvSeq</code>，使用<code>process</code>处理每一个<code>CvSeq</code>，而遇到需要删除的<code>CvSeq</code>时，又使用<code>cvSeqRemove</code>删除当前<code>CvSeq</code>中的第<code>index</code>个元素。实际上此时<code>index</code>很可能超出了当前<code>CvSeq</code>中总元素的个数，所以出现了超出边界的错误。正确的做法是直接删除该<code>CvSeq</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CvSeq *pCurSeq = pInputSeq;</span><br><span class="line">CvSeq *pOldSeq = <span class="literal">NULL</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( pCurSeq ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( process ( pCurSeq ) ) &#123;</span><br><span class="line">        pOldSeq = pCurSeq;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( pOldSeq-&gt;h_prev ) &#123;</span><br><span class="line">            pCurSeq = pOldSeq-&gt;h_prev;</span><br><span class="line">            pCurSeq-&gt;h_next = pOldSeq-&gt;h_next;</span><br><span class="line">            pOldSeq-&gt;h_next-&gt;h_prev = pCurSeq;</span><br><span class="line">            pCurSeq = pCurSeq-&gt;h_next;</span><br><span class="line">            cvClearSeq ( pOldSeq );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pCurSeq = pOldSeq-&gt;h_next;</span><br><span class="line">            pCurSeq-&gt;h_prev = <span class="literal">NULL</span>;</span><br><span class="line">            cvClearSeq ( pOldSeq );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pCurSeq = pCurSeq-&gt;h_next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;后来在<code>Google Book</code>里查了一下，发现<code>《Learning OpenCV: Computer Vision with the OpenCV Library》</code>中有这么一段话：The sequence structure itself has some important elements that you should be aware of. The first, and one you will use often, is total. This is the total number of points or objects in the sequence. The next four important elements are pointers to other sequence: <code>h_prev</code>, <code>h_next</code>, <code>v_prev</code> and <code>v_next</code>. These four pointers are part of what are called <code>CV_TREE_NODE_FIELDS</code>; they are used not to indicate elements inside of the sequence but rather to connect different sequences to one another. Other objects in the OpenCV universe also contain these tree node fields。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/opencv和图像处理/动态内存存储/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/opencv和图像处理/动态内存存储/" itemprop="url">动态内存存储</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T17:54:03+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/opencv和图像处理/" itemprop="url" rel="index">
                    <span itemprop="name">opencv和图像处理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="CvMemStorage"><a href="#CvMemStorage" class="headerlink" title="CvMemStorage"></a>CvMemStorage</h3><p>&emsp;&emsp;其原型如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CvMemStorage</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CvMemBlock</span> *<span class="title">bottom</span>;</span><span class="comment">/* first allocated block */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CvMemBlock</span> *<span class="title">top</span>;</span> <span class="comment">/* the current memory block - top of the stack */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CvMemStorage</span> *<span class="title">parent</span>;</span> <span class="comment">/* borrows new blocks from */</span></span><br><span class="line">    <span class="keyword">int</span> block_size; <span class="comment">/* block size */</span></span><br><span class="line">    <span class="keyword">int</span> free_space; <span class="comment">/* free space in the top block (in bytes) */</span></span><br><span class="line">&#125; CvMemStorage;</span><br></pre></td></tr></table></figure>
<p>内存存储器是一个可用来存储诸如序列、轮廓、图形、子划分等动态增长数据结构的底层结构。它是由一系列以同等大小的内存块构成，呈列表型：<code>bottom</code>域指的是列首，<code>top</code>域指的是当前指向的块但未必是列尾。在<code>bottom</code>和<code>top</code>之间所有的块(包括<code>bottom</code>，不包括<code>top</code>)被完全占据了空间；在<code>top</code>和列尾之间所有的块(包括块尾，不包括<code>top</code>)则是空的；而<code>top</code>块本身则被占据了部分空间，<code>free_space</code>指的是<code>top</code>块剩余的空字节数。新分配的内存缓冲区(或显式地通过<code>cvMemStorageAlloc</code>函数分配，或隐式地通过<code>cvSeqPush</code>、<code>cvGraphAddEdge</code>等高级函数分配)总是起始于当前块(即<code>top</code>块)的剩余那部分。如果剩余那部分能满足要求(足够分配的大小)，分配后，<code>free_space</code>就减少了新分配的那部分内存大小，外加一些用来保存适当列型的附加大小。当<code>top</code>块的剩余空间无法满足被分配的块(缓冲区)大小时，<code>top</code>块的下一个存储块被置为当前块(新的<code>top</code>块)，<code>free_space</code>被置为先前分配的整个块的大小。如果已经不存在空的存储块(即<code>top</code>块已是列尾)，则必须再分配一个新的块(或从<code>parent</code>那继承，见<code>cvCreateChildMemStorage</code>)并将该块加到列尾上去。于是存储器(<code>memory storage</code>)就如同栈(<code>Stack</code>)那样，<code>bottom</code>指向栈底，<code>(top, free_space)</code>对指向栈顶。栈顶可通过<code>cvSaveMemStoragePos</code>保存，通过<code>cvRestoreMemStoragePos</code>恢复指向，通过<code>cvClearStorage</code>重置。</p>
<h3 id="CvMemBlock"><a href="#CvMemBlock" class="headerlink" title="CvMemBlock"></a>CvMemBlock</h3><p>&emsp;&emsp;其原型如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CvMemBlock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CvMemBlock</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CvMemBlock</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; CvMemBlock;</span><br></pre></td></tr></table></figure>
<p><code>CvMemBlock</code>代表一个单独的内存存储块结构。内存存储块中的实际数据存储在<code>header</code>块之后(即存在一个头指针head指向的块<code>header</code>，该块不存储数据)，于是内存块的第<code>i</code>个字节可以通过表达式<code>((char *)(mem_block_ptr + 1))[i]</code>获得。然而，通常没必要直接去获得存储结构的域。</p>
<h3 id="CvMemStoragePos"><a href="#CvMemStoragePos" class="headerlink" title="CvMemStoragePos"></a>CvMemStoragePos</h3><p>&emsp;&emsp;其原型如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CvMemStoragePos</span> &#123;</span></span><br><span class="line">    CvMemBlock *top;</span><br><span class="line">    <span class="keyword">int</span> free_space;</span><br><span class="line">&#125; CvMemStoragePos;</span><br></pre></td></tr></table></figure>
<p>该结构保存栈顶的地址。栈顶可以通过<code>cvSaveMemStoragePos</code>保存，也可以通过<code>cvRestoreMemStoragePos</code>恢复。</p>
<h3 id="cvCreateMemStorage"><a href="#cvCreateMemStorage" class="headerlink" title="cvCreateMemStorage"></a>cvCreateMemStorage</h3><p>&emsp;&emsp;其作用是创建内存块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CvMemStorage *<span class="title">cvCreateMemStorage</span> <span class="params">( <span class="keyword">int</span> block_size = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>block_size</code>是存储块的大小，它以字节表示。如果大小是<code>0 byte</code>，则将该块设置成默认值，当前默认大小为<code>64k</code>。函数<code>cvCreateMemStorage</code>创建一内存块，并返回指向块首的指针。起初存储块是空的，除了<code>block_size</code>外，头部(即<code>header</code>)的所有域值都为<code>0</code>。</p>
<h3 id="cvReleaseMemStorage"><a href="#cvReleaseMemStorage" class="headerlink" title="cvReleaseMemStorage"></a>cvReleaseMemStorage</h3><p>&emsp;&emsp;其作用是释放内存块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvReleaseMemStorage</span> <span class="params">( CvMemStorage **storage )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>storage</code>指向被释放了的存储块的指针。函数<code>cvReleaseMemStorage</code>释放所有的存储(内存)块或者将它们返回给各自的<code>parent</code>(如果需要的话)。接下来再释放<code>header</code>块(即释放头指针<code>head</code>指向的块<code>free(head)</code>)，并清除指向该块的指针(即<code>head = NULL</code>)。在释放作为<code>parent</code>的块之前，先清除各自的<code>child</code>块。</p>
<h3 id="cvClearMemStorage"><a href="#cvClearMemStorage" class="headerlink" title="cvClearMemStorage"></a>cvClearMemStorage</h3><p>&emsp;&emsp;其作用是清空内存存储块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvClearMemStorage</span> <span class="params">( CvMemStorage *storage )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>storage</code>是存储存储块。函数<code>cvClearMemStorage</code>将存储块的<code>top</code>置到存储块的头部(清空存储块中的存储内容)。该函数并不释放内存，仅清空内存。假使该内存块有一个父内存块(即存在一内存块与其有父子关系)，则函数就将所有的块返回给其<code>parent</code>。</p>
<h3 id="cvMemStorageAlloc"><a href="#cvMemStorageAlloc" class="headerlink" title="cvMemStorageAlloc"></a>cvMemStorageAlloc</h3><p>&emsp;&emsp;其作用是在存储块中分配以内存缓冲区：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">cvMemStorageAlloc</span> <span class="params">( CvMemStorage *storage, <span class="keyword">size_t</span> size )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>storage</code>是内存块，<code>size</code>是缓冲区的大小。函数<code>cvMemStorageAlloc</code>在存储块中分配一内存缓冲区。该缓冲区的大小不能超过内存块的大小，否则就会导致运行时错误。缓冲区的地址被调整为<code>CV_STRUCT_ALIGN</code>字节(当前为<code>sizeof(double)</code>)。</p>
<h3 id="cvMemStorageAllocString"><a href="#cvMemStorageAllocString" class="headerlink" title="cvMemStorageAllocString"></a>cvMemStorageAllocString</h3><p>&emsp;&emsp;其作用是在存储块中分配一文本字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CvString</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">&#125; CvString;</span><br><span class="line">​</span><br><span class="line"><span class="function">CvString <span class="title">cvMemStorageAllocString</span> <span class="params">( CvMemStorage *storage, <span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">int</span> len = <span class="number">-1</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>storage</code>：存储块。</li>
<li><code>ptr</code>：字符串。</li>
<li><code>len</code>：字符串的长度(不计算<code>\0</code>)。如果参数为负数，函数就计算该字符串的长度。</li>
</ul>
<p>函数<code>cvMemStorageAlloString</code>在存储块中创建了一字符串的拷贝。它返回一个结构，该结构包含字符串的长度(该长度或通过用户传递，或通过计算得到)和指向被拷贝了的字符串的指针。</p>
<h3 id="cvSaveMemStoragePos"><a href="#cvSaveMemStoragePos" class="headerlink" title="cvSaveMemStoragePos"></a>cvSaveMemStoragePos</h3><p>&emsp;&emsp;其作用是保存内存块的位置(地址)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSaveMemStoragePos</span> <span class="params">( <span class="keyword">const</span> CvMemStorage *storage, CvMemStoragePos *pos )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>storage</code>是内存块，<code>pos</code>是内存块顶部位置。函数<code>cvSaveMemStoragePos</code>将存储块的当前位置保存到参数<code>pos</code>中。函数<code>cvRestoreMemStoragePos</code>可进一步获取该位置(地址)。</p>
<h3 id="cvRestoreMemStoragePos"><a href="#cvRestoreMemStoragePos" class="headerlink" title="cvRestoreMemStoragePos"></a>cvRestoreMemStoragePos</h3><p>&emsp;&emsp;其作用是恢复内存存储块的位置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvRestoreMemStoragePos</span> <span class="params">( CvMemStorage *storage, CvMemStoragePos *pos )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>storage</code>是内存块，<code>pos</code>是新的存储块的位置。函数<code>cvRestoreMemStoragePos</code>通过参数<code>pos</code>恢复内存块的位置。该函数和函数<code>cvClearMemStorage</code>是释放被占用内存块的唯一方法。注意，没有什么方法可以去释放存储块中被占用的部分内存。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/数学和物理/不可解问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/数学和物理/不可解问题/" itemprop="url">不可解问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T17:41:27+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;不可解问题(<code>Undecidable Decision Problem</code>)指的是这样一种问题：它无论如何也不可能有一个正确的算法来解决。虽然不可思议，但这种问题被证明确实是存在的。图灵在<code>1936</code>年提出了第一个不可解问题的实例：<code>The Halting Problem</code>。<br>&emsp;&emsp;<code>The Halting Problem</code>是指，输入一段程序代码和一个针对此程序的输入，能否编程判断运行这个程序后程序是否会终止。这个问题的答案是否定的，也就是说不可能有一种算法可以正确判断一个指定的程序运行后，给予指定的输入，程序最后出不出得来。换句话说，<code>The Halting Problem</code>是一个不可解问题。<br>&emsp;&emsp;假设我们某一天真做出了这么一个极度聪明的万能算法(就叫<code>God_algo</code>吧)，你只要给它一段程序(二进制描述)，再给它这段程序的输入，它就能告诉你这段程序在这个输入上会不会结束(停机)。我们来编写一下这个算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">God_algo</span> <span class="params">( <span class="keyword">char</span> *program, <span class="keyword">char</span> *input )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( &lt;program&gt; halts on &lt;input&gt; ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里假设<code>if</code>的判断语句里面是天才思考的结晶，它能够像上帝一样洞察一切程序的宿命。现在从这个<code>God_algo</code>出发，导出一个新的算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Satan_algo</span> <span class="params">( <span class="keyword">char</span> *program )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( God_algo ( program, program ) ) &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> ); <span class="comment">/* loop forever! */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* can never get here! */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如它的名字所暗示的那样，这个算法便是一切邪恶的根源了。当我们把这个算法运用到它自身身上时，会发生什么呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Satan_algo ( Satan_algo );</span><br></pre></td></tr></table></figure>
<p>我们来分析一下这行简单的调用：显然<code>Satan_algo(Satan_algo)</code>要么能够运行结束返回(停机)，要么不能返回(<code>loop forever</code>)。如果它能够结束，那么<code>Santa_algo</code>算法里面的那个<code>if</code>判断就会成立(因为<code>God_algo(Santa_algo, Santa_algo</code>)将会返回<code>true</code>)，从而程序便进入那个包含一个无穷循环<code>while(1);</code>的<code>if</code>分支，于是这个<code>Satan_algo(Satan_algo)</code>调用便永远不会返回(结束)了。如果不能结束(停机)，则<code>if</code>判断就会失败，从而选择另一个<code>if</code>分支并返回<code>false</code>，即<code>Satan_algo(Satan_algo)</code>又能够返回(停机)。可以得到如下结论：</p>
<ul>
<li><code>Satan_algo</code>能够停机 =&gt; <code>Satan_algo(Satan_algo)</code>不能停机。</li>
<li><code>Satan_algo</code>不能停机 =&gt; <code>Satan_algo(Satan_algo)</code>能够停机。</li>
</ul>
<p>于是得到矛盾的结果。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2018/12/30/数学和物理/完全平方数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/数学和物理/完全平方数/" itemprop="url">完全平方数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T16:46:33+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;一个正整数如果是另一个整数的完全平方，那么我们就称这个数为<code>完全平方数</code>，也叫做<code>平方数</code>。例如，<code>0</code>、<code>1</code>、<code>4</code>、<code>9</code>、<code>16</code>、<code>25</code>、<code>36</code>、<code>49</code>、<code>64</code>、<code>81</code>、<code>100</code>等。通过对这些完全平方数的观察和分析，我们可以获得一些规律性的认识。下面是完全平方数的一些常用性质：</p>
<ul>
<li>性质<code>1</code>：完全平方数的末位数只能是<code>0</code>、<code>1</code>、<code>4</code>、<code>5</code>、<code>6</code>、<code>9</code>。</li>
<li>性质<code>2</code>：奇数的平方的个位数字为奇数，十位数字为偶数。</li>
<li>性质<code>3</code>：如果完全平方数的十位数字是奇数，则它的个位数字一定是<code>6</code>；反之，如果完全平方数的个位数字是<code>6</code>，则它的十位数字一定是奇数。</li>
<li>性质<code>4</code>：凡个位数字是<code>5</code>，但末两位数字不是<code>25</code>的自然数不是完全平方数；末尾只有奇数个<code>0</code>的自然数(不包括<code>0</code>本身)不是完全平方数；个位数字为<code>1</code>、<code>4</code>、<code>9</code>，而十位数字为奇数的自然数不是完全平方数。</li>
<li>性质<code>5</code>：偶数的平方是<code>4</code>的倍数；奇数的平方是<code>4</code>的倍数加<code>1</code>。</li>
<li>性质<code>6</code>：奇数的平方是<code>8n + 1</code>型；偶数的平方为<code>8k</code>或<code>8k + 4</code>型。</li>
<li>性质<code>7</code>：平方数的形式必为<code>3k</code>或<code>3k + 1</code>之一。</li>
<li>性质<code>8</code>：不能被<code>5</code>整除的数的平方为<code>5k ± 1</code>型，能被<code>5</code>整除的数的平方为<code>5k</code>型。</li>
<li>性质<code>9</code>：平方数的形式具有下列形式之一：<code>16k</code>、<code>16k + 1</code>、<code>16k + 4</code>、<code>16k + 9</code>。</li>
<li>性质<code>10</code>：完全平方数的各位数字之和只能是<code>0</code>、<code>1</code>、<code>4</code>、<code>7</code>、<code>9</code>。</li>
<li>性质<code>11</code>：<code>a^2b</code>为完全平方数的充要条件是<code>b</code>为完全平方数。</li>
<li>性质<code>12</code>：如果质数<code>p</code>能整除<code>a</code>，但<code>p^2</code>不能整除<code>a</code>，则<code>a</code>不是完全平方数。</li>
<li>性质<code>13</code>：在两个相邻的整数的平方数之间的所有整数都不是完全平方数，即若<code>n^2 &lt; k &lt; (n+1)^2</code>，则<code>k</code>一定不是完全平方数。</li>
<li>性质<code>14</code>：一个正整数<code>n</code>是完全平方数的充分必要条件是<code>n</code>有奇数个因子(包括<code>1</code>和<code>n</code>本身)。</li>
<li>性质<code>15</code>：完全平方数的约数个数是奇数个。约数的个数为奇数个的自然数是完全平方数。</li>
<li>性质<code>16</code>：如果质数<code>p</code>能整除<code>a</code>，但<code>p</code>的平方不能整除<code>a</code>，则<code>a</code>不是完全平方数。</li>
</ul>
<p>&emsp;&emsp;与上述性质相对应的几个结论：</p>
<ul>
<li>个位数是<code>2</code>、<code>3</code>、<code>7</code>或<code>8</code>的整数一定不是完全平方数。</li>
<li>个位数和十位数都是奇数的整数一定不是完全平方数。</li>
<li>个位数是<code>6</code>，十位数是偶数的整数一定不是完全平方数。</li>
<li>形如<code>3k + 2</code>型的整数一定不是完全平方数。</li>
<li>形如<code>4k + 2</code>和<code>4k + 3</code>型的整数一定不是完全平方数。</li>
<li>形如<code>5k ± 2</code>型的整数一定不是完全平方数。</li>
<li>形如<code>8k + 2</code>、<code>8k + 3</code>、<code>8k + 5</code>、<code>8k + 6</code>、<code>8k + 7</code>型的整数一定不是完全平方数。</li>
<li>数字和是<code>2</code>、<code>3</code>、<code>5</code>、<code>6</code>、<code>8</code>的整数一定不是完全平方数。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/65/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/65/">65</a><span class="page-number current">66</span><a class="page-number" href="/page/67/">67</a><span class="space">&hellip;</span><a class="page-number" href="/page/96/">96</a><a class="extend next" rel="next" href="/page/67/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">955</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
