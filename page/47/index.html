<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="暴徒">
<meta property="og:url" content="http://fukangwei.gitee.io/page/47/index.html">
<meta property="og:site_name" content="暴徒">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="暴徒">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/47/">





  <title>暴徒</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">暴徒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/26/Qt语法详解/Qt之QWizardPage/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/26/Qt语法详解/Qt之QWizardPage/" itemprop="url">Qt之QWizardPage</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-26T16:28:02+08:00">
                2019-01-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QWizardPage</code> class is the base class for wizard pages.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Since</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QWizardPage</code></td>
<td><code>Qt 4.3</code></td>
<td><code>QWidget</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QWizardPage(QWidget * parent = 0)</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>buttonText(QWizard::WizardButton which) const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>cleanupPage()</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>initializePage()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isCommitPage() const</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>isComplete() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isFinalPage() const</code></td>
</tr>
<tr>
<td><code>virtual int</code></td>
<td><code>nextId() const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>pixmap(QWizard::WizardPixmap which) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setButtonText(QWizard::WizardButton which, const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCommitPage(bool commitPage)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFinalPage(bool finalPage)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPixmap(QWizard::WizardPixmap which, const QPixmap &amp; pixmap)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSubTitle(const QString &amp; subTitle)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTitle(const QString &amp; title)</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>subTitle() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>title() const</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>validatePage()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><ul>
<li><code>void completeChanged()</code></li>
</ul>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Retunrn</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QVariant</code></td>
<td><code>field(const QString &amp; name) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>registerField(const QString &amp; name, QWidget * widget, const char * property = 0, const char * changedSignal = 0)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setField(const QString &amp; name, const QVariant &amp; value)</code></td>
</tr>
<tr>
<td><code>QWizard *</code></td>
<td><code>wizard() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QWizardPage</code> class is the base class for wizard pages.<br>&emsp;&emsp;<code>QWizard</code> represents a wizard. Each page is a <code>QWizardPage</code>. When you create your own wizards, you can use <code>QWizardPage</code> directly, or you can subclass it for more control.<br>&emsp;&emsp;A page has the following attributes, which are rendered by <code>QWizard</code>: a title, a subTitle, and a set of pixmaps. Once a page is added to the wizard (using <code>QWizard::addPage()</code> or <code>QWizard::setPage()</code>), <code>wizard()</code> returns a pointer to the associated <code>QWizard</code> object.<br>&emsp;&emsp;Page provides five virtual functions that can be reimplemented to provide custom behavior:</p>
<ul>
<li><code>initializePage()</code> is called to initialize the page’s contents when the user clicks the wizard’s Next button. If you want to derive the page’s default from what the user entered on previous pages, this is the function to reimplement.</li>
<li><code>cleanupPage()</code> is called to reset the page’s contents when the user clicks the wizard’s Back button.</li>
<li><code>validatePage()</code> validates the page when the user clicks <code>Next</code> or <code>Finish</code>. It is often used to show an error message if the user has entered incomplete or invalid information.</li>
<li><code>nextId()</code> returns the <code>ID</code> of the next page. It is useful when creating <code>non-linear</code> wizards, which allow different traversal paths based on the information provided by the user.</li>
<li><code>isComplete()</code> is called to determine whether the <code>Next</code> and/or <code>Finish</code> button should be enabled or disabled. If you reimplement <code>isComplete()</code>, also make sure that <code>completeChanged()</code> is emitted whenever the complete state changes.</li>
</ul>
<p>&emsp;&emsp;Normally, the <code>Next</code> button and the <code>Finish</code> button of a wizard are mutually exclusive. If <code>isFinalPage()</code> returns <code>true</code>, <code>Finish</code> is available; otherwise, <code>Next</code> is available. By default, <code>isFinalPage()</code> is <code>true</code> only when <code>nextId()</code> returns <code>-1</code>. If you want to show <code>Next</code> and <code>Final</code> simultaneously for a page (letting the user perform an <code>early finish</code>), call <code>setFinalPage(true)</code> on that page. For wizards that support early finishes, you might also want to set the <code>HaveNextButtonOnLastPage</code> and <code>HaveFinishButtonOnEarlyPages</code> options on the wizard.<br>&emsp;&emsp;In many wizards, the contents of a page may affect the default values of the fields of a later page. To make it easy to communicate between pages, <code>QWizard</code> supports a <code>field</code> mechanism that allows you to register a field (e.g., a <code>QLineEdit</code>) on a page and to access its value from any page. Fields are global to the entire wizard and make it easy for any single page to access information stored by another page, without having to put all the logic in <code>QWizard</code> or having the pages know explicitly about each other. Fields are registered using <code>registerField()</code> and can be accessed at any time using <code>field()</code> and <code>setField()</code>.</p>
<h3 id="Property-Documentation"><a href="#Property-Documentation" class="headerlink" title="Property Documentation"></a>Property Documentation</h3><ul>
<li><code>subTitle</code>: This property holds the <code>subtitle</code> of the page. The <code>subtitle</code> is shown by the <code>QWizard</code>, between the title and the actual page. Subtitles are optional. In <code>ClassicStyle</code> and <code>ModernStyle</code>, using subtitles is necessary to make the header appear. In <code>MacStyle</code>, the <code>subtitle</code> is shown as a text label just above the actual page. The <code>subtitle</code> may be <code>plain text</code> or <code>HTML</code>, depending on the value of the <code>QWizard::subTitleFormat</code> property. By default, this property contains an empty string. Access functions:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QString</code></td>
<td><code>subTitle() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSubTitle(const QString &amp; subTitle)</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>title</code>: This property holds the <code>title</code> of the page. The <code>title</code> is shown by the QWizard, above the actual page. All pages should have a <code>title</code>. The <code>title</code> may be <code>plain text</code> or <code>HTML</code>, depending on the value of the <code>QWizard::titleFormat</code> property. By default, this property contains an empty string. Access functions:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QString</code></td>
<td><code>title() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTitle(const QString &amp; title)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QWizardPage::QWizardPage(QWidget * parent = 0)</code>: Constructs a wizard page with the given <code>parent</code>. When the page is inserted into a wizard using <code>QWizard::addPage()</code> or <code>QWizard::setPage()</code>, the <code>parent</code> is automatically set to be the wizard.</li>
<li><code>QString QWizardPage::buttonText(QWizard::WizardButton which) const</code>: Returns the text on button <code>which</code> on this page. If a text has ben set using <code>setButtonText()</code>, this text is returned. Otherwise, if a text has been set using <code>QWizard::setButtonText()</code>, this text is returned. By default, the text on buttons depends on the <code>QWizard::wizardStyle</code>. For example, on <code>Mac OS X</code>, the <code>Next</code> button is called Continue.</li>
<li><code>void QWizardPage::cleanupPage() [virtual]</code>: This virtual function is called by <code>QWizard::cleanupPage()</code> when the user leaves the page by clicking Back (unless the <code>QWizard::IndependentPages</code> option is set). The default implementation resets the page’s fields to their original values (the values they had before <code>initializePage()</code> was called).</li>
<li><code>void QWizardPage::completeChanged() [signal]</code>: This <code>signal</code> is emitted whenever the complete state of the page (i.e., the value of <code>isComplete()</code>) changes. If you reimplement <code>isComplete()</code>, make sure to emit <code>completeChanged()</code> whenever the value of <code>isComplete()</code> changes, to ensure that <code>QWizard</code> updates the enabled or disabled state of its buttons.</li>
<li><code>QVariant QWizardPage::field(const QString &amp; name) const [protected]</code>: Returns the value of the field called <code>name</code>. This function can be used to access fields on any page of the wizard. It is equivalent to calling <code>wizard()-&gt;field(name)</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> OutputFilesPage::initializePage() &#123;</span><br><span class="line">    QString className = field ( <span class="string">"className"</span> ).toString();</span><br><span class="line">    headerLineEdit-&gt;setText ( className.toLower() + <span class="string">".h"</span> );</span><br><span class="line">    implementationLineEdit-&gt;setText ( className.toLower() + <span class="string">".cpp"</span> );</span><br><span class="line">    outputDirLineEdit-&gt;setText ( QDir::convertSeparators ( QDir::tempPath() ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QWizardPage::initializePage() [virtual]</code>: This virtual function is called by <code>QWizard::initializePage()</code> to prepare the page just before it is shown either as a result of <code>QWizard::restart()</code> being called, or as a result of the user clicking <code>Next</code>. (However, if the <code>QWizard::IndependentPages</code> option is set, this function is only called the first time the page is shown.) By reimplementing this function, you can ensure that the page’s fields are properly initialized based on fields from previous pages. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> OutputFilesPage::initializePage() &#123;</span><br><span class="line">    QString className = field ( <span class="string">"className"</span> ).toString();</span><br><span class="line">    headerLineEdit-&gt;setText ( className.toLower() + <span class="string">".h"</span> );</span><br><span class="line">    implementationLineEdit-&gt;setText ( className.toLower() + <span class="string">".cpp"</span> );</span><br><span class="line">    outputDirLineEdit-&gt;setText ( QDir::convertSeparators ( QDir::tempPath() ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The default implementation does nothing.</p>
<ul>
<li><code>bool QWizardPage::isCommitPage() const</code>: Returns <code>true</code> if this page is a commit page; otherwise returns <code>false</code>.</li>
<li><code>bool QWizardPage::isComplete() const [virtual]</code>: This virtual function is called by <code>QWizard</code> to determine whether the <code>Next</code> or <code>Finish</code> button should be enabled or disabled. The default implementation returns <code>true</code> if all mandatory fields are filled; otherwise, it returns <code>false</code>. If you reimplement this function, make sure to emit <code>completeChanged()</code>, from the rest of your implementation, whenever the value of <code>isComplete()</code> changes. This ensures that <code>QWizard</code> updates the enabled or disabled state of its buttons.</li>
<li><code>bool QWizardPage::isFinalPage() const</code>: This function is called by <code>QWizard</code> to determine whether the <code>Finish</code> button should be shown for this page or not. By default, it returns <code>true</code> if there is no next page (i.e., <code>nextId()</code> returns <code>-1</code>); otherwise, it returns <code>false</code>. By explicitly calling <code>setFinalPage(true)</code>, you can let the user perform an <code>early finish</code>.</li>
<li><code>int QWizardPage::nextId() const [virtual]</code>: This virtual function is called by <code>QWizard::nextId()</code> to find out which page to show when the user clicks the <code>Next</code> button. The return value is the <code>ID</code> of the next page, or <code>-1</code> if no page follows. By default, this function returns the lowest <code>ID</code> greater than the <code>ID</code> of the current page, or <code>-1</code> if there is no such <code>ID</code>. By reimplementing this function, you can specify a dynamic page order. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> IntroPage::nextId() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( evaluateRadioButton-&gt;isChecked() ) &#123;</span><br><span class="line">        <span class="keyword">return</span> LicenseWizard::Page_Evaluate;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LicenseWizard::Page_Register;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QPixmap QWizardPage::pixmap(QWizard::WizardPixmap which) const</code>: Returns the pixmap set for role <code>which</code>. Pixmaps can also be set for the entire wizard using <code>QWizard::setPixmap()</code>, in which case they apply for all pages that don’t specify a pixmap.</li>
<li><code>void QWizardPage::registerField(const QString &amp; name, QWidget * widget, const char * property = 0, const char * changedSignal = 0) [protected]</code>: Creates a field called <code>name</code> associated with the given <code>property</code> of the given <code>widget</code>. From then on, that <code>property</code> becomes accessible using <code>field()</code> and <code>setField()</code>. Fields are global to the entire wizard and make it easy for any single page to access information stored by another page, without having to put all the logic in <code>QWizard</code> or having the pages know explicitly about each other. If <code>name</code> ends with an asterisk (<code>*</code>), the field is a mandatory field. When a page has mandatory fields, the <code>Next</code> and/or <code>Finish</code> buttons are enabled only when all mandatory fields are filled. This requires a <code>changedSignal</code> to be specified, to tell <code>QWizard</code> to recheck the value stored by the mandatory field. <code>QWizard</code> knows the most common <code>Qt</code> widgets. For these (or their subclasses), you don’t need to specify a <code>property</code> or a <code>changedSignal</code>. The table below lists these widgets:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Widget</th>
<th>Property</th>
<th>Change Notification Signal</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QAbstractButton</code></td>
<td><code>bool checked</code></td>
<td><code>toggled()</code></td>
</tr>
<tr>
<td><code>QAbstractSlider</code></td>
<td><code>int value</code></td>
<td><code>valueChanged()</code></td>
</tr>
<tr>
<td><code>QComboBox</code></td>
<td><code>int currentIndex</code></td>
<td><code>currentIndexChanged()</code></td>
</tr>
<tr>
<td><code>QDateTimeEdit</code></td>
<td><code>QDateTime dateTime</code></td>
<td><code>dateTimeChanged()</code></td>
</tr>
<tr>
<td><code>QLineEdit</code></td>
<td><code>QString text</code></td>
<td><code>textChanged()</code></td>
</tr>
<tr>
<td><code>QListWidget</code></td>
<td><code>int currentRow</code></td>
<td><code>currentRowChanged()</code></td>
</tr>
<tr>
<td><code>QSpinBox</code></td>
<td><code>int value</code></td>
<td><code>valueChanged()</code></td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;You can use <code>QWizard::setDefaultProperty()</code> to add entries to this table or to override existing entries. To consider a field <code>filled</code>, <code>QWizard</code> simply checks that their current value doesn’t equal their original value (the value they had before <code>initializePage()</code> was called). For <code>QLineEdit</code>, it also checks that <code>hasAcceptableInput()</code> returns <code>true</code>, to honor any validator or mask. <code>QWizard&#39;s</code> mandatory field mechanism is provided for convenience. It can be bypassed by reimplementing <code>QWizardPage::isComplete()</code>.</p>
<ul>
<li><code>void QWizardPage::setButtonText(QWizard::WizardButton which, const QString &amp; text)</code>: Sets the <code>text</code> on button which to be <code>text</code> on this page. By default, the <code>text</code> on buttons depends on the <code>QWizard::wizardStyle</code>, but may be redefined for the wizard as a whole using <code>QWizard::setButtonText()</code>.</li>
<li><code>void QWizardPage::setCommitPage(bool commitPage)</code>: Sets this page to be a commit page if <code>commitPage</code> is <code>true</code>; otherwise, sets it to be a normal page. A commit page is a page that represents an action which cannot be undone by clicking <code>Back</code> or <code>Cancel</code>. A <code>Commit</code> button replaces the <code>Next</code> button on a commit page. Clicking this button simply calls <code>QWizard::next()</code> just like clicking <code>Next</code> does. A page entered directly from a commit page has its <code>Back</code> button disabled.</li>
<li><code>void QWizardPage::setField(const QString &amp; name, const QVariant &amp; value) [protected]</code>: Sets the <code>value</code> of the field called name to <code>value</code>. This function can be used to set fields on any page of the wizard. It is equivalent to calling <code>wizard()-&gt;setField(name, value)</code>.</li>
<li><code>void QWizardPage::setFinalPage(bool finalPage)</code>: Explicitly sets this page to be final if <code>finalPage</code> is <code>true</code>. After calling <code>setFinalPage(true)</code>, <code>isFinalPage()</code> returns <code>true</code> and the <code>Finish</code> button is visible (and enabled if <code>isComplete()</code> returns <code>true</code>). After calling <code>setFinalPage(false)</code>, <code>isFinalPage()</code> returns <code>true</code> if <code>nextId()</code> returns <code>-1</code>; otherwise, it returns <code>false</code>.</li>
<li><code>void QWizardPage::setPixmap(QWizard::WizardPixmap which, const QPixmap &amp; pixmap)</code>: Sets the <code>pixmap</code> for role which to <code>pixmap</code>. The pixmaps are used by <code>QWizard</code> when displaying a page. Which pixmaps are actually used depend on the wizard style. Pixmaps can also be set for the entire wizard using <code>QWizard::setPixmap()</code>, in which case they apply for all pages that don’t specify a pixmap.</li>
<li><code>bool QWizardPage::validatePage() [virtual]</code>: This virtual function is called by <code>QWizard::validateCurrentPage()</code> when the user clicks <code>Next</code> or <code>Finish</code> to perform some <code>last-minute</code> validation. If it returns <code>true</code>, the next page is shown (or the wizard finishes); otherwise, the current page stays up. The default implementation returns <code>true</code>. When possible, it is usually better style to disable the <code>Next</code> or <code>Finish</code> button (by specifying mandatory fields or reimplementing <code>isComplete()</code>) than to reimplement <code>validatePage()</code>.</li>
<li><code>QWizard * QWizardPage::wizard() const [protected]</code>: Returns the wizard associated with this page, or <code>0</code> if this page hasn’t been inserted into a <code>QWizard</code> yet.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/26/Qt语法详解/Qt之QTextCodec/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/26/Qt语法详解/Qt之QTextCodec/" itemprop="url">Qt之QTextCodec</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-26T12:39:17+08:00">
                2019-01-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTextCodec</code> class provides conversions between text encodings. The header file is <code>QTextCodec</code>. <strong>Note</strong>: All functions in this class are reentrant, except for <code>setCodecForTr()</code>, <code>setCodecForCStrings()</code>, and <code>~QTextCodec()</code>, which are nonreentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual QList&lt;QByteArray&gt;</code></td>
<td><code>aliases() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>canEncode(QChar ch) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>canEncode(const QString &amp; s) const</code></td>
</tr>
<tr>
<td><code>QByteArray</code></td>
<td><code>fromUnicode(const QString &amp; str) const</code></td>
</tr>
<tr>
<td><code>QByteArray</code></td>
<td><code>fromUnicode(const QChar * input, int number, ConverterState * state = 0) const</code></td>
</tr>
<tr>
<td><code>QTextDecoder *</code></td>
<td><code>makeDecoder() const</code></td>
</tr>
<tr>
<td><code>QTextDecoder *</code></td>
<td><code>makeDecoder(ConversionFlags flags) const</code></td>
</tr>
<tr>
<td><code>QTextEncoder *</code></td>
<td><code>makeEncoder() const</code></td>
</tr>
<tr>
<td><code>QTextEncoder *</code></td>
<td><code>makeEncoder(ConversionFlags flags) const</code></td>
</tr>
<tr>
<td><code>virtual int</code></td>
<td><code>mibEnum() const = 0</code></td>
</tr>
<tr>
<td><code>virtual QByteArray</code></td>
<td><code>name() const = 0</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>toUnicode(const QByteArray &amp; a) const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>toUnicode(const char * input, int size, ConverterState * state = 0) const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>toUnicode(const char * chars) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Static-Public-Members"><a href="#Static-Public-Members" class="headerlink" title="Static Public Members"></a>Static Public Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QList&lt;QByteArray&gt;</code></td>
<td><code>availableCodecs()</code></td>
</tr>
<tr>
<td><code>QList&lt;int&gt;</code></td>
<td><code>availableMibs()</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForCStrings()</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForHtml(const QByteArray &amp; ba, QTextCodec * defaultCodec)</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForHtml(const QByteArray &amp; ba)</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForLocale()</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForMib(int mib)</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForName(const QByteArray &amp; name)</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForName(const char * name)</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForTr()</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForUtfText(const QByteArray &amp; ba, QTextCodec * defaultCodec)</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForUtfText(const QByteArray &amp; ba)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCodecForCStrings(QTextCodec * codec)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCodecForLocale(QTextCodec * c)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCodecForTr(QTextCodec * c)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextCodec()</code></td>
</tr>
<tr>
<td><code>virtual</code></td>
<td><code>QTextCodec()</code></td>
</tr>
<tr>
<td><code>virtual QByteArray</code></td>
<td><code>convertFromUnicode(const QChar * input, int number, ConverterState * state) const = 0</code></td>
</tr>
<tr>
<td><code>virtual QString</code></td>
<td><code>convertToUnicode(const char * chars, int len, ConverterState * state) const = 0</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextCodec</code> class provides conversions between text encodings. <code>Qt</code> uses Unicode to store, draw and manipulate strings. In many situations you may wish to deal with data that uses a different encoding. For example, most <code>Japanese</code> documents are still stored in <code>Shift-JIS</code> or <code>ISO 2022-JP</code>, while Russian users often have their documents in <code>KOI8-R</code> or <code>Windows-1251</code>. <code>Qt</code> provides a set of <code>QTextCodec</code> classes to help with converting <code>non-Unicode</code> formats to and from <code>Unicode</code>. You can also create your own codec classes.<br>&emsp;&emsp;The supported encodings are: <code>Apple Roman</code>; <code>Big5</code>; <code>Big5-HKSCS</code>; <code>CP949</code>; <code>EUC-JP</code>; <code>EUC-KR</code>; <code>GB18030-0</code>; <code>IBM 850</code>; <code>IBM 866</code>; <code>IBM 874</code>; <code>ISO 2022-JP</code>; <code>ISO 8859-1 to 10</code>; <code>ISO 8859-13 to 16</code>; <code>Iscii-Bng</code>, <code>Dev</code>, <code>Gjr</code>, <code>Knd</code>, <code>Mlm</code>, <code>Ori</code>, <code>Pnj</code>, <code>Tlg</code>, and <code>Tml</code>; <code>JIS X 0201</code>; <code>JIS X 0208</code>; <code>KOI8-R</code>; <code>KOI8-U</code>; <code>MuleLao-1</code>; <code>ROMAN8</code>; <code>Shift-JIS</code>; <code>TIS-620</code>; <code>TSCII</code>; <code>UTF-8</code>; <code>UTF-16</code>; <code>UTF-16BE</code>; <code>UTF-16LE</code>; <code>UTF-32</code>; <code>UTF-32BE</code>; <code>UTF-32LE</code>; <code>Windows-1250 to 1258</code>; <code>WINSAMI2</code>.<br>&emsp;&emsp;<code>QTextCodecs</code> can be used as follows to convert some locally encoded string to <code>Unicode</code>. Suppose you have some string encoded in <code>Russian KOI8-R</code> encoding, and want to convert it to <code>Unicode</code>. The simple way to do it is like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QByteArray encodedString = <span class="string">"..."</span>;</span><br><span class="line">QTextCodec *codec = QTextCodec::codecForName ( <span class="string">"KOI8-R"</span> );</span><br><span class="line">QString <span class="built_in">string</span> = codec-&gt;toUnicode ( encodedString );</span><br></pre></td></tr></table></figure>
<p>After this, string holds the text converted to <code>Unicode</code>. Converting a string from <code>Unicode</code> to the local encoding is just as easy:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString <span class="built_in">string</span> = <span class="string">"..."</span>;</span><br><span class="line">QTextCodec *codec = QTextCodec::codecForName ( <span class="string">"KOI8-R"</span> );</span><br><span class="line">QByteArray encodedString = codec-&gt;fromUnicode ( <span class="built_in">string</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;To read or write files in various encodings, use <code>QTextStream</code> and its <code>setCodec()</code> function. See the <code>Codecs</code> example for an application of <code>QTextCodec</code> to file <code>I/O</code>.<br>&emsp;&emsp;Some care must be taken when trying to convert the data in chunks, for example, when receiving it over a network. In such cases it is possible that a <code>multi-byte</code> character will be split over two chunks. At best this might result in the loss of a character and at worst cause the entire conversion to fail.<br>&emsp;&emsp;The approach to use in these situations is to create a <code>QTextDecoder</code> object for the codec and use this <code>QTextDecoder</code> for the whole decoding process, as shown below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QTextCodec *codec = QTextCodec::codecForName ( <span class="string">"Shift-JIS"</span> );</span><br><span class="line">QTextDecoder *decoder = codec-&gt;makeDecoder();</span><br><span class="line">​</span><br><span class="line">QString <span class="built_in">string</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( new_data_available() ) &#123;</span><br><span class="line">    QByteArray chunk = get_new_data();</span><br><span class="line">    <span class="built_in">string</span> += decoder-&gt;toUnicode ( chunk );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">delete</span> decoder;</span><br></pre></td></tr></table></figure>
<p>The <code>QTextDecoder</code> object maintains state between chunks and therefore works correctly even if a <code>multi-byte</code> character is split between chunks.</p>
<h3 id="Creating-Your-Own-Codec-Class"><a href="#Creating-Your-Own-Codec-Class" class="headerlink" title="Creating Your Own Codec Class"></a>Creating Your Own Codec Class</h3><p>&emsp;&emsp;Support for new text encodings can be added to <code>Qt</code> by creating <code>QTextCodec</code> subclasses.<br>&emsp;&emsp;The pure virtual functions describe the encoder to the system and the coder is used as required in the different text file formats supported by <code>QTextStream</code>, and under <code>X11</code>, for the <code>locale-specific</code> character input and output.<br>&emsp;&emsp;To add support for another encoding to <code>Qt</code>, make a subclass of <code>QTextCodec</code> and implement the functions listed in the table below.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name()</code></td>
<td>Returns the official name for the encoding. If the encoding is listed in the <code>IANA</code> <code>character-sets</code> encoding file, the name should be the preferred <code>MIME</code> name for the encoding.</td>
</tr>
<tr>
<td><code>aliases()</code></td>
<td>Returns a list of alternative names for the encoding. <code>QTextCodec</code> provides a default implementation that returns an empty list. For example, <code>ISO-8859-1</code> has <code>latin1</code>, <code>CP819</code>, <code>IBM819</code>, and <code>iso-ir-100</code> as aliases.</td>
</tr>
<tr>
<td><code>mibEnum()</code></td>
<td>Return the <code>MIB</code> enum for the encoding if it is listed in the <code>IANA</code> <code>character-sets</code> encoding file.</td>
</tr>
<tr>
<td><code>convertToUnicode()</code></td>
<td>Converts an <code>8-bit</code> character string to <code>Unicode</code>.</td>
</tr>
<tr>
<td><code>convertFromUnicode()</code></td>
<td>Converts a <code>Unicode</code> string to an <code>8-bit</code> character string.</td>
</tr>
</tbody>
</table>
</div>
<p>You may find it more convenient to make your codec class available as a plugin.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QTextCodec::ConversionFlag</code>:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCodec::DefaultConversion</code></td>
<td><code>0</code></td>
<td>No flag is set.</td>
</tr>
<tr>
<td><code>QTextCodec::ConvertInvalidToNull</code></td>
<td><code>0x80000000</code></td>
<td>If this flag is set, each invalid input character is output as a null character.</td>
</tr>
<tr>
<td><code>QTextCodec::IgnoreHeader</code></td>
<td><code>0x1</code></td>
<td>Ignore any <code>Unicode</code> <code>byte-order</code> mark and don’t generate any.</td>
</tr>
</tbody>
</table>
</div>
<p>The <code>ConversionFlags</code> type is a typedef for <code>QFlags&lt;ConversionFlag&gt;</code>. It stores an <code>OR</code> combination of <code>ConversionFlag</code> values.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextCodec::QTextCodec() [protected]</code>: Constructs a <code>QTextCodec</code>, and gives it the highest precedence. The <code>QTextCodec</code> should always be constructed on the heap (i.e. with new). <code>Qt</code> takes ownership and will delete it when the application terminates.</li>
<li><code>QTextCodec::~QTextCodec() [virtual protected]</code>: Destroys the <code>QTextCodec</code>. Note that you should not delete codecs yourself: once created they become <code>Qt&#39;s</code> responsibility. <strong>Warning</strong>: This function is not reentrant.</li>
<li><code>QList&lt;QByteArray&gt; QTextCodec::aliases() const [virtual]</code>: Subclasses can return a number of aliases for the codec in question. Standard aliases for codecs can be found in the <code>IANA</code> <code>character-sets</code> encoding file.</li>
<li><code>QList&lt;QByteArray&gt; QTextCodec::availableCodecs() [static]</code>: Returns the list of all available codecs, by name. Call <code>QTextCodec::codecForName()</code> to obtain the <code>QTextCodec</code> for the name. The list may contain many mentions of the same codec if the codec has aliases.</li>
<li><code>QList&lt;int&gt; QTextCodec::availableMibs() [static]</code>: Returns the list of <code>MIBs</code> for all available codecs. Call <code>QTextCodec::codecForMib()</code> to obtain the <code>QTextCodec</code> for the <code>MIB</code>.</li>
<li><code>bool QTextCodec::canEncode(QChar ch) const</code>: Returns <code>true</code> if the Unicode character <code>ch</code> can be fully encoded with this codec; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCodec::canEncode(const QString &amp; s) const</code>: This is an overloaded function. <code>s</code> contains the string being tested for <code>encode-ability</code>.</li>
<li><code>QTextCodec * QTextCodec::codecForCStrings() [static]</code>: Returns the codec used by <code>QString</code> to convert to and from <code>const char *</code> and <code>QByteArrays</code>. If this function returns <code>0</code> (the default), <code>QString</code> assumes <code>Latin-1</code>.</li>
<li><code>QTextCodec * QTextCodec::codecForHtml(const QByteArray &amp; ba, QTextCodec * defaultCodec) [static]</code>: Tries to detect the encoding of the provided snippet of <code>HTML</code> in the given byte array, ba, by checking the <code>BOM (Byte Order Mark</code>) and the <code>content-type</code> meta header and returns a <code>QTextCodec</code> instance that is capable of decoding the html to unicode. If the codec cannot be detected from the content provided, <code>defaultCodec</code> is returned.</li>
<li><code>QTextCodec * QTextCodec::codecForHtml(const QByteArray &amp; ba) [static]</code>: This is an overloaded function. Tries to detect the encoding of the provided snippet of <code>HTML</code> in the given byte array, <code>ba</code>, by checking the <code>BOM (Byte Order Mark)</code> and the <code>content-type</code> meta header and returns a <code>QTextCodec</code> instance that is capable of decoding the html to unicode. If the codec cannot be detected, this overload returns a <code>Latin-1</code> <code>QTextCodec</code>.</li>
<li><code>QTextCodec * QTextCodec::codecForLocale() [static]</code>: Returns a pointer to the codec most suitable for this locale. On <code>Windows</code>, the codec will be based on a system locale. On <code>Unix</code> systems, starting with <code>Qt 4.2</code>, the codec will be using the iconv library. Note that in both cases the codec’s name will be <code>System</code>.</li>
<li><code>QTextCodec * QTextCodec::codecForMib(int mib) [static]</code>: Returns the <code>QTextCodec</code> which matches the <code>MIBenum</code> <code>mib</code>.</li>
<li><code>QTextCodec * QTextCodec::codecForName(const QByteArray &amp; name) [static]</code>: Searches all installed <code>QTextCodec</code> objects and returns the one which best matches <code>name</code>; the match is <code>case-insensitive</code>.</li>
<li><code>QTextCodec * QTextCodec::codecForName(const char * name) [static]</code>: Searches all installed <code>QTextCodec</code> objects and returns the one which best matches <code>name</code>; the match is <code>case-insensitive</code>.</li>
<li><code>QTextCodec * QTextCodec::codecForTr() [static]</code>: Returns the codec used by <code>QObject::tr()</code> on its argument. If this function returns <code>0</code> (the default), <code>tr()</code> assumes <code>Latin-1</code>.</li>
<li><code>QTextCodec * QTextCodec::codecForUtfText(const QByteArray &amp; ba, QTextCodec * defaultCodec) [static]</code>: Tries to detect the encoding of the provided snippet <code>ba</code> by using the <code>BOM (Byte Order Mark)</code> and returns a <code>QTextCodec</code> instance that is capable of decoding the text to unicode. If the codec cannot be detected from the content provided, <code>defaultCodec</code> is returned.</li>
<li><code>QTextCodec * QTextCodec::codecForUtfText(const QByteArray &amp; ba) [static]</code>: This is an overloaded function. Tries to detect the encoding of the provided snippet <code>ba</code> by using the <code>BOM (Byte Order Mark)</code> and returns a <code>QTextCodec</code> instance that is capable of decoding the text to unicode. If the codec cannot be detected, this overload returns a <code>Latin-1</code> <code>QTextCodec</code>.</li>
<li><code>QByteArray QTextCodec::convertFromUnicode(const QChar * input, int number, ConverterState * state) const [pure virtual protected]</code>: <code>QTextCodec</code> subclasses must reimplement this function. Converts the first <code>number</code> of characters from the <code>input</code> array from <code>Unicode</code> to the encoding of the subclass, and returns the result in a <code>QByteArray</code>. <code>state</code> can be <code>0</code> in which case the conversion is stateless and default conversion rules should be used. If <code>state</code> is not <code>0</code>, the codec should save the <code>state</code> after the conversion in <code>state</code>, and adjust the <code>remainingChars</code> and <code>invalidChars</code> members of the struct.</li>
<li><code>QString QTextCodec::convertToUnicode(const char * chars, int len, ConverterState * state) const [pure virtual protected]</code>: <code>QTextCodec</code> subclasses must reimplement this function. Converts the first <code>len</code> characters of <code>chars</code> from the encoding of the subclass to <code>Unicode</code>, and returns the result in a <code>QString</code>. <code>state</code> can be <code>0</code>, in which case the conversion is stateless and default conversion rules should be used. If <code>state</code> is not <code>0</code>, the codec should save the <code>state</code> after the conversion in <code>state</code>, and adjust the <code>remainingChars</code> and <code>invalidChars</code> members of the struct.</li>
<li><code>QByteArray QTextCodec::fromUnicode(const QString &amp; str) const</code>: Converts <code>str</code> from <code>Unicode</code> to the encoding of this codec, and returns the result in a <code>QByteArray</code>.</li>
<li><code>QByteArray QTextCodec::fromUnicode(const QChar * input, int number, ConverterState * state = 0) const</code>: Converts the first <code>number</code> of characters from the <code>input</code> array from <code>Unicode</code> to the encoding of this codec, and returns the result in a <code>QByteArray</code>. The <code>state</code> of the convertor used is updated.</li>
<li><code>QTextDecoder * QTextCodec::makeDecoder() const</code>: Creates a <code>QTextDecoder</code> which stores enough state to decode chunks of <code>char *</code> data to create chunks of <code>Unicode</code> data. The caller is responsible for deleting the returned object.</li>
<li><code>QTextDecoder * QTextCodec::makeDecoder(ConversionFlags flags) const</code>: Creates a <code>QTextDecoder</code> with a specified flags to decode chunks of <code>char *</code> data to create chunks of <code>Unicode</code> data. The caller is responsible for deleting the returned object.</li>
<li><code>QTextEncoder * QTextCodec::makeEncoder() const</code>: Creates a <code>QTextEncoder</code> which stores enough state to encode chunks of <code>Unicode</code> data as <code>char *</code> data. The caller is responsible for deleting the returned object.</li>
<li><code>QTextEncoder * QTextCodec::makeEncoder(ConversionFlags flags) const</code>: Creates a <code>QTextEncoder</code> with a specified <code>flags</code> to encode chunks of <code>Unicode</code> data as <code>char *</code> data. The caller is responsible for deleting the returned object.</li>
<li><code>int QTextCodec::mibEnum() const [pure virtual]</code>: Subclasses of <code>QTextCodec</code> must reimplement this function. It returns the <code>MIBenum</code>. It is important that each <code>QTextCodec</code> subclass returns the correct unique value for this function.</li>
<li><code>QByteArray QTextCodec::name() const [pure virtual]</code>: <code>QTextCodec</code> subclasses must reimplement this function. It returns the name of the encoding supported by the subclass. If the codec is registered as a character set in the <code>IANA</code> <code>character-sets</code> encoding file this method should return the preferred mime name for the codec if defined, otherwise its name.</li>
<li><code>void QTextCodec::setCodecForCStrings(QTextCodec * codec) [static]</code>: Sets the <code>codec</code> used by <code>QString</code> to convert to and from <code>const char *</code> and <code>QByteArrays</code>. If the <code>codec</code> is <code>0</code> (the default), <code>QString</code> assumes <code>Latin-1</code>. <strong>Warning</strong>: Some codecs do not preserve the characters in the <code>ASCII</code> range (<code>0x00</code> to <code>0x7F</code>). For example, the <code>Japanese</code> <code>Shift-JIS</code> encoding maps the backslash character (<code>0x5A</code>) to the <code>Yen</code> character. To avoid undesirable <code>side-effects</code>, we recommend avoiding such codecs with <code>setCodecsForCString()</code>. <strong>Warning</strong>: This function is not reentrant.</li>
<li><code>void QTextCodec::setCodecForLocale(QTextCodec * c) [static]</code>: Set the codec to <code>c</code>; this will be returned by <code>codecForLocale()</code>. If <code>c</code> is a null pointer, the codec is reset to the default. This might be needed for some applications that want to use their own mechanism for setting the locale.</li>
<li><code>void QTextCodec::setCodecForTr(QTextCodec * c) [static]</code>: Sets the codec used by <code>QObject::tr()</code> on its argument to <code>c</code>. If <code>c</code> is <code>0</code> (the default), <code>tr()</code> assumes <code>Latin-1</code>. If the literal quoted text in the program is not in the <code>Latin-1</code> encoding, this function can be used to set the appropriate encoding. For example, software developed by <code>Korean</code> programmers might use <code>eucKR</code> for all the text in the program, in which case the <code>main()</code> function might look like this:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    QTextCodec::setCodecForTr ( QTextCodec::codecForName ( <span class="string">"eucKR"</span> ) );</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that this is not the way to select the encoding that the user has chosen. For example, to convert an application containing literal <code>English</code> strings to <code>Korean</code>, all that is needed is for the <code>English</code> strings to be passed through <code>tr()</code> and for translation files to be loaded. <strong>Warning</strong>: This function is not reentrant.</p>
<ul>
<li><code>QString QTextCodec::toUnicode(const QByteArray &amp; a) const</code>: Converts <code>a</code> from the encoding of this codec to <code>Unicode</code>, and returns the result in a <code>QString</code>.</li>
<li><code>QString QTextCodec::toUnicode(const char * input, int size, ConverterState * state = 0) const</code>: Converts the first <code>size</code> characters from the <code>input</code> from the encoding of this codec to <code>Unicode</code>, and returns the result in a <code>QString</code>. The <code>state</code> of the convertor used is updated.</li>
<li><code>QString QTextCodec::toUnicode(const char * chars) const</code>: This is an overloaded function. <code>chars</code> contains the source characters.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/25/Qt语法详解/Qt之QTextCharFormat/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/Qt语法详解/Qt之QTextCharFormat/" itemprop="url">Qt之QTextCharFormat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-25T20:51:00+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTextCharFormat</code> class provides formatting information for characters in a <code>QTextDocument</code>.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCharFormat</code></td>
<td><code>QTextFormat</code></td>
<td><code>QTextImageFormat</code> and <code>QTextTableCellFormat</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextCharFormat()</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>anchorHref() const</code></td>
</tr>
<tr>
<td><code>QStringList</code></td>
<td><code>anchorNames() const</code></td>
</tr>
<tr>
<td><code>QFont</code></td>
<td><code>font() const</code></td>
</tr>
<tr>
<td><code>QFont::Capitalization</code></td>
<td><code>fontCapitalization() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>fontFamily() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>fontFixedPitch() const</code></td>
</tr>
<tr>
<td><code>QFont::HintingPreference</code></td>
<td><code>fontHintingPreference() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>fontItalic() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>fontKerning() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>fontLetterSpacing() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>fontOverline() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>fontPointSize() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>fontStrikeOut() const</code></td>
</tr>
<tr>
<td><code>QFont::StyleHint</code></td>
<td><code>fontStyleHint() const</code></td>
</tr>
<tr>
<td><code>QFont::StyleStrategy</code></td>
<td><code>fontStyleStrategy() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>fontUnderline() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>fontWeight() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>fontWordSpacing() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isAnchor() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isValid() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setAnchor(bool anchor)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setAnchorHref(const QString &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setAnchorNames(const QStringList &amp; names)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFont(const QFont &amp; font)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontCapitalization(QFont::Capitalization capitalization)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontFamily(const QString &amp; family)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontFixedPitch(bool fixedPitch)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontHintingPreference(QFont::HintingPreference hintingPreference)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontItalic(bool italic)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontKerning(bool enable)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontLetterSpacing(qreal spacing)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontOverline(bool overline)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontPointSize(qreal size)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontStrikeOut(bool strikeOut)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontStyleHint(QFont::StyleHint hint, QFont::StyleStrategy strategy = QFont::PreferDefault)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontStyleStrategy(QFont::StyleStrategy strategy)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontUnderline(bool underline)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontWeight(int weight)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontWordSpacing(qreal spacing)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTextOutline(const QPen &amp; pen)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setToolTip(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUnderlineColor(const QColor &amp; color)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUnderlineStyle(UnderlineStyle style)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setVerticalAlignment(VerticalAlignment alignment)</code></td>
</tr>
<tr>
<td><code>QPen</code></td>
<td><code>textOutline() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>toolTip() const</code></td>
</tr>
<tr>
<td><code>QColor</code></td>
<td><code>underlineColor() const</code></td>
</tr>
<tr>
<td><code>UnderlineStyle</code></td>
<td><code>underlineStyle() const</code></td>
</tr>
<tr>
<td><code>VerticalAlignment</code></td>
<td><code>verticalAlignment() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextCharFormat</code> class provides formatting information for characters in a <code>QTextDocument</code>.<br>&emsp;&emsp;The character format of text in a document specifies the visual properties of the text, as well as information about its role in a hypertext document.<br>&emsp;&emsp;The font used can be set by supplying a font to the <code>setFont()</code> function, and each aspect of its appearance can be adjusted to give the desired effect. <code>setFontFamily()</code> and <code>setFontPointSize()</code> define the font’s family (e.g. <code>Times</code>) and printed size; <code>setFontWeight()</code> and <code>setFontItalic()</code> provide control over the style of the font. <code>setFontUnderline()</code>, <code>setFontOverline()</code>, <code>setFontStrikeOut()</code>, and <code>setFontFixedPitch()</code> provide additional effects for text.<br>&emsp;&emsp;The color is set with <code>setForeground()</code>. If the text is intended to be used as an anchor (for hyperlinks), this can be enabled with <code>setAnchor()</code>. The <code>setAnchorHref()</code> and <code>setAnchorNames()</code> functions are used to specify the information about the hyperlink’s destination and the anchor’s name.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QTextCharFormat::UnderlineStyle</code>: This enum describes the different ways drawing underlined text.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCharFormat::NoUnderline</code></td>
<td><code>0</code></td>
<td>Text is draw without any underlining decoration.</td>
</tr>
<tr>
<td><code>QTextCharFormat::SingleUnderline</code></td>
<td><code>1</code></td>
<td>A line is drawn using <code>Qt::SolidLine</code>.</td>
</tr>
<tr>
<td><code>QTextCharFormat::DashUnderline</code></td>
<td><code>2</code></td>
<td>Dashes are drawn using <code>Qt::DashLine</code>.</td>
</tr>
<tr>
<td><code>QTextCharFormat::DotLine</code></td>
<td><code>3</code></td>
<td>Dots are drawn using <code>Qt::DotLine</code>.</td>
</tr>
<tr>
<td><code>QTextCharFormat::DashDotLine</code></td>
<td><code>4</code></td>
<td>Dashs and dots are drawn using <code>Qt::DashDotLine</code>.</td>
</tr>
<tr>
<td><code>QTextCharFormat::DashDotDotLine</code></td>
<td><code>5</code></td>
<td>Underlines draw drawn using <code>Qt::DashDotDotLine</code>.</td>
</tr>
<tr>
<td><code>QTextCharFormat::WaveUnderline</code></td>
<td><code>6</code></td>
<td>The text is underlined using a wave shaped line.</td>
</tr>
<tr>
<td><code>QTextCharFormat::SpellCheckUnderline</code></td>
<td><code>7</code></td>
<td>The underline is drawn depending on the <code>QStyle::SH_SpellCeckUnderlineStyle</code> style hint of the <code>QApplication</code> style. By default this is mapped to <code>WaveUnderline</code>, on <code>Mac OS X</code> it is mapped to <code>DashDotLine</code>.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QTextCharFormat::VerticalAlignment</code>: This enum describes the ways that adjacent characters can be vertically aligned.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCharFormat::AlignNormal</code></td>
<td><code>0</code></td>
<td>Adjacent characters are positioned in the standard way for text in the writing system in use.</td>
</tr>
<tr>
<td><code>QTextCharFormat::AlignSuperScript</code></td>
<td><code>1</code></td>
<td>Characters are placed above the base line for normal text.</td>
</tr>
<tr>
<td><code>QTextCharFormat::AlignSubScript</code></td>
<td><code>2</code></td>
<td>Characters are placed below the base line for normal text.</td>
</tr>
<tr>
<td><code>QTextCharFormat::AlignMiddle</code></td>
<td><code>3</code></td>
<td>The center of the object is vertically aligned with the base line. Currently, this is only implemented for inline objects.</td>
</tr>
<tr>
<td><code>QTextCharFormat::AlignBottom</code></td>
<td><code>5</code></td>
<td>The bottom edge of the object is vertically aligned with the base line.</td>
</tr>
<tr>
<td><code>QTextCharFormat::AlignTop</code></td>
<td><code>4</code></td>
<td>The top edge of the object is vertically aligned with the base line.</td>
</tr>
<tr>
<td><code>QTextCharFormat::AlignBaseline</code></td>
<td><code>6</code></td>
<td>The base lines of the characters are aligned.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextCharFormat::QTextCharFormat()</code>: Constructs a new character format object.</li>
<li><code>QString QTextCharFormat::anchorHref() const</code>: Returns the text format’s hypertext link, or an empty string if none has been set.</li>
<li><code>QStringList QTextCharFormat::anchorNames() const</code>: Returns the anchor names associated with this text format, or an empty string list if none has been set. If the anchor names are set, text with this format can be the destination of a hypertext link.</li>
<li><code>QFont QTextCharFormat::font() const</code>: Returns the font for this character format.</li>
<li><code>QFont::Capitalization QTextCharFormat::fontCapitalization() const</code>: Returns the current capitalization type of the font.</li>
<li><code>QString QTextCharFormat::fontFamily() const</code>: Returns the text format’s font family.</li>
<li><code>bool QTextCharFormat::fontFixedPitch() const</code>: Returns <code>true</code> if the text format’s font is fixed pitch; otherwise returns <code>false</code>.</li>
<li><code>QFont::HintingPreference QTextCharFormat::fontHintingPreference() const</code>: Returns the hinting preference set for this text format.</li>
<li><code>bool QTextCharFormat::fontItalic() const</code>: Returns <code>true</code> if the text format’s font is italic; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCharFormat::fontKerning() const</code>: Returns <code>true</code> if the font kerning is enabled.</li>
<li><code>qreal QTextCharFormat::fontLetterSpacing() const</code>: Returns the current letter spacing percentage.</li>
<li><code>bool QTextCharFormat::fontOverline() const</code>: Returns <code>true</code> if the text format’s font is overlined; otherwise returns <code>false</code>.</li>
<li><code>qreal QTextCharFormat::fontPointSize() const</code>: Returns the font size used to display text in this format.</li>
<li><code>bool QTextCharFormat::fontStrikeOut() const</code>: Returns <code>true</code> if the text format’s font is struck out (has a horizontal line drawn through it); otherwise returns <code>false</code>.</li>
<li><code>QFont::StyleHint QTextCharFormat::fontStyleHint() const</code>: Returns the font style hint.</li>
<li><code>QFont::StyleStrategy QTextCharFormat::fontStyleStrategy() const</code>: Returns the current font style strategy.</li>
<li><code>bool QTextCharFormat::fontUnderline() const</code>: Returns <code>true</code> if the text format’s font is underlined; otherwise returns <code>false</code>.</li>
<li><code>int QTextCharFormat::fontWeight() const</code>: Returns the text format’s font weight.</li>
<li><code>qreal QTextCharFormat::fontWordSpacing() const</code>: Returns the current word spacing value.</li>
<li><code>bool QTextCharFormat::isAnchor() const</code>: Returns <code>true</code> if the text is formatted as an anchor; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCharFormat::isValid() const</code>: Returns <code>true</code> if this character format is valid; otherwise returns <code>false</code>.</li>
<li><code>void QTextCharFormat::setAnchor(bool anchor)</code>: If <code>anchor</code> is <code>true</code>, text with this format represents an anchor, and is formatted in the appropriate way; otherwise the text is formatted normally (Anchors are hyperlinks which are often shown underlined and in a different color from plain text). The way the text is rendered is independent of whether or not the format has a valid <code>anchor</code> defined. Use <code>setAnchorHref()</code>, and optionally <code>setAnchorNames()</code> to create a hypertext link.</li>
<li><code>void QTextCharFormat::setAnchorHref(const QString &amp; value)</code>: Sets the hypertext link for the text format to the given <code>value</code>. This is typically a <code>URL</code> like <code>http://example.com/index.html</code>. The anchor will be displayed with the value as its display text; if you want to display different text call <code>setAnchorNames()</code>. To format the text as a hypertext link use <code>setAnchor()</code>.</li>
<li><code>void QTextCharFormat::setAnchorNames(const QStringList &amp; names)</code>: Sets the text format’s anchor <code>names</code>. For the anchor to work as a hyperlink, the destination must be set with <code>setAnchorHref()</code> and the anchor must be enabled with <code>setAnchor()</code>.</li>
<li><code>void QTextCharFormat::setFont(const QFont &amp; font)</code>: Sets the text format’s <code>font</code>.</li>
<li><code>void QTextCharFormat::setFontCapitalization(QFont::Capitalization capitalization)</code>: Sets the <code>capitalization</code> of the text that apppears in this font to <code>capitalization</code>. A font’s <code>capitalization</code> makes the text appear in the selected <code>capitalization</code> mode.</li>
<li><code>void QTextCharFormat::setFontFamily(const QString &amp; family)</code>: Sets the text format’s font <code>family</code>.</li>
<li><code>void QTextCharFormat::setFontFixedPitch(bool fixedPitch)</code>: If <code>fixedPitch</code> is <code>true</code>, sets the text format’s font to be fixed pitch; otherwise a <code>non-fixed</code> pitch font is used.</li>
<li><code>void QTextCharFormat::setFontHintingPreference(QFont::HintingPreference hintingPreference)</code>: Sets the hinting preference of the text format’s font to be <code>hintingPreference</code>.</li>
<li><code>void QTextCharFormat::setFontItalic(bool italic)</code>: If <code>italic</code> is <code>true</code>, sets the text format’s font to be italic; otherwise the font will be <code>non-italic</code>.</li>
<li><code>void QTextCharFormat::setFontKerning(bool enable)</code>: Enables kerning for this font if <code>enable</code> is <code>true</code>; otherwise disables it. When kerning is enabled, glyph metrics do not add up anymore, even for <code>Latin</code> text. In other words, the assumption that <code>width(&#39;a&#39;) + width(&#39;b&#39;)</code> is equal to <code>width(&quot;ab&quot;)</code> is not neccesairly <code>true</code>.</li>
<li><code>void QTextCharFormat::setFontLetterSpacing(qreal spacing)</code>: Sets the letter <code>spacing</code> of this format to the given <code>spacing</code>, in percent. A value of <code>100</code> indicates default <code>spacing</code>; a value of <code>200</code> doubles the amount of space a letter takes.</li>
<li><code>void QTextCharFormat::setFontOverline(bool overline)</code>: If <code>overline</code> is <code>true</code>, sets the text format’s font to be overlined; otherwise the font is displayed <code>non-overlined</code>.</li>
<li><code>void QTextCharFormat::setFontPointSize(qreal size)</code>: Sets the text format’s font <code>size</code>.</li>
<li><code>void QTextCharFormat::setFontStrikeOut(bool strikeOut)</code>: If <code>strikeOut</code> is <code>true</code>, sets the text format’s font with <code>strike-out</code> enabled (with a horizontal line through it); otherwise it is displayed without strikeout.</li>
<li><code>void QTextCharFormat::setFontStyleHint(QFont::StyleHint hint, QFont::StyleStrategy strategy = QFont::PreferDefault)</code>: Sets the font style <code>hint</code> and <code>strategy</code>. <code>Qt</code> does not support style hints on <code>X11</code> since this information is not provided by the window system.</li>
<li><code>void QTextCharFormat::setFontStyleStrategy(QFont::StyleStrategy strategy)</code>: Sets the font style <code>strategy</code>.</li>
<li><code>void QTextCharFormat::setFontUnderline(bool underline)</code>: If <code>underline</code> is <code>true</code>, sets the text format’s font to be underlined; otherwise it is displayed <code>non-underlined</code>.</li>
<li><code>void QTextCharFormat::setFontWeight(int weight)</code>: Sets the text format’s font <code>weight</code> to <code>weight</code>.</li>
<li><code>void QTextCharFormat::setFontWordSpacing(qreal spacing)</code>: Sets the word <code>spacing</code> of this format to the given <code>spacing</code>, in pixels.</li>
<li><code>void QTextCharFormat::setTextOutline(const QPen &amp; pen)</code>: Sets the <code>pen</code> used to draw the outlines of characters to the given <code>pen</code>.</li>
<li><code>void QTextCharFormat::setToolTip(const QString &amp; text)</code>: Sets the tool tip for a fragment of <code>text</code> to the given <code>text</code>.</li>
<li><code>void QTextCharFormat::setUnderlineColor(const QColor &amp; color)</code>: Sets the underline <code>color</code> used for the characters with this format to the <code>color</code> specified.</li>
<li><code>void QTextCharFormat::setUnderlineStyle(UnderlineStyle style)</code>: Sets the <code>style</code> of underlining the text to <code>style</code>.</li>
<li><code>void QTextCharFormat::setVerticalAlignment(VerticalAlignment alignment)</code>: Sets the vertical <code>alignment</code> used for the characters with this format to the <code>alignment</code> specified.</li>
<li><code>QPen QTextCharFormat::textOutline() const</code>: Returns the pen used to draw the outlines of characters in this format.</li>
<li><code>QString QTextCharFormat::toolTip() const</code>: Returns the tool tip that is displayed for a fragment of text.</li>
<li><code>QColor QTextCharFormat::underlineColor() const</code>: Returns the color used to underline the characters with this format.</li>
<li><code>UnderlineStyle QTextCharFormat::underlineStyle() const</code>: Returns the style of underlining the text.</li>
<li><code>VerticalAlignment QTextCharFormat::verticalAlignment() const</code>: Returns the vertical alignment used for characters with this format.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/25/Qt语法详解/QByteArray和QBuffer/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/Qt语法详解/QByteArray和QBuffer/" itemprop="url">QByteArray和QBuffer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-25T18:41:07+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>QByteArray</code>类提供了一个字节数组，既可以存储原始的字节(包括<code>\0</code>)，又可以被用来存储以<code>\0</code>结尾的字符串(可以理解为字符数组<code>char str[] = {&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;}</code>或者<code>char *str = &quot;hello&quot;</code>)。由于<code>QByteArray</code>封装的功能很多，使用起来比<code>char *</code>要方便的多，而就其内部实现来讲，它会保证所有的数据以<code>\0</code>结尾，使用隐式数据共享(<code>copy-on-write</code>)来减少内存消耗以及不必要的数据拷贝。<br>&emsp;&emsp;有两种情况比较适合使用<code>QByteArray</code>，第一就是要存储纯二进制数据(<code>raw binary data</code>)或<code>8bit</code>编码文本字符串，第二种情况就是在内存资源很珍贵的情况下，例如<code>Qt for Embedded Linux</code>。<br>&emsp;&emsp;一种初始化<code>QByteArray</code>方式是给它的构造函数传入一个<code>const char *</code>即可。此时，<code>QByteArray</code>执行了深拷贝。如果出于效率考虑不想执行深拷贝，使用<code>QByteArray::fromRawData(const char * data, int siz)</code>，其返回的<code>QByteArray</code>对象将会和数据指针相关联。<br>&emsp;&emsp;对于语句<code>QByteArray array(&quot;Hello&quot;);</code>，<code>array</code>的<code>size</code>是<code>5</code>，但由于其在最后要存储额外的<code>\0</code>，其实际占用空间是<code>6</code>。<br>&emsp;&emsp;常用操作函数如下所示：<br>&emsp;&emsp;1. <code>int QByteArray::size() const</code>：如果<code>QByteArray</code>在从<code>raw</code>数据创建时，不包含尾随的终止符，<code>QByteArray</code>不会自动添加，除非通过深拷贝进行创建：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">ba</span> <span class="params">( <span class="string">"Hello"</span> )</span></span>;</span><br><span class="line"><span class="keyword">int</span> n = ba.size(); <span class="comment">/* n = 5 */</span></span><br><span class="line">ba.data() [<span class="number">0</span>]; <span class="comment">/* returns 'H' */</span></span><br><span class="line">ba.data() [<span class="number">4</span>]; <span class="comment">/* returns 'o' */</span></span><br><span class="line">ba.data() [<span class="number">5</span>]; <span class="comment">/* returns '\0' */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 和<code>C++</code>的普通数组一样，<code>QByteArray</code>也可以使用<code>[]</code>来访问其具体下表对应的字节。对于非<code>const</code>的<code>QByteArray</code>，可以直接进行赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QByteArray <span class="built_in">array</span>;</span><br><span class="line"><span class="built_in">array</span>.resize ( <span class="number">5</span> );</span><br><span class="line"><span class="built_in">array</span> [<span class="number">0</span>] = <span class="number">0x3c</span>;</span><br><span class="line"><span class="built_in">array</span> [<span class="number">1</span>] = <span class="number">0xb8</span>;</span><br><span class="line"><span class="built_in">array</span> [<span class="number">2</span>] = <span class="number">0x64</span>;</span><br><span class="line"><span class="built_in">array</span> [<span class="number">3</span>] = <span class="number">0x18</span>;</span><br><span class="line"><span class="built_in">array</span> [<span class="number">4</span>] = <span class="number">0xca</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3. 对于只读操作，请使用<code>at</code>，因为它可以避免深拷贝，比使用<code>[]</code>要快，效率要高：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">array</span>.at ( i ) &gt;= <span class="string">'a'</span> &amp;&amp; <span class="built_in">array</span>.at ( i ) &lt;= <span class="string">'f'</span> ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found character in range [a - f] "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;4. 可以使用<code>left</code>、<code>right</code>或者<code>mid</code>来实现一次取出多个字符：</p>
<ul>
<li><code>QByteArray QByteArray::left(int len) const</code>: Returns a byte array that contains the leftmost <code>len</code> bytes of this byte array. The entire byte array is returned if len is greater than <code>size()</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">x</span> <span class="params">( <span class="string">"Pineapple"</span> )</span></span>;</span><br><span class="line">QByteArray y = x.left ( <span class="number">4</span> ); <span class="comment">/* y = "Pine" */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>QByteArray QByteArray::right(int len) const</code>: Returns a byte array that contains the rightmost <code>len</code> bytes of this byte array. The entire byte array is returned if <code>len</code> is greater than <code>size()</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">x</span> <span class="params">( <span class="string">"Pineapple"</span> )</span></span>;</span><br><span class="line">QByteArray y = x.right ( <span class="number">5</span> ); <span class="comment">/* y = "apple" */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>QByteArray QByteArray::mid(int pos, int len = -1) const</code>：以<code>pos</code>作为起点，返回指定字节长度的<code>array</code>，如果<code>len</code>为<code>-1</code>(默认)，或者<code>pos + len &gt;= size()</code>，将返回从指定为<code>pos</code>开始直到字节数组尾的所有字节。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">x</span> <span class="params">( <span class="string">"Five pineapples"</span> )</span></span>;</span><br><span class="line">QByteArray y = x.mid ( <span class="number">5</span>, <span class="number">4</span> ); <span class="comment">/* y = "pine" */</span></span><br><span class="line">QByteArray z = x.mid ( <span class="number">5</span> ); <span class="comment">/* z = "pineapples" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;5. <code>char * QByteArray::data()</code>: Returns a pointer to the data stored in the byte array; <code>const char * QByteArray::constData() const</code>: Returns a pointer to the data stored in the byte array：通过<code>data</code>或者<code>constData</code>可以获得<code>QByteArray</code>的真实数据的指针，获得的数据指针在调用<code>QByteArray</code>的<code>non-const</code>函数之前都是有效的。</p>
<p>&emsp;&emsp;6. <code>uint qstrlen(const char * str)</code>: Returns the number of characters that precede(先于) the terminating <code>\0</code>, or <code>0</code> if <code>str</code> is <code>0</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QByteArray <span class="built_in">array</span> = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="built_in">printf</span> ( <span class="string">"%d\n"</span>, <span class="built_in">array</span>.size() - <span class="number">1</span> );</span><br><span class="line"><span class="built_in">printf</span> ( <span class="string">"%c\n"</span>, <span class="built_in">array</span>.data() [<span class="built_in">array</span>.size()] );</span><br><span class="line"><span class="built_in">printf</span> ( <span class="string">"%d\n"</span>, qstrlen ( ( <span class="keyword">const</span> <span class="keyword">char</span> * ) <span class="built_in">array</span>.data() ) );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;7. <code>QByteArray</code>提供了很多修改字节的方法，例如<code>append</code>、<code>prepend</code>、<code>insert</code>、<code>replace</code>和<code>remove</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">x</span> <span class="params">( <span class="string">"and"</span> )</span></span>;</span><br><span class="line">x.prepend ( <span class="string">"rock "</span> ); <span class="comment">/* x = "rock and" */</span></span><br><span class="line">x.append ( <span class="string">" roll"</span> ); <span class="comment">/* x = "rock and roll" */</span></span><br><span class="line">x.replace ( <span class="number">5</span>, <span class="number">3</span>, <span class="string">"&amp;"</span> ); <span class="comment">/* x = "rock &amp; roll" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;8. <code>QBuffer</code>类是一个操作<code>QByteArray</code>的输入输出设备的接口，其构造函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QBuffer ( QByteArray *byteArray, QObject *parent = <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p><code>QBuffer</code>类用来读写内存缓存。在使用之前，用<code>open</code>来打开缓存并且设置模式(<code>只读</code>、<code>只写</code>等)。<br>&emsp;&emsp;<code>QDataStream</code>和<code>QTextStream</code>也可以使用一个<code>QByteArray</code>参数来构造，这些构造函数创建并且打开一个内部的<code>QBuffer</code>。</p>
<hr>
<h3 id="QBuffer-Class-Reference"><a href="#QBuffer-Class-Reference" class="headerlink" title="QBuffer Class Reference"></a>QBuffer Class Reference</h3><p>&emsp;&emsp;该类一个<code>QByteArray</code>提供一个<code>QIODevice</code>接口类，其头文件为<code>QBuffer</code>，继承自<code>QIODevice</code>。注意，该类所以的函数是可重入的。<br>&emsp;&emsp;公共函数如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QBuffer ( QObject * parent = 0 )</code></td>
</tr>
<tr>
<td></td>
<td><code>QBuffer ( QByteArray * byteArray, QObject * parent = 0 )</code></td>
</tr>
<tr>
<td></td>
<td><code>~QBuffer ()</code></td>
</tr>
<tr>
<td><code>QByteArray &amp;</code></td>
<td><code>buffer ()</code></td>
</tr>
<tr>
<td><code>const QByteArray &amp;</code></td>
<td><code>buffer () const</code></td>
</tr>
<tr>
<td><code>const QByteArray &amp;</code></td>
<td><code>data () const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBuffer ( QByteArray * byteArray )</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setData ( const QByteArray &amp; data )</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setData ( const char * data, int size )</code></td>
</tr>
</tbody>
</table>
</div>
<p>重新实现的公共函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual bool</code></td>
<td><code>atEnd () const</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>canReadLine () const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>close ()</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>open ( OpenMode flags )</code></td>
</tr>
<tr>
<td><code>virtual qint64</code></td>
<td><code>pos () const</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>seek ( qint64 pos )</code></td>
</tr>
<tr>
<td><code>virtual qint64</code></td>
<td><code>size () const</code></td>
</tr>
</tbody>
</table>
</div>
<p>重新实现的受保护的函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual qint64</code></td>
<td><code>readData ( char * data, qint64 len )</code></td>
</tr>
<tr>
<td><code>virtual qint64</code></td>
<td><code>writeData ( const char * data, qint64 len )</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h3><p>&emsp;&emsp;<code>QBuffer</code>允许你通过使用<code>QIODevice</code>接口来存取一个<code>QByteArray</code>。<code>QByteArray</code>被视为一个标准的随机存取文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QBuffer buffer;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">buffer.open ( QBuffer::ReadWrite );</span><br><span class="line">buffer.write ( <span class="string">"Qt rocks!"</span> );</span><br><span class="line">buffer.seek ( <span class="number">0</span> );</span><br><span class="line">buffer.getChar ( &amp;ch ); <span class="comment">/* ch = 'Q' */</span></span><br><span class="line">buffer.getChar ( &amp;ch ); <span class="comment">/* ch = 't' */</span></span><br><span class="line">buffer.getChar ( &amp;ch ); <span class="comment">/* ch = ' ' */</span></span><br><span class="line">buffer.getChar ( &amp;ch ); <span class="comment">/* ch = 'r' */</span></span><br></pre></td></tr></table></figure>
<p>缺省情况下，当你创造一个<code>QBuffer</code>时，一个内部的<code>QByteArray</code>缓存被建立。你能通过调用<code>buffer</code>函数存取这个<code>buffer</code>，也能用一个存在的<code>QByteArray</code>通过调用<code>setBuffer</code>使用<code>QBuffer</code>，或者通过传递你的数组到<code>QBuffer</code>的构造函数调用<code>open</code>来打开<code>buffer</code>，然后调用<code>write</code>或者<code>putChar</code>来写<code>buffer</code>，<code>read</code>、<code>readLine</code>、<code>readALL</code>或者<code>getChar</code>来读<code>buffer</code>。<code>Size</code>返回目前<code>buffer</code>的大小，你能通过调用<code>seek</code>定位在这个<code>buffer</code>中的任意位置。当你退出时，应该调用<code>close</code>。下面的代码演示使用<code>QDataStream</code>和<code>QBuffer</code>写数据到一个<code>QByteArray</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QByteArray byteArray;</span><br><span class="line"><span class="function">QBuffer <span class="title">buffer</span> <span class="params">( &amp;byteArray )</span></span>;</span><br><span class="line">buffer.open ( QIODevice::WriteOnly );</span><br><span class="line">​</span><br><span class="line"><span class="function">QDataStream <span class="title">out</span> <span class="params">( &amp;buffer )</span></span>;</span><br><span class="line">out &lt;&lt; QApplication::palette();</span><br></pre></td></tr></table></figure>
<p>我们也可以转换<code>QPalette</code>到一个字节数组，下面是读数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QByteArray byteArray;</span><br><span class="line">QPalette palette;</span><br><span class="line"><span class="function">QBuffer <span class="title">buffer</span> <span class="params">( &amp;byteArray )</span></span>;</span><br><span class="line">buffer.open ( QIODevice::ReadOnly );</span><br><span class="line">​</span><br><span class="line"><span class="function">QDataStream <span class="title">in</span> <span class="params">( &amp;buffer )</span></span>;</span><br><span class="line">in &gt;&gt; palette;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>QTextStream</code>和<code>QDataStream</code>也提供方便的构造函数来在幕后构建<code>QByteArray</code>来创造一个<code>QBuffer</code>。当新的数据到达时，<code>QBuffer</code>发送信号<code>readRead</code>，通过连接这个信号，你能使用<code>QBuffer</code>来缓存即将被处理的数据。例如当从一个<code>FTP</code>服务器下载一个文件时，你能传递<code>buffer</code>到<code>QFtp</code>。当一个新的数据负荷已经被下载时，<code>readRead</code>信号被发出，当数据到达后，你能处理该数据。每当新数据已经被写入<code>buffer</code>时，<code>QBuffer</code>发出<code>bytesWritten</code>信号。<br>&emsp;&emsp;构造函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QBuffer::QBuffer ( QObject *parent = <span class="number">0</span> );</span><br><span class="line">QBuffer::QBuffer ( QByteArray *byteArray, QObject *parent = <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p>实例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">byteArray</span> <span class="params">( <span class="string">"abc"</span> )</span></span>;</span><br><span class="line"><span class="function">QBuffer <span class="title">buffer</span> <span class="params">( &amp;byteArray )</span></span>;</span><br><span class="line">buffer.open ( QIODevice::WriteOnly );</span><br><span class="line">buffer.seek ( <span class="number">3</span> );</span><br><span class="line">buffer.write ( <span class="string">"def"</span>, <span class="number">3</span> );</span><br><span class="line">buffer.close(); <span class="comment">/* byteArray = "abcdef" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;析构函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QBuffer::~QBuffer ()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其它函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> QBuffer::atEnd () <span class="keyword">const</span> [<span class="keyword">virtual</span>]</span><br><span class="line">QByteArray &amp;QBuffer::buffer ()</span><br><span class="line"><span class="keyword">const</span> QByteArray &amp;QBuffer::buffer () <span class="keyword">const</span></span><br><span class="line"><span class="keyword">bool</span> QBuffer::canReadLine () <span class="keyword">const</span> [<span class="keyword">virtual</span>]</span><br><span class="line"><span class="keyword">void</span> QBuffer::close () [<span class="keyword">virtual</span>]</span><br><span class="line"><span class="keyword">const</span> QByteArray &amp;QBuffer::data () <span class="keyword">const</span></span><br><span class="line"><span class="keyword">bool</span> QBuffer::open ( OpenMode flags ) [<span class="keyword">virtual</span>]</span><br><span class="line">qint64 QBuffer::pos () <span class="keyword">const</span> [<span class="keyword">virtual</span>]</span><br><span class="line">qint64 QBuffer::readData ( <span class="keyword">char</span> *data, qint64 len ) [<span class="keyword">virtual</span> <span class="keyword">protected</span>]</span><br><span class="line"><span class="keyword">bool</span> QBuffer::seek ( qint64 pos ) [<span class="keyword">virtual</span>]</span><br><span class="line"><span class="keyword">void</span> QBuffer::setBuffer ( QByteArray *byteArray )</span><br><span class="line"><span class="keyword">void</span> QBuffer::setData ( <span class="keyword">const</span> QByteArray &amp;data )</span><br><span class="line"><span class="keyword">void</span> QBuffer::setData ( <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> size )</span><br><span class="line">qint64 QBuffer::size () <span class="keyword">const</span> [<span class="keyword">virtual</span>]</span><br><span class="line">qint64 QBuffer::writeData ( <span class="keyword">const</span> <span class="keyword">char</span> *data, qint64 len ) [<span class="keyword">virtual</span> <span class="keyword">protected</span>]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">byteArray</span> <span class="params">( <span class="string">"abc"</span> )</span></span>;</span><br><span class="line">QBuffer buffer;</span><br><span class="line">buffer.setBuffer ( &amp;byteArray );</span><br><span class="line">buffer.open ( QIODevice::WriteOnly );</span><br><span class="line">buffer.seek ( <span class="number">3</span> );</span><br><span class="line">buffer.write ( <span class="string">"def"</span>, <span class="number">3</span> );</span><br><span class="line">buffer.close(); <span class="comment">/* byteArray = "abcdef" */</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Qt中QByteArray与byte之间转换"><a href="#Qt中QByteArray与byte之间转换" class="headerlink" title="Qt中QByteArray与byte之间转换"></a>Qt中QByteArray与byte之间转换</h3><p>&emsp;&emsp;1. <code>byte</code>数组到<code>QByteArray</code>的转换<br>&emsp;&emsp;推荐使用如下方法进行初始化，即使数组中有<code>0</code>也能完整赋值进去，因为<code>QByteArray</code>不认为<code>\0</code>就是结尾：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QByteArray byArr;</span><br><span class="line">byte cmd[<span class="number">5</span>] = &#123;<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'\0'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>&#125;;</span><br><span class="line">byArr.resize ( <span class="number">5</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">    byArr[i] = cmd[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用下面的转换方法，当数组中包含<code>0x00</code>(即<code>\0</code>)，就会丢失后面的数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QByteArray byArr = QByteArray ( ( <span class="keyword">const</span> <span class="keyword">char</span> * ) cmd );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. <code>QByteArray</code>到<code>byte</code>数组的转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> isize = byArr.size();</span><br><span class="line">byte *pby = ( byte * ) ( byArr.data() );</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/25/Qt语法详解/Qt之QMimeData/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/Qt语法详解/Qt之QMimeData/" itemprop="url">Qt之QMimeData</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-25T15:09:10+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QMimeData</code> class provides a container for data that records information about its <code>MIME</code> type.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QMimeData</code></td>
<td><code>QObject</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QMimeData()</code></td>
</tr>
<tr>
<td></td>
<td><code>~QMimeData()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>QVariant</code></td>
<td><code>colorData() const</code></td>
</tr>
<tr>
<td><code>QByteArray</code></td>
<td><code>data(const QString &amp; mimeType) const</code></td>
</tr>
<tr>
<td><code>virtual QStringList</code></td>
<td><code>formats() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasColor() const</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>hasFormat(const QString &amp; mimeType) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasHtml() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasImage() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasText() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasUrls() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>html() const</code></td>
</tr>
<tr>
<td><code>QVariant</code></td>
<td><code>imageData() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeFormat(const QString &amp; mimeType)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setColorData(const QVariant &amp; color)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setData(const QString &amp; mimeType, const QByteArray &amp; data)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHtml(const QString &amp; html)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setImageData(const QVariant &amp; image)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setText(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUrls(const QList&lt;QUrl&gt; &amp; urls)</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>text() const</code></td>
</tr>
<tr>
<td><code>QList&lt;QUrl&gt;</code></td>
<td><code>urls() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual QVariant</code></td>
<td><code>retrieveData(const QString &amp; mimeType, QVariant::Type type) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QMimeData</code> class provides a container for data that records information about its <code>MIME</code> type.<br>&emsp;&emsp;<code>QMimeData</code> is used to describe information that can be stored in the clipboard, and transferred via the drag and drop mechanism. <code>QMimeData</code> objects associate the data that they hold with the corresponding <code>MIME</code> types to ensure that information can be safely transferred between applications, and copied around within the same application.<br>&emsp;&emsp;<code>QMimeData</code> objects are usually created using new and supplied to <code>QDrag</code> or <code>QClipboard</code> objects. This is to enable <code>Qt</code> to manage the memory that they use.<br>&emsp;&emsp;A single <code>QMimeData</code> object can store the same data using several different formats at the same time. The <code>formats()</code> function returns a list of the available formats in order of preference. The <code>data()</code> function returns the raw data associated with a <code>MIME</code> type, and <code>setData()</code> allows you to set the data for a <code>MIME</code> type.<br>&emsp;&emsp;For the most common <code>MIME</code> types, <code>QMimeData</code> provides convenience functions to access the data:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Tester</th>
<th>Getter</th>
<th>Setter</th>
<th>MIME Types</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hasText()</code></td>
<td><code>text()</code></td>
<td><code>setText()</code></td>
<td><code>text/plain</code></td>
</tr>
<tr>
<td><code>hasHtml()</code></td>
<td><code>html()</code></td>
<td><code>setHtml()</code></td>
<td><code>text/html</code></td>
</tr>
<tr>
<td><code>hasUrls()</code></td>
<td><code>urls()</code></td>
<td><code>setUrls()</code></td>
<td><code>text/uri-list</code></td>
</tr>
<tr>
<td><code>hasImage()</code></td>
<td><code>imageData()</code></td>
<td><code>setImageData()</code></td>
<td><code>image/ *</code></td>
</tr>
<tr>
<td><code>hasColor()</code></td>
<td><code>colorData()</code></td>
<td><code>setColorData()</code></td>
<td><code>application/x-color</code></td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;For example, if your write a widget that accepts <code>URL</code> drags, you would end up writing code like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MyWidget::dragEnterEvent ( QDragEnterEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasUrls() ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MyWidget::dropEvent ( QDropEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasUrls() ) &#123;</span><br><span class="line">        foreach ( QUrl url, event-&gt;mimeData()-&gt;urls() ) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;There are three approaches for storing custom data in a <code>QMimeData</code> object:<br>&emsp;&emsp;1. Custom data can be stored directly in a <code>QMimeData</code> object as a <code>QByteArray</code> using <code>setData()</code>. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QByteArray csvData = ...;</span><br><span class="line">​</span><br><span class="line">QMimeData *mimeData = <span class="keyword">new</span> QMimeData;</span><br><span class="line">mimeData-&gt;setData ( <span class="string">"text/csv"</span>, csvData );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. We can subclass <code>QMimeData</code> and reimplement <code>hasFormat()</code>, <code>formats()</code>, and <code>retrieveData()</code>.<br>&emsp;&emsp;3. If the drag and drop operation occurs within a single application, we can subclass <code>QMimeData</code> and add extra data in it, and use a <code>qobject_cast()</code> in the receiver’s drop event handler. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MyWidget::dropEvent ( QDropEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">const</span> MyMimeData *myData = qobject_cast&lt;<span class="keyword">const</span> MyMimeData *&gt; ( event-&gt;mimeData() );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( myData ) &#123;</span><br><span class="line">        <span class="comment">/* access myData's data directly (not through QMimeData's API) */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Platform-Specific-MIME-Types"><a href="#Platform-Specific-MIME-Types" class="headerlink" title="Platform-Specific MIME Types"></a>Platform-Specific MIME Types</h3><p>&emsp;&emsp;On <code>Windows</code>, <code>formats()</code> will also return custom formats available in the <code>MIME</code> data, using the <code>x-qt-windows-mime</code> subtype to indicate that they represent data in <code>non-standard</code> formats. The formats will take the following form:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/x-qt-windows-mime; value="<span class="tag">&lt;<span class="name">custom</span> <span class="attr">type</span>&gt;</span>"</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The following are examples of custom <code>MIME</code> types:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">application/x-qt-windows-mime; value="FileGroupDescriptor"</span><br><span class="line">application/x-qt-windows-mime; value="FileContents"</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The value declaration of each format describes the way in which the data is encoded.<br>&emsp;&emsp;On <code>Windows</code>, the <code>MIME</code> format does not always map directly to the clipboard formats. <code>Qt</code> provides <code>QWindowsMime</code> to map clipboard formats to <code>open-standard</code> <code>MIME</code> formats. Similarly, the <code>QMacPasteboardMime</code> maps <code>MIME</code> to <code>Mac</code> flavors.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QMimeData::QMimeData()</code>: Constructs a new <code>MIME</code> data object with no data in it.</li>
<li><code>QMimeData::~QMimeData()</code>: Destroys the <code>MIME</code> data object.</li>
<li><code>void QMimeData::clear()</code>: Removes all the <code>MIME</code> type and data entries in the object.</li>
<li><code>QVariant QMimeData::colorData() const</code>: Returns a color if the data stored in the object represents a color (<code>MIME</code> type <code>application/x-color</code>); otherwise returns a null variant. A <code>QVariant</code> is used because <code>QMimeData</code> belongs to the <code>QtCore</code> library, whereas <code>QColor</code> belongs to <code>QtGui</code>. To convert the <code>QVariant</code> to a <code>QColor</code>, simply use <code>qvariant_cast()</code>. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasColor() ) &#123;</span><br><span class="line">    QColor color = qvariant_cast&lt;QColor&gt; ( event-&gt;mimeData()-&gt;colorData() );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QByteArray QMimeData::data(const QString &amp; mimeType) const</code>: Returns the data stored in the object in the format described by the <code>MIME</code> type specified by <code>mimeType</code>.</li>
<li><code>[virtual] QStringList QMimeData::formats() const</code>: Returns a list of formats supported by the object. This is a list of <code>MIME</code> types for which the object can return suitable data. The formats in the list are in a priority order. For the most common types of data, you can call the <code>higher-level</code> functions <code>hasText()</code>, <code>hasHtml()</code>, <code>hasUrls()</code>, <code>hasImage()</code>, and <code>hasColor()</code> instead.</li>
<li><code>bool QMimeData::hasColor() const</code>: Returns <code>true</code> if the object can return a color (<code>MIME</code> type <code>application/x-color</code>); otherwise returns <code>false</code>.</li>
<li><code>[virtual] bool QMimeData::hasFormat(const QString &amp; mimeType) const</code>: Returns <code>true</code> if the object can return data for the <code>MIME</code> type specified by <code>mimeType</code>; otherwise returns <code>false</code>. For the most common types of data, you can call the <code>higher-level</code> functions <code>hasText()</code>, <code>hasHtml()</code>, <code>hasUrls()</code>, <code>hasImage()</code>, and <code>hasColor()</code> instead.</li>
<li><code>bool QMimeData::hasHtml() const</code>: Returns <code>true</code> if the object can return <code>HTML</code> (<code>MIME</code> type <code>text/html</code>); otherwise returns <code>false</code>.</li>
<li><code>bool QMimeData::hasImage() const</code>: Returns <code>true</code> if the object can return an image; otherwise returns <code>false</code>.</li>
<li><code>bool QMimeData::hasText() const</code>: Returns <code>true</code> if the object can return plain text (<code>MIME</code> type <code>text/plain</code>); otherwise returns <code>false</code>.</li>
<li><code>bool QMimeData::hasUrls() const</code>: Returns <code>true</code> if the object can return a list of urls; otherwise returns <code>false</code>. <code>URLs</code> correspond to the <code>MIME</code> type <code>text/uri-list</code>.</li>
<li><code>QString QMimeData::html() const</code>: Returns a string if the data stored in the object is <code>HTML</code> (<code>MIME</code> type <code>text/html</code>); otherwise returns an empty string.</li>
<li><code>QVariant QMimeData::imageData() const</code>: Returns a <code>QVariant</code> storing a <code>QImage</code> if the object can return an image; otherwise returns a null variant. A <code>QVariant</code> is used because <code>QMimeData</code> belongs to the <code>QtCore</code> library, whereas <code>QImage</code> belongs to <code>QtGui</code>. To convert the <code>QVariant</code> to a <code>QImage</code>, simply use <code>qvariant_cast()</code>. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasImage() ) &#123;</span><br><span class="line">    QImage image = qvariant_cast&lt;QImage&gt; ( event-&gt;mimeData()-&gt;imageData() );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QMimeData::removeFormat(const QString &amp; mimeType)</code>: Removes the data entry for <code>mimeType</code> in the object.</li>
<li><code>[virtual protected] QVariant QMimeData::retrieveData(const QString &amp; mimeType, QVariant::Type type) const</code>: Returns a variant with the given <code>type</code> containing data for the <code>MIME</code> type specified by <code>mimeType</code>. If the object does not support the <code>MIME</code> type or variant type given, a null variant is returned instead. This function is called by the general <code>data()</code> getter and by the convenience getters (<code>text()</code>, <code>html()</code>, <code>urls()</code>, <code>imageData()</code>, and <code>colorData()</code>). You can reimplement it if you want to store your data using a custom data structure (instead of a <code>QByteArray</code>, which is what <code>setData()</code> provides). You would then also need to reimplement <code>hasFormat()</code> and <code>formats()</code>.</li>
<li><code>void QMimeData::setColorData(const QVariant &amp; color)</code>: Sets the <code>color</code> data in the object to the given <code>color</code>. Colors correspond to the <code>MIME</code> type <code>application/x-color</code>.</li>
<li><code>void QMimeData::setData(const QString &amp; mimeType, const QByteArray &amp; data)</code>: Sets the <code>data</code> associated with the <code>MIME</code> type given by <code>mimeType</code> to the specified <code>data</code>. For the most common types of <code>data</code>, you can call the <code>higher-level</code> functions <code>setText()</code>, <code>setHtml()</code>, <code>setUrls()</code>, <code>setImageData()</code>, and <code>setColorData()</code> instead. Note that if you want to use a custom <code>data</code> type in an item view drag and drop operation, you must register it as a <code>Qt</code> meta type, using the <code>Q_DECLARE_METATYPE()</code> macro, and implement stream operators for it. The stream operators must then be registered with the <code>qRegisterMetaTypeStreamOperators()</code> function.</li>
<li><code>void QMimeData::setHtml(const QString &amp; html)</code>: Sets <code>html</code> as the <code>HTML</code> (<code>MIME</code> type <code>text/html</code>) used to represent the data.</li>
<li><code>void QMimeData::setImageData(const QVariant &amp; image)</code>: Sets the data in the object to the given <code>image</code>. A <code>QVariant</code> is used because <code>QMimeData</code> belongs to the <code>QtCore</code> library, whereas <code>QImage</code> belongs to <code>QtGui</code>. The conversion from <code>QImage</code> to <code>QVariant</code> is implicit. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimeData-&gt;setImageData ( QImage ( <span class="string">"beautifulfjord.png"</span> ) );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QMimeData::setText(const QString &amp; text)</code>: Sets <code>text</code> as the plain <code>text</code> (<code>MIME</code> type <code>text/plain</code>) used to represent the data.</li>
<li><code>void QMimeData::setUrls(const QList&lt;QUrl&gt; &amp; urls)</code>: Sets the <code>URLs</code> stored in the <code>MIME</code> data object to those specified by <code>urls</code>. <code>URLs</code> correspond to the <code>MIME</code> type <code>text/uri-list</code>.</li>
<li><code>QString QMimeData::text() const</code>: Returns a plain text (<code>MIME</code> type <code>text/plain</code>) representation of the data.</li>
<li><code>QList&lt;QUrl&gt; QMimeData::urls() const</code>: Returns a list of <code>URLs</code> contained within the <code>MIME</code> data object. <code>URLs</code> correspond to the <code>MIME</code> type <code>text/uri-list</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/25/Qt语法详解/Qt之iterator/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/Qt语法详解/Qt之iterator/" itemprop="url">Qt之iterator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-25T11:41:26+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QList::iterator</code> class provides an <code>STL-style</code> <code>non-const</code> iterator for <code>QList</code> and <code>QQueue</code>. The header file is <code>iterator</code>.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>iterator()</code></td>
</tr>
<tr>
<td></td>
<td><code>iterator(const iterator &amp; other)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const const_iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>operator*() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>operator+(int j) const</code></td>
</tr>
<tr>
<td><code>iterator &amp;</code></td>
<td><code>operator++()</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>operator++(int)</code></td>
</tr>
<tr>
<td><code>iterator &amp;</code></td>
<td><code>operator+=(int j)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>operator-(int j) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>operator-(iterator other) const</code></td>
</tr>
<tr>
<td><code>iterator &amp;</code></td>
<td><code>operator--()</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>operator--(int)</code></td>
</tr>
<tr>
<td><code>iterator &amp;</code></td>
<td><code>operator-=(int j)</code></td>
</tr>
<tr>
<td><code>T *</code></td>
<td><code>operator-&gt;() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&lt;(const iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&lt;(const const_iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&lt;=(const iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&lt;=(const const_iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const const_iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&gt;(const iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&gt;(const const_iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&gt;=(const iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&gt;=(const const_iterator &amp; other) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>operator[](int j) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QList::iterator</code> class provides an <code>STL-style</code> <code>non-const</code> iterator for <code>QList</code> and <code>QQueue</code>.<br>&emsp;&emsp;<code>QList</code> features both <code>STL-style</code> iterators and <code>Java-style</code> iterators. The <code>STL-style</code> iterators are more <code>low-level</code> and more cumbersome to use; on the other hand, they are slightly faster and, for developers who already know <code>STL</code>, have the advantage of familiarity.<br>&emsp;&emsp;<code>QList&lt;T&gt;::iterator</code> allows you to iterate over a <code>QList&lt;T&gt;</code> (or <code>QQueue&lt;T&gt;</code>) and to modify the list item associated with the iterator. If you want to iterate over a const <code>QList</code>, use <code>QList::const_iterator</code> instead. It is generally good practice to use <code>QList::const_iterator</code> on a <code>non-const</code> <code>QList</code> as well, unless you need to change the <code>QList</code> through the iterator. Const iterators are slightly faster, and can improve code readability.<br>&emsp;&emsp;The default <code>QList::iterator</code> constructor creates an uninitialized iterator. You must initialize it using a <code>QList</code> function like <code>QList::begin()</code>, <code>QList::end()</code>, or <code>QList::insert()</code> before you can start iterating. Here’s a typical loop that prints all the items stored in a list:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span>.append ( <span class="string">"January"</span> );</span><br><span class="line"><span class="built_in">list</span>.append ( <span class="string">"February"</span> );</span><br><span class="line"><span class="built_in">list</span>.append ( <span class="string">"December"</span> );</span><br><span class="line">​</span><br><span class="line">QList&lt;QString&gt;::iterator i;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="built_in">list</span>.begin(); i != <span class="built_in">list</span>.end(); ++i ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Let’s see a few examples of things we can do with a <code>QList::iterator</code> that we cannot do with a <code>QList::const_iterator</code>. Here’s an example that increments every value stored in a <code>QList&lt;int&gt;</code> by <code>2</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="built_in">list</span>.begin(); i != <span class="built_in">list</span>.end(); ++i)</span><br><span class="line">    *i += <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Most <code>QList</code> functions accept an integer index rather than an iterator. For that reason, iterators are rarely useful in connection with <code>QList</code>. One place where <code>STL-style</code> iterators do make sense is as arguments to generic algorithms.<br>&emsp;&emsp;For example, here’s how to delete all the widgets stored in a <code>QList&lt;QWidget *&gt;</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QWidget *&gt; <span class="built_in">list</span>;​</span><br><span class="line">qDeleteAll ( <span class="built_in">list</span>.begin(), <span class="built_in">list</span>.end() );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Multiple iterators can be used on the same list. However, be aware that any <code>non-const</code> function call performed on the <code>QList</code> will render all existing iterators undefined. If you need to keep iterators over a long period of time, we recommend that you use <code>QLinkedList</code> rather than <code>QList</code>.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>iterator::iterator()</code>: Constructs an uninitialized iterator. Functions like <code>operator*()</code> and <code>operator++()</code> should not be called on an uninitialized iterator. Use <code>operator=()</code> to assign a value to it before using it.</li>
<li><code>iterator::iterator(const iterator &amp; other)</code>: Constructs a copy of <code>other</code>.</li>
<li><code>bool iterator::operator!=(const iterator &amp; other) const</code>: Returns <code>true</code> if <code>other</code> points to a different item than this iterator; otherwise returns <code>false</code>.</li>
<li><code>bool iterator::operator!=(const const_iterator &amp; other) const</code>:  Returns <code>true</code> if <code>other</code> points to a different item than this iterator; otherwise returns <code>false</code>.</li>
<li><code>T &amp; iterator::operator*() const</code>: Returns a modifiable reference to the current item. You can change the value of an item by using <code>operator*()</code> on the left side of an assignment, for example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *it == <span class="string">"Hello"</span> ) &#123;</span><br><span class="line">    *it = <span class="string">"Bonjour"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>iterator iterator::operator+(int j) const</code>: Returns an iterator to the item at <code>j</code> positions forward from this iterator (If <code>j</code> is negative, the iterator goes backward).</li>
<li><code>iterator &amp; iterator::operator++()</code>: The prefix <code>++</code> operator (<code>++it</code>) advances the iterator to the next item in the list and returns an iterator to the new current item. Calling this function on <code>QList::end()</code> leads to undefined results.</li>
<li><code>iterator iterator::operator++(int)</code>: This is an overloaded function. The postfix <code>++</code> operator (<code>it++</code>) advances the iterator to the next item in the list and returns an iterator to the previously current item.</li>
<li><code>iterator &amp; iterator::operator+=(int j)</code>: Advances the iterator by <code>j</code> items (If <code>j</code> is negative, the iterator goes backward).</li>
<li><code>iterator iterator::operator-(int j) const</code>: Returns an iterator to the item at <code>j</code> positions backward from this iterator (If <code>j</code> is negative, the iterator goes forward).</li>
<li><code>int iterator::operator-(iterator other) const</code>: Returns the number of items between the item pointed to by <code>other</code> and the item pointed to by this iterator.</li>
<li><code>iterator &amp; iterator::operator--()</code>: The prefix <code>--</code> operator (<code>--it</code>) makes the preceding item current and returns an iterator to the new current item. Calling this function on <code>QList::begin()</code> leads to undefined results.</li>
<li><code>iterator iterator::operator--(int)</code>: This is an overloaded function. The postfix <code>--</code> operator (<code>it--</code>) makes the preceding item current and returns an iterator to the previously current item.</li>
<li><code>iterator &amp; iterator::operator-=(int j)</code>: Makes the iterator go back by <code>j</code> items (If <code>j</code> is negative, the iterator goes forward).</li>
<li><code>T * iterator::operator-&gt;() const</code>: Returns a pointer to the current item.</li>
<li><code>bool iterator::operator&lt;(const iterator &amp; other) const</code>: Returns <code>true</code> if the item pointed to by this iterator is less than the item pointed to by the <code>other</code> iterator.</li>
<li><code>bool iterator::operator&lt;(const const_iterator &amp; other) const</code>: Returns <code>true</code> if the item pointed to by this iterator is less than the item pointed to by the <code>other</code> iterator.</li>
<li><code>bool iterator::operator&lt;=(const iterator &amp; other) const</code>: Returns <code>true</code> if the item pointed to by this iterator is less than or equal to the item pointed to by the <code>other</code> iterator.</li>
<li><code>bool iterator::operator&lt;=(const const_iterator &amp; other) const</code>: Returns <code>true</code> if the item pointed to by this iterator is less than or equal to the item pointed to by the <code>other</code> iterator.</li>
<li><code>bool iterator::operator==(const iterator &amp; other) const</code>: Returns true if <code>other</code> points to the same item as this iterator; otherwise returns <code>false</code>.</li>
<li><code>bool iterator::operator==(const const_iterator &amp; other) const</code>: Returns <code>true</code> if <code>other</code> points to the same item as this iterator; otherwise returns <code>false</code>.</li>
<li><code>bool iterator::operator&gt;(const iterator &amp; other) const</code>: Returns <code>true</code> if the item pointed to by this iterator is greater than the item pointed to by the <code>other</code> iterator.</li>
<li><code>bool iterator::operator&gt;(const const_iterator &amp; other) const</code>: Returns <code>true</code> if the item pointed to by this iterator is greater than the item pointed to by the <code>other</code> iterator.</li>
<li><code>bool iterator::operator&gt;=(const iterator &amp; other) const</code>: Returns <code>true</code> if the item pointed to by this iterator is greater than or equal to the item pointed to by the <code>other</code> iterator.</li>
<li><code>bool iterator::operator&gt;=(const const_iterator &amp; other) const</code>: Returns <code>true</code> if the item pointed to by this iterator is greater than or equal to the item pointed to by the <code>other</code> iterator.</li>
<li><code>T &amp; iterator::operator[](int j) const</code>: Returns a modifiable reference to the item at position <code>*this + j</code>. This function is provided to make <code>QList</code> iterators behave like <code>C++</code> pointers.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/24/Qt语法详解/Qt之QDir/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/24/Qt语法详解/Qt之QDir/" itemprop="url">Qt之QDir</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-24T19:36:49+08:00">
                2019-01-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;类<code>QDir</code>提供了对目录结构和其内容的访问方式。<code>QDir</code>用来操作路径名、访问关于路径和文件的信息、操作基础的文件系统，还可以用来访问<code>Qt</code>的资源系统。<br>&emsp;&emsp;<code>Qt</code>可以使用相对路径和绝对路径指向一个文件，<code>isRelative</code>和<code>isAbsolute</code>函数可以判断<code>QDir</code>对象使用的是相对路径还是绝对路径。将相对路径转换为绝对路径使用<code>makeAbsolute</code>函数。目录路径可以通过<code>path</code>函数返回，通过<code>setPath</code>函数设置新路径，绝对路径使用<code>absolutePath</code>返回。目录名可以使用<code>dirName</code>返回。目录的路径可以通过<code>cd</code>、<code>cdUp</code>改变，可以使<code>mkdir</code>创建目录，<code>rename</code>改变目录名。判断目录是否存在可以使用<code>exists</code>，目录的属性可以使用<code>isReadable</code>、<code>isAbsolute</code>、<code>isRelative</code>和<code>isRoot</code>。目录下有很多条目，包括文件、目录和符号链接，总的条目数可以使用<code>count</code>来统计。<code>entryList</code>可以返回目录下所有条目组成的字符串链表，文件可以使用<code>remove</code>函数删除，<code>rmdir</code>删除目录。在这里简单说一下几个类似的方法的区别：</p>
<ul>
<li><code>entryInfoList</code>与<code>entryList</code>：第一个函数会返回此文件加下所有文件及目录的完整信息，包括用户组、大小、访问时间、权限等等所有与文件有关的信息；而第二个方法只是返回此目录下的所有文件及目录的名字。</li>
<li><code>absoluteFilePath</code>与<code>absolutePath</code>：<code>absoluteFilePath</code>返回带本文件名的路径信息，<code>absolutePath</code>返回不带本文件名的路径信息。</li>
</ul>
<p>&emsp;&emsp;<code>Qt</code>使用<code>/</code>来作为通用的目录分隔符，这一点和在<code>URLs</code>中的路径分割符的用法一致。如果你使用<code>/</code>作为文件分隔符，<code>Qt</code>会自动地转换你的路径来匹配你的基础的操作系统。<br>&emsp;&emsp;绝对路径的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QDir ( <span class="string">"/home/user/Documents"</span> );</span><br><span class="line">QDir ( <span class="string">"C:/Documents and Settings"</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;相对路径的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QDir ( <span class="string">"images/landscape.png"</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;使用示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtCore&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    <span class="function">QDir <span class="title">mDir</span> <span class="params">( <span class="string">"D:/qttest"</span> )</span></span>; <span class="comment">/* 或者用“D:\\qttest”来代替 */</span></span><br><span class="line">    QDir nDir;</span><br><span class="line">    qDebug() &lt;&lt; mDir.exists(); <span class="comment">/* 测试路径是否存在 */</span></span><br><span class="line">    <span class="comment">/* 返回指定目录下指定文件的绝对路径 */</span></span><br><span class="line">    qDebug() &lt;&lt; mDir.absoluteFilePath ( <span class="string">"main.cpp"</span> );</span><br><span class="line">    qDebug() &lt;&lt; mDir.dirName(); <span class="comment">/* 剥离掉路径，只返回目录的名字 */</span></span><br><span class="line">    <span class="function">QFileInfo <span class="title">fi</span> <span class="params">( <span class="string">"C:/Documents and Settings/Administrator/pcmscan.cfg"</span> )</span></span>;</span><br><span class="line">    qDebug() &lt;&lt; fi.absoluteFilePath(); <span class="comment">/* 返回文件的绝对路径 */</span></span><br><span class="line">    qDebug() &lt;&lt; fi.filePath(); <span class="comment">/* 返回文件的路径 */</span></span><br><span class="line">    qDebug() &lt;&lt; fi.fileName(); <span class="comment">/* 剥离掉路径，只返回文件的名字 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* driver返回系统根目录下的目录列表 */</span></span><br><span class="line">    foreach ( QFileInfo mItem, nDir.drives() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; mItem.absolutePath();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* entryInfoList根据名字或属性顺序返回指定目录下所有的文件和目录的QFileInfo对象 */</span></span><br><span class="line">    foreach ( QFileInfo nItem, nDir.entryInfoList() ) &#123;</span><br><span class="line">        qDebug() &lt;&lt; nItem.absoluteFilePath();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    QString mPath = <span class="string">"D:/test/ZZZ"</span>;</span><br><span class="line">    QDir kDir;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( !kDir.exists ( mPath ) ) &#123; <span class="comment">/* 判断指定目录下是否存在指定目录 */</span></span><br><span class="line">        kDir.mkpath ( mPath ); <span class="comment">/* 生成指定目录 */</span></span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"Create"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"Already exits"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="string">"D:/qttest/main.cpp"</span></span><br><span class="line"><span class="string">"qttest"</span></span><br><span class="line"><span class="string">"C:/Documents and Settings/Administrator/pcmscan.cfg"</span></span><br><span class="line"><span class="string">"C:/Documents and Settings/Administrator/pcmscan.cfg"</span></span><br><span class="line"><span class="string">"pcmscan.cfg"</span></span><br><span class="line"><span class="string">"C:/"</span></span><br><span class="line"><span class="string">"D:/"</span></span><br><span class="line"><span class="string">"E:/"</span></span><br><span class="line"><span class="string">"F:/"</span></span><br><span class="line"><span class="string">"G:/"</span></span><br><span class="line"><span class="string">"H:/"</span></span><br><span class="line"><span class="string">"D:/qttest/QtDir-build-desktop"</span></span><br><span class="line"><span class="string">"D:/qttest"</span></span><br><span class="line"><span class="string">"D:/qttest/QtDir-build-desktop/debug"</span></span><br><span class="line"><span class="string">"D:/qttest/QtDir-build-desktop/Makefile"</span></span><br><span class="line"><span class="string">"D:/qttest/QtDir-build-desktop/Makefile.Debug"</span></span><br><span class="line"><span class="string">"D:/qttest/QtDir-build-desktop/Makefile.Release"</span></span><br><span class="line"><span class="string">"D:/qttest/QtDir-build-desktop/release"</span></span><br><span class="line">Already exits</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><code>QString QDir::homePath() [static]</code>: Returns the absolute path of the user’s home directory. Under <code>Windows</code>, this function will return the directory of the current user’s profile. Typically, this is:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:/Documents <span class="keyword">and</span> Settings/Username</span><br></pre></td></tr></table></figure>
<p>Use the <code>toNativeSeparators()</code> function to convert the separators to the ones that are appropriate for the underlying operating system.<br>&emsp;&emsp;If the directory of the current user’s profile does not exist or cannot be retrieved, the following alternatives will be checked (in the given order) until an existing and available path is found:</p>
<ul>
<li>The path specified by the <code>USERPROFILE</code> environment variable.</li>
<li>The path formed by concatenating the <code>HOMEDRIVE</code> and <code>HOMEPATH</code> environment variables.</li>
<li>The path specified by the <code>HOME</code> environment variable.</li>
<li>The path returned by the <code>rootPath()</code> function (which uses the <code>SystemDrive</code> environment variable)</li>
<li>The <code>C:/</code> directory.</li>
</ul>
<p>Under <code>non-Windows</code> operating systems the <code>HOME</code> environment variable is used if it exists, otherwise the path returned by the <code>rootPath()</code>.</p>
<ul>
<li><code>QString QDir::rootPath() [static]</code>: Returns the absolute path of the root directory. For <code>Unix</code> operating systems, this returns <code>/</code>. For <code>Windows</code>, this normally returns <code>c:/</code>. I.E. the root of the system drive.</li>
<li><code>QString QDir::tempPath()</code>: Returns the absolute path of the system’s temporary directory. On <code>Unix/Linux</code> systems, this is the path in the <code>TMPDIR</code> environment variable or <code>/tmp</code> if <code>TMPDIR</code> is not defined. On <code>Windows</code>, this is usually the path in the <code>TEMP</code> or <code>TMP</code> environment variable. Whether a directory separator is added to the end or not, depends on the operating system.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/24/Qt语法详解/Qt之QProcess/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/24/Qt语法详解/Qt之QProcess/" itemprop="url">Qt之QProcess</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-24T16:31:18+08:00">
                2019-01-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="QProcess进程类"><a href="#QProcess进程类" class="headerlink" title="QProcess进程类"></a>QProcess进程类</h3><p>&emsp;&emsp;<code>Qt</code>提供了<code>QProcess</code>类用于启动外部程序并与之通信。启动一个新的进程的操作非常简单，只需要将待启动的程序名称和启动参数传递给<code>start</code>函数即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QObject *parent;</span><br><span class="line">QString program = <span class="string">"tar"</span>;</span><br><span class="line">QStringList arguments;</span><br><span class="line">arguments &lt;&lt; <span class="string">"czvf"</span> &lt;&lt; <span class="string">"backup.tar.gz"</span> &lt;&lt; <span class="string">"/home"</span>;</span><br><span class="line">QProcess *myProcess = <span class="keyword">new</span> QProcess ( parent );</span><br><span class="line">QProcess-&gt;start ( program, arguments );</span><br></pre></td></tr></table></figure>
<p>当调用<code>start</code>函数后，<code>myProcess</code>进程立即进入启动状态，但<code>tar</code>程序尚未被调用，不能读写标准输入输出设备。当进程完成启动后就进入<code>运行状态</code>，并向外发出<code>started</code>信号。<br>&emsp;&emsp;在输入输出方面，<code>QProcess</code>将一个进程看做一个流类型的<code>I/O</code>设备，可以像使用<code>QTcpSocket</code>读写流类型的网络连接一样来读写一个进程。可以通过<code>QIODevice::write</code>函数向所启动进程的标准输入写数据，也可以通过<code>QIODevice::read</code>、<code>QIODevice::readLine</code>和<code>QIODevice::getChar</code>函数从这个进程的标准输出读数据。由于<code>QProcess</code>是从<code>QIODevice</code>类继承而来的，因此它也可以作<code>QXmlReader</code>的数据来源，或者为<code>QFtp</code>产生上传数据。最后当进程退出时，<code>QProcess</code>进入起始状态(即<code>非运行状态</code>)，并发出<code>finished</code>信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span> <span class="params">( <span class="keyword">int</span> exitCode, QProcess::ExitStatus exitStatus )</span></span>;</span><br></pre></td></tr></table></figure>
<p>信号在参数中返回了进程退出的退出码和退出状态，可以调用<code>exitCode</code>函数和<code>exitStatus</code>函数分别获取最后退出进程的这两个值。<code>Qt</code>定义的进程<code>退出状态</code>只有正常退出和进程崩溃两种，分别对应值<code>QProcess::NormalExit</code>(值为<code>0</code>)和<code>QProcess::CrashExit</code>(值为<code>1</code>)。当进程在运行中产生错误时，<code>QProcess</code>将发出<code>error</code>信号，可以通过调用<code>error</code>函数返回最后一次产生错误的类型，并通过<code>state</code>找出此时进程所处的状态。<code>Qt</code>定义了如下的进程错误代码：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>错误常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QProcess::FailedToStart</code></td>
<td><code>0</code></td>
<td>进程启动失败</td>
</tr>
<tr>
<td><code>QProcess::Crashed</code></td>
<td><code>1</code></td>
<td>进程成功启动后崩溃</td>
</tr>
<tr>
<td><code>QProcess::Timedout</code></td>
<td><code>2</code></td>
<td>最后一次调用<code>waitFor</code>函数超时，此时<code>QProcess</code>状态不变，并可以再次调用<code>waitFor</code>类型的函数</td>
</tr>
<tr>
<td><code>QProcess::WriteError</code></td>
<td><code>3</code></td>
<td>向进程写入时出错，例如进程尚未启动或者输入通道被关闭时</td>
</tr>
<tr>
<td><code>QProcess::ReadError</code></td>
<td><code>4</code></td>
<td>从进程中读取数据时出错，例如进程尚未启动时</td>
</tr>
<tr>
<td><code>QProcess::UnknownError</code></td>
<td><code>5</code></td>
<td>未知错误，这也是<code>error</code>函数返回的默认值</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;可以通过调用<code>setReadChanned</code>函数设置当前的读通道，当有可读数据时，<code>Qt</code>将发出<code>readyRead</code>信号；如果是从标准输出和标准错误通道中读取数据，还会发出<code>readyReadStandardOutput</code>信号；如果是从标准错误读取，也会发出<code>readyReadStandardError</code>信号。<code>readAllStandardOutput</code>函数从标准输出通道中读取数据，<code>readAllStandardErrot</code>函数从标准错误通道中读取数据。在进程启动以前，以<code>MergedChannels</code>为参数调用<code>setReadChannelMode</code>函数，可以把标准输出通道和标准输错误通道合并。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QProcess&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    QProcess proc;</span><br><span class="line">    QStringList arguments;</span><br><span class="line">    arguments &lt;&lt; <span class="string">"-na"</span>;</span><br><span class="line">    proc.start ( <span class="string">"netstat"</span>, arguments );</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 等待进程启动 */</span></span><br><span class="line">    <span class="keyword">if</span> ( !proc.waitForStarted() ) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"启动失败\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    proc.closeWriteChannel(); <span class="comment">/* 关闭写通道，因为没有向进程写数据 */</span></span><br><span class="line">    QByteArray procOutput; <span class="comment">/* 用于保存进程的控制台输出 */</span></span><br><span class="line">​</span><br><span class="line">    <span class="comment">/* 等待进程结束 */</span></span><br><span class="line">    <span class="keyword">while</span> ( <span class="literal">false</span> == proc.waitForFinished() ) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"结束失败\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    procOutput = proc.readAll(); <span class="comment">/* 读取进程输出到控制台的数据 */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; procOutput.data() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">/* 输出读到的数据 */</span></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS; <span class="comment">/* 返回EXIT_SUCCESS */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Qt之进程间交互"><a href="#Qt之进程间交互" class="headerlink" title="Qt之进程间交互"></a>Qt之进程间交互</h3><p>&emsp;&emsp;<code>mainwindow.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOW_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtGui&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MainWindow ( QWidget *parent = <span class="number">0</span> );</span><br><span class="line">    ~MainWindow();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">openProcess</span><span class="params">()</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QProcess *p;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mainwindow.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line">​</span><br><span class="line">MainWindow::MainWindow ( QWidget *parent ) : QMainWindow ( parent ) &#123;</span><br><span class="line">    p = <span class="keyword">new</span> QProcess ( <span class="keyword">this</span> );</span><br><span class="line">    QPushButton *bt = <span class="keyword">new</span> QPushButton ( <span class="string">"execute notepad"</span>, <span class="keyword">this</span> );</span><br><span class="line">    connect ( bt, SIGNAL ( clicked() ), <span class="keyword">this</span>, SLOT ( openProcess() ) );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">MainWindow::~MainWindow() &#123;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MainWindow::openProcess() &#123;</span><br><span class="line">    p-&gt;start ( <span class="string">"notepad.exe"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个窗口只有一个按钮，当你点击按钮之后，程序会调用<code>Windows</code>的记事本。<code>QProcess::start</code>接收两个参数，第一个是要执行的命令或者程序，这里就是<code>notepad.exe</code>；第二个是<code>QStringList</code>类型的数据，也就是需要传递给这个程序的运行参数。注意，这个程序能够被系统找到。<br>&emsp;&emsp;调用一个系统命令，这里使用的是<code>Windows</code>，因此需要调用<code>dir</code>；如果你是在<code>Linux</code>进行编译，就需要改成<code>ls</code>。<br>&emsp;&emsp;<code>mainwindow.h</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOW_H</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtGui&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MainWindow ( QWidget *parent = <span class="number">0</span> );</span><br><span class="line">    ~MainWindow();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">openProcess</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readResult</span> <span class="params">( <span class="keyword">int</span> exitCode )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QProcess *p;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mainwindow.cpp</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line">​</span><br><span class="line">MainWindow::MainWindow ( QWidget *parent ) : QMainWindow ( parent ) &#123;</span><br><span class="line">    p = <span class="keyword">new</span> QProcess ( <span class="keyword">this</span> );</span><br><span class="line">    QPushButton *bt = <span class="keyword">new</span> QPushButton ( <span class="string">"execute notepad"</span>, <span class="keyword">this</span> );</span><br><span class="line">    connect ( bt, SIGNAL ( clicked() ), <span class="keyword">this</span>, SLOT ( openProcess() ) );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">MainWindow::~MainWindow() &#123;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MainWindow::openProcess() &#123;</span><br><span class="line">    p-&gt;start ( <span class="string">"cmd.exe"</span>, QStringList() &lt;&lt; <span class="string">"/c"</span> &lt;&lt; <span class="string">"dir"</span> );</span><br><span class="line">    connect ( p, SIGNAL ( finished ( <span class="keyword">int</span> ) ), <span class="keyword">this</span>, SLOT ( readResult ( <span class="keyword">int</span> ) ) );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MainWindow::readResult ( <span class="keyword">int</span> exitCode ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( exitCode == <span class="number">0</span> ) &#123;</span><br><span class="line">        QTextCodec *gbkCodec = QTextCodec::codecForName ( <span class="string">"GBK"</span> );</span><br><span class="line">        QString result = gbkCodec-&gt;toUnicode ( p-&gt;readAll() );</span><br><span class="line">        QMessageBox::information ( <span class="keyword">this</span>, <span class="string">"dir"</span>, result );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在按钮点击的<code>slot</code>函数中，通过<code>QProcess::start</code>函数运行了指令<code>cmd.exe /c dir</code>，意思是打开系统的<code>cmd</code>程序，然后运行<code>dir</code>指令。然后将<code>process</code>的<code>finished</code>信号连接到新增加的<code>slot</code>函数。<code>signal</code>函数有一个<code>int</code>型参数，我们知道，对于<code>C/C++</code>程序而言，<code>main</code>函数总是返回一个<code>int</code>，也就是退出代码，用于指示程序是否正常退出，这里的<code>int</code>参数就是这个退出代码。<code>slot</code>函数首先检查退出代码是否为<code>0</code>，如果退出代码为<code>0</code>，说明是正常退出。然后把结果显示在<code>QMessageBox</code>中。<code>QProcess::readAll</code>函数可以读出程序输出内容，由于它的返回结果是<code>QByteArray</code>型，所以再转换成<code>QString</code>显示出来。中文版<code>Windows</code>使用的是<code>GBK</code>编码，而<code>Qt</code>使用的是<code>Unicode</code>编码，因此需要做一下转换，否则会出现乱码。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/24/Qt语法详解/Qt开发注意事项/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/24/Qt语法详解/Qt开发注意事项/" itemprop="url">Qt开发注意事项</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-24T16:12:55+08:00">
                2019-01-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>如果出现<code>&#39;tr&#39; was not declared in this scope</code>的问题，将<code>tr</code>替换为<code>QObject::tr</code>即可。</li>
<li><code>Qt</code>设置控件随窗口大小变化的方法：拖一个控件到窗体上(任何控件都可以)；在窗体空白处<code>右键 -&gt; 布局 -&gt; 栅格布局</code>即可。</li>
<li>显示的界面其父类要么统一为<code>QWidget</code>，要么统一为<code>QDialog</code>，如果混用的话，会出现界面混乱的<code>BUG</code>。</li>
<li>新版<code>Qt Designer</code>查看窗体代码的地方是<code>窗体 -&gt; 查看代码</code>。</li>
<li><code>Qt::QSplashScreen</code>是欢迎窗口类型，通常用于制作软件的启动动画；<code>Qt::Dialog</code>则是对话框类型。</li>
<li><code>Qt</code>包含路径信息的代码应该用<code>/</code>符号，例如<code>C:/logo.png</code>。</li>
<li>对于<code>QLineEdit</code>中的验证器，只有输入行被正确地输入时才能触发相应的槽。</li>
<li>如果出现<code>Qt</code>工程打不开的情况，可以尝试把后缀名为<code>.pro.user</code>的文件删除掉，然后再打开工程。</li>
<li>如果<code>Qt Creator</code>中的源文件或头文件出现乱码的情况，可以将文件的编码格式转换为<code>System</code>。</li>
<li>如果出现窗口拒绝拖拽打开文件的情况，可以在窗口的构造函数中加入代码<code>setAcceptDrops(true);</code>。</li>
<li><code>Qt</code>界面类(例如<code>Dialog</code>和<code>widget</code>)的变量不能定义为全局变量，否则会出现重大<code>BUG</code>。</li>
<li><code>connect</code>函数的参数分别为信号发射的对象、发射的信号、接收信号的对象、对信号进行处理的槽。发射信号的对象和信号是在同一个类中，接收信号的对象和槽是在同一个类中，这两个类也可以是同一个类。</li>
<li><code>connect</code>函数中信号的参数和槽的参数是一一对应的，即信号会把自己的参数传递给槽的参数。</li>
<li><code>qDebug</code>函数无法直接输出<code>string</code>类型的变量，但可以输出<code>QString</code>类型的变量。如果需要输出<code>string</code>变量，则需要在其后面加上<code>.c_str()</code>。</li>
<li><code>QString</code>类型的数据不是以<code>\0</code>结尾的，这要和<code>C</code>语言的字符串进行区分，访问<code>QString</code>中的单个字符使用<code>at</code>函数。</li>
<li>在<code>Qt</code>中使用图片时，最好将图片添加到资源文件中，这样可以避免由于图片路径的错误而带来的麻烦。使用资源文件中的图片的方法是<code>:图片的资源文件路径</code>。</li>
<li><code>Qt</code>判断字符串是否为空应该使用成员函数<code>isEmpty()</code>，而不应该用<code>null</code>。</li>
<li>Qt的<code>find</code>函数返回的迭代器的类型为<code>const_iterator</code>，因此要将相应的迭代器变量设置为<code>const_iterator</code>型。</li>
<li>当使用<code>Qt</code>的网络功能时，需要在<code>.pro</code>文件中增加语句<code>QT += network</code>。</li>
<li>关于<code>Qt</code>中<code>emit</code>的作用：在程序中应该能找到类似这样的语句<code>connect ( obj, SIGNAL ( changeCurrentShape ( * ) ), anotherobj, SLOG ( FUN ( * ) ) );</code>，当执行到<code>emit changeCurrentShape(Shape::Triangle)</code>时，<code>Qt</code>的信号槽机制会自动触发<code>FUN</code>函数。</li>
<li>如果需要为窗口上的控件设置加速键，例如按住<code>Alt + N</code>即可跳到某个控件上，可以类似这样做：<code>pushbotton-&gt;setText(tr(&quot;&amp;nihao&quot;));</code>是设置<code>Alt + N</code>为加速键。如果需要在控件上显示<code>&amp;</code>，需要使用<code>&amp;&amp;</code>。</li>
<li><code>Qt::CaseSensitivity</code>为枚举类型，可取值<code>Qt::CaseSensitive</code>(大小写敏感)和<code>Qt::CaseInsensitive</code>(大小写不敏感)，表示匹配的灵敏度。</li>
<li>在<code>Qt</code>中，窗口的标题可以随时被改变，要使用<code>setWindowTitle</code>函数。</li>
<li><code>Qt</code>的<code>setGeometry (9, 9, 50, 25)</code>四个参数是指从屏幕上<code>(9,9)</code>位置开始(即为最左上角的点)，显示一个<code>50 * 25</code>的界面(宽<code>50</code>，高<code>25</code>)。</li>
<li><code>Qt</code>中的<code>void QApplication::beep () [static]</code>可以让系统发出蜂鸣声，但是该操作目前不支持嵌入式<code>linux</code>。</li>
<li>在<code>ui</code>上迅速设置槽函数的方法：在控件上右击，选择<code>转到槽</code>，再点击相应的时间，即可在相应的文件中增加其槽函数。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/24/Qt语法详解/Qt之QHostAddress/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/24/Qt语法详解/Qt之QHostAddress/" itemprop="url">Qt之QHostAddress</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-24T14:57:19+08:00">
                2019-01-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>&emsp;&emsp;<code>QHostAddress</code>类提供一个<code>IP</code>地址。这个类提供一种独立于平台和协议的方式来保存<code>IPv4</code>和<code>IPv6</code>地址。<code>QHostAddress</code>通常与<code>QTcpSocket</code>、QTcpServer、QUdpSocket一起使用，来连接到主机或建立一个服务器。<br>&emsp;&emsp;可以通过<code>setAddress</code>来设置一个主机地址，使用<code>toIPv4Address</code>、<code>toIPv6Address</code>或<code>toString</code>来检索主机地址，你可以通过<code>protocol</code>来检查协议类型。注意，<code>QHostAddress</code>不做<code>DNS</code>查询，而<code>QHostInfo</code>是有必要的。这个类还支持通用的预定义地址：<code>Null</code>、<code>LocalHost</code>、<code>LocalHostIPv6</code>、<code>Broadcast</code>和<code>Any</code>。</p>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><p>&emsp;&emsp;枚举变量为<code>QHostAddress::SpecialAddress</code>，取值范围如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QHostAddress::Null</code></td>
<td><code>0</code></td>
<td>空地址对象，相当于<code>QHostAddress</code></td>
</tr>
<tr>
<td><code>QHostAddress::LocalHost</code></td>
<td><code>2</code></td>
<td><code>IPv4</code>本地主机地址，相当于<code>QHostAddress(&quot;127.0.0.1&quot;)</code></td>
</tr>
<tr>
<td><code>QHostAddress::LocalHostIPv6</code></td>
<td><code>3</code></td>
<td><code>IPv6</code>本地主机地址，相当于<code>QHostAddress(&quot;::1&quot;)</code></td>
</tr>
<tr>
<td><code>QHostAddress::Broadcast</code></td>
<td><code>1</code></td>
<td><code>Pv4</code>广播地址，相当于<code>QHostAddress(&quot;255.255.255.255&quot;)</code></td>
</tr>
<tr>
<td><code>QHostAddress::AnyIPv4</code></td>
<td><code>6</code></td>
<td>意思是<code>IPv4 any-address</code>，相当于<code>QHostAddress(&quot;0.0.0.0&quot;)</code>，与该地址绑定的<code>socket</code>将只监听<code>IPv4</code>接口</td>
</tr>
<tr>
<td><code>QHostAddress::AnyIPv6</code></td>
<td><code>5</code></td>
<td>意思是<code>IPv6 any-address</code>，相当于<code>QHostAddress(&quot;::&quot;)</code>，与该地址绑定的<code>socket</code>将只监听<code>IPv6</code>接口</td>
</tr>
<tr>
<td><code>QHostAddress::Any</code></td>
<td><code>4</code></td>
<td>双<code>any-address</code>栈，与该地址绑定的<code>socket</code>将侦听<code>IPv4</code>和<code>IPv6</code>接口</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>bool isLoopback() const</code>：如果地址是<code>IPv6</code>的环回地址，或者<code>IPv4</code>的环回地址，则返回<code>true</code>。</li>
<li><code>bool isNull() const</code>：如果主机地址为空(<code>INADDR_ANY</code>或<code>in6addr_any</code>)，返回<code>true</code>。默认的构造函数创建一个空的地址，这个地址对于任何主机或接口是无效的。</li>
<li><code>QAbstractSocket::NetworkLayerProtocol protocol() const</code>：返回主机地址的网络层协议。</li>
<li><code>QString scopeId() const</code>：返回<code>IPv6</code>地址的范围<code>ID</code>。对于<code>IPv4</code>地址，如果该地址不包含范围<code>ID</code>，则返回一个空字符串。</li>
</ul>
<p>&emsp;&emsp;<code>IPv6</code>的范围<code>ID</code>指定非全球<code>IPv6</code>地址范围的可达性，限制地址可以被使用的区域。所有<code>IPv6</code>地址与这种可达范围相关联。范围<code>ID</code>用于消除那些不能保证是全局唯一性的地址。<br>&emsp;&emsp;当使用<code>链路本地</code>或<code>本地站点</code>地址的<code>IPv6</code>连接，必须指定范围<code>ID</code>。对<code>链路本地</code>地址来说，范围<code>ID</code>通常与接口名称(例如<code>eth0</code>、<code>en1</code>)或者数目(例如<code>1</code>、<code>2</code>)相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">quint32 <span class="title">toIPv4Address</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">quint32 <span class="title">toIPv4Address</span> <span class="params">( <span class="keyword">bool</span> *ok )</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<p>返回<code>IPv4</code>地址为一个数字。如果地址是<code>127.0.0.1</code>，返回值为<code>2130706433</code>(即<code>0x7f000001</code>)。如果<code>protocol</code>是<code>IPv4Protocol</code>，该值是有效的；如果是<code>IPv6Protocol</code>，并且<code>IPv6</code>地址是一个<code>IPv4</code>映射的地址，在这种情况下，<code>ok</code>将被设置为<code>true</code>，否则它将被设置为<code>false</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Q_IPV6ADDR <span class="title">toIPv6Address</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<p>返回的<code>IPv6</code>地址为<code>Q_IPV6ADDR</code>结构，该结构由<code>16</code>位无符号字符组成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Q_IPV6ADDR addr = hostAddr.toIPv6Address(); <span class="comment">/* 该地址包含16位无符号字符 */</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i ) &#123;</span><br><span class="line">    <span class="comment">/* 处理addr[i] */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>protocol</code>是<code>IPv6Protocol</code>，该值是有效的；如果是<code>IPv4Protocol</code>，返回地址将是<code>IPv4</code>地址映射的<code>IPv6</code>地址。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>&emsp;&emsp;简单应用：构造一个<code>QHostAddress</code>，通过<code>toString</code>来获取对应的<code>IP</code>地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QHostAddress address = QHostAddress ( QHostAddress::LocalHost );</span><br><span class="line">QString strIPAddress = address.toString();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取所有主机地址：<code>QNetworkInterface</code>类中提供了一个静态函数<code>allAddresses</code>，用于返回一个<code>QHostAddress</code>主机地址列表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QHostAddress&gt; <span class="built_in">list</span> = QNetworkInterface::allAddresses();</span><br><span class="line">​</span><br><span class="line">foreach ( QHostAddress address, <span class="built_in">list</span> ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( address.isNull() ) &#123; <span class="comment">/* 主机地址为空 */</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    QAbstractSocket::NetworkLayerProtocol nProtocol = address.protocol();</span><br><span class="line">    QString strScopeId = address.scopeId();</span><br><span class="line">    QString strAddress = address.toString();</span><br><span class="line">    <span class="keyword">bool</span> bLoopback = address.isLoopback();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( nProtocol == QAbstractSocket::IPv4Protocol ) &#123; <span class="comment">/* 如果是IPv4 */</span></span><br><span class="line">        <span class="keyword">bool</span> bOk = <span class="literal">false</span>;</span><br><span class="line">        quint32 nIPV4 = address.toIPv4Address ( &amp;bOk );</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> ( bOk ) &#123;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">"IPV4 : "</span> &lt;&lt; nIPV4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( nProtocol == QAbstractSocket::IPv6Protocol ) &#123; <span class="comment">/* 如果是IPv6 */</span></span><br><span class="line">        QStringList IPV6List ( <span class="string">""</span> );</span><br><span class="line">        Q_IPV6ADDR IPV6 = address.toIPv6Address();</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i ) &#123;</span><br><span class="line">            quint8 nC = IPV6[i];</span><br><span class="line">            IPV6List &lt;&lt; QString::number ( nC );</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"IPV6: "</span> &lt;&lt; IPV6List.join ( <span class="string">" "</span> );</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"Protocol: "</span> &lt;&lt; nProtocol;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"ScopeId: "</span> &lt;&lt; strScopeId;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"Address: "</span> &lt;&lt; strAddress;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"IsLoopback: "</span> &lt;&lt; bLoopback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">IPV6: <span class="string">" 254 128 0 0 0 0 0 0 89 150 39 163 131 181 42 231"</span></span><br><span class="line">Protocol: QAbstractSocket::NetworkLayerProtocol(IPv6Protocol)</span><br><span class="line">ScopeId: <span class="string">"18"</span></span><br><span class="line">Address: <span class="string">"fe80::5996:27a3:83b5:2ae7%18"</span></span><br><span class="line">IsLoopback: <span class="literal">false</span></span><br><span class="line">​</span><br><span class="line">IPV4: <span class="number">3232249857</span></span><br><span class="line">Protocol: QAbstractSocket::NetworkLayerProtocol(IPv4Protocol)</span><br><span class="line">ScopeId: <span class="string">""</span></span><br><span class="line">Address: <span class="string">"192.168.56.1"</span></span><br><span class="line">IsLoopback: <span class="literal">false</span></span><br><span class="line">​</span><br><span class="line">IPV6: <span class="string">" 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1"</span></span><br><span class="line">Protocol: QAbstractSocket::NetworkLayerProtocol(IPv6Protocol)</span><br><span class="line">ScopeId: <span class="string">""</span></span><br><span class="line">Address: <span class="string">"::1"</span></span><br><span class="line">IsLoopback: <span class="literal">true</span></span><br><span class="line">​</span><br><span class="line">IPV4: <span class="number">2130706433</span></span><br><span class="line">Protocol: QAbstractSocket::NetworkLayerProtocol(IPv4Protocol)</span><br><span class="line">ScopeId: <span class="string">""</span></span><br><span class="line">Address: <span class="string">"127.0.0.1"</span></span><br><span class="line">IsLoopback: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>&emsp;&emsp;例如限制本地链路地址范围为<code>169.254.1.0</code>至<code>169.254.254.255</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLinkLocalAddress</span> <span class="params">( QHostAddress addr )</span> </span>&#123;</span><br><span class="line">    quint32 nIPv4 = addr.toIPv4Address();</span><br><span class="line">    quint32 nMinRange = QHostAddress ( <span class="string">"169.254.1.0"</span> ).toIPv4Address();</span><br><span class="line">    quint32 nMaxRange = QHostAddress ( <span class="string">"169.254.254.255"</span> ).toIPv4Address();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( nIPv4 &gt;= nMinRange ) &amp;&amp; ( nIPv4 &lt;= nMaxRange ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/46/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/46/">46</a><span class="page-number current">47</span><a class="page-number" href="/page/48/">48</a><span class="space">&hellip;</span><a class="page-number" href="/page/94/">94</a><a class="extend next" rel="next" href="/page/48/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">934</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
