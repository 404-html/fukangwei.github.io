<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="泥腿子出身">
<meta property="og:url" content="http://fukangwei.gitee.io/page/47/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="泥腿子出身">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/page/47/">





  <title>泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/27/Qt语法详解/QT信号和槽的原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/27/Qt语法详解/QT信号和槽的原理/" itemprop="url">QT信号和槽的原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T18:19:25+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;信号(<code>SIGNAL</code>)和槽(<code>SLOT</code>)是<code>Qt</code>编程的一个重要部分。这个机制可以在对象之间彼此并不了解的情况下将它们的行为联系起来。<br>&emsp;&emsp;槽和普通的<code>C++</code>成员函数很像，它可以像任何<code>C++</code>成员函数一样被调用，可以传递任何类型的参数。不同之处在于一个槽函数能和一个信号相连接，只要信号发出了，这个槽函数就会自动被调用，这个任务是由<code>connect</code>函数来实现的。<br>&emsp;&emsp;<code>connect</code>函数语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect ( sender, SIGNAL ( signal ), receiver, SLOT ( slot ) );</span><br></pre></td></tr></table></figure>
<p><code>sender</code>和<code>receiver</code>是<code>QObject</code>对象指针，<code>signal</code>和<code>slot</code>是不带参数的函数原型。宏<code>SIGNAL</code>和<code>SLOT</code>的作用是把它们转换成字符串。<br>&emsp;&emsp;信号和槽的一些使用规则如下：</p>
<ul>
<li>一个信号可以连接到多个槽，当信号发出后，槽函数都会被调用，但是调用的顺序是随机的、不确定的：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connect ( slider, SIGNAL ( valueChanged ( <span class="keyword">int</span> ) ), \</span><br><span class="line">          spinBox, SLOT ( setValue ( <span class="keyword">int</span> ) ) );</span><br><span class="line">connect ( slider, SIGNAL ( valueChanged ( <span class="keyword">int</span> ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SLOT ( updateStatusBarIndicator ( <span class="keyword">int</span> ) ) );</span><br></pre></td></tr></table></figure>
<ul>
<li>多个信号可以连接到一个槽，任何一个信号发出，槽函数都会执行：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect ( lcd, SIGNAL ( overflow() ), <span class="keyword">this</span>, SLOT ( handleMathError() ) );</span><br><span class="line">connect ( calculator, SIGNAL ( divisionByZero() ), <span class="keyword">this</span>, SLOT ( handleMathError() ) );</span><br></pre></td></tr></table></figure>
<ul>
<li>一个信号可以和另一个信号相连，第一个信号发出后，第二个信号也同时发送：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect ( lineEdit, SIGNAL ( textChanged ( <span class="keyword">const</span> QString &amp; ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SIGNAL ( updateRecord ( <span class="keyword">const</span> QString &amp; ) ) );</span><br></pre></td></tr></table></figure>
<ul>
<li>连接可以被删除，这个函数很少使用，一个对象删除后，<code>Qt</code>自动删除这个对象的所有连接：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disconnect ( lcd, SIGNAL ( overflow() ), <span class="keyword">this</span>, SLOT ( handleMathError() ) );</span><br></pre></td></tr></table></figure>
<ul>
<li>信号和槽函数必须有着相同的参数类型，这样信号和槽函数才能成功连接：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect ( ftp, SIGNAL ( rawCommandReply ( <span class="keyword">int</span>, <span class="keyword">const</span> QString &amp; ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SLOT ( processReply ( <span class="keyword">int</span>, <span class="keyword">const</span> QString &amp; ) ) );</span><br></pre></td></tr></table></figure>
<ul>
<li>如果信号里的参数个数多于槽函数的参数，多余的参数被忽略：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect ( ftp, SIGNAL ( rawCommandReply ( <span class="keyword">int</span>, <span class="keyword">const</span> QString &amp; ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SLOT ( checkErrorCode ( <span class="keyword">int</span> ) ) );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;大多数情况下使用控件的信号和槽，实际上信号和槽机制在<code>QObject</code>中就实现了，也可以实现在任何从<code>QObject</code>继承的子类中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Employee() &#123;</span><br><span class="line">        mySalary = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">salary</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mySalary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSalary</span> <span class="params">( <span class="keyword">int</span> newSalary )</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">salaryChanged</span> <span class="params">( <span class="keyword">int</span> newSalary )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mySalary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Employee::setSalary ( <span class="keyword">int</span> newSalary ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( newSalary != mySalary ) &#123;</span><br><span class="line">        mySalary = newSalary;</span><br><span class="line">        <span class="function">emit <span class="title">salaryChanged</span> <span class="params">( mySalary )</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，只有<code>newSalary != mySalary</code>时才发出<code>salaryChanged</code>信号，这样避免了死循环的出现。</p>
<hr>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;信号和槽是一种高级接口，应用于对象之间的通信，它是<code>QT</code>的核心特性。它独立于标准的<code>C/C++</code>语言，因此要正确的处理信号和槽，必须借助一个称为<code>moc(Meta Object Compiler)</code>的<code>QT</code>工具，该工具是一个<code>C++</code>预处理程序，它为高层次的事件处理自动生成所需要的附加代码。<br>&emsp;&emsp;在我们所熟知的很多<code>GUI</code>工具包中，窗口小部件(<code>widget</code>)都有一个回调函数用于响应它们能触发的每个动作，这个回调函数通常是一个指向某个函数的指针。但是<code>QT</code>的信号和槽取代了这些凌乱的函数指针，使得编写这些通信程序更为简单。<br>&emsp;&emsp;所有从<code>QObject</code>或其子类(例如<code>Qwidget</code>)派生的类都能够包含信号和槽。当对象改变其状态时，信号就由该对象发射(<code>emit</code>)出去，这就是对象所要做的全部事情，它不知道另一端是谁在接收这个信号。这就是真正的信息封装，它确保对象被当作一个真正的软件组件来使用。槽用于接收信号，但它们是普通的对象成员函数。一个槽并不知道是否有任何信号与自己相连接。，而且对象并不了解具体的通信机制。<br>&emsp;&emsp;你可以将很多信号与单个的槽进行连接，也可以将单个的信号与很多的槽进行连接，甚至于将一个信号与另外一个信号相连接也是可能的，这时无论第一个信号什么时候发射，系统都将立刻发射第二个信号。总之，信号与槽构造了一个强大的部件编程机制。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>&emsp;&emsp;当某个信号对其客户或所有者的内部状态发生改变时，信号就会被一个对象发射，只有定义过这个信号的类及其派生类才能够发射这个信号。当一个信号被发射时，与其相关联的槽将被立刻执行，就像一个正常的函数调用一样。<code>信号-槽</code>机制完全独立于任何<code>GUI</code>事件循环。只有当所有的槽返回以后，发射函数(<code>emit</code>)才返回。如果存在多个槽与某个信号相关联，那么当这个信号被发射时，这些槽将会一个接一个地执行，但是它们执行的顺序将会是随机的、不确定的。<br>&emsp;&emsp;信号的声明是在头文件中进行的，<code>QT</code>的<code>signals</code>关键字指出进入了信号声明区，随后即可声明自己的信号。例如下面定义了三个信号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignal</span> <span class="params">( <span class="keyword">int</span> x )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignalParam</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y )</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中<code>signals</code>是<code>QT</code>的关键字，<code>void mySignal()</code>定义了信号<code>mySignal</code>，这个信号没有携带参数；<code>void mySignal(int x)</code>定义了重名信号<code>mySignal</code>，但是它携带一个整型参数，有点类似于<code>C++</code>中的重载函数。从形式上，信号的声明与普通的<code>C++</code>函数是一样的，但是信号却没有函数体定义。另外，信号的返回类型都是<code>void</code>，不要指望能从信号返回什么有用信息。信号由<code>moc</code>自动产生，它们不应该在<code>.cpp</code>文件中实现。</p>
<h3 id="槽"><a href="#槽" class="headerlink" title="槽"></a>槽</h3><p>&emsp;&emsp;槽是普通的<code>C++</code>成员函数，可以被正常调用，它们唯一的特殊性就是很多信号可以与其相关联。当与其关联的信号被发射时，这个槽就会被调用。槽可以有参数，但槽的参数不能有缺省值。<br>&emsp;&emsp;既然槽是普通的成员函数，因此与其它的函数一样，它们也有权限，槽的权限决定了谁能够与其相关联。同普通的<code>C++</code>成员函数一样，槽函数也分为三种类型，即<code>public slots</code>、<code>private slots</code>和<code>protected slots</code>。</p>
<ul>
<li><code>public slots</code>：在这个区内声明的槽意味着任何对象都可将信号与之相连接。</li>
<li><code>protected slots</code>：在这个区内声明的槽意味着当前类及其子类可以将信号与之相连接。</li>
<li><code>private slots</code>：在这个区内声明的槽意味着只有类自己可以将信号与之相连接。</li>
</ul>
<p>槽也能够声明为虚函数，这也是非常有用的。槽的声明也是在头文件中进行的，例如下面声明了三个槽：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySlot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySlot</span> <span class="params">( <span class="keyword">int</span> x )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignalParam</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="信号与槽的关联"><a href="#信号与槽的关联" class="headerlink" title="信号与槽的关联"></a>信号与槽的关联</h3><p>&emsp;&emsp;通过调用<code>QObject</code>对象的<code>connect</code>函数来将某个对象的信号与另外一个对象的槽函数相关联，这样当发射者发射信号时，接收者的槽函数将被调用。该函数的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> QObject::connect ( <span class="keyword">const</span> QObject *sender, <span class="keyword">const</span> <span class="keyword">char</span> *signal, \</span><br><span class="line">                        <span class="keyword">const</span> QObject *receiver, <span class="keyword">const</span> <span class="keyword">char</span> *member ) [<span class="keyword">static</span>]</span><br></pre></td></tr></table></figure>
<p>这个函数的作用就是将发射者<code>sender</code>对象中的信号<code>signal</code>与接收者<code>receiver</code>中的<code>member</code>槽函数联系起来。指定信号<code>signal</code>时必须使用<code>QT</code>的宏<code>SIGNAL</code>，指定槽函数时必须使用宏<code>SLOT</code>。如果发射者与接收者属于同一个对象的话，那么在<code>connect</code>调用中接收者参数可以省略。例如下面定义了两个对象即标签对象<code>label</code>和滚动条对象<code>scroll</code>，并将<code>valueChanged</code>信号与标签对象的<code>setNum</code>相关联，信号还携带了一个整型参数，这样标签总是显示滚动条所处位置的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> QLabel;</span><br><span class="line">QScrollBar *scroll = <span class="keyword">new</span> QScrollBar;</span><br><span class="line">QObject::connect ( scroll, SIGNAL ( valueChanged ( <span class="keyword">int</span> ) ), label, SLOT ( setNum ( <span class="keyword">int</span> ) ) );</span><br></pre></td></tr></table></figure>
<p>一个信号甚至能够与另一个信号相关联：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> :</span> <span class="keyword">public</span> QWidget &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyWidget();</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">aSignal</span><span class="params">()</span></span>;​</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPushButton *aButton;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyWidget::MyWidget() &#123;</span><br><span class="line">    aButton = <span class="keyword">new</span> QPushButton ( <span class="keyword">this</span> );</span><br><span class="line">    connect ( aButton, SIGNAL ( clicked() ), <span class="keyword">this</span>, SIGNAL ( aSignal() ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的构造函数中，<code>MyWidget</code>创建了一个私有的按钮<code>aButton</code>，按钮的单击事件产生的信号<code>clicked</code>与另外一个信号<code>aSignal</code>进行了关联。当信号<code>clicked</code>被发射时，信号<code>aSignal</code>也接着被发射。当然也可以直接将单击事件与某个私有的槽函数相关联，然后在槽中发射<code>aSignal</code>信号。<br>&emsp;&emsp;当信号与槽没有必要继续保持关联时，可以使用<code>disconnect</code>函数来断开连接：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> QObject::disconnect ( <span class="keyword">const</span> QObject *sender, <span class="keyword">const</span> <span class="keyword">char</span> *signal, \</span><br><span class="line">                           <span class="keyword">const</span> Object *receiver, <span class="keyword">const</span> <span class="keyword">char</span> *member ) [<span class="keyword">static</span>]</span><br></pre></td></tr></table></figure>
<h3 id="元对象工具"><a href="#元对象工具" class="headerlink" title="元对象工具"></a>元对象工具</h3><p>&emsp;&emsp;元对象编译器<code>moc</code>对<code>C++</code>文件中的类声明进行分析，并产生用于初始化元对象的<code>C++</code>代码，元对象包含全部信号和槽的名字以及指向这些函数的指针。<br>&emsp;&emsp;<code>moc</code>读取<code>C++</code>源文件，如果发现有<code>Q_OBJECT</code>宏声明的类，它就会生成另外一个<code>C++</code>源文件，这个新生成的文件中包含有该类的元对象代码。假设有一个头文件<code>mysignal.h</code>，在这个文件中包含有信号或槽的声明，那么在编译之前，<code>moc</code>工具就会根据该文件自动生成一个名为<code>mysignal.moc.h</code>的<code>C++</code>源文件，并将其提交给编译器；类似地，对应于<code>mysignal.cpp</code>文件，<code>moc</code>工具将自动生成一个名为<code>mysignal.moc.cpp</code>文件，并提交给编译器。</p>
<h3 id="程序样例"><a href="#程序样例" class="headerlink" title="程序样例"></a>程序样例</h3><p>&emsp;&emsp;信号和槽函数的声明一般位于头文件中，同时在类声明的开始位置必须加上<code>Q_OBJECT</code>语句。这条语句是不可缺少的，它将告诉编译器在编译之前必须先应用<code>moc</code>工具进行扩展。关键字<code>signals</code>指出随后开始信号的声明，<code>siganls</code>没有<code>public</code>、<code>private</code>、<code>protected</code>等属性，这点不同于<code>slots</code>。另外，<code>signals</code>、<code>slots</code>关键字是<code>QT</code>自己定义的，不是<code>C++</code>中的关键字。<br>&emsp;&emsp;信号的声明类似于函数的声明而非变量的声明，左边要有类型，右边要有括号。如果要向槽中传递参数的话，在括号中指定每个形参的类型，当然形参的个数可以多于一个。<br>&emsp;&emsp;关键字<code>slots</code>指出随后开始槽的声明，槽的声明与普通函数的声明一样，可以携带零或多个形参。既然信号的声明类似于普通<code>C++</code>函数的声明，那么信号也可采用<code>C++</code>中重载函数的形式进行声明。例如第一次定义的<code>void mySignal()</code>没有带参数，而第二次定义的却带有参数，从这里可以看到<code>QT</code>的信号机制是非常灵活的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* tsignal.h */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TsignalApp</span>:</span> <span class="keyword">public</span> QMainWindow &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">signals: <span class="comment">/* 信号声明区 */</span></span><br><span class="line">    <span class="comment">/* 声明信号mySignal() */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/* 声明信号mySignal(int) */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignal</span> <span class="params">( <span class="keyword">int</span> x )</span></span>;</span><br><span class="line">    <span class="comment">/* 声明信号mySignalParam(int, int) */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignalParam</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots: <span class="comment">/* 槽声明区 */</span></span><br><span class="line">    <span class="comment">/* 声明槽函数mySlot() */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySlot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/* 声明槽函数mySlot(int) */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySlot</span> <span class="params">( <span class="keyword">int</span> x )</span></span>;</span><br><span class="line">    <span class="comment">/* 声明槽函数mySignalParam (int, int) */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignalParam</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y )</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/* tsignal.cpp */</span></span><br><span class="line">TsignalApp::TsignalApp() &#123;</span><br><span class="line">    <span class="comment">/* 将信号mySignal与槽mySlot相关联 */</span></span><br><span class="line">    connect ( <span class="keyword">this</span>, SIGNAL ( mySignal() ), <span class="keyword">this</span>, SLOT ( mySlot() ) );</span><br><span class="line">    <span class="comment">/* 将信号mySignal(int)与槽mySlot(int)相关联 */</span></span><br><span class="line">    connect ( <span class="keyword">this</span>, SIGNAL ( mySignal ( <span class="keyword">int</span> ) ), \</span><br><span class="line">              <span class="keyword">this</span>, SLOT ( mySlot ( <span class="keyword">int</span> ) ) );</span><br><span class="line">    <span class="comment">/* 将信号mySignalParam(int, int)与槽mySlotParam(int, int)相关联 */</span></span><br><span class="line">    connect ( <span class="keyword">this</span>, SIGNAL ( mySignalParam ( <span class="keyword">int</span>, <span class="keyword">int</span> ) ), \</span><br><span class="line">              <span class="keyword">this</span>, SLOT ( mySlotParam ( <span class="keyword">int</span>, <span class="keyword">int</span> ) ) );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> TsignalApp::mySlot() &#123; <span class="comment">/* 定义槽函数mySlot */</span></span><br><span class="line">    QMessageBox::about ( <span class="keyword">this</span>, <span class="string">"Tsignal"</span>, <span class="string">"signal/slot sample without parameter."</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> TsignalApp::mySlot ( <span class="keyword">int</span> x ) &#123; <span class="comment">/* 定义槽函数mySlot(int) */</span></span><br><span class="line">    QMessageBox::about ( <span class="keyword">this</span>, <span class="string">"Tsignal"</span>, <span class="string">"signal/slot sample with one parameter."</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> TsignalApp::mySlotParam ( <span class="keyword">int</span> x, <span class="keyword">int</span> y ) &#123; <span class="comment">/* 定义槽函数mySlotParam(int, int) */</span></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span> ( s, <span class="string">"x:%d y:%d"</span>, x, y );</span><br><span class="line">    QMessageBox::about ( <span class="keyword">this</span>, <span class="string">"Tsignal"</span>, s );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TsignalApp::slotFileNew() &#123;</span><br><span class="line">    <span class="comment">/* 发射信号mySignal */</span></span><br><span class="line">    <span class="function">emit <span class="title">mySignal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/* 发射信号mySignal(int) */</span></span><br><span class="line">    <span class="function">emit <span class="title">mySignal</span> <span class="params">( <span class="number">5</span> )</span></span>;</span><br><span class="line">    <span class="comment">/* 发射信号mySignalParam(int, int) */</span></span><br><span class="line">    <span class="function">emit <span class="title">mySignalParam</span> <span class="params">( <span class="number">5</span>, <span class="number">100</span> )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应注意的问题"><a href="#应注意的问题" class="headerlink" title="应注意的问题"></a>应注意的问题</h3><p>&emsp;&emsp;信号与槽机制是比较灵活的，但有些局限性必须要了解，这样在实际使用过程中避免产生错误。<br>&emsp;&emsp;1. 信号与槽的效率是非常高的，但是同真正的回调函数比较起来，由于增加了灵活性，因此在速度上还是有所损失。当然这种损失相对来说是比较小的，在一台<code>i586</code>的机器上测试是<code>10</code>微秒，可见这种机制所提供的简洁性、灵活性还是值得的。但如果要追求高效率的话，比如在实时系统中就要尽可能地少用这种机制。<br>&emsp;&emsp;2. 信号与槽机制与普通函数的调用一样，如果使用不当的话，在程序执行时也有可能产生死循环。因此在定义槽函数时一定要注意避免间接形成无限循环，即在槽中再次发射所接收到的同样信号。例如，如果在<code>mySlot()</code>槽函数中加上语句<code>emit mySignal()</code>即可形成死循环。<br>&emsp;&emsp;3. 如果一个信号与多个槽相联系的话，那么当这个信号被发射时，与之相关的槽被激活的顺序将是随机的。<br>&emsp;&emsp;4. 宏定义不能用在<code>signal</code>和<code>slot</code>的参数中。既然<code>moc</code>工具不扩展<code>define</code>，因此在<code>signals</code>和<code>slots</code>中携带参数的宏就不能正确地工作，如果不带参数则是可以的。例如，下面的例子中将带有参数的宏<code>SIGNEDNESS(a)</code>作为信号的参数是不合语法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ultrix</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> SIGNEDNESS(a) unsigned a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> SIGNEDNESS(a) a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Whatever</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">someSignal</span> <span class="params">( SIGNEDNESS ( a ) )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;5. 构造函数不能用在<code>signals</code>或者<code>slots</code>声明区域内。下面的用法是不符合语法要求的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    SomeClass ( QObject *parent, <span class="keyword">const</span> <span class="keyword">char</span> *name ) : QObject ( parent, name ) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;6. 函数指针不能作为信号或槽的参数。下面的例子中将<code>void (* applyFunction)(QList *, void *)</code>作为参数是不符合语法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">someClass</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span> <span class="params">( <span class="keyword">void</span> ( *applyFunction ) ( QList *, <span class="keyword">void</span> * ), <span class="keyword">char</span> * )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你可以采用下面的方法绕过这个限制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">( *ApplyFunctionType )</span> <span class="params">( QList *, <span class="keyword">void</span> * )</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">someClass</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span> <span class="params">( ApplyFunctionType, <span class="keyword">char</span> * )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;7. 信号与槽不能有缺省参数。下面的用法是不合理的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">/* 将x的缺省值定义成100，在槽函数声明中使用是错误的 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">someSlot</span> <span class="params">( <span class="keyword">int</span> x = <span class="number">100</span> )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;8. 信号与槽也不能携带模板类参数。如果将信号、槽声明为模板类参数的话，即使<code>moc</code>工具不报告错误，也不可能得到预期的结果。下面的例子中，当信号发射时，槽函数不会被正确调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="keyword">void</span> MyWidget::setLocation ( pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; location );</span><br><span class="line"><span class="keyword">public</span> signals:</span><br><span class="line">    <span class="keyword">void</span> MyObject::moved ( pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; location );</span><br></pre></td></tr></table></figure>
<p>但是可以使用<code>typedef</code>语句来绕过这个限制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; IntPair;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="keyword">void</span> MyWidget::setLocation ( IntPair location );</span><br><span class="line"><span class="keyword">public</span> signals:</span><br><span class="line">    <span class="keyword">void</span> MyObject::moved ( IntPair location );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;9. 嵌套的类不能位于信号或槽区域内，也不能有信号或者槽。下面的例子中，在<code>class B</code>中声明槽<code>b</code>是不符合语法的，在信号区内声明槽<code>b</code>也是不符合语法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> slots: <span class="comment">/* 在嵌套类中声明槽不合语法 */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">​</span><br><span class="line">signals:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>; <span class="comment">/* 在信号区内声明嵌套类不合语法 */</span></span><br><span class="line">    &#125;:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;10. 友元声明不能位于信号或者槽声明区内，它们应该在普通<code>C++</code>的<code>private</code>、<code>protected</code>或者<code>public</code>区内进行声明。下面的例子是不符合语法规范的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">someClass</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">signals: <span class="comment">/* 信号定义区 */</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTemplate</span>;</span> <span class="comment">/* 此处定义不合语法 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/27/Qt语法详解/Qt之QSplashScreen/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/27/Qt语法详解/Qt之QSplashScreen/" itemprop="url">Qt之QSplashScreen</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T14:56:49+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QSplashScreen</code> widget provides a splash screen that can be shown during application startup. The header file is <code>QSplashScreen</code>.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QSplashScreen(const QPixmap &amp; pixmap = QPixmap(), Qt::WindowFlags f = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>QSplashScreen(QWidget * parent, const QPixmap &amp; pixmap = QPixmap(), Qt::WindowFlags f = 0)</code></td>
</tr>
<tr>
<td><code>virtual</code></td>
<td><code>~QSplashScreen()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>finish(QWidget * mainWin)</code></td>
</tr>
<tr>
<td><code>const QPixmap</code></td>
<td><code>pixmap() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>repaint()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPixmap(const QPixmap &amp; pixmap)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Slots"><a href="#Public-Slots" class="headerlink" title="Public Slots"></a>Public Slots</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>clearMessage()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>showMessage(const QString &amp; message, int alignment = Qt::AlignLeft, const QColor &amp; color = Qt::black)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><ul>
<li><code>void messageChanged(const QString &amp; message)</code></li>
</ul>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><ul>
<li><code>virtual void drawContents(QPainter * painter)</code></li>
</ul>
<h3 id="Reimplemented-Protected-Functions"><a href="#Reimplemented-Protected-Functions" class="headerlink" title="Reimplemented Protected Functions"></a>Reimplemented Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual bool</code></td>
<td><code>event(QEvent * e)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>mousePressEvent(QMouseEvent *)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QSplashScreen</code> widget provides a splash screen that can be shown during application startup.<br>&emsp;&emsp;A splash screen is a widget that is usually displayed when an application is being started. Splash screens are often used for applications that have long start up times (e.g. database or networking applications that take time to establish connections) to provide the user with feedback that the application is loading.<br>&emsp;&emsp;The splash screen appears in the center of the screen. It may be useful to add the <code>Qt::WindowStaysOnTopHint</code> to the splash widget’s window flags if you want to keep it above all the other windows on the desktop.<br>&emsp;&emsp;Some <code>X11</code> window managers do not support the <code>stays on top</code> flag. A solution is to set up a timer that periodically calls <code>raise()</code> on the splash screen to simulate the <code>stays on top</code> effect.<br>&emsp;&emsp;The most common usage is to show a splash screen before the main widget is displayed on the screen. This is illustrated in the following code snippet in which a splash screen is displayed and some initialization tasks are performed before the application’s main window is shown:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span> <span class="params">( <span class="string">":/splash.png"</span> )</span></span>;</span><br><span class="line">    <span class="function">QSplashScreen <span class="title">splash</span> <span class="params">( pixmap )</span></span>;</span><br><span class="line">    splash.show();</span><br><span class="line">    app.processEvents();</span><br><span class="line">    ...</span><br><span class="line">    QMainWindow window;</span><br><span class="line">    window.show();</span><br><span class="line">    splash.finish ( &amp;window );</span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The user can hide the splash screen by clicking on it with the mouse. Since the splash screen is typically displayed before the event loop has started running, it is necessary to periodically call <code>QApplication::processEvents()</code> to receive the mouse clicks.<br>&emsp;&emsp;It is sometimes useful to update the splash screen with messages, for example, announcing connections established or modules loaded as the application starts up:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">pixmap</span> <span class="params">( <span class="string">":/splash.png"</span> )</span></span>;</span><br><span class="line">QSplashScreen *splash = <span class="keyword">new</span> QSplashScreen ( pixmap );</span><br><span class="line">splash-&gt;show();</span><br><span class="line">​</span><br><span class="line">... <span class="comment">/* Loading some items */</span></span><br><span class="line">splash-&gt;showMessage ( <span class="string">"Loaded modules"</span> );</span><br><span class="line">​</span><br><span class="line">qApp-&gt;processEvents();</span><br><span class="line">​</span><br><span class="line">... <span class="comment">/* Establishing connections */</span></span><br><span class="line">splash-&gt;showMessage ( <span class="string">"Established connections"</span> );</span><br><span class="line">​</span><br><span class="line">qApp-&gt;processEvents();</span><br></pre></td></tr></table></figure>
<p><code>QSplashScreen</code> supports this with the <code>showMessage()</code> function. If you wish to do your own drawing you can get a pointer to the pixmap used in the splash screen with <code>pixmap()</code>. Alternatively, you can subclass <code>QSplashScreen</code> and reimplement <code>drawContents()</code>.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QSplashScreen::QSplashScreen(const QPixmap &amp; pixmap = QPixmap(), Qt::WindowFlags f = 0)</code>: Construct a splash screen that will display the <code>pixmap</code>. There should be no need to set the widget flags, <code>f</code>, except perhaps <code>Qt::WindowStaysOnTopHint</code>.</li>
<li><code>QSplashScreen::QSplashScreen(QWidget * parent, const QPixmap &amp; pixmap = QPixmap(), Qt::WindowFlags f = 0)</code>: This is an overloaded function. This function allows you to specify a <code>parent</code> for your splashscreen. The typical use for this constructor is if you have a multiple screens and prefer to have the splash screen on a different screen than your primary one. In that case pass the proper <code>desktop()</code> as the <code>parent</code>.</li>
<li><code>QSplashScreen::~QSplashScreen() [virtual]</code>: Destructor.</li>
<li><code>void QSplashScreen::clearMessage() [slot]</code>: Removes the message being displayed on the splash screen.</li>
<li><code>void QSplashScreen::drawContents(QPainter * painter) [virtual protected]</code>: Draw the contents of the splash screen using <code>painter</code>. The default implementation draws the message passed by <code>showMessage()</code>. Reimplement this function if you want to do your own drawing on the splash screen.</li>
<li><code>bool QSplashScreen::event(QEvent * e) [virtual protected]</code>: Reimplemented from <code>QObject::event()</code>.</li>
<li><code>void QSplashScreen::finish(QWidget * mainWin)</code>: Makes the splash screen wait until the widget <code>mainWin</code> is displayed before calling <code>close()</code> on itself.</li>
<li><code>void QSplashScreen::messageChanged(const QString &amp; message) [signal]</code>: This signal is emitted when the <code>message</code> on the splash screen changes. <code>message</code> is the new message and is a <code>null-string</code> when the message has been removed.</li>
<li><code>void QSplashScreen::mousePressEvent(QMouseEvent *) [virtual protected]</code>: Reimplemented from <code>QWidget::mousePressEvent()</code>.</li>
<li><code>const QPixmap QSplashScreen::pixmap() const</code>: Returns the pixmap that is used in the splash screen. The image does not have any of the text drawn by <code>showMessage()</code> calls.</li>
<li><code>void QSplashScreen::repaint()</code>: This overrides <code>QWidget::repaint()</code>. It differs from the standard repaint function in that it also calls <code>QApplication::flush()</code> to ensure the updates are displayed, even when there is no event loop present.</li>
<li><code>void QSplashScreen::setPixmap(const QPixmap &amp; pixmap)</code>: Sets the <code>pixmap</code> that will be used as the splash screen’s image to pixmap.</li>
<li><code>void QSplashScreen::showMessage(const QString &amp; message, int alignment = Qt::AlignLeft, const QColor &amp; color = Qt::black) [slot]</code>: Draws the <code>message</code> text onto the splash screen with <code>color</code> and aligns the text according to the flags in <code>alignment</code>. To make sure the splash screen is repainted immediately, you can call <code>QCoreApplication&#39;s</code> <code>processEvents()</code> after the call to <code>showMessage()</code>. You usually want this to make sure that the <code>message</code> is kept up to date with what your application is doing (e.g., loading files).</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/27/Qt语法详解/Qt之QTreeWidgetItem/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/27/Qt语法详解/Qt之QTreeWidgetItem/" itemprop="url">Qt之QTreeWidgetItem</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T00:36:51+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTreeWidgetItem</code> class provides an item for use with the <code>QTreeWidget</code> convenience class. The header file is <code>QTreeWidgetItem</code>.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTreeWidgetItem(int type = Type)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTreeWidgetItem(const QStringList &amp; strings, int type = Type)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTreeWidgetItem(QTreeWidget * parent, int type = Type)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTreeWidgetItem(QTreeWidget * parent, const QStringList &amp; strings, int type = Type)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTreeWidgetItem(QTreeWidget * parent, QTreeWidgetItem * preceding, int type = Type)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTreeWidgetItem(QTreeWidgetItem * parent, int type = Type)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTreeWidgetItem(QTreeWidgetItem * parent, const QStringList &amp; strings, int type = Type)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTreeWidgetItem(QTreeWidgetItem * parent, QTreeWidgetItem * preceding, int type = Type)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTreeWidgetItem(const QTreeWidgetItem &amp; other)</code></td>
</tr>
<tr>
<td><code>virtual</code></td>
<td><code>~QTreeWidgetItem()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addChild(QTreeWidgetItem * child)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addChildren(const QList&lt;QTreeWidgetItem *&gt; &amp; children)</code></td>
</tr>
<tr>
<td><code>QBrush</code></td>
<td><code>background(int column) const</code></td>
</tr>
<tr>
<td><code>Qt::CheckState</code></td>
<td><code>checkState(int column) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>child(int index) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>childCount() const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem::ChildIndicatorPolicy</code></td>
<td><code>childIndicatorPolicy() const</code></td>
</tr>
<tr>
<td><code>virtual QTreeWidgetItem *</code></td>
<td><code>clone() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>columnCount() const</code></td>
</tr>
<tr>
<td><code>virtual QVariant</code></td>
<td><code>data(int column, int role) const</code></td>
</tr>
<tr>
<td><code>Qt::ItemFlags</code></td>
<td><code>flags() const</code></td>
</tr>
<tr>
<td><code>QFont</code></td>
<td><code>font(int column) const</code></td>
</tr>
<tr>
<td><code>QBrush</code></td>
<td><code>foreground(int column) const</code></td>
</tr>
<tr>
<td><code>QIcon</code></td>
<td><code>icon(int column) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>indexOfChild(QTreeWidgetItem * child) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertChild(int index, QTreeWidgetItem * child)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertChildren(int index, const QList&lt;QTreeWidgetItem *&gt; &amp; children)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isDisabled() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isExpanded() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isFirstColumnSpanned() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isHidden() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isSelected() const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>parent() const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>read(QDataStream &amp; in)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeChild(QTreeWidgetItem * child)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBackground(int column, const QBrush &amp; brush)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCheckState(int column, Qt::CheckState state)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setChildIndicatorPolicy(QTreeWidgetItem::ChildIndicatorPolicy policy)</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>setData(int column, int role, const QVariant &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDisabled(bool disabled)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setExpanded(bool expand)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFirstColumnSpanned(bool span)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFlags(Qt::ItemFlags flags)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFont(int column, const QFont &amp; font)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setForeground(int column, const QBrush &amp; brush)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHidden(bool hide)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setIcon(int column, const QIcon &amp; icon)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSelected(bool select)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSizeHint(int column, const QSize &amp; size)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setStatusTip(int column, const QString &amp; statusTip)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setText(int column, const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTextAlignment(int column, int alignment)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setToolTip(int column, const QString &amp; toolTip)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setWhatsThis(int column, const QString &amp; whatsThis)</code></td>
</tr>
<tr>
<td><code>QSize</code></td>
<td><code>sizeHint(int column) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>sortChildren(int column, Qt::SortOrder order)</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>statusTip(int column) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>takeChild(int index)</code></td>
</tr>
<tr>
<td><code>QList&lt;QTreeWidgetItem *&gt;</code></td>
<td><code>takeChildren()</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>text(int column) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>textAlignment(int column) const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>toolTip(int column) const</code></td>
</tr>
<tr>
<td><code>QTreeWidget *</code></td>
<td><code>treeWidget() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>type() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>whatsThis(int column) const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>write(QDataStream &amp; out) const</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>operator&lt;(const QTreeWidgetItem &amp; other) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem &amp;</code></td>
<td><code>operator=(const QTreeWidgetItem &amp; other)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><ul>
<li><code>void emitDataChanged()</code></li>
</ul>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; out, const QTreeWidgetItem &amp; item)</code></li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; in, QTreeWidgetItem &amp; item)</code></li>
</ul>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTreeWidgetItem</code> class provides an item for use with the <code>QTreeWidget</code> convenience class.<br>&emsp;&emsp;Tree widget items are used to hold rows of information for tree widgets. Rows usually contain several columns of data, each of which can contain a text label and an icon.<br>&emsp;&emsp;The <code>QTreeWidgetItem</code> class is a convenience class that replaces the <code>QListViewItem</code> class in <code>Qt 3</code>. It provides an item for use with the <code>QTreeWidget</code> class.<br>&emsp;&emsp;Items are usually constructed with a parent that is either a <code>QTreeWidget</code> (for <code>top-level</code> items) or a <code>QTreeWidgetItem</code> (for items on lower levels of the tree). For example, the following code constructs a <code>top-level</code> item to represent cities of the world, and adds a entry for <code>Oslo</code> as a child item:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QTreeWidgetItem *cities = <span class="keyword">new</span> QTreeWidgetItem ( treeWidget );</span><br><span class="line">cities-&gt;setText ( <span class="number">0</span>, tr ( <span class="string">"Cities"</span> ) );</span><br><span class="line">QTreeWidgetItem *osloItem = <span class="keyword">new</span> QTreeWidgetItem ( cities );</span><br><span class="line">osloItem-&gt;setText ( <span class="number">0</span>, tr ( <span class="string">"Oslo"</span> ) );</span><br><span class="line">osloItem-&gt;setText ( <span class="number">1</span>, tr ( <span class="string">"Yes"</span> ) );</span><br></pre></td></tr></table></figure>
<p>Items can be added in a particular order by specifying the item they follow when they are constructed:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QTreeWidgetItem *planets = <span class="keyword">new</span> QTreeWidgetItem ( treeWidget, cities );</span><br><span class="line">planets-&gt;setText ( <span class="number">0</span>, tr ( <span class="string">"Planets"</span> ) );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Each column in an item can have its own background brush which is set with the <code>setBackground()</code> function. The current background brush can be found with <code>background()</code>. The text label for each column can be rendered with its own font and brush. These are specified with the <code>setFont()</code> and <code>setForeground()</code> functions, and read with <code>font()</code> and <code>foreground()</code>.<br>&emsp;&emsp;The main difference between <code>top-level</code> items and those in lower levels of the tree is that a <code>top-level</code> item has no <code>parent()</code>. This information can be used to tell the difference between items, and is useful to know when inserting and removing items from the tree. Children of an item can be removed with <code>takeChild()</code> and inserted at a given index in the list of children with the <code>insertChild()</code> function.<br>&emsp;&emsp;By default, items are enabled, selectable, checkable, and can be the source of a drag and drop operation. Each item’s flags can be changed by calling <code>setFlags()</code> with the appropriate value. Checkable items can be checked and unchecked with the <code>setCheckState()</code> function. The corresponding <code>checkState()</code> function indicates whether the item is currently checked.</p>
<h3 id="Subclassing"><a href="#Subclassing" class="headerlink" title="Subclassing"></a>Subclassing</h3><p>&emsp;&emsp;When subclassing <code>QTreeWidgetItem</code> to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than <code>UserType</code>.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QTreeWidgetItem::ChildIndicatorPolicy</code>:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTreeWidgetItem::ShowIndicator</code></td>
<td><code>0</code></td>
<td>The controls for expanding and collapsing will be shown for this item even if there are no children.</td>
</tr>
<tr>
<td><code>QTreeWidgetItem::DontShowIndicator</code></td>
<td><code>1</code></td>
<td>The controls for expanding and collapsing will never be shown even if there are children. If the node is forced open the user will not be able to expand or collapse the item.</td>
</tr>
<tr>
<td><code>QTreeWidgetItem::DontShowIndicatorWhenChildless</code></td>
<td><code>2</code></td>
<td>The controls for expanding and collapsing will be shown if the item contains children.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QTreeWidgetItem::ItemType</code>: This enum describes the types that are used to describe tree widget items.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTreeWidgetItem::Type</code></td>
<td><code>0</code></td>
<td>The default type for tree widget items.</td>
</tr>
<tr>
<td><code>QTreeWidgetItem::UserType</code></td>
<td><code>1000</code></td>
<td>The minimum value for custom types. Values below <code>UserType</code> are reserved by <code>Qt</code>.</td>
</tr>
</tbody>
</table>
</div>
<p>You can define new user types in <code>QTreeWidgetItem</code> subclasses to ensure that custom items are treated specially; for example, when items are sorted.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTreeWidgetItem::QTreeWidgetItem(int type = Type)</code>: Constructs a tree widget item of the specified <code>type</code>. The item must be inserted into a tree widget.</li>
<li><code>QTreeWidgetItem::QTreeWidgetItem(const QStringList &amp; strings, int type = Type)</code>: Constructs a tree widget item of the specified <code>type</code>. The item must be inserted into a tree widget. The given list of <code>strings</code> will be set as the item text for each column in the item.</li>
<li><code>QTreeWidgetItem::QTreeWidgetItem(QTreeWidget * parent, int type = Type)</code>: Constructs a tree widget item of the specified <code>type</code> and appends it to the items in the given <code>parent</code>.</li>
<li><code>QTreeWidgetItem::QTreeWidgetItem(QTreeWidget * parent, const QStringList &amp; strings, int type = Type)</code>: Constructs a tree widget item of the specified <code>type</code> and appends it to the items in the given <code>parent</code>. The given list of <code>strings</code> will be set as the item text for each column in the item.</li>
<li><code>QTreeWidgetItem::QTreeWidgetItem(QTreeWidget * parent, QTreeWidgetItem * preceding, int type = Type)</code>: Constructs a tree widget item of the specified <code>type</code> and inserts it into the given <code>parent</code> after the <code>preceding</code> item.</li>
<li><code>QTreeWidgetItem::QTreeWidgetItem(QTreeWidgetItem * parent, int type = Type)</code>: Constructs a tree widget item and append it to the given <code>parent</code>.</li>
<li><code>QTreeWidgetItem::QTreeWidgetItem(QTreeWidgetItem * parent, const QStringList &amp; strings, int type = Type)</code>: Constructs a tree widget item and append it to the given <code>parent</code>. The given list of <code>strings</code> will be set as the item text for each column in the item.</li>
<li><code>QTreeWidgetItem::QTreeWidgetItem(QTreeWidgetItem * parent, QTreeWidgetItem * preceding, int type = Type)</code>: Constructs a tree widget item of the specified <code>type</code> that is inserted into the <code>parent</code> after the <code>preceding</code> child item.</li>
<li><code>QTreeWidgetItem::QTreeWidgetItem(const QTreeWidgetItem &amp; other)</code>: Constructs a copy of <code>other</code>. Note that <code>type()</code> and <code>treeWidget()</code> are not copied. This function is useful when reimplementing <code>clone()</code>.</li>
<li><code>QTreeWidgetItem::~QTreeWidgetItem() [virtual]</code>: Destroys this tree widget item. The item will be removed from <code>QTreeWidgets</code> to which it has been added. This makes it safe to delete an item at any time.</li>
<li><code>void QTreeWidgetItem::addChild(QTreeWidgetItem * child)</code>: Appends the <code>child</code> item to the list of children.</li>
<li><code>void QTreeWidgetItem::addChildren(const QList&lt;QTreeWidgetItem *&gt; &amp; children)</code>: Appends the given list of <code>children</code> to the item.</li>
<li><code>QBrush QTreeWidgetItem::background(int column) const</code>: Returns the brush used to render the background of the specified <code>column</code>.</li>
<li><code>Qt::CheckState QTreeWidgetItem::checkState(int column) const</code>: Returns the check state of the label in the given <code>column</code>.</li>
<li><code>QTreeWidgetItem * QTreeWidgetItem::child(int index) const</code>: Returns the item at the given <code>index</code> in the list of the item’s children.</li>
<li><code>int QTreeWidgetItem::childCount() const</code>: Returns the number of child items.</li>
<li><code>QTreeWidgetItem::ChildIndicatorPolicy QTreeWidgetItem::childIndicatorPolicy() const</code>: Returns the item indicator policy. This policy decides when the tree branch <code>expand/collapse</code> indicator is shown.</li>
<li><code>QTreeWidgetItem * QTreeWidgetItem::clone() const [virtual]</code>: Creates a deep copy of the item and of its children.</li>
<li><code>int QTreeWidgetItem::columnCount() const</code>: Returns the number of columns in the item.</li>
<li><code>QVariant QTreeWidgetItem::data(int column, int role) const [virtual]</code>: Returns the value for the item’s <code>column</code> and <code>role</code>.</li>
<li><code>void QTreeWidgetItem::emitDataChanged() [protected]</code>: Causes the model associated with this item to emit a <code>dataChanged()</code> signal for this item. You normally only need to call this function if you have subclassed <code>QTreeWidgetItem</code> and reimplemented <code>data()</code> and/or <code>setData()</code>.</li>
<li><code>Qt::ItemFlags QTreeWidgetItem::flags() const</code>: Returns the flags used to describe the item. These determine whether the item can be checked, edited, and selected. The default value for flags is <code>Qt::ItemIsSelectable | Qt::ItemIsUserCheckable | Qt::ItemIsEnabled | Qt::ItemIsDragEnabled</code>. If the item was constructed with a parent, flags will in addition contain <code>Qt::ItemIsDropEnabled</code>.</li>
<li><code>QFont QTreeWidgetItem::font(int column) const</code>: Returns the font used to render the text in the specified <code>column</code>.</li>
<li><code>QBrush QTreeWidgetItem::foreground(int column) const</code>: Returns the brush used to render the foreground (e.g. <code>text</code>) of the specified <code>column</code>.</li>
<li><code>QIcon QTreeWidgetItem::icon(int column) const</code>: Returns the icon that is displayed in the specified <code>column</code>.</li>
<li><code>int QTreeWidgetItem::indexOfChild(QTreeWidgetItem * child) const</code>: Returns the index of the given <code>child</code> in the item’s list of children.</li>
<li><code>void QTreeWidgetItem::insertChild(int index, QTreeWidgetItem * child)</code>: Inserts the <code>child</code> item at <code>index</code> in the list of children. If the <code>child</code> has already been inserted somewhere else it wont be inserted again.</li>
<li><code>void QTreeWidgetItem::insertChildren(int index, const QList&lt;QTreeWidgetItem *&gt; &amp; children)</code>: Inserts the given list of <code>children</code> into the list of the item <code>children</code> at <code>index</code>. Children that have already been inserted somewhere else wont be inserted.</li>
<li><code>bool QTreeWidgetItem::isDisabled() const</code>: Returns <code>true</code> if the item is disabled; otherwise returns <code>false</code>.</li>
<li><code>bool QTreeWidgetItem::isExpanded() const</code>: Returns <code>true</code> if the item is expanded, otherwise returns <code>false</code>.</li>
<li><code>bool QTreeWidgetItem::isFirstColumnSpanned() const</code>: Returns <code>true</code> if the item is spanning all the columns in a row; otherwise returns <code>false</code>.</li>
<li><code>bool QTreeWidgetItem::isHidden() const</code>: Returns <code>true</code> if the item is hidden, otherwise returns <code>false</code>.</li>
<li><code>bool QTreeWidgetItem::isSelected() const</code>: Returns <code>true</code> if the item is selected, otherwise returns <code>false</code>.</li>
<li><code>QTreeWidgetItem * QTreeWidgetItem::parent() const</code>: Returns the item’s parent.</li>
<li><code>void QTreeWidgetItem::read(QDataStream &amp; in) [virtual]</code>: Reads the item from stream <code>in</code>. This only reads data into a single item.</li>
<li><code>void QTreeWidgetItem::removeChild(QTreeWidgetItem * child)</code>: Removes the given item indicated by <code>child</code>. The removed item will not be deleted.</li>
<li><code>void QTreeWidgetItem::setBackground(int column, const QBrush &amp; brush)</code>: Sets the background <code>brush</code> of the label in the given <code>column</code> to the specified <code>brush</code>.</li>
<li><code>void QTreeWidgetItem::setCheckState(int column, Qt::CheckState state)</code>: Sets the item in the given column check <code>state</code> to be <code>state</code>.</li>
<li><code>void QTreeWidgetItem::setChildIndicatorPolicy(QTreeWidgetItem::ChildIndicatorPolicy policy)</code>: Sets the item indicator <code>policy</code>. This <code>policy</code> decides when the tree branch <code>expand/collapse</code> indicator is shown. The default value is <code>ShowForChildren</code>.</li>
<li><code>void QTreeWidgetItem::setData(int column, int role, const QVariant &amp; value) [virtual]</code>: Sets the <code>value</code> for the item’s <code>column</code> and <code>role</code> to the given <code>value</code>. The <code>role</code> describes the type of data specified by <code>value</code>, and is defined by the <code>Qt::ItemDataRole</code> enum.</li>
<li><code>void QTreeWidgetItem::setDisabled(bool disabled)</code>: Disables the item if <code>disabled</code> is <code>true</code>; otherwise enables the item.</li>
<li><code>void QTreeWidgetItem::setExpanded(bool expand)</code>: Expands the item if <code>expand</code> is true, otherwise collapses the item. <strong>Warning</strong>: The <code>QTreeWidgetItem</code> must be added to the <code>QTreeWidget</code> before calling this function.</li>
<li><code>void QTreeWidgetItem::setFirstColumnSpanned(bool span)</code>: Sets the first section to <code>span</code> all columns if <code>span</code> is <code>true</code>; otherwise all item sections are shown.</li>
<li><code>void QTreeWidgetItem::setFlags(Qt::ItemFlags flags)</code>: Sets the <code>flags</code> for the item to the given <code>flags</code>. These determine whether the item can be selected or modified. This is often used to disable an item.</li>
<li><code>void QTreeWidgetItem::setFont(int column, const QFont &amp; font)</code>: Sets the <code>font</code> used to display the text in the given <code>column</code> to the given <code>font</code>.</li>
<li><code>void QTreeWidgetItem::setForeground(int column, const QBrush &amp; brush)</code>: Sets the foreground <code>brush</code> of the label in the given <code>column</code> to the specified <code>brush</code>.</li>
<li><code>void QTreeWidgetItem::setHidden(bool hide)</code>: Hides the item if <code>hide</code> is <code>true</code>, otherwise shows the item.</li>
<li><code>void QTreeWidgetItem::setIcon(int column, const QIcon &amp; icon)</code>: Sets the <code>icon</code> to be displayed in the given <code>column</code> to <code>icon</code>.</li>
<li><code>void QTreeWidgetItem::setSelected(bool select)</code>: Sets the selected state of the item to <code>select</code>.</li>
<li><code>void QTreeWidgetItem::setSizeHint(int column, const QSize &amp; size)</code>: Sets the <code>size</code> hint for the tree item in the given <code>column</code> to be <code>size</code>. If no <code>size</code> hint is set, the item delegate will compute the <code>size</code> hint based on the item data.</li>
<li><code>void QTreeWidgetItem::setStatusTip(int column, const QString &amp; statusTip)</code>: Sets the status tip for the given <code>column</code> to the given <code>statusTip</code>. <code>QTreeWidget</code> mouse tracking needs to be enabled for this feature to work.</li>
<li><code>void QTreeWidgetItem::setText(int column, const QString &amp; text)</code>: Sets the <code>text</code> to be displayed in the given <code>column</code> to the given <code>text</code>.</li>
<li><code>void QTreeWidgetItem::setTextAlignment(int column, int alignment)</code>: Sets the text <code>alignment</code> for the label in the given <code>column</code> to the <code>alignment</code> specified.</li>
<li><code>void QTreeWidgetItem::setToolTip(int column, const QString &amp; toolTip)</code>: Sets the tooltip for the given <code>column</code> to <code>toolTip</code>.</li>
<li><code>void QTreeWidgetItem::setWhatsThis(int column, const QString &amp; whatsThis)</code>: Sets the <code>What&#39;s This?</code> help for the given <code>column</code> to <code>whatsThis</code>.</li>
<li><code>QSize QTreeWidgetItem::sizeHint(int column) const</code>: Returns the size hint set for the tree item in the given <code>column</code>.</li>
<li><code>void QTreeWidgetItem::sortChildren(int column, Qt::SortOrder order)</code>: Sorts the children of the item using the given <code>order</code>, by the values in the given <code>column</code>. <strong>Note</strong>: This function does nothing if the item is not associated with a <code>QTreeWidget</code>.</li>
<li><code>QString QTreeWidgetItem::statusTip(int column) const</code>: Returns the status tip for the contents of the given <code>column</code>.</li>
<li><code>QTreeWidgetItem * QTreeWidgetItem::takeChild(int index)</code>: Removes the item at <code>index</code> and returns it, otherwise return <code>0</code>.</li>
<li><code>QList&lt;QTreeWidgetItem *&gt; QTreeWidgetItem::takeChildren()</code>: Removes the list of children and returns it, otherwise returns an empty list.</li>
<li><code>QString QTreeWidgetItem::text(int column) const</code>: Returns the text in the specified <code>column</code>.</li>
<li><code>int QTreeWidgetItem::textAlignment(int column) const</code>: Returns the text alignment for the label in the given <code>column</code>.</li>
<li><code>QString QTreeWidgetItem::toolTip(int column) const</code>: Returns the tool tip for the given <code>column</code>.</li>
<li><code>QTreeWidget * QTreeWidgetItem::treeWidget() const</code>: Returns the tree widget that contains the item.</li>
<li><code>int QTreeWidgetItem::type() const</code>: Returns the type passed to the <code>QTreeWidgetItem</code> constructor.</li>
<li><code>QString QTreeWidgetItem::whatsThis(int column) const</code>: Returns the <code>What&#39;s This?</code> help for the contents of the given <code>column</code>.</li>
<li><code>void QTreeWidgetItem::write(QDataStream &amp; out) const [virtual]</code>: Writes the item to stream <code>out</code>. This only writes data from one single item.</li>
<li><code>bool QTreeWidgetItem::operator&lt;(const QTreeWidgetItem &amp; other) const [virtual]</code>: Returns <code>true</code> if the text in the item is less than the text in the <code>other</code> item, otherwise returns <code>false</code>.</li>
<li><code>QTreeWidgetItem &amp; QTreeWidgetItem::operator=(const QTreeWidgetItem &amp; other)</code>: Assigns <code>other&#39;s</code> data and flags to this item. Note that <code>type()</code> and <code>treeWidget()</code> are not copied. This function is useful when reimplementing <code>clone()</code>.</li>
</ul>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; out, const QTreeWidgetItem &amp; item)</code>: Writes the tree widget item item to stream out. This operator uses <code>QTreeWidgetItem::write()</code>.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; in, QTreeWidgetItem &amp; item)</code>: Reads a tree widget item from stream in into item. This operator uses <code>QTreeWidgetItem::read()</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/26/Qt语法详解/Qt之QNetwork系列/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/26/Qt语法详解/Qt之QNetwork系列/" itemprop="url">Qt之QNetwork系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-26T21:42:05+08:00">
                2019-01-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="QNetworkAccessManager"><a href="#QNetworkAccessManager" class="headerlink" title="QNetworkAccessManager"></a>QNetworkAccessManager</h3><p>&emsp;&emsp;这个类的所有函数都是可重入的，它是从<code>Qt 4.4</code>引入的。</p>
<h4 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h4><p>&emsp;&emsp;<code>QNetworkAccessManager</code>类允许应用程序发送网络请求和接收网络应答。<code>Network Access API</code>都是围绕着一个<code>QNetworkAccessManager</code>对象构造的，这个对象包含着发送请求的一些通用配置和设置。它包含着代理和缓存的配置，以及和这些事物相关的一些信号，并且应答信号可以作为我们检测一个网络操作的进度。一个<code>QNetworkAccessManager</code>对于一整个<code>Qt</code>应用程序来说已经足够了！<br>&emsp;&emsp;一旦一个<code>QNetworkAccessManager</code>对象被创建了，那么应用程序就可以使用它在网络上发送请求。它提供了一组标准的函数，可以承载网络请求和一些可选的数据，并且每一个请求返回一个<code>QNetworkReply</code>对象。该返回的对象包含着返回的请求应带的所有数据。<br>&emsp;&emsp;一个简单的从网络下载的例子可如下完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QNetworkAccessManager *manager = <span class="keyword">new</span> QNetworkAccessManager ( <span class="keyword">this</span> );</span><br><span class="line">connect ( manager, SIGNAL ( finished ( QNetworkReply * ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SLOT ( replyFinished ( QNetworkReply * ) ) );</span><br><span class="line">manager-&gt;get ( QNetworkRequest ( QUrl ( <span class="string">"http://qt.nokia.com"</span> ) ) );</span><br></pre></td></tr></table></figure>
<p><code>QNetworkAccessManager</code>有一个异步的<code>API</code>。当上面的<code>replyFinished</code>槽被调用的时候，它带的参数就是包含有下载的数据的<code>QNetworkReply</code>对象。注意，当请求完成的时候，程序员需要在适当的时候删除<code>QNetworkReply</code>对象。不要在连接到信号<code>finished</code>的槽函数中直接删除掉，你可以使用<code>deleteLater</code>函数。<br>&emsp;&emsp;注意，<code>QNetworkAccessManager</code>将会把它收到的请求排队，并行执行的请求数量是依赖于协议的。目前对于桌面平台的<code>HTTP</code>协议，对于一个<code>主机/端口</code>的组合，可并行执行<code>6</code>个请求。<br>&emsp;&emsp;一个更加复杂的例子如下所示，假设<code>manager</code>已经存在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QNetworkRequest request;</span><br><span class="line">request.setUrl ( QUrl ( <span class="string">"http://qt.nokia.com"</span> ) );</span><br><span class="line">request.setRawHeader ( <span class="string">"User-Agent"</span>, <span class="string">"MyOwnBrowser 1.0"</span> );</span><br><span class="line">QNetworkReply *reply = manager-&gt;get ( request );</span><br><span class="line">connect ( reply, SIGNAL ( readyRead() ), <span class="keyword">this</span>, SLOT ( slotReadyRead() ) );</span><br><span class="line">connect ( reply, SIGNAL ( error ( QNetworkReply::NetworkError ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SLOT ( slotError ( QNetworkReply::NetworkError ) ) );</span><br><span class="line">connect ( reply, SIGNAL ( sslErrors ( QList&lt;QSslError&gt; ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SLOT ( slotSslErrors ( QList&lt;QSslError&gt; ) ) );</span><br></pre></td></tr></table></figure>
<h4 id="网络和漫游支持"><a href="#网络和漫游支持" class="headerlink" title="网络和漫游支持"></a>网络和漫游支持</h4><p>&emsp;&emsp;在<code>Qt 4.7</code>版本中，<code>QNetworkAccessManager</code>有了额外的<code>Bearer Management API</code>支持，使得<code>QNetworkAccessManager</code>具有了管理管理网络连接的能力。<code>QNetworkAccessManager</code>可以在设备离线的时候启用网络接口，并且如果当前进程是最后一个使用网络时，<code>QNetworkAccessManager</code>可以停止网络接口。每一个入队/挂起的网络请求可以自动地传输到一个新的接入点。客户希望不作出任何改变就可以利用这个特性。实际上它就像把与特定平台相关的网络连接的代码从应用程序中删除。</p>
<h4 id="成员类型文档"><a href="#成员类型文档" class="headerlink" title="成员类型文档"></a>成员类型文档</h4><ul>
<li><code>enum QNetworkAccessManager::NetworkAccessibility</code>：表明是否可以通过网络管理接入网络。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QNetworkAccessManager::UnknownAccessibility</code></td>
<td><code>-1</code></td>
<td>The network accessibility cannot be determined.</td>
</tr>
<tr>
<td><code>QNetworkAccessManager::NotAccessible</code></td>
<td><code>0</code></td>
<td>The network is not currently accessible, either because there is currently no network coverage or network access has been explicitly disabled by a call to <code>setNetworkAccessible()</code>.</td>
</tr>
<tr>
<td><code>QNetworkAccessManager::Accessible</code></td>
<td><code>1</code></td>
<td>The network is accessible.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>enum QNetworkAccessManager::Operation</code>表明这个对于一个应答的处理过程。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QNetworkAccessManager::HeadOperation</code></td>
<td><code>1</code></td>
<td>retrieve headers operation (created with <code>head()</code>)</td>
</tr>
<tr>
<td><code>QNetworkAccessManager::GetOperation</code></td>
<td><code>2</code></td>
<td>retrieve headers and download contents (created with <code>get()</code>)</td>
</tr>
<tr>
<td><code>QNetworkAccessManager::PutOperation</code></td>
<td><code>3</code></td>
<td>upload contents operation (created with <code>put()</code>)</td>
</tr>
<tr>
<td><code>QNetworkAccessManager::PostOperation</code></td>
<td><code>4</code></td>
<td>send the contents of an <code>HTML</code> form for processing via <code>HTTP</code> <code>POST</code> (created with <code>post()</code>)</td>
</tr>
<tr>
<td><code>QNetworkAccessManager::DeleteOperation</code></td>
<td><code>5</code></td>
<td>delete contents operation (created with <code>deleteResource()</code>)</td>
</tr>
<tr>
<td><code>QNetworkAccessManager::CustomOperation</code></td>
<td><code>6</code></td>
<td>custom operation (created with <code>sendCustomRequest()</code>)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="属性文档"><a href="#属性文档" class="headerlink" title="属性文档"></a>属性文档</h4><p>&emsp;&emsp;<code>NetworkAccessibility</code>这个属性表明当前是否可以通过网络管理接入网络。如果网络不可接入，那么<code>network access manager</code>将不会处理任何新的网络请求，所有这些请求都会发生错误而失败。那些以<code>file://scheme</code>作为<code>URLs</code>的请求仍然会被处理。这个属性的默认值反应了设备的物理状态。应用程序可以通过如下操作来覆盖它的值以禁止任何网络请求：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networkAccessManager-&gt;setNetworkAccessible ( QNetworkAccessManager::NotAccessible );</span><br></pre></td></tr></table></figure>
<p>可以通过如下调用来再次使能网络：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networkAccessManager-&gt;setNetworkAccessible ( QNetworkAccessManager::Accessible );</span><br></pre></td></tr></table></figure>
<p>调用<code>setNetworkAccessible</code>并不会改变网络状态。<br>&emsp;&emsp;Access functions:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NetworkAccessibility <span class="title">networkAccessible</span> <span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNetworkAccessible</span> <span class="params">( NetworkAccessibility accessible )</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Notifier signal:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">networkAccessibleChanged</span> <span class="params">( QNetworkAccessManager::NetworkAccessibility accessible )</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="QNetworkRequest"><a href="#QNetworkRequest" class="headerlink" title="QNetworkRequest"></a>QNetworkRequest</h3><p>&emsp;&emsp;这个类是从<code>Qt 4.4</code>开始引入进来的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QNetworkRequest ( const QUrl &amp;url = QUrl() )</code></td>
</tr>
<tr>
<td></td>
<td><code>QNetworkRequest ( const QNetworkRequest &amp;other )</code></td>
</tr>
<tr>
<td></td>
<td><code>~QNetworkRequest ()</code></td>
</tr>
<tr>
<td><code>QVariant</code></td>
<td><code>attribute ( Attribute code, const QVariant &amp;defaultValue = QVariant() ) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasRawHeader ( const QByteArray &amp;headerName ) const</code></td>
</tr>
<tr>
<td><code>QVariant</code></td>
<td><code>header ( KnownHeaders header ) const</code></td>
</tr>
<tr>
<td><code>QObject *</code></td>
<td><code>originatingObject () const</code></td>
</tr>
<tr>
<td><code>Priority</code></td>
<td><code>priority () const</code></td>
</tr>
<tr>
<td><code>QByteArray</code></td>
<td><code>rawHeader ( const QByteArray &amp;headerName ) const</code></td>
</tr>
<tr>
<td><code>QList&lt;QByteArray&gt;</code></td>
<td><code>rawHeaderList () const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setAttribute ( Attribute code, const QVariant &amp;value )</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHeader ( KnownHeaders header, const QVariant &amp;value )</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setOriginatingObject ( QObject *object )</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPriority ( Priority priority )</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setRawHeader ( const QByteArray &amp;headerName, const QByteArray &amp;headerValue )</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSslConfiguration ( const QSslConfiguration &amp;config )</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUrl ( const QUrl &amp;url )</code></td>
</tr>
<tr>
<td><code>QSslConfiguration</code></td>
<td><code>sslConfiguration () const</code></td>
</tr>
<tr>
<td><code>QUrl</code></td>
<td><code>url () const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!= ( const QNetworkRequest &amp;other ) const</code></td>
</tr>
<tr>
<td><code>QNetworkRequest &amp;</code></td>
<td><code>operator= ( const QNetworkRequest &amp;other )</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator== ( const QNetworkRequest &amp;other ) const</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="详细描述-1"><a href="#详细描述-1" class="headerlink" title="详细描述"></a>详细描述</h4><p>&emsp;&emsp;<code>QNetworkRequest</code>类包含一个和<code>QNetworkAccessManager</code>一起发送的请求。<code>QNetworkRequest</code>是<code>Network Access API</code>的一部分，并且这个类包含着在网络上发送请求的必要信息。它包含了一个<code>URL</code>和一些可以用来修改请求的附加信息。</p>
<h4 id="成员类型文档-1"><a href="#成员类型文档-1" class="headerlink" title="成员类型文档"></a>成员类型文档</h4><ul>
<li>enum <code>QNetworkRequest::Attribute</code>：<code>QNetworkRequest</code>和<code>QNetworkReply</code>的属性编码。属性是额外的<code>meta</code>数据，可以用来控制请求的行为，并且可以通过应答传递更多的信息到应用程序中。属性都是可扩展的，允许自定义实现来传递自定义的值。下面的表格说明默认属性值，都是和<code>QVariant</code>类型相关，指明属性的默认值是否丢失，是否在请求和应答中使用。</li>
<li>enum <code>QNetworkRequest::CacheLoadControl</code>：控制了<code>QNetworkAccessManager</code>的缓冲机制。</li>
<li>enum <code>QNetworkRequest::KnownHeaders</code>：列出了<code>QNetworkRequest</code>解析的已知的首部。每一个已知的首部都用完整的<code>HTTP</code>名字以原始类型的形式呈现。</li>
<li>enum <code>QNetworkRequest::LoadControl</code>：表明请求的缓存机制的一个方面是否被人为的覆盖了，例如被<code>QtWebKit</code>。</li>
<li>enum <code>QNetworkRequest::Priority</code>：这个表枚举了可能的网络请求的优先级。</li>
</ul>
<hr>
<h3 id="QNetworkReply"><a href="#QNetworkReply" class="headerlink" title="QNetworkReply"></a>QNetworkReply</h3><p>&emsp;&emsp;这个类是从<code>Qt 4.4</code>引入的，其中的所有函数都是可重入的。</p>
<h4 id="详细描述-2"><a href="#详细描述-2" class="headerlink" title="详细描述"></a>详细描述</h4><p>&emsp;&emsp;<code>QNetworkReply</code>类包含了发送给<code>QNetworkManager</code>的数据和首部。<code>QNetworkReply</code>类包含了发送给<code>QNetworkAccessManager</code>请求的所有应答数据。和<code>QNetworkRequest</code>类似，这些数据包含了一个<code>URL</code>和一些首部信息(同时包含解析后的和原始形式的)，以及一些和应答状态相关的信息，再加上应答信息自身的内容。<br>&emsp;&emsp;<code>QNetworkReply</code>是一个顺序访问的<code>QIODevice</code>，这也意味着一旦数据从该对象中读取出来，那么该对象就不再持有这些数据。因此当需要保存数据时，这个工作应该由应用程序完成。无论什么时候从网络中获得数据，<code>readyRead</code>信号都会被触发。<code>downloadProgress</code>信号在接收到数据时也会被发送，但是它所持有的数据量不一定就是真实接收到的数据量。<code>QNetworkReply</code>是一个与应答信息关联的<code>QIODevice</code>，它同样触发<code>uploadProgress</code>信号，这表明<code>upload</code>操作拥有这些数据。注意，不要在连接到<code>error</code>或者<code>finished</code>的槽函数里删除该对象，应该使用<code>deleteLater</code>。</p>
<h4 id="成员类型"><a href="#成员类型" class="headerlink" title="成员类型"></a>成员类型</h4><ul>
<li><code>enum QNetworkReply::NetworkError</code>：表明在处理请求的过程中所有可能的错误情况。</li>
<li><code>typedef QNetworkReply::RawHeaderPair</code>：<code>RawHeaderPair</code>是一个<code>QPair&lt;QByteArray, QByteArray&gt;</code>，第一个<code>QByteArray</code>代表头部的名字，第二个代表头部信息。</li>
<li><code>void QNetworkReply::finished () [signal]</code>：当应答信息被处理完毕时，这个信号就会被触发。当这个信号被触发后，就不会再对应答数据或者元数据进行更新。除非<code>close</code>被调用，否则应答信息会一直被打开等待读取，可以通过<code>read</code>或者<code>readAll</code>方法读取数据。特别地，在<code>readyRead</code>后如果没有调用<code>read</code>，那么调用<code>readAll</code>就会将所有的内容都存储在一个<code>QByteArray</code>中。这个信号和<code>QNetworkAccessManager::finished</code>是串联触发的。注意，不要在与这个信号关联的槽函数中直接删除掉<code>QNetworkReply</code>对象，应该使用<code>deleteLater</code>。你可以在收到<code>finished</code>信号之前使用<code>isFinished</code>函数检查一个<code>QNetworkReply</code>是否已经结束。</li>
</ul>
<p>&emsp;&emsp;另外一些重要的函数就是对应答信息的读取函数了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">qint64 <span class="title">read</span> <span class="params">( <span class="keyword">char</span> *, qint64 )</span></span></span><br><span class="line"><span class="function">QByteArray <span class="title">read</span> <span class="params">( qint64 )</span></span></span><br><span class="line"><span class="function">QByteArray <span class="title">readAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">qint64 <span class="title">readBufferSize</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readChannelFinished</span><span class="params">()</span></span></span><br><span class="line"><span class="function">qint64 <span class="title">readData</span> <span class="params">( <span class="keyword">char</span> *, qint64 )</span></span></span><br><span class="line"><span class="function">qint64 <span class="title">readLine</span> <span class="params">( <span class="keyword">char</span> *, qint64 )</span></span></span><br><span class="line"><span class="function">QByteArray <span class="title">readLine</span> <span class="params">( qint64 )</span></span></span><br><span class="line"><span class="function">qint64 <span class="title">readLineData</span> <span class="params">( <span class="keyword">char</span> *, qint64 )</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readyRead</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QNetworkReply::downloadProgress ( qint64 bytesReceived, qint64 bytesTotal ) [signal]</code>：这个信号被触发，用来表明该网络请求的下载部分的进度。如果该网络请求没有相关联的下载部分，这个信号在参数<code>bytesReceived</code>和<code>bytesTotal</code>的值都为<code>0</code>时，会被触发一次。参数<code>bytesReceived</code>表明已经接收到的数据量，而<code>bytesTotal</code>则表明总共期望下载的数据量。如果期望下载的数据量未知，那么<code>bytesTotal</code>就为<code>-1</code>。当<code>bytesReceived</code>和<code>bytesTotal</code>相等时，就表明下载完毕，此时<code>bytesTotal</code>就不等于<code>-1</code>了。注意，<code>bytesReceived</code>和<code>bytesTotal</code>的值也许都和<code>size</code>不同，它是通过<code>read</code>或者<code>readAll</code>获得的总的数据量，或者表明数据量的头部的值<code>ContentLengthHeader</code>。造成这种情况的原因是：协议头部或者是数据在下载的过程总可能被压缩。</li>
<li><code>void QNetworkReply::uploadProgress ( qint64 bytesSent, qint64 bytesTotal ) [signal]</code>：该信号表示的是网络请求中上传的部分，其它都和上面的<code>downloadProgress</code>类似。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/26/Qt语法详解/Qt之QSyntaxHighlighter/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/26/Qt语法详解/Qt之QSyntaxHighlighter/" itemprop="url">Qt之QSyntaxHighlighter</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-26T20:46:10+08:00">
                2019-01-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QSyntaxHighlighter</code> class allows you to define syntax highlighting rules, and in addition you can use the class to query a document’s current formatting or user data.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Since</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QSyntaxHighlighter</code></td>
<td><code>Qt 4.1</code></td>
<td><code>QObject</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QSyntaxHighlighter(QObject * parent)</code></td>
</tr>
<tr>
<td></td>
<td><code>QSyntaxHighlighter(QTextDocument * parent)</code></td>
</tr>
<tr>
<td></td>
<td><code>QSyntaxHighlighter(QTextEdit * parent)</code></td>
</tr>
<tr>
<td><code>virtual</code></td>
<td><code>~QSyntaxHighlighter()</code></td>
</tr>
<tr>
<td><code>QTextDocument *</code></td>
<td><code>document() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDocument(QTextDocument * doc)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Slots"><a href="#Public-Slots" class="headerlink" title="Public Slots"></a>Public Slots</h3><ul>
<li><code>void rehighlight()</code></li>
<li><code>void rehighlightBlock(const QTextBlock &amp; block)</code></li>
</ul>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextBlock</code></td>
<td><code>currentBlock() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>currentBlockState() const</code></td>
</tr>
<tr>
<td><code>QTextBlockUserData *</code></td>
<td><code>currentBlockUserData() const</code></td>
</tr>
<tr>
<td><code>QTextCharFormat</code></td>
<td><code>format(int position) const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>highlightBlock(const QString &amp; text) = 0</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>previousBlockState() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentBlockState(int newState)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentBlockUserData(QTextBlockUserData * data)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFormat(int start, int count, const QTextCharFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFormat(int start, int count, const QColor &amp; color)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFormat(int start, int count, const QFont &amp; font)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QSyntaxHighlighter</code> class allows you to define syntax highlighting rules, and in addition you can use the class to query a document’s current formatting or user data.<br>&emsp;&emsp;The <code>QSyntaxHighlighter</code> class is a base class for implementing <code>QTextEdit</code> syntax highlighters. A syntax highligher automatically highlights parts of the text in a <code>QTextEdit</code>, or more generally in a <code>QTextDocument</code>. Syntax highlighters are often used when the user is entering text in a specific format (for example source code) and help the user to read the text and identify syntax errors.<br>&emsp;&emsp;To provide your own syntax highlighting, you must subclass <code>QSyntaxHighlighter</code> and reimplement <code>highlightBlock()</code>.<br>&emsp;&emsp;When you create an instance of your <code>QSyntaxHighlighter</code> subclass, pass it the <code>QTextEdit</code> or <code>QTextDocument</code> that you want the syntax highlighting to be applied to. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit *editor = <span class="keyword">new</span> QTextEdit;</span><br><span class="line">MyHighlighter *highlighter = <span class="keyword">new</span> MyHighlighter ( editor-&gt;document() );</span><br></pre></td></tr></table></figure>
<p>After this your <code>highlightBlock()</code> function will be called automatically whenever necessary. Use your <code>highlightBlock()</code> function to apply formatting (e.g. setting the font and color) to the text that is passed to it. <code>QSyntaxHighlighter</code> provides the <code>setFormat()</code> function which applies a given <code>QTextCharFormat</code> on the current text block. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MyHighlighter::highlightBlock ( <span class="keyword">const</span> QString &amp;text ) &#123;</span><br><span class="line">    QTextCharFormat myClassFormat;</span><br><span class="line">    myClassFormat.setFontWeight ( QFont::Bold );</span><br><span class="line">    myClassFormat.setForeground ( Qt::darkMagenta );</span><br><span class="line">    QString pattern = <span class="string">"\\bMy[A-Za-z]+\\b"</span>;</span><br><span class="line">    <span class="function">QRegExp <span class="title">expression</span> <span class="params">( pattern )</span></span>;</span><br><span class="line">    <span class="keyword">int</span> index = text.indexOf ( expression );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( index &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = expression.matchedLength();</span><br><span class="line">        setFormat ( index, length, myClassFormat );</span><br><span class="line">        index = text.indexOf ( expression, index + length );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Some syntaxes can have constructs that span several text blocks. For example, a <code>C++</code> syntax highlighter should be able to cope with <code>/*...*/</code> multiline comments. To deal with these cases it is necessary to know the end state of the previous text block (e.g. <code>in comment</code>).<br>&emsp;&emsp;Inside your <code>highlightBlock()</code> implementation you can query the end state of the previous text block using the <code>previousBlockState()</code> function. After parsing the block you can save the last state using <code>setCurrentBlockState()</code>.<br>&emsp;&emsp;The <code>currentBlockState()</code> and <code>previousBlockState()</code> functions return an int value. If no state is set, the returned value is <code>-1</code>. You can designate any other value to identify any given state using the <code>setCurrentBlockState()</code> function. Once the state is set the <code>QTextBlock</code> keeps that value until it is set set again or until the corresponding paragraph of text is deleted.<br>&emsp;&emsp;For example, if you’re writing a simple <code>C++</code> syntax highlighter, you might designate <code>1</code> to signify <code>in comment</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">QTextCharFormat multiLineCommentFormat;</span><br><span class="line">multiLineCommentFormat.setForeground ( Qt::red );</span><br><span class="line">​</span><br><span class="line"><span class="function">QRegExp <span class="title">startExpression</span> <span class="params">( <span class="string">"/\\*"</span> )</span></span>;</span><br><span class="line"><span class="function">QRegExp <span class="title">endExpression</span> <span class="params">( <span class="string">"\\*/"</span> )</span></span>;</span><br><span class="line">​</span><br><span class="line">setCurrentBlockState ( <span class="number">0</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( previousBlockState() != <span class="number">1</span> ) &#123;</span><br><span class="line">    startIndex = text.indexOf ( startExpression );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( startIndex &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="keyword">int</span> endIndex = text.indexOf ( endExpression, startIndex );</span><br><span class="line">    <span class="keyword">int</span> commentLength;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( endIndex == <span class="number">-1</span> ) &#123;</span><br><span class="line">        setCurrentBlockState ( <span class="number">1</span> );</span><br><span class="line">        commentLength = text.length() - startIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        commentLength = endIndex - startIndex + endExpression.matchedLength();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    setFormat ( startIndex, commentLength, multiLineCommentFormat );</span><br><span class="line">    startIndex = text.indexOf ( startExpression, startIndex + commentLength );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;In the example above, we first set the current block state to <code>0</code>. Then, if the previous block ended within a comment, we higlight from the beginning of the current block (<code>startIndex = 0</code>). Otherwise, we search for the given start expression. If the specified end expression cannot be found in the text block, we change the current block state by calling <code>setCurrentBlockState()</code>, and make sure that the rest of the block is higlighted.<br>&emsp;&emsp;In addition you can query the current formatting and user data using the <code>format()</code> and <code>currentBlockUserData()</code> functions respectively. You can also attach user data to the current text block using the <code>setCurrentBlockUserData()</code> function. <code>QTextBlockUserData</code> can be used to store custom settings. In the case of syntax highlighting, it is in particular interesting as cache storage for information that you may figure out while parsing the paragraph’s text.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QSyntaxHighlighter::QSyntaxHighlighter(QObject * parent)</code>: Constructs a <code>QSyntaxHighlighter</code> with the given <code>parent</code>.</li>
<li><code>QSyntaxHighlighter::QSyntaxHighlighter(QTextDocument * parent)</code>: Constructs a <code>QSyntaxHighlighter</code> and installs it on <code>parent</code>. The specified <code>QTextDocument</code> also becomes the owner of the <code>QSyntaxHighlighter</code>.</li>
<li><code>QSyntaxHighlighter::QSyntaxHighlighter(QTextEdit * parent)</code>: Constructs a <code>QSyntaxHighlighter</code> and installs it on <code>parent&#39;s</code> <code>QTextDocument</code>. The specified <code>QTextEdit</code> also becomes the owner of the <code>QSyntaxHighlighter</code>.</li>
<li><code>QSyntaxHighlighter::~QSyntaxHighlighter() [virtual]</code>: Destructor. Uninstalls this syntax highlighter from the text document.</li>
<li><code>QTextBlock QSyntaxHighlighter::currentBlock() const [protected]</code>: Returns the current text block.</li>
<li><code>int QSyntaxHighlighter::currentBlockState() const [protected]</code>: Returns the state of the current text block. If no value is set, the returned value is <code>-1</code>.</li>
<li><code>QTextBlockUserData * QSyntaxHighlighter::currentBlockUserData() const [protected]</code>: Returns the <code>QTextBlockUserData</code> object previously attached to the current text block.</li>
<li><code>QTextDocument * QSyntaxHighlighter::document() const</code>: Returns the <code>QTextDocument</code> on which this syntax highlighter is installed.</li>
<li><code>QTextCharFormat QSyntaxHighlighter::format(int position) const [protected]</code>: Returns the format at <code>position</code> inside the syntax highlighter’s current text block.</li>
<li><code>void QSyntaxHighlighter::highlightBlock(const QString &amp; text) [pure virtual protected]</code>: Highlights the given <code>text</code> block. This function is called when necessary by the rich <code>text</code> engine, i.e. on <code>text</code> blocks which have changed. To provide your own syntax highlighting, you must subclass <code>QSyntaxHighlighter</code> and reimplement <code>highlightBlock()</code>. In your reimplementation you should parse the block’s <code>text</code> and call <code>setFormat()</code> as often as necessary to apply any font and color changes that you require. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MyHighlighter::highlightBlock ( <span class="keyword">const</span> QString &amp;text ) &#123;</span><br><span class="line">    QTextCharFormat myClassFormat;</span><br><span class="line">    myClassFormat.setFontWeight ( QFont::Bold );</span><br><span class="line">    myClassFormat.setForeground ( Qt::darkMagenta );</span><br><span class="line">    QString pattern = <span class="string">"\\bMy[A-Za-z]+\\b"</span>;</span><br><span class="line">    <span class="function">QRegExp <span class="title">expression</span> <span class="params">( pattern )</span></span>;</span><br><span class="line">    <span class="keyword">int</span> index = text.indexOf ( expression );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> ( index &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = expression.matchedLength();</span><br><span class="line">        setFormat ( index, length, myClassFormat );</span><br><span class="line">        index = text.indexOf ( expression, index + length );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Some syntaxes can have constructs that span several text blocks. For example, a <code>C++</code> syntax highlighter should be able to cope with <code>/*...*/</code> multiline comments. To deal with these cases it is necessary to know the end state of the previous text block (e.g. <code>in comment</code>).<br>&emsp;&emsp;Inside your <code>highlightBlock()</code> implementation you can query the end state of the previous text block using the <code>previousBlockState()</code> function. After parsing the block you can save the last state using <code>setCurrentBlockState()</code>.<br>&emsp;&emsp;The <code>currentBlockState()</code> and <code>previousBlockState()</code> functions return an int value. If no state is set, the returned value is <code>-1</code>. You can designate any other value to identify any given state using the <code>setCurrentBlockState()</code> function. Once the state is set the <code>QTextBlock</code> keeps that value until it is set set again or until the corresponding paragraph of text gets deleted.<br>&emsp;&emsp;For example, if you’re writing a simple <code>C++</code> syntax highlighter, you might designate <code>1</code> to signify <code>in comment</code>. For a text block that ended in the middle of a comment you’d set <code>1</code> using <code>setCurrentBlockState</code>, and for other paragraphs you’d set <code>0</code>. In your parsing code if the return value of <code>previousBlockState()</code> is <code>1</code>, you would highlight the text as a <code>C++</code> comment until you reached the closing <code>*/</code>.</p>
<ul>
<li><code>int QSyntaxHighlighter::previousBlockState() const [protected]</code>: Returns the end state of the text block previous to the syntax highlighter’s current block. If no value was previously set, the returned value is <code>-1</code>.</li>
<li><code>void QSyntaxHighlighter::rehighlight() [slot]</code>: Reapplies the highlighting to the whole document.</li>
<li><code>void QSyntaxHighlighter::rehighlightBlock(const QTextBlock &amp; block) [slot]</code>: Reapplies the highlighting to the given <code>QTextBlock</code> <code>block</code>.</li>
<li><code>void QSyntaxHighlighter::setCurrentBlockState(int newState) [protected]</code>: Sets the state of the current text block to <code>newState</code>.</li>
<li><code>void QSyntaxHighlighter::setCurrentBlockUserData(QTextBlockUserData * data) [protected]</code>: Attaches the given <code>data</code> to the current text block. The ownership is passed to the underlying text document, i.e. the provided <code>QTextBlockUserData</code> object will be deleted if the corresponding text block gets deleted. <code>QTextBlockUserData</code> can be used to store custom settings. In the case of syntax highlighting, it is in particular interesting as cache storage for information that you may figure out while parsing the paragraph’s text. For example while parsing the text, you can keep track of parenthesis characters that you encounter (<code>{[(</code> and the like), and store their relative position and the actual <code>QChar</code> in a simple class derived from <code>QTextBlockUserData</code>:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ParenthesisInfo</span> &#123;</span></span><br><span class="line">    QChar <span class="keyword">char</span>;</span><br><span class="line">    <span class="keyword">int</span> position;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlockData</span> :</span> <span class="keyword">public</span> QTextBlockUserData &#123;</span><br><span class="line">    QVector&lt;ParenthesisInfo&gt; parentheses;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;During cursor navigation in the associated editor, you can ask the current <code>QTextBlock</code> (retrieved using the <code>QTextCursor::block()</code> function) if it has a user data object set and cast it to your <code>BlockData</code> object. Then you can check if the current cursor position matches with a previously recorded parenthesis position, and, depending on the type of parenthesis (opening or closing), find the next opening or closing parenthesis on the same level.<br>&emsp;&emsp;In this way you can do a visual parenthesis matching and highlight from the current cursor position to the matching parenthesis. That makes it easier to spot a missing parenthesis in your code and to find where a corresponding <code>opening/closing</code> parenthesis is when editing parenthesis intensive code.</p>
<ul>
<li><code>void QSyntaxHighlighter::setDocument(QTextDocument * doc)</code>: Installs the syntax highlighter on the given <code>QTextDocument</code> <code>doc</code>. A <code>QSyntaxHighlighter</code> can only be used with one document at a time.</li>
<li><code>void QSyntaxHighlighter::setFormat(int start, int count, const QTextCharFormat &amp; format) [protected]</code>: This function is applied to the syntax highlighter’s current text block (i.e. the text that is passed to the <code>highlightBlock()</code> function). The specified <code>format</code> is applied to the text from the <code>start</code> position for a length of <code>count</code> characters (if <code>count</code> is <code>0</code>, nothing is done). The formatting properties set in <code>format</code> are merged at display time with the formatting information stored directly in the document, for example as previously set with <code>QTextCursor&#39;s</code> functions. Note that the document itself remains unmodified by the <code>format</code> set through this function.</li>
<li><code>void QSyntaxHighlighter::setFormat(int start, int count, const QColor &amp; color) [protected]</code>: This is an overloaded function. The specified <code>color</code> is applied to the current text block from the <code>start</code> position for a length of <code>count</code> characters. The other attributes of the current text block, e.g. the font and background color, are reset to default values.</li>
<li><code>void QSyntaxHighlighter::setFormat(int start, int count, const QFont &amp; font) [protected]</code>: This is an overloaded function. The specified <code>font</code> is applied to the current text block from the <code>start</code> position for a length of <code>count</code> characters. The other attributes of the current text block, e.g. the font and background color, are reset to default values.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/26/Qt语法详解/Qt之QWizardPage/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/26/Qt语法详解/Qt之QWizardPage/" itemprop="url">Qt之QWizardPage</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-26T16:28:02+08:00">
                2019-01-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QWizardPage</code> class is the base class for wizard pages.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Since</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QWizardPage</code></td>
<td><code>Qt 4.3</code></td>
<td><code>QWidget</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QWizardPage(QWidget * parent = 0)</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>buttonText(QWizard::WizardButton which) const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>cleanupPage()</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>initializePage()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isCommitPage() const</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>isComplete() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isFinalPage() const</code></td>
</tr>
<tr>
<td><code>virtual int</code></td>
<td><code>nextId() const</code></td>
</tr>
<tr>
<td><code>QPixmap</code></td>
<td><code>pixmap(QWizard::WizardPixmap which) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setButtonText(QWizard::WizardButton which, const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCommitPage(bool commitPage)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFinalPage(bool finalPage)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPixmap(QWizard::WizardPixmap which, const QPixmap &amp; pixmap)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSubTitle(const QString &amp; subTitle)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTitle(const QString &amp; title)</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>subTitle() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>title() const</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>validatePage()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><ul>
<li><code>void completeChanged()</code></li>
</ul>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Retunrn</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QVariant</code></td>
<td><code>field(const QString &amp; name) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>registerField(const QString &amp; name, QWidget * widget, const char * property = 0, const char * changedSignal = 0)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setField(const QString &amp; name, const QVariant &amp; value)</code></td>
</tr>
<tr>
<td><code>QWizard *</code></td>
<td><code>wizard() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QWizardPage</code> class is the base class for wizard pages.<br>&emsp;&emsp;<code>QWizard</code> represents a wizard. Each page is a <code>QWizardPage</code>. When you create your own wizards, you can use <code>QWizardPage</code> directly, or you can subclass it for more control.<br>&emsp;&emsp;A page has the following attributes, which are rendered by <code>QWizard</code>: a title, a subTitle, and a set of pixmaps. Once a page is added to the wizard (using <code>QWizard::addPage()</code> or <code>QWizard::setPage()</code>), <code>wizard()</code> returns a pointer to the associated <code>QWizard</code> object.<br>&emsp;&emsp;Page provides five virtual functions that can be reimplemented to provide custom behavior:</p>
<ul>
<li><code>initializePage()</code> is called to initialize the page’s contents when the user clicks the wizard’s Next button. If you want to derive the page’s default from what the user entered on previous pages, this is the function to reimplement.</li>
<li><code>cleanupPage()</code> is called to reset the page’s contents when the user clicks the wizard’s Back button.</li>
<li><code>validatePage()</code> validates the page when the user clicks <code>Next</code> or <code>Finish</code>. It is often used to show an error message if the user has entered incomplete or invalid information.</li>
<li><code>nextId()</code> returns the <code>ID</code> of the next page. It is useful when creating <code>non-linear</code> wizards, which allow different traversal paths based on the information provided by the user.</li>
<li><code>isComplete()</code> is called to determine whether the <code>Next</code> and/or <code>Finish</code> button should be enabled or disabled. If you reimplement <code>isComplete()</code>, also make sure that <code>completeChanged()</code> is emitted whenever the complete state changes.</li>
</ul>
<p>&emsp;&emsp;Normally, the <code>Next</code> button and the <code>Finish</code> button of a wizard are mutually exclusive. If <code>isFinalPage()</code> returns <code>true</code>, <code>Finish</code> is available; otherwise, <code>Next</code> is available. By default, <code>isFinalPage()</code> is <code>true</code> only when <code>nextId()</code> returns <code>-1</code>. If you want to show <code>Next</code> and <code>Final</code> simultaneously for a page (letting the user perform an <code>early finish</code>), call <code>setFinalPage(true)</code> on that page. For wizards that support early finishes, you might also want to set the <code>HaveNextButtonOnLastPage</code> and <code>HaveFinishButtonOnEarlyPages</code> options on the wizard.<br>&emsp;&emsp;In many wizards, the contents of a page may affect the default values of the fields of a later page. To make it easy to communicate between pages, <code>QWizard</code> supports a <code>field</code> mechanism that allows you to register a field (e.g., a <code>QLineEdit</code>) on a page and to access its value from any page. Fields are global to the entire wizard and make it easy for any single page to access information stored by another page, without having to put all the logic in <code>QWizard</code> or having the pages know explicitly about each other. Fields are registered using <code>registerField()</code> and can be accessed at any time using <code>field()</code> and <code>setField()</code>.</p>
<h3 id="Property-Documentation"><a href="#Property-Documentation" class="headerlink" title="Property Documentation"></a>Property Documentation</h3><ul>
<li><code>subTitle</code>: This property holds the <code>subtitle</code> of the page. The <code>subtitle</code> is shown by the <code>QWizard</code>, between the title and the actual page. Subtitles are optional. In <code>ClassicStyle</code> and <code>ModernStyle</code>, using subtitles is necessary to make the header appear. In <code>MacStyle</code>, the <code>subtitle</code> is shown as a text label just above the actual page. The <code>subtitle</code> may be <code>plain text</code> or <code>HTML</code>, depending on the value of the <code>QWizard::subTitleFormat</code> property. By default, this property contains an empty string. Access functions:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QString</code></td>
<td><code>subTitle() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSubTitle(const QString &amp; subTitle)</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>title</code>: This property holds the <code>title</code> of the page. The <code>title</code> is shown by the QWizard, above the actual page. All pages should have a <code>title</code>. The <code>title</code> may be <code>plain text</code> or <code>HTML</code>, depending on the value of the <code>QWizard::titleFormat</code> property. By default, this property contains an empty string. Access functions:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QString</code></td>
<td><code>title() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTitle(const QString &amp; title)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QWizardPage::QWizardPage(QWidget * parent = 0)</code>: Constructs a wizard page with the given <code>parent</code>. When the page is inserted into a wizard using <code>QWizard::addPage()</code> or <code>QWizard::setPage()</code>, the <code>parent</code> is automatically set to be the wizard.</li>
<li><code>QString QWizardPage::buttonText(QWizard::WizardButton which) const</code>: Returns the text on button <code>which</code> on this page. If a text has ben set using <code>setButtonText()</code>, this text is returned. Otherwise, if a text has been set using <code>QWizard::setButtonText()</code>, this text is returned. By default, the text on buttons depends on the <code>QWizard::wizardStyle</code>. For example, on <code>Mac OS X</code>, the <code>Next</code> button is called Continue.</li>
<li><code>void QWizardPage::cleanupPage() [virtual]</code>: This virtual function is called by <code>QWizard::cleanupPage()</code> when the user leaves the page by clicking Back (unless the <code>QWizard::IndependentPages</code> option is set). The default implementation resets the page’s fields to their original values (the values they had before <code>initializePage()</code> was called).</li>
<li><code>void QWizardPage::completeChanged() [signal]</code>: This <code>signal</code> is emitted whenever the complete state of the page (i.e., the value of <code>isComplete()</code>) changes. If you reimplement <code>isComplete()</code>, make sure to emit <code>completeChanged()</code> whenever the value of <code>isComplete()</code> changes, to ensure that <code>QWizard</code> updates the enabled or disabled state of its buttons.</li>
<li><code>QVariant QWizardPage::field(const QString &amp; name) const [protected]</code>: Returns the value of the field called <code>name</code>. This function can be used to access fields on any page of the wizard. It is equivalent to calling <code>wizard()-&gt;field(name)</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> OutputFilesPage::initializePage() &#123;</span><br><span class="line">    QString className = field ( <span class="string">"className"</span> ).toString();</span><br><span class="line">    headerLineEdit-&gt;setText ( className.toLower() + <span class="string">".h"</span> );</span><br><span class="line">    implementationLineEdit-&gt;setText ( className.toLower() + <span class="string">".cpp"</span> );</span><br><span class="line">    outputDirLineEdit-&gt;setText ( QDir::convertSeparators ( QDir::tempPath() ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QWizardPage::initializePage() [virtual]</code>: This virtual function is called by <code>QWizard::initializePage()</code> to prepare the page just before it is shown either as a result of <code>QWizard::restart()</code> being called, or as a result of the user clicking <code>Next</code>. (However, if the <code>QWizard::IndependentPages</code> option is set, this function is only called the first time the page is shown.) By reimplementing this function, you can ensure that the page’s fields are properly initialized based on fields from previous pages. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> OutputFilesPage::initializePage() &#123;</span><br><span class="line">    QString className = field ( <span class="string">"className"</span> ).toString();</span><br><span class="line">    headerLineEdit-&gt;setText ( className.toLower() + <span class="string">".h"</span> );</span><br><span class="line">    implementationLineEdit-&gt;setText ( className.toLower() + <span class="string">".cpp"</span> );</span><br><span class="line">    outputDirLineEdit-&gt;setText ( QDir::convertSeparators ( QDir::tempPath() ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The default implementation does nothing.</p>
<ul>
<li><code>bool QWizardPage::isCommitPage() const</code>: Returns <code>true</code> if this page is a commit page; otherwise returns <code>false</code>.</li>
<li><code>bool QWizardPage::isComplete() const [virtual]</code>: This virtual function is called by <code>QWizard</code> to determine whether the <code>Next</code> or <code>Finish</code> button should be enabled or disabled. The default implementation returns <code>true</code> if all mandatory fields are filled; otherwise, it returns <code>false</code>. If you reimplement this function, make sure to emit <code>completeChanged()</code>, from the rest of your implementation, whenever the value of <code>isComplete()</code> changes. This ensures that <code>QWizard</code> updates the enabled or disabled state of its buttons.</li>
<li><code>bool QWizardPage::isFinalPage() const</code>: This function is called by <code>QWizard</code> to determine whether the <code>Finish</code> button should be shown for this page or not. By default, it returns <code>true</code> if there is no next page (i.e., <code>nextId()</code> returns <code>-1</code>); otherwise, it returns <code>false</code>. By explicitly calling <code>setFinalPage(true)</code>, you can let the user perform an <code>early finish</code>.</li>
<li><code>int QWizardPage::nextId() const [virtual]</code>: This virtual function is called by <code>QWizard::nextId()</code> to find out which page to show when the user clicks the <code>Next</code> button. The return value is the <code>ID</code> of the next page, or <code>-1</code> if no page follows. By default, this function returns the lowest <code>ID</code> greater than the <code>ID</code> of the current page, or <code>-1</code> if there is no such <code>ID</code>. By reimplementing this function, you can specify a dynamic page order. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> IntroPage::nextId() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( evaluateRadioButton-&gt;isChecked() ) &#123;</span><br><span class="line">        <span class="keyword">return</span> LicenseWizard::Page_Evaluate;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LicenseWizard::Page_Register;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QPixmap QWizardPage::pixmap(QWizard::WizardPixmap which) const</code>: Returns the pixmap set for role <code>which</code>. Pixmaps can also be set for the entire wizard using <code>QWizard::setPixmap()</code>, in which case they apply for all pages that don’t specify a pixmap.</li>
<li><code>void QWizardPage::registerField(const QString &amp; name, QWidget * widget, const char * property = 0, const char * changedSignal = 0) [protected]</code>: Creates a field called <code>name</code> associated with the given <code>property</code> of the given <code>widget</code>. From then on, that <code>property</code> becomes accessible using <code>field()</code> and <code>setField()</code>. Fields are global to the entire wizard and make it easy for any single page to access information stored by another page, without having to put all the logic in <code>QWizard</code> or having the pages know explicitly about each other. If <code>name</code> ends with an asterisk (<code>*</code>), the field is a mandatory field. When a page has mandatory fields, the <code>Next</code> and/or <code>Finish</code> buttons are enabled only when all mandatory fields are filled. This requires a <code>changedSignal</code> to be specified, to tell <code>QWizard</code> to recheck the value stored by the mandatory field. <code>QWizard</code> knows the most common <code>Qt</code> widgets. For these (or their subclasses), you don’t need to specify a <code>property</code> or a <code>changedSignal</code>. The table below lists these widgets:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Widget</th>
<th>Property</th>
<th>Change Notification Signal</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QAbstractButton</code></td>
<td><code>bool checked</code></td>
<td><code>toggled()</code></td>
</tr>
<tr>
<td><code>QAbstractSlider</code></td>
<td><code>int value</code></td>
<td><code>valueChanged()</code></td>
</tr>
<tr>
<td><code>QComboBox</code></td>
<td><code>int currentIndex</code></td>
<td><code>currentIndexChanged()</code></td>
</tr>
<tr>
<td><code>QDateTimeEdit</code></td>
<td><code>QDateTime dateTime</code></td>
<td><code>dateTimeChanged()</code></td>
</tr>
<tr>
<td><code>QLineEdit</code></td>
<td><code>QString text</code></td>
<td><code>textChanged()</code></td>
</tr>
<tr>
<td><code>QListWidget</code></td>
<td><code>int currentRow</code></td>
<td><code>currentRowChanged()</code></td>
</tr>
<tr>
<td><code>QSpinBox</code></td>
<td><code>int value</code></td>
<td><code>valueChanged()</code></td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;You can use <code>QWizard::setDefaultProperty()</code> to add entries to this table or to override existing entries. To consider a field <code>filled</code>, <code>QWizard</code> simply checks that their current value doesn’t equal their original value (the value they had before <code>initializePage()</code> was called). For <code>QLineEdit</code>, it also checks that <code>hasAcceptableInput()</code> returns <code>true</code>, to honor any validator or mask. <code>QWizard&#39;s</code> mandatory field mechanism is provided for convenience. It can be bypassed by reimplementing <code>QWizardPage::isComplete()</code>.</p>
<ul>
<li><code>void QWizardPage::setButtonText(QWizard::WizardButton which, const QString &amp; text)</code>: Sets the <code>text</code> on button which to be <code>text</code> on this page. By default, the <code>text</code> on buttons depends on the <code>QWizard::wizardStyle</code>, but may be redefined for the wizard as a whole using <code>QWizard::setButtonText()</code>.</li>
<li><code>void QWizardPage::setCommitPage(bool commitPage)</code>: Sets this page to be a commit page if <code>commitPage</code> is <code>true</code>; otherwise, sets it to be a normal page. A commit page is a page that represents an action which cannot be undone by clicking <code>Back</code> or <code>Cancel</code>. A <code>Commit</code> button replaces the <code>Next</code> button on a commit page. Clicking this button simply calls <code>QWizard::next()</code> just like clicking <code>Next</code> does. A page entered directly from a commit page has its <code>Back</code> button disabled.</li>
<li><code>void QWizardPage::setField(const QString &amp; name, const QVariant &amp; value) [protected]</code>: Sets the <code>value</code> of the field called name to <code>value</code>. This function can be used to set fields on any page of the wizard. It is equivalent to calling <code>wizard()-&gt;setField(name, value)</code>.</li>
<li><code>void QWizardPage::setFinalPage(bool finalPage)</code>: Explicitly sets this page to be final if <code>finalPage</code> is <code>true</code>. After calling <code>setFinalPage(true)</code>, <code>isFinalPage()</code> returns <code>true</code> and the <code>Finish</code> button is visible (and enabled if <code>isComplete()</code> returns <code>true</code>). After calling <code>setFinalPage(false)</code>, <code>isFinalPage()</code> returns <code>true</code> if <code>nextId()</code> returns <code>-1</code>; otherwise, it returns <code>false</code>.</li>
<li><code>void QWizardPage::setPixmap(QWizard::WizardPixmap which, const QPixmap &amp; pixmap)</code>: Sets the <code>pixmap</code> for role which to <code>pixmap</code>. The pixmaps are used by <code>QWizard</code> when displaying a page. Which pixmaps are actually used depend on the wizard style. Pixmaps can also be set for the entire wizard using <code>QWizard::setPixmap()</code>, in which case they apply for all pages that don’t specify a pixmap.</li>
<li><code>bool QWizardPage::validatePage() [virtual]</code>: This virtual function is called by <code>QWizard::validateCurrentPage()</code> when the user clicks <code>Next</code> or <code>Finish</code> to perform some <code>last-minute</code> validation. If it returns <code>true</code>, the next page is shown (or the wizard finishes); otherwise, the current page stays up. The default implementation returns <code>true</code>. When possible, it is usually better style to disable the <code>Next</code> or <code>Finish</code> button (by specifying mandatory fields or reimplementing <code>isComplete()</code>) than to reimplement <code>validatePage()</code>.</li>
<li><code>QWizard * QWizardPage::wizard() const [protected]</code>: Returns the wizard associated with this page, or <code>0</code> if this page hasn’t been inserted into a <code>QWizard</code> yet.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/26/Qt语法详解/Qt之QTextCodec/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/26/Qt语法详解/Qt之QTextCodec/" itemprop="url">Qt之QTextCodec</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-26T12:39:17+08:00">
                2019-01-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTextCodec</code> class provides conversions between text encodings. The header file is <code>QTextCodec</code>. <strong>Note</strong>: All functions in this class are reentrant, except for <code>setCodecForTr()</code>, <code>setCodecForCStrings()</code>, and <code>~QTextCodec()</code>, which are nonreentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual QList&lt;QByteArray&gt;</code></td>
<td><code>aliases() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>canEncode(QChar ch) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>canEncode(const QString &amp; s) const</code></td>
</tr>
<tr>
<td><code>QByteArray</code></td>
<td><code>fromUnicode(const QString &amp; str) const</code></td>
</tr>
<tr>
<td><code>QByteArray</code></td>
<td><code>fromUnicode(const QChar * input, int number, ConverterState * state = 0) const</code></td>
</tr>
<tr>
<td><code>QTextDecoder *</code></td>
<td><code>makeDecoder() const</code></td>
</tr>
<tr>
<td><code>QTextDecoder *</code></td>
<td><code>makeDecoder(ConversionFlags flags) const</code></td>
</tr>
<tr>
<td><code>QTextEncoder *</code></td>
<td><code>makeEncoder() const</code></td>
</tr>
<tr>
<td><code>QTextEncoder *</code></td>
<td><code>makeEncoder(ConversionFlags flags) const</code></td>
</tr>
<tr>
<td><code>virtual int</code></td>
<td><code>mibEnum() const = 0</code></td>
</tr>
<tr>
<td><code>virtual QByteArray</code></td>
<td><code>name() const = 0</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>toUnicode(const QByteArray &amp; a) const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>toUnicode(const char * input, int size, ConverterState * state = 0) const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>toUnicode(const char * chars) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Static-Public-Members"><a href="#Static-Public-Members" class="headerlink" title="Static Public Members"></a>Static Public Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QList&lt;QByteArray&gt;</code></td>
<td><code>availableCodecs()</code></td>
</tr>
<tr>
<td><code>QList&lt;int&gt;</code></td>
<td><code>availableMibs()</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForCStrings()</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForHtml(const QByteArray &amp; ba, QTextCodec * defaultCodec)</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForHtml(const QByteArray &amp; ba)</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForLocale()</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForMib(int mib)</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForName(const QByteArray &amp; name)</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForName(const char * name)</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForTr()</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForUtfText(const QByteArray &amp; ba, QTextCodec * defaultCodec)</code></td>
</tr>
<tr>
<td><code>QTextCodec *</code></td>
<td><code>codecForUtfText(const QByteArray &amp; ba)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCodecForCStrings(QTextCodec * codec)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCodecForLocale(QTextCodec * c)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCodecForTr(QTextCodec * c)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextCodec()</code></td>
</tr>
<tr>
<td><code>virtual</code></td>
<td><code>QTextCodec()</code></td>
</tr>
<tr>
<td><code>virtual QByteArray</code></td>
<td><code>convertFromUnicode(const QChar * input, int number, ConverterState * state) const = 0</code></td>
</tr>
<tr>
<td><code>virtual QString</code></td>
<td><code>convertToUnicode(const char * chars, int len, ConverterState * state) const = 0</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextCodec</code> class provides conversions between text encodings. <code>Qt</code> uses Unicode to store, draw and manipulate strings. In many situations you may wish to deal with data that uses a different encoding. For example, most <code>Japanese</code> documents are still stored in <code>Shift-JIS</code> or <code>ISO 2022-JP</code>, while Russian users often have their documents in <code>KOI8-R</code> or <code>Windows-1251</code>. <code>Qt</code> provides a set of <code>QTextCodec</code> classes to help with converting <code>non-Unicode</code> formats to and from <code>Unicode</code>. You can also create your own codec classes.<br>&emsp;&emsp;The supported encodings are: <code>Apple Roman</code>; <code>Big5</code>; <code>Big5-HKSCS</code>; <code>CP949</code>; <code>EUC-JP</code>; <code>EUC-KR</code>; <code>GB18030-0</code>; <code>IBM 850</code>; <code>IBM 866</code>; <code>IBM 874</code>; <code>ISO 2022-JP</code>; <code>ISO 8859-1 to 10</code>; <code>ISO 8859-13 to 16</code>; <code>Iscii-Bng</code>, <code>Dev</code>, <code>Gjr</code>, <code>Knd</code>, <code>Mlm</code>, <code>Ori</code>, <code>Pnj</code>, <code>Tlg</code>, and <code>Tml</code>; <code>JIS X 0201</code>; <code>JIS X 0208</code>; <code>KOI8-R</code>; <code>KOI8-U</code>; <code>MuleLao-1</code>; <code>ROMAN8</code>; <code>Shift-JIS</code>; <code>TIS-620</code>; <code>TSCII</code>; <code>UTF-8</code>; <code>UTF-16</code>; <code>UTF-16BE</code>; <code>UTF-16LE</code>; <code>UTF-32</code>; <code>UTF-32BE</code>; <code>UTF-32LE</code>; <code>Windows-1250 to 1258</code>; <code>WINSAMI2</code>.<br>&emsp;&emsp;<code>QTextCodecs</code> can be used as follows to convert some locally encoded string to <code>Unicode</code>. Suppose you have some string encoded in <code>Russian KOI8-R</code> encoding, and want to convert it to <code>Unicode</code>. The simple way to do it is like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QByteArray encodedString = <span class="string">"..."</span>;</span><br><span class="line">QTextCodec *codec = QTextCodec::codecForName ( <span class="string">"KOI8-R"</span> );</span><br><span class="line">QString <span class="built_in">string</span> = codec-&gt;toUnicode ( encodedString );</span><br></pre></td></tr></table></figure>
<p>After this, string holds the text converted to <code>Unicode</code>. Converting a string from <code>Unicode</code> to the local encoding is just as easy:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString <span class="built_in">string</span> = <span class="string">"..."</span>;</span><br><span class="line">QTextCodec *codec = QTextCodec::codecForName ( <span class="string">"KOI8-R"</span> );</span><br><span class="line">QByteArray encodedString = codec-&gt;fromUnicode ( <span class="built_in">string</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;To read or write files in various encodings, use <code>QTextStream</code> and its <code>setCodec()</code> function. See the <code>Codecs</code> example for an application of <code>QTextCodec</code> to file <code>I/O</code>.<br>&emsp;&emsp;Some care must be taken when trying to convert the data in chunks, for example, when receiving it over a network. In such cases it is possible that a <code>multi-byte</code> character will be split over two chunks. At best this might result in the loss of a character and at worst cause the entire conversion to fail.<br>&emsp;&emsp;The approach to use in these situations is to create a <code>QTextDecoder</code> object for the codec and use this <code>QTextDecoder</code> for the whole decoding process, as shown below:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QTextCodec *codec = QTextCodec::codecForName ( <span class="string">"Shift-JIS"</span> );</span><br><span class="line">QTextDecoder *decoder = codec-&gt;makeDecoder();</span><br><span class="line">​</span><br><span class="line">QString <span class="built_in">string</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( new_data_available() ) &#123;</span><br><span class="line">    QByteArray chunk = get_new_data();</span><br><span class="line">    <span class="built_in">string</span> += decoder-&gt;toUnicode ( chunk );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">delete</span> decoder;</span><br></pre></td></tr></table></figure>
<p>The <code>QTextDecoder</code> object maintains state between chunks and therefore works correctly even if a <code>multi-byte</code> character is split between chunks.</p>
<h3 id="Creating-Your-Own-Codec-Class"><a href="#Creating-Your-Own-Codec-Class" class="headerlink" title="Creating Your Own Codec Class"></a>Creating Your Own Codec Class</h3><p>&emsp;&emsp;Support for new text encodings can be added to <code>Qt</code> by creating <code>QTextCodec</code> subclasses.<br>&emsp;&emsp;The pure virtual functions describe the encoder to the system and the coder is used as required in the different text file formats supported by <code>QTextStream</code>, and under <code>X11</code>, for the <code>locale-specific</code> character input and output.<br>&emsp;&emsp;To add support for another encoding to <code>Qt</code>, make a subclass of <code>QTextCodec</code> and implement the functions listed in the table below.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name()</code></td>
<td>Returns the official name for the encoding. If the encoding is listed in the <code>IANA</code> <code>character-sets</code> encoding file, the name should be the preferred <code>MIME</code> name for the encoding.</td>
</tr>
<tr>
<td><code>aliases()</code></td>
<td>Returns a list of alternative names for the encoding. <code>QTextCodec</code> provides a default implementation that returns an empty list. For example, <code>ISO-8859-1</code> has <code>latin1</code>, <code>CP819</code>, <code>IBM819</code>, and <code>iso-ir-100</code> as aliases.</td>
</tr>
<tr>
<td><code>mibEnum()</code></td>
<td>Return the <code>MIB</code> enum for the encoding if it is listed in the <code>IANA</code> <code>character-sets</code> encoding file.</td>
</tr>
<tr>
<td><code>convertToUnicode()</code></td>
<td>Converts an <code>8-bit</code> character string to <code>Unicode</code>.</td>
</tr>
<tr>
<td><code>convertFromUnicode()</code></td>
<td>Converts a <code>Unicode</code> string to an <code>8-bit</code> character string.</td>
</tr>
</tbody>
</table>
</div>
<p>You may find it more convenient to make your codec class available as a plugin.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QTextCodec::ConversionFlag</code>:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCodec::DefaultConversion</code></td>
<td><code>0</code></td>
<td>No flag is set.</td>
</tr>
<tr>
<td><code>QTextCodec::ConvertInvalidToNull</code></td>
<td><code>0x80000000</code></td>
<td>If this flag is set, each invalid input character is output as a null character.</td>
</tr>
<tr>
<td><code>QTextCodec::IgnoreHeader</code></td>
<td><code>0x1</code></td>
<td>Ignore any <code>Unicode</code> <code>byte-order</code> mark and don’t generate any.</td>
</tr>
</tbody>
</table>
</div>
<p>The <code>ConversionFlags</code> type is a typedef for <code>QFlags&lt;ConversionFlag&gt;</code>. It stores an <code>OR</code> combination of <code>ConversionFlag</code> values.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextCodec::QTextCodec() [protected]</code>: Constructs a <code>QTextCodec</code>, and gives it the highest precedence. The <code>QTextCodec</code> should always be constructed on the heap (i.e. with new). <code>Qt</code> takes ownership and will delete it when the application terminates.</li>
<li><code>QTextCodec::~QTextCodec() [virtual protected]</code>: Destroys the <code>QTextCodec</code>. Note that you should not delete codecs yourself: once created they become <code>Qt&#39;s</code> responsibility. <strong>Warning</strong>: This function is not reentrant.</li>
<li><code>QList&lt;QByteArray&gt; QTextCodec::aliases() const [virtual]</code>: Subclasses can return a number of aliases for the codec in question. Standard aliases for codecs can be found in the <code>IANA</code> <code>character-sets</code> encoding file.</li>
<li><code>QList&lt;QByteArray&gt; QTextCodec::availableCodecs() [static]</code>: Returns the list of all available codecs, by name. Call <code>QTextCodec::codecForName()</code> to obtain the <code>QTextCodec</code> for the name. The list may contain many mentions of the same codec if the codec has aliases.</li>
<li><code>QList&lt;int&gt; QTextCodec::availableMibs() [static]</code>: Returns the list of <code>MIBs</code> for all available codecs. Call <code>QTextCodec::codecForMib()</code> to obtain the <code>QTextCodec</code> for the <code>MIB</code>.</li>
<li><code>bool QTextCodec::canEncode(QChar ch) const</code>: Returns <code>true</code> if the Unicode character <code>ch</code> can be fully encoded with this codec; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCodec::canEncode(const QString &amp; s) const</code>: This is an overloaded function. <code>s</code> contains the string being tested for <code>encode-ability</code>.</li>
<li><code>QTextCodec * QTextCodec::codecForCStrings() [static]</code>: Returns the codec used by <code>QString</code> to convert to and from <code>const char *</code> and <code>QByteArrays</code>. If this function returns <code>0</code> (the default), <code>QString</code> assumes <code>Latin-1</code>.</li>
<li><code>QTextCodec * QTextCodec::codecForHtml(const QByteArray &amp; ba, QTextCodec * defaultCodec) [static]</code>: Tries to detect the encoding of the provided snippet of <code>HTML</code> in the given byte array, ba, by checking the <code>BOM (Byte Order Mark</code>) and the <code>content-type</code> meta header and returns a <code>QTextCodec</code> instance that is capable of decoding the html to unicode. If the codec cannot be detected from the content provided, <code>defaultCodec</code> is returned.</li>
<li><code>QTextCodec * QTextCodec::codecForHtml(const QByteArray &amp; ba) [static]</code>: This is an overloaded function. Tries to detect the encoding of the provided snippet of <code>HTML</code> in the given byte array, <code>ba</code>, by checking the <code>BOM (Byte Order Mark)</code> and the <code>content-type</code> meta header and returns a <code>QTextCodec</code> instance that is capable of decoding the html to unicode. If the codec cannot be detected, this overload returns a <code>Latin-1</code> <code>QTextCodec</code>.</li>
<li><code>QTextCodec * QTextCodec::codecForLocale() [static]</code>: Returns a pointer to the codec most suitable for this locale. On <code>Windows</code>, the codec will be based on a system locale. On <code>Unix</code> systems, starting with <code>Qt 4.2</code>, the codec will be using the iconv library. Note that in both cases the codec’s name will be <code>System</code>.</li>
<li><code>QTextCodec * QTextCodec::codecForMib(int mib) [static]</code>: Returns the <code>QTextCodec</code> which matches the <code>MIBenum</code> <code>mib</code>.</li>
<li><code>QTextCodec * QTextCodec::codecForName(const QByteArray &amp; name) [static]</code>: Searches all installed <code>QTextCodec</code> objects and returns the one which best matches <code>name</code>; the match is <code>case-insensitive</code>.</li>
<li><code>QTextCodec * QTextCodec::codecForName(const char * name) [static]</code>: Searches all installed <code>QTextCodec</code> objects and returns the one which best matches <code>name</code>; the match is <code>case-insensitive</code>.</li>
<li><code>QTextCodec * QTextCodec::codecForTr() [static]</code>: Returns the codec used by <code>QObject::tr()</code> on its argument. If this function returns <code>0</code> (the default), <code>tr()</code> assumes <code>Latin-1</code>.</li>
<li><code>QTextCodec * QTextCodec::codecForUtfText(const QByteArray &amp; ba, QTextCodec * defaultCodec) [static]</code>: Tries to detect the encoding of the provided snippet <code>ba</code> by using the <code>BOM (Byte Order Mark)</code> and returns a <code>QTextCodec</code> instance that is capable of decoding the text to unicode. If the codec cannot be detected from the content provided, <code>defaultCodec</code> is returned.</li>
<li><code>QTextCodec * QTextCodec::codecForUtfText(const QByteArray &amp; ba) [static]</code>: This is an overloaded function. Tries to detect the encoding of the provided snippet <code>ba</code> by using the <code>BOM (Byte Order Mark)</code> and returns a <code>QTextCodec</code> instance that is capable of decoding the text to unicode. If the codec cannot be detected, this overload returns a <code>Latin-1</code> <code>QTextCodec</code>.</li>
<li><code>QByteArray QTextCodec::convertFromUnicode(const QChar * input, int number, ConverterState * state) const [pure virtual protected]</code>: <code>QTextCodec</code> subclasses must reimplement this function. Converts the first <code>number</code> of characters from the <code>input</code> array from <code>Unicode</code> to the encoding of the subclass, and returns the result in a <code>QByteArray</code>. <code>state</code> can be <code>0</code> in which case the conversion is stateless and default conversion rules should be used. If <code>state</code> is not <code>0</code>, the codec should save the <code>state</code> after the conversion in <code>state</code>, and adjust the <code>remainingChars</code> and <code>invalidChars</code> members of the struct.</li>
<li><code>QString QTextCodec::convertToUnicode(const char * chars, int len, ConverterState * state) const [pure virtual protected]</code>: <code>QTextCodec</code> subclasses must reimplement this function. Converts the first <code>len</code> characters of <code>chars</code> from the encoding of the subclass to <code>Unicode</code>, and returns the result in a <code>QString</code>. <code>state</code> can be <code>0</code>, in which case the conversion is stateless and default conversion rules should be used. If <code>state</code> is not <code>0</code>, the codec should save the <code>state</code> after the conversion in <code>state</code>, and adjust the <code>remainingChars</code> and <code>invalidChars</code> members of the struct.</li>
<li><code>QByteArray QTextCodec::fromUnicode(const QString &amp; str) const</code>: Converts <code>str</code> from <code>Unicode</code> to the encoding of this codec, and returns the result in a <code>QByteArray</code>.</li>
<li><code>QByteArray QTextCodec::fromUnicode(const QChar * input, int number, ConverterState * state = 0) const</code>: Converts the first <code>number</code> of characters from the <code>input</code> array from <code>Unicode</code> to the encoding of this codec, and returns the result in a <code>QByteArray</code>. The <code>state</code> of the convertor used is updated.</li>
<li><code>QTextDecoder * QTextCodec::makeDecoder() const</code>: Creates a <code>QTextDecoder</code> which stores enough state to decode chunks of <code>char *</code> data to create chunks of <code>Unicode</code> data. The caller is responsible for deleting the returned object.</li>
<li><code>QTextDecoder * QTextCodec::makeDecoder(ConversionFlags flags) const</code>: Creates a <code>QTextDecoder</code> with a specified flags to decode chunks of <code>char *</code> data to create chunks of <code>Unicode</code> data. The caller is responsible for deleting the returned object.</li>
<li><code>QTextEncoder * QTextCodec::makeEncoder() const</code>: Creates a <code>QTextEncoder</code> which stores enough state to encode chunks of <code>Unicode</code> data as <code>char *</code> data. The caller is responsible for deleting the returned object.</li>
<li><code>QTextEncoder * QTextCodec::makeEncoder(ConversionFlags flags) const</code>: Creates a <code>QTextEncoder</code> with a specified <code>flags</code> to encode chunks of <code>Unicode</code> data as <code>char *</code> data. The caller is responsible for deleting the returned object.</li>
<li><code>int QTextCodec::mibEnum() const [pure virtual]</code>: Subclasses of <code>QTextCodec</code> must reimplement this function. It returns the <code>MIBenum</code>. It is important that each <code>QTextCodec</code> subclass returns the correct unique value for this function.</li>
<li><code>QByteArray QTextCodec::name() const [pure virtual]</code>: <code>QTextCodec</code> subclasses must reimplement this function. It returns the name of the encoding supported by the subclass. If the codec is registered as a character set in the <code>IANA</code> <code>character-sets</code> encoding file this method should return the preferred mime name for the codec if defined, otherwise its name.</li>
<li><code>void QTextCodec::setCodecForCStrings(QTextCodec * codec) [static]</code>: Sets the <code>codec</code> used by <code>QString</code> to convert to and from <code>const char *</code> and <code>QByteArrays</code>. If the <code>codec</code> is <code>0</code> (the default), <code>QString</code> assumes <code>Latin-1</code>. <strong>Warning</strong>: Some codecs do not preserve the characters in the <code>ASCII</code> range (<code>0x00</code> to <code>0x7F</code>). For example, the <code>Japanese</code> <code>Shift-JIS</code> encoding maps the backslash character (<code>0x5A</code>) to the <code>Yen</code> character. To avoid undesirable <code>side-effects</code>, we recommend avoiding such codecs with <code>setCodecsForCString()</code>. <strong>Warning</strong>: This function is not reentrant.</li>
<li><code>void QTextCodec::setCodecForLocale(QTextCodec * c) [static]</code>: Set the codec to <code>c</code>; this will be returned by <code>codecForLocale()</code>. If <code>c</code> is a null pointer, the codec is reset to the default. This might be needed for some applications that want to use their own mechanism for setting the locale.</li>
<li><code>void QTextCodec::setCodecForTr(QTextCodec * c) [static]</code>: Sets the codec used by <code>QObject::tr()</code> on its argument to <code>c</code>. If <code>c</code> is <code>0</code> (the default), <code>tr()</code> assumes <code>Latin-1</code>. If the literal quoted text in the program is not in the <code>Latin-1</code> encoding, this function can be used to set the appropriate encoding. For example, software developed by <code>Korean</code> programmers might use <code>eucKR</code> for all the text in the program, in which case the <code>main()</code> function might look like this:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span> <span class="params">( argc, argv )</span></span>;</span><br><span class="line">    QTextCodec::setCodecForTr ( QTextCodec::codecForName ( <span class="string">"eucKR"</span> ) );</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that this is not the way to select the encoding that the user has chosen. For example, to convert an application containing literal <code>English</code> strings to <code>Korean</code>, all that is needed is for the <code>English</code> strings to be passed through <code>tr()</code> and for translation files to be loaded. <strong>Warning</strong>: This function is not reentrant.</p>
<ul>
<li><code>QString QTextCodec::toUnicode(const QByteArray &amp; a) const</code>: Converts <code>a</code> from the encoding of this codec to <code>Unicode</code>, and returns the result in a <code>QString</code>.</li>
<li><code>QString QTextCodec::toUnicode(const char * input, int size, ConverterState * state = 0) const</code>: Converts the first <code>size</code> characters from the <code>input</code> from the encoding of this codec to <code>Unicode</code>, and returns the result in a <code>QString</code>. The <code>state</code> of the convertor used is updated.</li>
<li><code>QString QTextCodec::toUnicode(const char * chars) const</code>: This is an overloaded function. <code>chars</code> contains the source characters.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/25/Qt语法详解/Qt之QTextCharFormat/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/Qt语法详解/Qt之QTextCharFormat/" itemprop="url">Qt之QTextCharFormat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-25T20:51:00+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QTextCharFormat</code> class provides formatting information for characters in a <code>QTextDocument</code>.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCharFormat</code></td>
<td><code>QTextFormat</code></td>
<td><code>QTextImageFormat</code> and <code>QTextTableCellFormat</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextCharFormat()</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>anchorHref() const</code></td>
</tr>
<tr>
<td><code>QStringList</code></td>
<td><code>anchorNames() const</code></td>
</tr>
<tr>
<td><code>QFont</code></td>
<td><code>font() const</code></td>
</tr>
<tr>
<td><code>QFont::Capitalization</code></td>
<td><code>fontCapitalization() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>fontFamily() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>fontFixedPitch() const</code></td>
</tr>
<tr>
<td><code>QFont::HintingPreference</code></td>
<td><code>fontHintingPreference() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>fontItalic() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>fontKerning() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>fontLetterSpacing() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>fontOverline() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>fontPointSize() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>fontStrikeOut() const</code></td>
</tr>
<tr>
<td><code>QFont::StyleHint</code></td>
<td><code>fontStyleHint() const</code></td>
</tr>
<tr>
<td><code>QFont::StyleStrategy</code></td>
<td><code>fontStyleStrategy() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>fontUnderline() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>fontWeight() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>fontWordSpacing() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isAnchor() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isValid() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setAnchor(bool anchor)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setAnchorHref(const QString &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setAnchorNames(const QStringList &amp; names)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFont(const QFont &amp; font)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontCapitalization(QFont::Capitalization capitalization)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontFamily(const QString &amp; family)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontFixedPitch(bool fixedPitch)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontHintingPreference(QFont::HintingPreference hintingPreference)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontItalic(bool italic)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontKerning(bool enable)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontLetterSpacing(qreal spacing)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontOverline(bool overline)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontPointSize(qreal size)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontStrikeOut(bool strikeOut)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontStyleHint(QFont::StyleHint hint, QFont::StyleStrategy strategy = QFont::PreferDefault)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontStyleStrategy(QFont::StyleStrategy strategy)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontUnderline(bool underline)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontWeight(int weight)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFontWordSpacing(qreal spacing)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTextOutline(const QPen &amp; pen)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setToolTip(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUnderlineColor(const QColor &amp; color)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUnderlineStyle(UnderlineStyle style)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setVerticalAlignment(VerticalAlignment alignment)</code></td>
</tr>
<tr>
<td><code>QPen</code></td>
<td><code>textOutline() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>toolTip() const</code></td>
</tr>
<tr>
<td><code>QColor</code></td>
<td><code>underlineColor() const</code></td>
</tr>
<tr>
<td><code>UnderlineStyle</code></td>
<td><code>underlineStyle() const</code></td>
</tr>
<tr>
<td><code>VerticalAlignment</code></td>
<td><code>verticalAlignment() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextCharFormat</code> class provides formatting information for characters in a <code>QTextDocument</code>.<br>&emsp;&emsp;The character format of text in a document specifies the visual properties of the text, as well as information about its role in a hypertext document.<br>&emsp;&emsp;The font used can be set by supplying a font to the <code>setFont()</code> function, and each aspect of its appearance can be adjusted to give the desired effect. <code>setFontFamily()</code> and <code>setFontPointSize()</code> define the font’s family (e.g. <code>Times</code>) and printed size; <code>setFontWeight()</code> and <code>setFontItalic()</code> provide control over the style of the font. <code>setFontUnderline()</code>, <code>setFontOverline()</code>, <code>setFontStrikeOut()</code>, and <code>setFontFixedPitch()</code> provide additional effects for text.<br>&emsp;&emsp;The color is set with <code>setForeground()</code>. If the text is intended to be used as an anchor (for hyperlinks), this can be enabled with <code>setAnchor()</code>. The <code>setAnchorHref()</code> and <code>setAnchorNames()</code> functions are used to specify the information about the hyperlink’s destination and the anchor’s name.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QTextCharFormat::UnderlineStyle</code>: This enum describes the different ways drawing underlined text.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCharFormat::NoUnderline</code></td>
<td><code>0</code></td>
<td>Text is draw without any underlining decoration.</td>
</tr>
<tr>
<td><code>QTextCharFormat::SingleUnderline</code></td>
<td><code>1</code></td>
<td>A line is drawn using <code>Qt::SolidLine</code>.</td>
</tr>
<tr>
<td><code>QTextCharFormat::DashUnderline</code></td>
<td><code>2</code></td>
<td>Dashes are drawn using <code>Qt::DashLine</code>.</td>
</tr>
<tr>
<td><code>QTextCharFormat::DotLine</code></td>
<td><code>3</code></td>
<td>Dots are drawn using <code>Qt::DotLine</code>.</td>
</tr>
<tr>
<td><code>QTextCharFormat::DashDotLine</code></td>
<td><code>4</code></td>
<td>Dashs and dots are drawn using <code>Qt::DashDotLine</code>.</td>
</tr>
<tr>
<td><code>QTextCharFormat::DashDotDotLine</code></td>
<td><code>5</code></td>
<td>Underlines draw drawn using <code>Qt::DashDotDotLine</code>.</td>
</tr>
<tr>
<td><code>QTextCharFormat::WaveUnderline</code></td>
<td><code>6</code></td>
<td>The text is underlined using a wave shaped line.</td>
</tr>
<tr>
<td><code>QTextCharFormat::SpellCheckUnderline</code></td>
<td><code>7</code></td>
<td>The underline is drawn depending on the <code>QStyle::SH_SpellCeckUnderlineStyle</code> style hint of the <code>QApplication</code> style. By default this is mapped to <code>WaveUnderline</code>, on <code>Mac OS X</code> it is mapped to <code>DashDotLine</code>.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QTextCharFormat::VerticalAlignment</code>: This enum describes the ways that adjacent characters can be vertically aligned.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCharFormat::AlignNormal</code></td>
<td><code>0</code></td>
<td>Adjacent characters are positioned in the standard way for text in the writing system in use.</td>
</tr>
<tr>
<td><code>QTextCharFormat::AlignSuperScript</code></td>
<td><code>1</code></td>
<td>Characters are placed above the base line for normal text.</td>
</tr>
<tr>
<td><code>QTextCharFormat::AlignSubScript</code></td>
<td><code>2</code></td>
<td>Characters are placed below the base line for normal text.</td>
</tr>
<tr>
<td><code>QTextCharFormat::AlignMiddle</code></td>
<td><code>3</code></td>
<td>The center of the object is vertically aligned with the base line. Currently, this is only implemented for inline objects.</td>
</tr>
<tr>
<td><code>QTextCharFormat::AlignBottom</code></td>
<td><code>5</code></td>
<td>The bottom edge of the object is vertically aligned with the base line.</td>
</tr>
<tr>
<td><code>QTextCharFormat::AlignTop</code></td>
<td><code>4</code></td>
<td>The top edge of the object is vertically aligned with the base line.</td>
</tr>
<tr>
<td><code>QTextCharFormat::AlignBaseline</code></td>
<td><code>6</code></td>
<td>The base lines of the characters are aligned.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextCharFormat::QTextCharFormat()</code>: Constructs a new character format object.</li>
<li><code>QString QTextCharFormat::anchorHref() const</code>: Returns the text format’s hypertext link, or an empty string if none has been set.</li>
<li><code>QStringList QTextCharFormat::anchorNames() const</code>: Returns the anchor names associated with this text format, or an empty string list if none has been set. If the anchor names are set, text with this format can be the destination of a hypertext link.</li>
<li><code>QFont QTextCharFormat::font() const</code>: Returns the font for this character format.</li>
<li><code>QFont::Capitalization QTextCharFormat::fontCapitalization() const</code>: Returns the current capitalization type of the font.</li>
<li><code>QString QTextCharFormat::fontFamily() const</code>: Returns the text format’s font family.</li>
<li><code>bool QTextCharFormat::fontFixedPitch() const</code>: Returns <code>true</code> if the text format’s font is fixed pitch; otherwise returns <code>false</code>.</li>
<li><code>QFont::HintingPreference QTextCharFormat::fontHintingPreference() const</code>: Returns the hinting preference set for this text format.</li>
<li><code>bool QTextCharFormat::fontItalic() const</code>: Returns <code>true</code> if the text format’s font is italic; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCharFormat::fontKerning() const</code>: Returns <code>true</code> if the font kerning is enabled.</li>
<li><code>qreal QTextCharFormat::fontLetterSpacing() const</code>: Returns the current letter spacing percentage.</li>
<li><code>bool QTextCharFormat::fontOverline() const</code>: Returns <code>true</code> if the text format’s font is overlined; otherwise returns <code>false</code>.</li>
<li><code>qreal QTextCharFormat::fontPointSize() const</code>: Returns the font size used to display text in this format.</li>
<li><code>bool QTextCharFormat::fontStrikeOut() const</code>: Returns <code>true</code> if the text format’s font is struck out (has a horizontal line drawn through it); otherwise returns <code>false</code>.</li>
<li><code>QFont::StyleHint QTextCharFormat::fontStyleHint() const</code>: Returns the font style hint.</li>
<li><code>QFont::StyleStrategy QTextCharFormat::fontStyleStrategy() const</code>: Returns the current font style strategy.</li>
<li><code>bool QTextCharFormat::fontUnderline() const</code>: Returns <code>true</code> if the text format’s font is underlined; otherwise returns <code>false</code>.</li>
<li><code>int QTextCharFormat::fontWeight() const</code>: Returns the text format’s font weight.</li>
<li><code>qreal QTextCharFormat::fontWordSpacing() const</code>: Returns the current word spacing value.</li>
<li><code>bool QTextCharFormat::isAnchor() const</code>: Returns <code>true</code> if the text is formatted as an anchor; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCharFormat::isValid() const</code>: Returns <code>true</code> if this character format is valid; otherwise returns <code>false</code>.</li>
<li><code>void QTextCharFormat::setAnchor(bool anchor)</code>: If <code>anchor</code> is <code>true</code>, text with this format represents an anchor, and is formatted in the appropriate way; otherwise the text is formatted normally (Anchors are hyperlinks which are often shown underlined and in a different color from plain text). The way the text is rendered is independent of whether or not the format has a valid <code>anchor</code> defined. Use <code>setAnchorHref()</code>, and optionally <code>setAnchorNames()</code> to create a hypertext link.</li>
<li><code>void QTextCharFormat::setAnchorHref(const QString &amp; value)</code>: Sets the hypertext link for the text format to the given <code>value</code>. This is typically a <code>URL</code> like <code>http://example.com/index.html</code>. The anchor will be displayed with the value as its display text; if you want to display different text call <code>setAnchorNames()</code>. To format the text as a hypertext link use <code>setAnchor()</code>.</li>
<li><code>void QTextCharFormat::setAnchorNames(const QStringList &amp; names)</code>: Sets the text format’s anchor <code>names</code>. For the anchor to work as a hyperlink, the destination must be set with <code>setAnchorHref()</code> and the anchor must be enabled with <code>setAnchor()</code>.</li>
<li><code>void QTextCharFormat::setFont(const QFont &amp; font)</code>: Sets the text format’s <code>font</code>.</li>
<li><code>void QTextCharFormat::setFontCapitalization(QFont::Capitalization capitalization)</code>: Sets the <code>capitalization</code> of the text that apppears in this font to <code>capitalization</code>. A font’s <code>capitalization</code> makes the text appear in the selected <code>capitalization</code> mode.</li>
<li><code>void QTextCharFormat::setFontFamily(const QString &amp; family)</code>: Sets the text format’s font <code>family</code>.</li>
<li><code>void QTextCharFormat::setFontFixedPitch(bool fixedPitch)</code>: If <code>fixedPitch</code> is <code>true</code>, sets the text format’s font to be fixed pitch; otherwise a <code>non-fixed</code> pitch font is used.</li>
<li><code>void QTextCharFormat::setFontHintingPreference(QFont::HintingPreference hintingPreference)</code>: Sets the hinting preference of the text format’s font to be <code>hintingPreference</code>.</li>
<li><code>void QTextCharFormat::setFontItalic(bool italic)</code>: If <code>italic</code> is <code>true</code>, sets the text format’s font to be italic; otherwise the font will be <code>non-italic</code>.</li>
<li><code>void QTextCharFormat::setFontKerning(bool enable)</code>: Enables kerning for this font if <code>enable</code> is <code>true</code>; otherwise disables it. When kerning is enabled, glyph metrics do not add up anymore, even for <code>Latin</code> text. In other words, the assumption that <code>width(&#39;a&#39;) + width(&#39;b&#39;)</code> is equal to <code>width(&quot;ab&quot;)</code> is not neccesairly <code>true</code>.</li>
<li><code>void QTextCharFormat::setFontLetterSpacing(qreal spacing)</code>: Sets the letter <code>spacing</code> of this format to the given <code>spacing</code>, in percent. A value of <code>100</code> indicates default <code>spacing</code>; a value of <code>200</code> doubles the amount of space a letter takes.</li>
<li><code>void QTextCharFormat::setFontOverline(bool overline)</code>: If <code>overline</code> is <code>true</code>, sets the text format’s font to be overlined; otherwise the font is displayed <code>non-overlined</code>.</li>
<li><code>void QTextCharFormat::setFontPointSize(qreal size)</code>: Sets the text format’s font <code>size</code>.</li>
<li><code>void QTextCharFormat::setFontStrikeOut(bool strikeOut)</code>: If <code>strikeOut</code> is <code>true</code>, sets the text format’s font with <code>strike-out</code> enabled (with a horizontal line through it); otherwise it is displayed without strikeout.</li>
<li><code>void QTextCharFormat::setFontStyleHint(QFont::StyleHint hint, QFont::StyleStrategy strategy = QFont::PreferDefault)</code>: Sets the font style <code>hint</code> and <code>strategy</code>. <code>Qt</code> does not support style hints on <code>X11</code> since this information is not provided by the window system.</li>
<li><code>void QTextCharFormat::setFontStyleStrategy(QFont::StyleStrategy strategy)</code>: Sets the font style <code>strategy</code>.</li>
<li><code>void QTextCharFormat::setFontUnderline(bool underline)</code>: If <code>underline</code> is <code>true</code>, sets the text format’s font to be underlined; otherwise it is displayed <code>non-underlined</code>.</li>
<li><code>void QTextCharFormat::setFontWeight(int weight)</code>: Sets the text format’s font <code>weight</code> to <code>weight</code>.</li>
<li><code>void QTextCharFormat::setFontWordSpacing(qreal spacing)</code>: Sets the word <code>spacing</code> of this format to the given <code>spacing</code>, in pixels.</li>
<li><code>void QTextCharFormat::setTextOutline(const QPen &amp; pen)</code>: Sets the <code>pen</code> used to draw the outlines of characters to the given <code>pen</code>.</li>
<li><code>void QTextCharFormat::setToolTip(const QString &amp; text)</code>: Sets the tool tip for a fragment of <code>text</code> to the given <code>text</code>.</li>
<li><code>void QTextCharFormat::setUnderlineColor(const QColor &amp; color)</code>: Sets the underline <code>color</code> used for the characters with this format to the <code>color</code> specified.</li>
<li><code>void QTextCharFormat::setUnderlineStyle(UnderlineStyle style)</code>: Sets the <code>style</code> of underlining the text to <code>style</code>.</li>
<li><code>void QTextCharFormat::setVerticalAlignment(VerticalAlignment alignment)</code>: Sets the vertical <code>alignment</code> used for the characters with this format to the <code>alignment</code> specified.</li>
<li><code>QPen QTextCharFormat::textOutline() const</code>: Returns the pen used to draw the outlines of characters in this format.</li>
<li><code>QString QTextCharFormat::toolTip() const</code>: Returns the tool tip that is displayed for a fragment of text.</li>
<li><code>QColor QTextCharFormat::underlineColor() const</code>: Returns the color used to underline the characters with this format.</li>
<li><code>UnderlineStyle QTextCharFormat::underlineStyle() const</code>: Returns the style of underlining the text.</li>
<li><code>VerticalAlignment QTextCharFormat::verticalAlignment() const</code>: Returns the vertical alignment used for characters with this format.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/25/Qt语法详解/QByteArray和QBuffer/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/Qt语法详解/QByteArray和QBuffer/" itemprop="url">QByteArray和QBuffer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-25T18:41:07+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;<code>QByteArray</code>类提供了一个字节数组，既可以存储原始的字节(包括<code>\0</code>)，又可以被用来存储以<code>\0</code>结尾的字符串(可以理解为字符数组<code>char str[] = {&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;}</code>或者<code>char *str = &quot;hello&quot;</code>)。由于<code>QByteArray</code>封装的功能很多，使用起来比<code>char *</code>要方便的多，而就其内部实现来讲，它会保证所有的数据以<code>\0</code>结尾，使用隐式数据共享(<code>copy-on-write</code>)来减少内存消耗以及不必要的数据拷贝。<br>&emsp;&emsp;有两种情况比较适合使用<code>QByteArray</code>，第一就是要存储纯二进制数据(<code>raw binary data</code>)或<code>8bit</code>编码文本字符串，第二种情况就是在内存资源很珍贵的情况下，例如<code>Qt for Embedded Linux</code>。<br>&emsp;&emsp;一种初始化<code>QByteArray</code>方式是给它的构造函数传入一个<code>const char *</code>即可。此时，<code>QByteArray</code>执行了深拷贝。如果出于效率考虑不想执行深拷贝，使用<code>QByteArray::fromRawData(const char * data, int siz)</code>，其返回的<code>QByteArray</code>对象将会和数据指针相关联。<br>&emsp;&emsp;对于语句<code>QByteArray array(&quot;Hello&quot;);</code>，<code>array</code>的<code>size</code>是<code>5</code>，但由于其在最后要存储额外的<code>\0</code>，其实际占用空间是<code>6</code>。<br>&emsp;&emsp;常用操作函数如下所示：<br>&emsp;&emsp;1. <code>int QByteArray::size() const</code>：如果<code>QByteArray</code>在从<code>raw</code>数据创建时，不包含尾随的终止符，<code>QByteArray</code>不会自动添加，除非通过深拷贝进行创建：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">ba</span> <span class="params">( <span class="string">"Hello"</span> )</span></span>;</span><br><span class="line"><span class="keyword">int</span> n = ba.size(); <span class="comment">/* n = 5 */</span></span><br><span class="line">ba.data() [<span class="number">0</span>]; <span class="comment">/* returns 'H' */</span></span><br><span class="line">ba.data() [<span class="number">4</span>]; <span class="comment">/* returns 'o' */</span></span><br><span class="line">ba.data() [<span class="number">5</span>]; <span class="comment">/* returns '\0' */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 和<code>C++</code>的普通数组一样，<code>QByteArray</code>也可以使用<code>[]</code>来访问其具体下表对应的字节。对于非<code>const</code>的<code>QByteArray</code>，可以直接进行赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QByteArray <span class="built_in">array</span>;</span><br><span class="line"><span class="built_in">array</span>.resize ( <span class="number">5</span> );</span><br><span class="line"><span class="built_in">array</span> [<span class="number">0</span>] = <span class="number">0x3c</span>;</span><br><span class="line"><span class="built_in">array</span> [<span class="number">1</span>] = <span class="number">0xb8</span>;</span><br><span class="line"><span class="built_in">array</span> [<span class="number">2</span>] = <span class="number">0x64</span>;</span><br><span class="line"><span class="built_in">array</span> [<span class="number">3</span>] = <span class="number">0x18</span>;</span><br><span class="line"><span class="built_in">array</span> [<span class="number">4</span>] = <span class="number">0xca</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3. 对于只读操作，请使用<code>at</code>，因为它可以避免深拷贝，比使用<code>[]</code>要快，效率要高：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">array</span>.at ( i ) &gt;= <span class="string">'a'</span> &amp;&amp; <span class="built_in">array</span>.at ( i ) &lt;= <span class="string">'f'</span> ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found character in range [a - f] "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;4. 可以使用<code>left</code>、<code>right</code>或者<code>mid</code>来实现一次取出多个字符：</p>
<ul>
<li><code>QByteArray QByteArray::left(int len) const</code>: Returns a byte array that contains the leftmost <code>len</code> bytes of this byte array. The entire byte array is returned if len is greater than <code>size()</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">x</span> <span class="params">( <span class="string">"Pineapple"</span> )</span></span>;</span><br><span class="line">QByteArray y = x.left ( <span class="number">4</span> ); <span class="comment">/* y = "Pine" */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>QByteArray QByteArray::right(int len) const</code>: Returns a byte array that contains the rightmost <code>len</code> bytes of this byte array. The entire byte array is returned if <code>len</code> is greater than <code>size()</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">x</span> <span class="params">( <span class="string">"Pineapple"</span> )</span></span>;</span><br><span class="line">QByteArray y = x.right ( <span class="number">5</span> ); <span class="comment">/* y = "apple" */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>QByteArray QByteArray::mid(int pos, int len = -1) const</code>：以<code>pos</code>作为起点，返回指定字节长度的<code>array</code>，如果<code>len</code>为<code>-1</code>(默认)，或者<code>pos + len &gt;= size()</code>，将返回从指定为<code>pos</code>开始直到字节数组尾的所有字节。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">x</span> <span class="params">( <span class="string">"Five pineapples"</span> )</span></span>;</span><br><span class="line">QByteArray y = x.mid ( <span class="number">5</span>, <span class="number">4</span> ); <span class="comment">/* y = "pine" */</span></span><br><span class="line">QByteArray z = x.mid ( <span class="number">5</span> ); <span class="comment">/* z = "pineapples" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;5. <code>char * QByteArray::data()</code>: Returns a pointer to the data stored in the byte array; <code>const char * QByteArray::constData() const</code>: Returns a pointer to the data stored in the byte array：通过<code>data</code>或者<code>constData</code>可以获得<code>QByteArray</code>的真实数据的指针，获得的数据指针在调用<code>QByteArray</code>的<code>non-const</code>函数之前都是有效的。</p>
<p>&emsp;&emsp;6. <code>uint qstrlen(const char * str)</code>: Returns the number of characters that precede(先于) the terminating <code>\0</code>, or <code>0</code> if <code>str</code> is <code>0</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QByteArray <span class="built_in">array</span> = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="built_in">printf</span> ( <span class="string">"%d\n"</span>, <span class="built_in">array</span>.size() - <span class="number">1</span> );</span><br><span class="line"><span class="built_in">printf</span> ( <span class="string">"%c\n"</span>, <span class="built_in">array</span>.data() [<span class="built_in">array</span>.size()] );</span><br><span class="line"><span class="built_in">printf</span> ( <span class="string">"%d\n"</span>, qstrlen ( ( <span class="keyword">const</span> <span class="keyword">char</span> * ) <span class="built_in">array</span>.data() ) );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;7. <code>QByteArray</code>提供了很多修改字节的方法，例如<code>append</code>、<code>prepend</code>、<code>insert</code>、<code>replace</code>和<code>remove</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">x</span> <span class="params">( <span class="string">"and"</span> )</span></span>;</span><br><span class="line">x.prepend ( <span class="string">"rock "</span> ); <span class="comment">/* x = "rock and" */</span></span><br><span class="line">x.append ( <span class="string">" roll"</span> ); <span class="comment">/* x = "rock and roll" */</span></span><br><span class="line">x.replace ( <span class="number">5</span>, <span class="number">3</span>, <span class="string">"&amp;"</span> ); <span class="comment">/* x = "rock &amp; roll" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;8. <code>QBuffer</code>类是一个操作<code>QByteArray</code>的输入输出设备的接口，其构造函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QBuffer ( QByteArray *byteArray, QObject *parent = <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p><code>QBuffer</code>类用来读写内存缓存。在使用之前，用<code>open</code>来打开缓存并且设置模式(<code>只读</code>、<code>只写</code>等)。<br>&emsp;&emsp;<code>QDataStream</code>和<code>QTextStream</code>也可以使用一个<code>QByteArray</code>参数来构造，这些构造函数创建并且打开一个内部的<code>QBuffer</code>。</p>
<hr>
<h3 id="QBuffer-Class-Reference"><a href="#QBuffer-Class-Reference" class="headerlink" title="QBuffer Class Reference"></a>QBuffer Class Reference</h3><p>&emsp;&emsp;该类一个<code>QByteArray</code>提供一个<code>QIODevice</code>接口类，其头文件为<code>QBuffer</code>，继承自<code>QIODevice</code>。注意，该类所以的函数是可重入的。<br>&emsp;&emsp;公共函数如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QBuffer ( QObject * parent = 0 )</code></td>
</tr>
<tr>
<td></td>
<td><code>QBuffer ( QByteArray * byteArray, QObject * parent = 0 )</code></td>
</tr>
<tr>
<td></td>
<td><code>~QBuffer ()</code></td>
</tr>
<tr>
<td><code>QByteArray &amp;</code></td>
<td><code>buffer ()</code></td>
</tr>
<tr>
<td><code>const QByteArray &amp;</code></td>
<td><code>buffer () const</code></td>
</tr>
<tr>
<td><code>const QByteArray &amp;</code></td>
<td><code>data () const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBuffer ( QByteArray * byteArray )</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setData ( const QByteArray &amp; data )</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setData ( const char * data, int size )</code></td>
</tr>
</tbody>
</table>
</div>
<p>重新实现的公共函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual bool</code></td>
<td><code>atEnd () const</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>canReadLine () const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>close ()</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>open ( OpenMode flags )</code></td>
</tr>
<tr>
<td><code>virtual qint64</code></td>
<td><code>pos () const</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>seek ( qint64 pos )</code></td>
</tr>
<tr>
<td><code>virtual qint64</code></td>
<td><code>size () const</code></td>
</tr>
</tbody>
</table>
</div>
<p>重新实现的受保护的函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual qint64</code></td>
<td><code>readData ( char * data, qint64 len )</code></td>
</tr>
<tr>
<td><code>virtual qint64</code></td>
<td><code>writeData ( const char * data, qint64 len )</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h3><p>&emsp;&emsp;<code>QBuffer</code>允许你通过使用<code>QIODevice</code>接口来存取一个<code>QByteArray</code>。<code>QByteArray</code>被视为一个标准的随机存取文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QBuffer buffer;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">buffer.open ( QBuffer::ReadWrite );</span><br><span class="line">buffer.write ( <span class="string">"Qt rocks!"</span> );</span><br><span class="line">buffer.seek ( <span class="number">0</span> );</span><br><span class="line">buffer.getChar ( &amp;ch ); <span class="comment">/* ch = 'Q' */</span></span><br><span class="line">buffer.getChar ( &amp;ch ); <span class="comment">/* ch = 't' */</span></span><br><span class="line">buffer.getChar ( &amp;ch ); <span class="comment">/* ch = ' ' */</span></span><br><span class="line">buffer.getChar ( &amp;ch ); <span class="comment">/* ch = 'r' */</span></span><br></pre></td></tr></table></figure>
<p>缺省情况下，当你创造一个<code>QBuffer</code>时，一个内部的<code>QByteArray</code>缓存被建立。你能通过调用<code>buffer</code>函数存取这个<code>buffer</code>，也能用一个存在的<code>QByteArray</code>通过调用<code>setBuffer</code>使用<code>QBuffer</code>，或者通过传递你的数组到<code>QBuffer</code>的构造函数调用<code>open</code>来打开<code>buffer</code>，然后调用<code>write</code>或者<code>putChar</code>来写<code>buffer</code>，<code>read</code>、<code>readLine</code>、<code>readALL</code>或者<code>getChar</code>来读<code>buffer</code>。<code>Size</code>返回目前<code>buffer</code>的大小，你能通过调用<code>seek</code>定位在这个<code>buffer</code>中的任意位置。当你退出时，应该调用<code>close</code>。下面的代码演示使用<code>QDataStream</code>和<code>QBuffer</code>写数据到一个<code>QByteArray</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QByteArray byteArray;</span><br><span class="line"><span class="function">QBuffer <span class="title">buffer</span> <span class="params">( &amp;byteArray )</span></span>;</span><br><span class="line">buffer.open ( QIODevice::WriteOnly );</span><br><span class="line">​</span><br><span class="line"><span class="function">QDataStream <span class="title">out</span> <span class="params">( &amp;buffer )</span></span>;</span><br><span class="line">out &lt;&lt; QApplication::palette();</span><br></pre></td></tr></table></figure>
<p>我们也可以转换<code>QPalette</code>到一个字节数组，下面是读数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QByteArray byteArray;</span><br><span class="line">QPalette palette;</span><br><span class="line"><span class="function">QBuffer <span class="title">buffer</span> <span class="params">( &amp;byteArray )</span></span>;</span><br><span class="line">buffer.open ( QIODevice::ReadOnly );</span><br><span class="line">​</span><br><span class="line"><span class="function">QDataStream <span class="title">in</span> <span class="params">( &amp;buffer )</span></span>;</span><br><span class="line">in &gt;&gt; palette;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>QTextStream</code>和<code>QDataStream</code>也提供方便的构造函数来在幕后构建<code>QByteArray</code>来创造一个<code>QBuffer</code>。当新的数据到达时，<code>QBuffer</code>发送信号<code>readRead</code>，通过连接这个信号，你能使用<code>QBuffer</code>来缓存即将被处理的数据。例如当从一个<code>FTP</code>服务器下载一个文件时，你能传递<code>buffer</code>到<code>QFtp</code>。当一个新的数据负荷已经被下载时，<code>readRead</code>信号被发出，当数据到达后，你能处理该数据。每当新数据已经被写入<code>buffer</code>时，<code>QBuffer</code>发出<code>bytesWritten</code>信号。<br>&emsp;&emsp;构造函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QBuffer::QBuffer ( QObject *parent = <span class="number">0</span> );</span><br><span class="line">QBuffer::QBuffer ( QByteArray *byteArray, QObject *parent = <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p>实例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">byteArray</span> <span class="params">( <span class="string">"abc"</span> )</span></span>;</span><br><span class="line"><span class="function">QBuffer <span class="title">buffer</span> <span class="params">( &amp;byteArray )</span></span>;</span><br><span class="line">buffer.open ( QIODevice::WriteOnly );</span><br><span class="line">buffer.seek ( <span class="number">3</span> );</span><br><span class="line">buffer.write ( <span class="string">"def"</span>, <span class="number">3</span> );</span><br><span class="line">buffer.close(); <span class="comment">/* byteArray = "abcdef" */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;析构函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QBuffer::~QBuffer ()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其它函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> QBuffer::atEnd () <span class="keyword">const</span> [<span class="keyword">virtual</span>]</span><br><span class="line">QByteArray &amp;QBuffer::buffer ()</span><br><span class="line"><span class="keyword">const</span> QByteArray &amp;QBuffer::buffer () <span class="keyword">const</span></span><br><span class="line"><span class="keyword">bool</span> QBuffer::canReadLine () <span class="keyword">const</span> [<span class="keyword">virtual</span>]</span><br><span class="line"><span class="keyword">void</span> QBuffer::close () [<span class="keyword">virtual</span>]</span><br><span class="line"><span class="keyword">const</span> QByteArray &amp;QBuffer::data () <span class="keyword">const</span></span><br><span class="line"><span class="keyword">bool</span> QBuffer::open ( OpenMode flags ) [<span class="keyword">virtual</span>]</span><br><span class="line">qint64 QBuffer::pos () <span class="keyword">const</span> [<span class="keyword">virtual</span>]</span><br><span class="line">qint64 QBuffer::readData ( <span class="keyword">char</span> *data, qint64 len ) [<span class="keyword">virtual</span> <span class="keyword">protected</span>]</span><br><span class="line"><span class="keyword">bool</span> QBuffer::seek ( qint64 pos ) [<span class="keyword">virtual</span>]</span><br><span class="line"><span class="keyword">void</span> QBuffer::setBuffer ( QByteArray *byteArray )</span><br><span class="line"><span class="keyword">void</span> QBuffer::setData ( <span class="keyword">const</span> QByteArray &amp;data )</span><br><span class="line"><span class="keyword">void</span> QBuffer::setData ( <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> size )</span><br><span class="line">qint64 QBuffer::size () <span class="keyword">const</span> [<span class="keyword">virtual</span>]</span><br><span class="line">qint64 QBuffer::writeData ( <span class="keyword">const</span> <span class="keyword">char</span> *data, qint64 len ) [<span class="keyword">virtual</span> <span class="keyword">protected</span>]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">byteArray</span> <span class="params">( <span class="string">"abc"</span> )</span></span>;</span><br><span class="line">QBuffer buffer;</span><br><span class="line">buffer.setBuffer ( &amp;byteArray );</span><br><span class="line">buffer.open ( QIODevice::WriteOnly );</span><br><span class="line">buffer.seek ( <span class="number">3</span> );</span><br><span class="line">buffer.write ( <span class="string">"def"</span>, <span class="number">3</span> );</span><br><span class="line">buffer.close(); <span class="comment">/* byteArray = "abcdef" */</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Qt中QByteArray与byte之间转换"><a href="#Qt中QByteArray与byte之间转换" class="headerlink" title="Qt中QByteArray与byte之间转换"></a>Qt中QByteArray与byte之间转换</h3><p>&emsp;&emsp;1. <code>byte</code>数组到<code>QByteArray</code>的转换<br>&emsp;&emsp;推荐使用如下方法进行初始化，即使数组中有<code>0</code>也能完整赋值进去，因为<code>QByteArray</code>不认为<code>\0</code>就是结尾：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QByteArray byArr;</span><br><span class="line">byte cmd[<span class="number">5</span>] = &#123;<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'\0'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>&#125;;</span><br><span class="line">byArr.resize ( <span class="number">5</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">    byArr[i] = cmd[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用下面的转换方法，当数组中包含<code>0x00</code>(即<code>\0</code>)，就会丢失后面的数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QByteArray byArr = QByteArray ( ( <span class="keyword">const</span> <span class="keyword">char</span> * ) cmd );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. <code>QByteArray</code>到<code>byte</code>数组的转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> isize = byArr.size();</span><br><span class="line">byte *pby = ( byte * ) ( byArr.data() );</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/25/Qt语法详解/Qt之QMimeData/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/Qt语法详解/Qt之QMimeData/" itemprop="url">Qt之QMimeData</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-25T15:09:10+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;The <code>QMimeData</code> class provides a container for data that records information about its <code>MIME</code> type.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QMimeData</code></td>
<td><code>QObject</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QMimeData()</code></td>
</tr>
<tr>
<td></td>
<td><code>~QMimeData()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>QVariant</code></td>
<td><code>colorData() const</code></td>
</tr>
<tr>
<td><code>QByteArray</code></td>
<td><code>data(const QString &amp; mimeType) const</code></td>
</tr>
<tr>
<td><code>virtual QStringList</code></td>
<td><code>formats() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasColor() const</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>hasFormat(const QString &amp; mimeType) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasHtml() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasImage() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasText() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasUrls() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>html() const</code></td>
</tr>
<tr>
<td><code>QVariant</code></td>
<td><code>imageData() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeFormat(const QString &amp; mimeType)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setColorData(const QVariant &amp; color)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setData(const QString &amp; mimeType, const QByteArray &amp; data)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHtml(const QString &amp; html)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setImageData(const QVariant &amp; image)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setText(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUrls(const QList&lt;QUrl&gt; &amp; urls)</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>text() const</code></td>
</tr>
<tr>
<td><code>QList&lt;QUrl&gt;</code></td>
<td><code>urls() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual QVariant</code></td>
<td><code>retrieveData(const QString &amp; mimeType, QVariant::Type type) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QMimeData</code> class provides a container for data that records information about its <code>MIME</code> type.<br>&emsp;&emsp;<code>QMimeData</code> is used to describe information that can be stored in the clipboard, and transferred via the drag and drop mechanism. <code>QMimeData</code> objects associate the data that they hold with the corresponding <code>MIME</code> types to ensure that information can be safely transferred between applications, and copied around within the same application.<br>&emsp;&emsp;<code>QMimeData</code> objects are usually created using new and supplied to <code>QDrag</code> or <code>QClipboard</code> objects. This is to enable <code>Qt</code> to manage the memory that they use.<br>&emsp;&emsp;A single <code>QMimeData</code> object can store the same data using several different formats at the same time. The <code>formats()</code> function returns a list of the available formats in order of preference. The <code>data()</code> function returns the raw data associated with a <code>MIME</code> type, and <code>setData()</code> allows you to set the data for a <code>MIME</code> type.<br>&emsp;&emsp;For the most common <code>MIME</code> types, <code>QMimeData</code> provides convenience functions to access the data:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Tester</th>
<th>Getter</th>
<th>Setter</th>
<th>MIME Types</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hasText()</code></td>
<td><code>text()</code></td>
<td><code>setText()</code></td>
<td><code>text/plain</code></td>
</tr>
<tr>
<td><code>hasHtml()</code></td>
<td><code>html()</code></td>
<td><code>setHtml()</code></td>
<td><code>text/html</code></td>
</tr>
<tr>
<td><code>hasUrls()</code></td>
<td><code>urls()</code></td>
<td><code>setUrls()</code></td>
<td><code>text/uri-list</code></td>
</tr>
<tr>
<td><code>hasImage()</code></td>
<td><code>imageData()</code></td>
<td><code>setImageData()</code></td>
<td><code>image/ *</code></td>
</tr>
<tr>
<td><code>hasColor()</code></td>
<td><code>colorData()</code></td>
<td><code>setColorData()</code></td>
<td><code>application/x-color</code></td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;For example, if your write a widget that accepts <code>URL</code> drags, you would end up writing code like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MyWidget::dragEnterEvent ( QDragEnterEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasUrls() ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MyWidget::dropEvent ( QDropEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasUrls() ) &#123;</span><br><span class="line">        foreach ( QUrl url, event-&gt;mimeData()-&gt;urls() ) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;There are three approaches for storing custom data in a <code>QMimeData</code> object:<br>&emsp;&emsp;1. Custom data can be stored directly in a <code>QMimeData</code> object as a <code>QByteArray</code> using <code>setData()</code>. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QByteArray csvData = ...;</span><br><span class="line">​</span><br><span class="line">QMimeData *mimeData = <span class="keyword">new</span> QMimeData;</span><br><span class="line">mimeData-&gt;setData ( <span class="string">"text/csv"</span>, csvData );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. We can subclass <code>QMimeData</code> and reimplement <code>hasFormat()</code>, <code>formats()</code>, and <code>retrieveData()</code>.<br>&emsp;&emsp;3. If the drag and drop operation occurs within a single application, we can subclass <code>QMimeData</code> and add extra data in it, and use a <code>qobject_cast()</code> in the receiver’s drop event handler. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MyWidget::dropEvent ( QDropEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">const</span> MyMimeData *myData = qobject_cast&lt;<span class="keyword">const</span> MyMimeData *&gt; ( event-&gt;mimeData() );</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( myData ) &#123;</span><br><span class="line">        <span class="comment">/* access myData's data directly (not through QMimeData's API) */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Platform-Specific-MIME-Types"><a href="#Platform-Specific-MIME-Types" class="headerlink" title="Platform-Specific MIME Types"></a>Platform-Specific MIME Types</h3><p>&emsp;&emsp;On <code>Windows</code>, <code>formats()</code> will also return custom formats available in the <code>MIME</code> data, using the <code>x-qt-windows-mime</code> subtype to indicate that they represent data in <code>non-standard</code> formats. The formats will take the following form:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/x-qt-windows-mime; value="<span class="tag">&lt;<span class="name">custom</span> <span class="attr">type</span>&gt;</span>"</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The following are examples of custom <code>MIME</code> types:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">application/x-qt-windows-mime; value="FileGroupDescriptor"</span><br><span class="line">application/x-qt-windows-mime; value="FileContents"</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The value declaration of each format describes the way in which the data is encoded.<br>&emsp;&emsp;On <code>Windows</code>, the <code>MIME</code> format does not always map directly to the clipboard formats. <code>Qt</code> provides <code>QWindowsMime</code> to map clipboard formats to <code>open-standard</code> <code>MIME</code> formats. Similarly, the <code>QMacPasteboardMime</code> maps <code>MIME</code> to <code>Mac</code> flavors.</p>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QMimeData::QMimeData()</code>: Constructs a new <code>MIME</code> data object with no data in it.</li>
<li><code>QMimeData::~QMimeData()</code>: Destroys the <code>MIME</code> data object.</li>
<li><code>void QMimeData::clear()</code>: Removes all the <code>MIME</code> type and data entries in the object.</li>
<li><code>QVariant QMimeData::colorData() const</code>: Returns a color if the data stored in the object represents a color (<code>MIME</code> type <code>application/x-color</code>); otherwise returns a null variant. A <code>QVariant</code> is used because <code>QMimeData</code> belongs to the <code>QtCore</code> library, whereas <code>QColor</code> belongs to <code>QtGui</code>. To convert the <code>QVariant</code> to a <code>QColor</code>, simply use <code>qvariant_cast()</code>. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasColor() ) &#123;</span><br><span class="line">    QColor color = qvariant_cast&lt;QColor&gt; ( event-&gt;mimeData()-&gt;colorData() );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>QByteArray QMimeData::data(const QString &amp; mimeType) const</code>: Returns the data stored in the object in the format described by the <code>MIME</code> type specified by <code>mimeType</code>.</li>
<li><code>[virtual] QStringList QMimeData::formats() const</code>: Returns a list of formats supported by the object. This is a list of <code>MIME</code> types for which the object can return suitable data. The formats in the list are in a priority order. For the most common types of data, you can call the <code>higher-level</code> functions <code>hasText()</code>, <code>hasHtml()</code>, <code>hasUrls()</code>, <code>hasImage()</code>, and <code>hasColor()</code> instead.</li>
<li><code>bool QMimeData::hasColor() const</code>: Returns <code>true</code> if the object can return a color (<code>MIME</code> type <code>application/x-color</code>); otherwise returns <code>false</code>.</li>
<li><code>[virtual] bool QMimeData::hasFormat(const QString &amp; mimeType) const</code>: Returns <code>true</code> if the object can return data for the <code>MIME</code> type specified by <code>mimeType</code>; otherwise returns <code>false</code>. For the most common types of data, you can call the <code>higher-level</code> functions <code>hasText()</code>, <code>hasHtml()</code>, <code>hasUrls()</code>, <code>hasImage()</code>, and <code>hasColor()</code> instead.</li>
<li><code>bool QMimeData::hasHtml() const</code>: Returns <code>true</code> if the object can return <code>HTML</code> (<code>MIME</code> type <code>text/html</code>); otherwise returns <code>false</code>.</li>
<li><code>bool QMimeData::hasImage() const</code>: Returns <code>true</code> if the object can return an image; otherwise returns <code>false</code>.</li>
<li><code>bool QMimeData::hasText() const</code>: Returns <code>true</code> if the object can return plain text (<code>MIME</code> type <code>text/plain</code>); otherwise returns <code>false</code>.</li>
<li><code>bool QMimeData::hasUrls() const</code>: Returns <code>true</code> if the object can return a list of urls; otherwise returns <code>false</code>. <code>URLs</code> correspond to the <code>MIME</code> type <code>text/uri-list</code>.</li>
<li><code>QString QMimeData::html() const</code>: Returns a string if the data stored in the object is <code>HTML</code> (<code>MIME</code> type <code>text/html</code>); otherwise returns an empty string.</li>
<li><code>QVariant QMimeData::imageData() const</code>: Returns a <code>QVariant</code> storing a <code>QImage</code> if the object can return an image; otherwise returns a null variant. A <code>QVariant</code> is used because <code>QMimeData</code> belongs to the <code>QtCore</code> library, whereas <code>QImage</code> belongs to <code>QtGui</code>. To convert the <code>QVariant</code> to a <code>QImage</code>, simply use <code>qvariant_cast()</code>. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasImage() ) &#123;</span><br><span class="line">    QImage image = qvariant_cast&lt;QImage&gt; ( event-&gt;mimeData()-&gt;imageData() );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QMimeData::removeFormat(const QString &amp; mimeType)</code>: Removes the data entry for <code>mimeType</code> in the object.</li>
<li><code>[virtual protected] QVariant QMimeData::retrieveData(const QString &amp; mimeType, QVariant::Type type) const</code>: Returns a variant with the given <code>type</code> containing data for the <code>MIME</code> type specified by <code>mimeType</code>. If the object does not support the <code>MIME</code> type or variant type given, a null variant is returned instead. This function is called by the general <code>data()</code> getter and by the convenience getters (<code>text()</code>, <code>html()</code>, <code>urls()</code>, <code>imageData()</code>, and <code>colorData()</code>). You can reimplement it if you want to store your data using a custom data structure (instead of a <code>QByteArray</code>, which is what <code>setData()</code> provides). You would then also need to reimplement <code>hasFormat()</code> and <code>formats()</code>.</li>
<li><code>void QMimeData::setColorData(const QVariant &amp; color)</code>: Sets the <code>color</code> data in the object to the given <code>color</code>. Colors correspond to the <code>MIME</code> type <code>application/x-color</code>.</li>
<li><code>void QMimeData::setData(const QString &amp; mimeType, const QByteArray &amp; data)</code>: Sets the <code>data</code> associated with the <code>MIME</code> type given by <code>mimeType</code> to the specified <code>data</code>. For the most common types of <code>data</code>, you can call the <code>higher-level</code> functions <code>setText()</code>, <code>setHtml()</code>, <code>setUrls()</code>, <code>setImageData()</code>, and <code>setColorData()</code> instead. Note that if you want to use a custom <code>data</code> type in an item view drag and drop operation, you must register it as a <code>Qt</code> meta type, using the <code>Q_DECLARE_METATYPE()</code> macro, and implement stream operators for it. The stream operators must then be registered with the <code>qRegisterMetaTypeStreamOperators()</code> function.</li>
<li><code>void QMimeData::setHtml(const QString &amp; html)</code>: Sets <code>html</code> as the <code>HTML</code> (<code>MIME</code> type <code>text/html</code>) used to represent the data.</li>
<li><code>void QMimeData::setImageData(const QVariant &amp; image)</code>: Sets the data in the object to the given <code>image</code>. A <code>QVariant</code> is used because <code>QMimeData</code> belongs to the <code>QtCore</code> library, whereas <code>QImage</code> belongs to <code>QtGui</code>. The conversion from <code>QImage</code> to <code>QVariant</code> is implicit. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimeData-&gt;setImageData ( QImage ( <span class="string">"beautifulfjord.png"</span> ) );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QMimeData::setText(const QString &amp; text)</code>: Sets <code>text</code> as the plain <code>text</code> (<code>MIME</code> type <code>text/plain</code>) used to represent the data.</li>
<li><code>void QMimeData::setUrls(const QList&lt;QUrl&gt; &amp; urls)</code>: Sets the <code>URLs</code> stored in the <code>MIME</code> data object to those specified by <code>urls</code>. <code>URLs</code> correspond to the <code>MIME</code> type <code>text/uri-list</code>.</li>
<li><code>QString QMimeData::text() const</code>: Returns a plain text (<code>MIME</code> type <code>text/plain</code>) representation of the data.</li>
<li><code>QList&lt;QUrl&gt; QMimeData::urls() const</code>: Returns a list of <code>URLs</code> contained within the <code>MIME</code> data object. <code>URLs</code> correspond to the <code>MIME</code> type <code>text/uri-list</code>.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/46/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/46/">46</a><span class="page-number current">47</span><a class="page-number" href="/page/48/">48</a><span class="space">&hellip;</span><a class="page-number" href="/page/94/">94</a><a class="extend next" rel="next" href="/page/48/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">939</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
