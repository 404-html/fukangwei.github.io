<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="&amp;emsp;&amp;emsp;The QTextDocument class holds formatted text that can be viewed and edited using a QTextEdit.     Header Inherits     QTextDocument QObject     Note: All functions in this class are reentr">
<meta property="og:type" content="article">
<meta property="og:title" content="Qt之QTextDocument">
<meta property="og:url" content="http://fukangwei.gitee.io/2019/02/02/Qt语法详解/Qt之QTextDocument/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:description" content="&amp;emsp;&amp;emsp;The QTextDocument class holds formatted text that can be viewed and edited using a QTextEdit.     Header Inherits     QTextDocument QObject     Note: All functions in this class are reentr">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-04-02T11:21:01.017Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Qt之QTextDocument">
<meta name="twitter:description" content="&amp;emsp;&amp;emsp;The QTextDocument class holds formatted text that can be viewed and edited using a QTextEdit.     Header Inherits     QTextDocument QObject     Note: All functions in this class are reentr">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/2019/02/02/Qt语法详解/Qt之QTextDocument/">





  <title>Qt之QTextDocument | 泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/02/Qt语法详解/Qt之QTextDocument/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Qt之QTextDocument</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-02T00:28:55+08:00">
                2019-02-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&emsp;&emsp;The <code>QTextDocument</code> class holds formatted text that can be viewed and edited using a <code>QTextEdit</code>.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextDocument</code></td>
<td><code>QObject</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextDocument(QObject * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTextDocument(const QString &amp; text, QObject * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QTextDocument()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addResource(int type, const QUrl &amp; name, const QVariant &amp; resource)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>adjustSize()</code></td>
</tr>
<tr>
<td><code>QVector&lt;QTextFormat&gt;</code></td>
<td><code>allFormats() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>availableRedoSteps() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>availableUndoSteps() const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>blockCount() const</code></td>
</tr>
<tr>
<td><code>QChar</code></td>
<td><code>characterAt(int pos) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>characterCount() const</code></td>
</tr>
<tr>
<td><code>virtual void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clearUndoRedoStacks(Stacks stacksToClear = UndoAndRedoStacks)</code></td>
</tr>
<tr>
<td><code>QTextDocument *</code></td>
<td><code>clone(QObject * parent = 0) const</code></td>
</tr>
<tr>
<td><code>Qt::CursorMoveStyle</code></td>
<td><code>defaultCursorMoveStyle() const</code></td>
</tr>
<tr>
<td><code>QFont</code></td>
<td><code>defaultFont() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>defaultStyleSheet() const</code></td>
</tr>
<tr>
<td><code>QTextOption</code></td>
<td><code>defaultTextOption() const</code></td>
</tr>
<tr>
<td><code>QAbstractTextDocumentLayout *</code></td>
<td><code>documentLayout() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>documentMargin() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>drawContents(QPainter * p, const QRectF &amp; rect = QRectF())</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>QTextCursor</code></td>
<td><code>find(const QString &amp; subString, const QTextCursor &amp; cursor, FindFlags options = 0) const</code></td>
</tr>
<tr>
<td><code>QTextCursor</code></td>
<td><code>find(const QRegExp &amp; expr, const QTextCursor &amp; cursor, FindFlags options = 0) const</code></td>
</tr>
<tr>
<td><code>QTextCursor</code></td>
<td><code>find(const QString &amp; subString, int position = 0, FindFlags options = 0) const</code></td>
</tr>
<tr>
<td><code>QTextCursor</code></td>
<td><code>find(const QRegExp &amp; expr, int position = 0, FindFlags options = 0) const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>findBlock(int pos) const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>findBlockByLineNumber(int lineNumber) const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>findBlockByNumber(int blockNumber) const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>firstBlock() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>idealWidth() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>indentWidth() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isModified() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isRedoAvailable() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isUndoAvailable() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isUndoRedoEnabled() const</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>lastBlock() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lineCount() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>markContentsDirty(int position, int length)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>maximumBlockCount() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>metaInformation(MetaInformation info) const</code></td>
</tr>
<tr>
<td><code>QTextObject *</code></td>
<td><code>object(int objectIndex) const</code></td>
</tr>
<tr>
<td><code>QTextObject *</code></td>
<td><code>objectForFormat(const QTextFormat &amp; f) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>pageCount() const</code></td>
</tr>
<tr>
<td><code>QSizeF</code></td>
<td><code>pageSize() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>print(QPrinter * printer) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>redo(QTextCursor * cursor)</code></td>
</tr>
<tr>
<td><code>QVariant</code></td>
<td><code>resource(int type, const QUrl &amp; name) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>revision() const</code></td>
</tr>
<tr>
<td><code>QTextFrame *</code></td>
<td><code>rootFrame() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDefaultCursorMoveStyle(Qt::CursorMoveStyle style)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDefaultFont(const QFont &amp; font)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDefaultStyleSheet(const QString &amp; sheet)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDefaultTextOption(const QTextOption &amp; option)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDocumentLayout(QAbstractTextDocumentLayout * layout)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDocumentMargin(qreal margin)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHtml(const QString &amp; html)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setIndentWidth(qreal width)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMaximumBlockCount(int maximum)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMetaInformation(MetaInformation info, const QString &amp; string)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPageSize(const QSizeF &amp; size)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPlainText(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTextWidth(qreal width)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUndoRedoEnabled(bool enable)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUseDesignMetrics(bool b)</code></td>
</tr>
<tr>
<td><code>QSizeF</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>qreal</code></td>
<td><code>textWidth() const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>toHtml(const QByteArray &amp; encoding = QByteArray()) const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>toPlainText() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>undo(QTextCursor * cursor)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>useDesignMetrics() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Slots"><a href="#Public-Slots" class="headerlink" title="Public Slots"></a>Public Slots</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>redo()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setModified(bool m = true)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>undo()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>blockCountChanged(int newBlockCount)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>contentsChange(int position, int charsRemoved, int charsAdded)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>contentsChanged()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>cursorPositionChanged(const QTextCursor &amp; cursor)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>documentLayoutChanged()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>modificationChanged(bool changed)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>redoAvailable(bool available)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>undoAvailable(bool available)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>undoCommandAdded()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Retrun</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual QTextObject *</code></td>
<td><code>createObject(const QTextFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>virtual QVariant</code></td>
<td><code>loadResource(int type, const QUrl &amp; name)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextDocument</code> class holds formatted text that can be viewed and edited using a <code>QTextEdit</code>.<br>&emsp;&emsp;<code>QTextDocument</code> is a container for structured rich text documents, providing support for styled text and various types of document elements, such as lists, tables, frames, and images. They can be created for use in a <code>QTextEdit</code>, or used independently.<br>&emsp;&emsp;Each document element is described by an associated format object. Each format object is treated as a unique object by <code>QTextDocuments</code>, and can be passed to <code>objectForFormat()</code> to obtain the document element that it is applied to.<br>&emsp;&emsp;A <code>QTextDocument</code> can be edited programmatically using a <code>QTextCursor</code>, and its contents can be examined by traversing the document structure. The entire document structure is stored as a hierarchy of document elements beneath the root frame, found with the <code>rootFrame()</code> function. Alternatively, if you just want to iterate over the textual contents of the document you can use <code>begin()</code>, <code>end()</code> and <code>findBlock()</code> to retrieve text blocks that you can examine and iterate over.<br>&emsp;&emsp;The layout of a document is determined by the <code>documentLayout()</code>; you can create your own <code>QAbstractTextDocumentLayout</code> subclass and set it using <code>setDocumentLayout()</code> if you want to use your own layout logic. The document’s title and other <code>meta-information</code> can be obtained by calling the <code>metaInformation()</code> function. For documents that are exposed to users through the <code>QTextEdit</code> class, the document title is also available via the <code>QTextEdit::documentTitle()</code> function.<br>&emsp;&emsp;The <code>toPlainText()</code> and <code>toHtml()</code> convenience functions allow you to retrieve the contents of the document as <code>plain text</code> and <code>HTML</code>. The document’s text can be searched using the <code>find()</code> functions.<br>&emsp;&emsp;Undo/redo of operations performed on the document can be controlled using the <code>setUndoRedoEnabled()</code> function. The undo/redo system can be controlled by an editor widget through the <code>undo()</code> and <code>redo()</code> slots; the document also provides <code>contentsChanged()</code>, <code>undoAvailable()</code> and <code>redoAvailable()</code> signals that inform connected editor widgets about the state of the undo/redo system. The following are the undo/redo operations of a <code>QTextDocument</code>:</p>
<ul>
<li>Insertion or removal of characters. A sequence of insertions or removals within the same text block are regarded as a single undo/redo operation.</li>
<li>Insertion or removal of text blocks. Sequences of insertion or removals in a single operation (e.g., by selecting and then deleting text) are regarded as a single undo/redo operation.</li>
<li>Text character format changes.</li>
<li>Text block format changes.</li>
<li>Text block group format changes.</li>
</ul>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QTextDocument::FindFlag &amp; flags QTextDocument::FindFlags</code>: This enum describes the options available to <code>QTextDocument&#39;s</code> find function. The options can be <code>OR-ed</code> together from the following list:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextDocument::FindBackward</code></td>
<td><code>0x00001</code></td>
<td>Search backwards instead of forwards.</td>
</tr>
<tr>
<td><code>QTextDocument::FindCaseSensitively</code></td>
<td><code>0x00002</code></td>
<td>By default find works case insensitive. Specifying this option changes the behaviour to a case sensitive find operation.</td>
</tr>
<tr>
<td><code>QTextDocument::FindWholeWords</code></td>
<td><code>0x00004</code></td>
<td>Makes find match only complete words.</td>
</tr>
</tbody>
</table>
</div>
<p>The FindFlags type is a typedef for <code>QFlags&lt;FindFlag&gt;</code>. It stores an <code>OR</code> combination of <code>FindFlag</code> values.</p>
<ul>
<li>enum <code>QTextDocument::MetaInformation</code>: This enum describes the different types of meta information that can be added to a document.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextDocument::DocumentTitle</code></td>
<td><code>0</code></td>
<td>The title of the document.</td>
</tr>
<tr>
<td><code>QTextDocument::DocumentUrl</code></td>
<td><code>1</code></td>
<td>The url of the document. The <code>loadResource()</code> function uses this url as the base when loading relative resources.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QTextDocument::ResourceType</code>: This enum describes the types of resources that can be loaded by <code>QTextDocument&#39;s</code> <code>loadResource()</code> function.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextDocument::HtmlResource</code></td>
<td><code>1</code></td>
<td>The resource contains <code>HTML</code>.</td>
</tr>
<tr>
<td><code>QTextDocument::ImageResource</code></td>
<td><code>2</code></td>
<td>The resource contains image data. Currently supported data types are <code>QVariant::Pixmap</code> and <code>QVariant::Image</code>. If the corresponding variant is of type <code>QVariant::ByteArray</code> then Qt attempts to load the image using <code>QImage::loadFromData</code>. <code>QVariant::Icon</code> is currently not supported. The icon needs to be converted to one of the supported types first, for example using <code>QIcon::pixmap</code>.</td>
</tr>
<tr>
<td><code>QTextDocument::StyleSheetResource</code></td>
<td><code>3</code></td>
<td>The resource contains <code>CSS</code>.</td>
</tr>
<tr>
<td><code>QTextDocument::UserResource</code></td>
<td><code>100</code></td>
<td>The first available value for user defined resource types.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QTextDocument::Stacks</code>:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextDocument::UndoStack</code></td>
<td><code>0x01</code></td>
<td>The undo stack.</td>
</tr>
<tr>
<td><code>QTextDocument::RedoStack</code></td>
<td><code>0x02</code></td>
<td>The redo stack.</td>
</tr>
<tr>
<td><code>QTextDocument::UndoAndRedoStacks</code></td>
<td><code>UndoStack &#124; RedoStack</code></td>
<td>Both the undo and redo stacks.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Property-Documentation"><a href="#Property-Documentation" class="headerlink" title="Property Documentation"></a>Property Documentation</h3><ul>
<li><code>blockCount(const int)</code>: Returns the number of text blocks in the document. The value of this property is undefined in documents with tables or frames. By default, if defined, this property contains a value of <code>1</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">blockCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>defaultFont(QFont)</code>: This property holds the default font used to display the document’s text. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFont <span class="title">defaultFont</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDefaultFont</span> <span class="params">( <span class="keyword">const</span> QFont &amp;font )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>defaultStyleSheet(QString)</code>: The default style sheet is applied to all newly <code>HTML</code> formatted text that is inserted into the document, for example using <code>setHtml()</code> or <code>QTextCursor::insertHtml()</code>. The style sheet needs to be compliant to <code>CSS 2.1</code> syntax. <strong>Note</strong>: Changing the default style sheet does not have any effect to the existing content of the document. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">defaultStyleSheet</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDefaultStyleSheet</span> <span class="params">( <span class="keyword">const</span> QString &amp;sheet )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>defaultTextOption(QTextOption)</code>: This property holds the default text option will be set on all <code>QTextLayouts</code> in the document. When <code>QTextBlocks</code> are created, the <code>defaultTextOption</code> is set on their <code>QTextLayout</code>. This allows setting global properties for the document such as the default word wrap mode. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTextOption <span class="title">defaultTextOption</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDefaultTextOption</span> <span class="params">( <span class="keyword">const</span> QTextOption &amp;option )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>documentMargin(qreal)</code>: The margin around the document. The default is <code>4</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">qreal <span class="title">documentMargin</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDocumentMargin</span> <span class="params">( qreal margin )</span></span></span><br></pre></td></tr></table></figure>
<p><code>indentWidth(qreal)</code>: Returns the width used for text list and text block indenting. The indent properties of <code>QTextListFormat</code> and <code>QTextBlockFormat</code> specify multiples of this value. The default indent width is <code>40</code>. Access functions:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">qreal <span class="title">indentWidth</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIndentWidth</span> <span class="params">( qreal width )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>maximumBlockCount(int)</code>: This property specifies the limit for blocks in the document. Specifies the maximum number of blocks the document may have. If there are more blocks in the document that specified with this property blocks are removed from the beginning of the document. A negative or zero value specifies that the document may contain an unlimited amount of blocks. The default value is <code>0</code>. Note that setting this property will apply the limit immediately to the document contents. Setting this property also disables the undo redo history. This property is undefined in documents with tables or frames. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumBlockCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMaximumBlockCount</span> <span class="params">( <span class="keyword">int</span> maximum )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>modified(bool)</code>: This property holds whether the document has been modified by the user. By default, this property is <code>false</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isModified</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setModified</span> <span class="params">( <span class="keyword">bool</span> m = <span class="literal">true</span> )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>pageSize(QSizeF)</code>: This property holds the page size that should be used for laying out the document. By default, for a <code>newly-created</code>, empty document, this property contains an undefined size. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QSizeF <span class="title">pageSize</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPageSize</span><span class="params">(<span class="keyword">const</span> QSizeF &amp; size)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>size(const QSizeF)</code>: Returns the actual size of the document. This is equivalent to <code>documentLayout()-&gt;documentSize()</code>; The size of the document can be changed either by setting a text width or setting an entire page size. Note that the width is always <code>&gt;= pageSize().width()</code>. By default, for a <code>newly-created</code>, empty document, this property contains a <code>configuration-dependent</code> size. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QSizeF <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>textWidth(qreal)</code>: The text width specifies the preferred width for text in the document. If the text (or content in general) is wider than the specified with it is broken into multiple lines and grows vertically. If the text cannot be broken into multiple lines to fit into the specified text width it will be larger and the <code>size()</code> and the <code>idealWidth()</code> property will reflect that. If the text width is set to <code>-1</code> then the text will not be broken into multiple lines unless it is enforced through an explicit line break or a new paragraph. The default value is <code>-1</code>. Setting the text width will also set the page height to <code>-1</code>, causing the document to grow or shrink vertically in a continuous way. If you want the document layout to break the text into multiple pages then you have to set the pageSize property instead. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">qreal <span class="title">textWidth</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTextWidth</span> <span class="params">( qreal width )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>undoRedoEnabled(bool)</code>: This property holds whether undo/redo are enabled for this document. This defaults to <code>true</code>. If disabled, the undo stack is cleared and no items will be added to it. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUndoRedoEnabled</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setUndoRedoEnabled</span> <span class="params">( <span class="keyword">bool</span> enable )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>useDesignMetrics(bool)</code>: This property holds whether the document uses design metrics of fonts to improve the accuracy of text layout. If this property is set to <code>true</code>, the layout will use design metrics. Otherwise, the metrics of the paint device as set on <code>QAbstractTextDocumentLayout::setPaintDevice()</code> will be used. Using design metrics makes a layout have a width that is no longer dependent on hinting and <code>pixel-rounding</code>. This means that <code>WYSIWYG</code> text layout becomes possible because the width scales much more linearly based on paintdevice metrics than it would otherwise. By default, this property is <code>false</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">useDesignMetrics</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setUseDesignMetrics</span> <span class="params">( <span class="keyword">bool</span> b )</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextDocument::QTextDocument(QObject * parent = 0)</code>: Constructs an empty <code>QTextDocument</code> with the given <code>parent</code>.</li>
<li><code>QTextDocument::QTextDocument(const QString &amp; text, QObject * parent = 0)</code>: Constructs a <code>QTextDocument</code> containing the plain (unformatted) <code>text</code> specified, and with the given <code>parent</code>.</li>
<li><code>QTextDocument::~QTextDocument()</code>: Destroys the document.</li>
<li><code>void QTextDocument::addResource(int type, const QUrl &amp; name, const QVariant &amp; resource)</code>: Adds the <code>resource</code> to the resource cache, using <code>type</code> and <code>name</code> as identifiers. <code>type</code> should be a value from <code>QTextDocument::ResourceType</code>. For example, you can add an image as a resource in order to reference it from within the document:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document-&gt;addResource ( QTextDocument::ImageResource, QUrl ( <span class="string">"mydata://image.png"</span> ), QVariant ( image ) );</span><br></pre></td></tr></table></figure>
<p>The image can be inserted into the document using the <code>QTextCursor</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QTextImageFormat imageFormat;</span><br><span class="line">imageFormat.setName ( <span class="string">"mydata://image.png"</span> );</span><br><span class="line">cursor.insertImage ( imageFormat );</span><br></pre></td></tr></table></figure>
<p>Alternatively, you can insert images using the <code>HTML</code> img tag:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">editor-&gt;append ( <span class="string">"&lt;img src=\"mydata://image.png\" /&gt;"</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QTextDocument::adjustSize()</code>: Adjusts the document to a reasonable size.</li>
<li><code>QVector&lt;QTextFormat&gt; QTextDocument::allFormats() const</code>: Returns a vector of text formats for all the formats used in the document.</li>
<li><code>int QTextDocument::availableRedoSteps() const</code>: Returns the number of available redo steps.</li>
<li><code>int QTextDocument::availableUndoSteps() const</code>: Returns the number of available undo steps.</li>
<li><code>QTextBlock QTextDocument::begin() const</code>: Returns the document’s first text block.</li>
<li><code>void QTextDocument::blockCountChanged(int newBlockCount) [signal]</code>: This signal is emitted when the total number of text blocks in the document changes. The value passed in <code>newBlockCount</code> is the new total.</li>
<li><code>QChar QTextDocument::characterAt(int pos) const</code>: Returns the character at position <code>pos</code>, or a null character if the position is out of range.</li>
<li><code>int QTextDocument::characterCount() const</code>: Returns the number of characters of this document.</li>
<li><code>void QTextDocument::clear() [virtual]</code>: Clears the document.</li>
<li><code>void QTextDocument::clearUndoRedoStacks(Stacks stacksToClear = UndoAndRedoStacks)</code>: Clears the stacks specified by <code>stacksToClear</code>. This method clears any commands on the undo stack, the redo stack, or both (the default). If commands are cleared, the appropriate signals are emitted, <code>QTextDocument::undoAvailable()</code> or <code>QTextDocument::redoAvailable()</code>.</li>
<li><code>QTextDocument * QTextDocument::clone(QObject * parent = 0) const</code>: Creates a new QTextDocument that is a copy of this text document. <code>parent</code> is the parent of the returned text document.</li>
<li><code>void QTextDocument::contentsChange(int position, int charsRemoved, int charsAdded) [signal]</code>: This signal is emitted whenever the document’s content changes; for example, when text is inserted or deleted, or when formatting is applied. Information is provided about the <code>position</code> of the character in the document where the change occurred, the number of characters removed (<code>charsRemoved</code>), and the number of characters added (<code>charsAdded</code>). The signal is emitted before the document’s layout manager is notified about the change. This hook allows you to implement syntax highlighting for the document.</li>
<li><code>void QTextDocument::contentsChanged() [signal]</code>: This signal is emitted whenever the document’s content changes; for example, when text is inserted or deleted, or when formatting is applied.</li>
<li><code>QTextObject * QTextDocument::createObject(const QTextFormat &amp; format) [virtual protected]</code>: Creates and returns a new document object (a <code>QTextObject</code>), based on the given <code>format</code>. <code>QTextObjects</code> will always get created through this method, so you must reimplement it if you use custom text objects inside your document.</li>
<li><code>void QTextDocument::cursorPositionChanged(const QTextCursor &amp; cursor) [signal]</code>: This signal is emitted whenever the position of a cursor changed due to an editing operation. The cursor that changed is passed in <code>cursor</code>. If you need a signal when the cursor is moved with the arrow keys, you can use the <code>cursorPositionChanged()</code> signal in <code>QTextEdit</code>.</li>
<li><code>Qt::CursorMoveStyle QTextDocument::defaultCursorMoveStyle() const</code>: The default cursor movement style is used by all <code>QTextCursor</code> objects created from the document. The default is <code>Qt::LogicalMoveStyle</code>.</li>
<li><code>QAbstractTextDocumentLayout * QTextDocument::documentLayout() const</code>: Returns the document layout for this document.</li>
<li><code>void QTextDocument::documentLayoutChanged() [signal]</code>: This signal is emitted when a new document layout is set.</li>
<li><code>void QTextDocument::drawContents(QPainter * p, const QRectF &amp; rect = QRectF())</code>: Draws the content of the document with painter <code>p</code>, clipped to <code>rect</code>. If <code>rect</code> is a null rectangle (default), then the document is painted unclipped.</li>
<li><code>QTextBlock QTextDocument::end() const</code>: This function returns a block to test for the end of the document while iterating over it.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( QTextBlock it = doc-&gt;begin(); it != doc-&gt;end(); it = it.next() ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it.text().toStdString() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The block returned is invalid and represents the block after the last block in the document. You can use <code>lastBlock()</code> to retrieve the last valid block of the document.</p>
<ul>
<li><code>QTextCursor QTextDocument::find(const QString &amp; subString, const QTextCursor &amp; cursor, FindFlags options = 0) const</code>: Finds the next occurrence of the string, <code>subString</code>, in the document. The search starts at the position of the given <code>cursor</code>, and proceeds forwards through the document unless specified otherwise in the search options. The <code>options</code> control the type of search performed. Returns a cursor with the match selected if <code>subString</code> was found; otherwise returns a null cursor. If the given <code>cursor</code> has a selection, the search begins after the selection; otherwise it begins at the cursor’s position. By default the search is <code>case-sensitive</code>, and can match text anywhere in the document.</li>
<li><code>QTextCursor QTextDocument::find(const QRegExp &amp; expr, const QTextCursor &amp; cursor, FindFlags options = 0) const</code>: Finds the next occurrence, matching the regular expression, <code>expr</code>, in the document. The search starts at the position of the given <code>cursor</code>, and proceeds forwards through the document unless specified otherwise in the search options. The <code>options</code> control the type of search performed. The <code>FindCaseSensitively</code> option is ignored for this overload, use <code>QRegExp::caseSensitivity</code> instead. Returns a cursor with the match selected if a match was found; otherwise returns a null cursor. If the given <code>cursor</code> has a selection, the search begins after the selection; otherwise it begins at the cursor’s position. By default the search is <code>case-sensitive</code>, and can match text anywhere in the document.</li>
<li><code>QTextCursor QTextDocument::find(const QString &amp; subString, int position = 0, FindFlags options = 0) const</code>: This is an overloaded function. Finds the next occurrence of the string, <code>subString</code>, in the document. The search starts at the given <code>position</code>, and proceeds forwards through the document unless specified otherwise in the search options. The <code>options</code> control the type of search performed. Returns a cursor with the match selected if <code>subString</code> was found; otherwise returns a null cursor. If the <code>position</code> is <code>0</code> (the default), the search begins from the beginning of the document; otherwise it begins at the specified <code>position</code>.</li>
<li><code>QTextCursor QTextDocument::find(const QRegExp &amp; expr, int position = 0, FindFlags options = 0) const</code>: This is an overloaded function. Finds the next occurrence, matching the regular expression, <code>expr</code>, in the document. The search starts at the given <code>position</code>, and proceeds forwards through the document unless specified otherwise in the search options. The <code>options</code> control the type of search performed. The <code>FindCaseSensitively</code> option is ignored for this overload, use <code>QRegExp::caseSensitivity</code> instead. Returns a cursor with the match selected if a match was found; otherwise returns a null cursor. If the <code>position</code> is <code>0</code> (the default) the search begins from the beginning of the document; otherwise it begins at the specified <code>position</code>.</li>
<li><code>QTextBlock QTextDocument::findBlock(int pos) const</code>: Returns the text block that contains the <code>pos-th</code> character.</li>
<li><code>QTextBlock QTextDocument::findBlockByLineNumber(int lineNumber) const</code>: Returns the text block that contains the specified <code>lineNumber</code>.</li>
<li><code>QTextBlock QTextDocument::findBlockByNumber(int blockNumber) const</code>: Returns the text block with the specified <code>blockNumber</code>.</li>
<li><code>QTextBlock QTextDocument::firstBlock() const</code>: Returns the document’s first text block.</li>
<li><code>qreal QTextDocument::idealWidth() const</code>: Returns the ideal width of the text document. The ideal width is the actually used width of the document without optional alignments taken into account. It is always <code>&lt;= size().width()</code>.</li>
<li><code>bool QTextDocument::isEmpty() const</code>: Returns <code>true</code> if the document is empty; otherwise returns <code>false</code>.</li>
<li><code>bool QTextDocument::isRedoAvailable() const</code>: Returns <code>true</code> if redo is available; otherwise returns <code>false</code>.</li>
<li><code>bool QTextDocument::isUndoAvailable() const</code>: Returns <code>true</code> if undo is available; otherwise returns <code>false</code>.</li>
<li><code>QTextBlock QTextDocument::lastBlock() const</code>: Returns the document’s last (valid) text block.</li>
<li><code>int QTextDocument::lineCount() const</code>: Returns the number of lines of this document (if the layout supports this). Otherwise, this is identical to the number of blocks.</li>
<li><code>QVariant QTextDocument::loadResource(int type, const QUrl &amp; name) [virtual protected]</code>: Loads data of the specified <code>type</code> from the resource with the given <code>name</code>. This function is called by the rich text engine to request data that isn’t directly stored by <code>QTextDocument</code>, but still associated with it. For example, images are referenced indirectly by the name attribute of a <code>QTextImageFormat</code> object. When called by <code>Qt</code>, <code>type</code> is one of the values of <code>QTextDocument::ResourceType</code>. If the <code>QTextDocument</code> is a child object of a <code>QTextEdit</code>, <code>QTextBrowser</code>, or a <code>QTextDocument</code> itself then the default implementation tries to retrieve the data from the parent.</li>
<li><code>void QTextDocument::markContentsDirty(int position, int length)</code>: Marks the contents specified by the given <code>position</code> and <code>length</code> as <code>dirty</code>, informing the document that it needs to be laid out again.</li>
<li><code>QString QTextDocument::metaInformation(MetaInformation info) const</code>: Returns meta information about the document of the type specified by <code>info</code>.</li>
<li><code>void QTextDocument::modificationChanged(bool changed) [signal]</code>: This signal is emitted whenever the content of the document changes in a way that affects the modification state. If <code>changed</code> is <code>true</code>, the document has been modified; otherwise it is <code>false</code>. For example, calling <code>setModified(false)</code> on a document and then inserting text causes the signal to get emitted. If you undo that operation, causing the document to return to its original unmodified state, the signal will get emitted again.</li>
<li><code>QTextObject * QTextDocument::object(int objectIndex) const</code>: Returns the text object associated with the given <code>objectIndex</code>.</li>
<li><code>QTextObject * QTextDocument::objectForFormat(const QTextFormat &amp; f) const</code>: Returns the text object associated with the format <code>f</code>.</li>
<li><code>int QTextDocument::pageCount() const</code>: Returns the number of pages in this document.</li>
<li><code>void QTextDocument::print(QPrinter * printer) const</code>: Prints the document to the given <code>printer</code>. The <code>QPrinter</code> must be set up before being used with this function. This is only a convenience method to print the whole document to the printer. If the document is already paginated through a specified height in the <code>pageSize()</code> property it is printed <code>as-is</code>. If the document is not paginated, like for example a document used in a <code>QTextEdit</code>, then a temporary copy of the document is created and the copy is broken into multiple pages according to the size of the <code>QPrinter&#39;s</code> <code>paperRect()</code>. By default a <code>2</code> cm margin is set around the document contents. In addition the current page number is printed at the bottom of each page. Note that <code>QPrinter::Selection</code> is not supported as print range with this function since the selection is a property of <code>QTextCursor</code>. If you have a <code>QTextEdit</code> associated with your <code>QTextDocument</code> then you can use <code>QTextEdit&#39;s</code> <code>print()</code> function because <code>QTextEdit</code> has access to the user’s selection.</li>
<li><code>void QTextDocument::redo(QTextCursor * cursor)</code>: Redoes the last editing operation on the document if redo is available. The provided <code>cursor</code> is positioned at the end of the location where the edition operation was redone.</li>
<li><code>void QTextDocument::redo() [slot]</code>: This is an overloaded function. Redoes the last editing operation on the document if redo is available.</li>
<li><code>void QTextDocument::redoAvailable(bool available) [signal]</code>: This signal is emitted whenever redo operations become available (<code>available</code> is <code>true</code>) or unavailable (<code>available</code> is <code>false</code>).</li>
<li><code>QVariant QTextDocument::resource(int type, const QUrl &amp; name) const</code>: Returns data of the specified <code>type</code> from the resource with the given <code>name</code>. This function is called by the rich text engine to request data that isn’t directly stored by <code>QTextDocument</code>, but still associated with it. For example, images are referenced indirectly by the name attribute of a <code>QTextImageFormat</code> object. Resources are cached internally in the document. If a resource can not be found in the cache, <code>loadResource</code> is called to try to load the resource. <code>loadResource</code> should then use <code>addResource</code> to add the resource to the cache.</li>
<li><code>int QTextDocument::revision() const</code>: Returns the document’s revision (if undo is enabled). The revision is guaranteed to increase when a document that is not modified is edited.</li>
<li><code>QTextFrame * QTextDocument::rootFrame() const</code>: Returns the document’s root frame.</li>
<li><code>void QTextDocument::setDefaultCursorMoveStyle(Qt::CursorMoveStyle style)</code>: Sets the default cursor movement style to the given <code>style</code>.</li>
<li><code>void QTextDocument::setDocumentLayout(QAbstractTextDocumentLayout * layout)</code>: Sets the document to use the given <code>layout</code>. The previous layout is deleted.</li>
<li><code>void QTextDocument::setHtml(const QString &amp; html)</code>: Replaces the entire contents of the document with the given <code>HTML-formatted</code> text in the <code>html</code> string. The <code>HTML</code> formatting is respected as much as possible; for example, <code>&lt;b&gt;bold&lt;/b&gt; text</code> will produce text where the first word has a font weight that gives it a bold appearance: <code>bold text</code>. <strong>Note</strong>: It is the responsibility of the caller to make sure that the text is correctly decoded when a <code>QString</code> containing <code>HTML</code> is created and passed to <code>setHtml()</code>.</li>
<li><code>void QTextDocument::setMetaInformation(MetaInformation info, const QString &amp; string)</code>: Sets the document’s meta information of the type specified by <code>info</code> to the given <code>string</code>.</li>
<li><code>void QTextDocument::setPlainText(const QString &amp; text)</code>: Replaces the entire contents of the document with the given plain <code>text</code>.</li>
<li><code>QString QTextDocument::toHtml(const QByteArray &amp; encoding = QByteArray()) const</code>: Returns a string containing an <code>HTML</code> representation of the document. The <code>encoding</code> parameter specifies the value for the charset attribute in the html header. For example if <code>utf-8</code> is specified then the beginning of the generated html will look like this:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>...</span><br></pre></td></tr></table></figure>
<p>If no encoding is specified then no such meta information is generated. If you later on convert the returned html string into a byte array for transmission over a network or when saving to disk you should specify the encoding you’re going to use for the conversion to a byte array here.</p>
<ul>
<li><code>QString QTextDocument::toPlainText() const</code>: Returns the plain text contained in the document. If you want formatting information use a <code>QTextCursor</code> instead.</li>
<li><code>void QTextDocument::undo(QTextCursor * cursor)</code>: Undoes the last editing operation on the document if undo is available. The provided <code>cursor</code> is positioned at the end of the location where the edition operation was undone.</li>
<li><code>void QTextDocument::undo() [slot]</code>: This is an overloaded function.</li>
<li><code>void QTextDocument::undoAvailable(bool available) [signal]</code>: This signal is emitted whenever undo operations become available (<code>available</code> is true) or unavailable (<code>available</code> is false).</li>
<li><code>void QTextDocument::undoCommandAdded() [signal]</code>: This signal is emitted every time a new level of undo is added to the <code>QTextDocument</code>.</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/01/Qt语法详解/Qt之拖放/" rel="next" title="Qt之拖放">
                <i class="fa fa-chevron-left"></i> Qt之拖放
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/02/Qt语法详解/Qt之sqlite数据库/" rel="prev" title="Qt之sqlite数据库">
                Qt之sqlite数据库 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">949</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Public-Functions"><span class="nav-number">1.</span> <span class="nav-text">Public Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Public-Slots"><span class="nav-number">2.</span> <span class="nav-text">Public Slots</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Signals"><span class="nav-number">3.</span> <span class="nav-text">Signals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Protected-Functions"><span class="nav-number">4.</span> <span class="nav-text">Protected Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Detailed-Description"><span class="nav-number">5.</span> <span class="nav-text">Detailed Description</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Member-Type-Documentation"><span class="nav-number">6.</span> <span class="nav-text">Member Type Documentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Property-Documentation"><span class="nav-number">7.</span> <span class="nav-text">Property Documentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Member-Function-Documentation"><span class="nav-number">8.</span> <span class="nav-text">Member Function Documentation</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
