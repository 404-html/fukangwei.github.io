<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="&amp;emsp;&amp;emsp;拖放是应用程序内或者多个应用程序之间传递信息的一种直观的操作方式。除了为剪贴板提供支持之外，通常还提供数据的移动和复制功能。&amp;emsp;&amp;emsp;拖放操作包括两个截然不同的动作，即拖动、放下。Qt窗口部件可以作为拖动点(drag site)、放下点(drop site)或者同时作为拖动点和放下点。&amp;emsp;&amp;emsp;下面介绍如何让一个Qt应用程序接收一个拖动操作，当用">
<meta property="og:type" content="article">
<meta property="og:title" content="Qt之拖放">
<meta property="og:url" content="http://fukangwei.gitee.io/2019/02/01/Qt语法详解/Qt之拖放/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:description" content="&amp;emsp;&amp;emsp;拖放是应用程序内或者多个应用程序之间传递信息的一种直观的操作方式。除了为剪贴板提供支持之外，通常还提供数据的移动和复制功能。&amp;emsp;&amp;emsp;拖放操作包括两个截然不同的动作，即拖动、放下。Qt窗口部件可以作为拖动点(drag site)、放下点(drop site)或者同时作为拖动点和放下点。&amp;emsp;&amp;emsp;下面介绍如何让一个Qt应用程序接收一个拖动操作，当用">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-04-02T11:20:45.833Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Qt之拖放">
<meta name="twitter:description" content="&amp;emsp;&amp;emsp;拖放是应用程序内或者多个应用程序之间传递信息的一种直观的操作方式。除了为剪贴板提供支持之外，通常还提供数据的移动和复制功能。&amp;emsp;&amp;emsp;拖放操作包括两个截然不同的动作，即拖动、放下。Qt窗口部件可以作为拖动点(drag site)、放下点(drop site)或者同时作为拖动点和放下点。&amp;emsp;&amp;emsp;下面介绍如何让一个Qt应用程序接收一个拖动操作，当用">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/2019/02/01/Qt语法详解/Qt之拖放/">





  <title>Qt之拖放 | 泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/01/Qt语法详解/Qt之拖放/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Qt之拖放</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-01T18:27:48+08:00">
                2019-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&emsp;&emsp;拖放是应用程序内或者多个应用程序之间传递信息的一种直观的操作方式。除了为剪贴板提供支持之外，通常还提供数据的移动和复制功能。<br>&emsp;&emsp;拖放操作包括两个截然不同的动作，即拖动、放下。<code>Qt</code>窗口部件可以作为拖动点(<code>drag site</code>)、放下点(<code>drop site</code>)或者同时作为拖动点和放下点。<br>&emsp;&emsp;下面介绍如何让一个<code>Qt</code>应用程序接收一个拖动操作，当用户从桌面或者文件资源管理器中拖动一个文件到这个应用程序上放下时，该应用程序就会将文件的信息显示出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabelView</span> :</span> <span class="keyword">public</span> QTableView &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TabelView</span> <span class="params">( QWidget *parent = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dragEnterEvent</span> <span class="params">( QDragEnterEvent *event )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dragMoveEvent</span> <span class="params">( QDragMoveEvent *event )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dropEvent</span> <span class="params">( QDropEvent *event )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">TabelView::TabelView ( QWidget *parent ) : QTableView ( parent ) &#123;</span><br><span class="line">    setAcceptDrops ( <span class="literal">true</span> );</span><br><span class="line">    setDragDropMode ( QAbstractItemView::DragDrop );</span><br><span class="line">    setDragEnabled ( <span class="literal">true</span> );</span><br><span class="line">    setDropIndicatorShown ( <span class="literal">true</span> );</span><br><span class="line">    <span class="keyword">this</span>-&gt;setWindowTitle ( <span class="string">"TableView"</span> );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> TabelView::dragEnterEvent ( QDragEnterEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasFormat ( <span class="string">"text/uri-list"</span> ) ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"drag enter"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;以上通过自定义<code>QTableView</code>来实现拖放事件，首先需要设置<code>setAcceptDrops(true)</code>来接受放下事件，通过设置<code>setDropIndicatorShown(true)</code>则可以清晰地看到放下过程中的图标指示。然后实现<code>dragEnterEvent</code>、<code>dropEvent</code>方法，当用户把一个对象拖动到这个窗体上时，就会调用<code>dragEnterEvent</code>，如果对这个事件调用<code>acceptProposedAction</code>，就表明可以在这个窗体上拖放对象。默认情况下窗口部件是不接受拖动的，<code>Qt</code>会自动改变光标向用户说明这个窗口部件不是有效的放下点。<br>&emsp;&emsp;我们希望用户拖放的只能是文件，而非其他类型的东西。为了实现这一点，可以检查拖动的<code>MIME</code>类型。<code>MIME</code>类型中<code>text/uri-list</code>用于存储统一资源标识符，它们可以是文件名、统一资源定位器(例如<code>HTTP</code>、<code>FTP</code>路径)或者其它全局资源标识符。标准的<code>MIME</code>类型由国际因特网地址分配委员会<code>IANA</code>定义的，它们由类型、子类型信息以及分割两者的斜线组成。<code>MIME</code>类通常由剪贴板和拖放系统使用，以识别不同类型的数据。<br>&emsp;&emsp;当用户在窗口部件上放下一个对象时，就会调用<code>dropEvent</code>。我们调用函数<code>QMimeData::urls</code>来获得<code>QUrl</code>列表。通常情况下，用户一次只拖动一个选择区域来同时拖动多个文件也是可能的，如果要拖放的<code>URL</code>不止一个，或者要拖放的<code>URL</code>不是一个本地文件名，则会立即返回到原调用处。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TabelView::dragMoveEvent ( QDragMoveEvent *event ) &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"drag move"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>QWidget</code>也提供了<code>dragMoveEvent</code>和<code>dragLeveEvent</code>函数，但是绝大多数情况下并不需要重新实现，上面简单实现了<code>dragMoveEvent</code>函数。</p>
<hr>
<h3 id="Drag-and-Drop"><a href="#Drag-and-Drop" class="headerlink" title="Drag and Drop"></a>Drag and Drop</h3><p>&emsp;&emsp;Drag and drop provides a simple visual mechanism which users can use to transfer information between and within applications (In the literature this is referred to as a <code>direct manipulation model</code>). Drag and drop is similar in function to the clipboard’s cut and paste mechanism.<br>&emsp;&emsp;This document describes the basic drag and drop mechanism and outlines the approach used to enable it in custom widgets. Drag and drop operations are also supported by Qt’s item views and by the graphics view framework. More information is available in Using drag and drop with item views and <code>Graphics View Framework</code>.</p>
<h3 id="Drag-and-Drop-Classes"><a href="#Drag-and-Drop-Classes" class="headerlink" title="Drag and Drop Classes"></a>Drag and Drop Classes</h3><p>&emsp;&emsp;These classes deal with drag and drop and the necessary mime type encoding and decoding.</p>
<ul>
<li>QDragEnterEvent: Event which is sent to a widget when a drag and drop action enters it.</li>
<li>QDragLeaveEvent: Event that is sent to a widget when a drag and drop action leaves it.</li>
<li>QDragMoveEvent: Event which is sent while a drag and drop action is in progress.</li>
<li>QDropEvent: Event which is sent when a drag and drop action is completed.</li>
<li>QMacPasteboardMime: Converts between a <code>MIME</code> type and a <code>Uniform Type Identifier</code> (<code>UTI</code>) format.</li>
<li>QWindowsMime: Maps <code>open-standard</code> <code>MIME</code> to Window <code>Clipboard</code> formats.</li>
</ul>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><p>&emsp;&emsp;The <code>QApplication</code> object provides some properties that are related to drag and drop operations:</p>
<ul>
<li><code>QApplication::startDragTime</code> describes the amount of time in milliseconds that the user must hold down a mouse button over an object before a drag will begin.</li>
<li><code>QApplication::startDragDistance</code> indicates how far the user has to move the mouse while holding down a mouse button before the movement will be interpreted as dragging. Use of high values for this quantity prevents accidental dragging when the user only meant to click on an object.</li>
</ul>
<p>&emsp;&emsp;These quantities provide sensible default values for you to use if you provide drag and drop support in your widgets.</p>
<h3 id="Dragging"><a href="#Dragging" class="headerlink" title="Dragging"></a>Dragging</h3><p>&emsp;&emsp;To start a drag, create a <code>QDrag</code> object, and call its <code>exec()</code> function. In most applications, it is a good idea to begin a drag and drop operation only after a mouse button has been pressed and the cursor has been moved a certain distance. However, the simplest way to enable dragging from a widget is to reimplement the widget’s <code>mousePressEvent()</code> and start a drag and drop operation:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::mousePressEvent ( QMouseEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;button() == Qt::LeftButton</span><br><span class="line">         &amp;&amp; iconLabel-&gt;geometry().contains ( event-&gt;pos() ) ) &#123;</span><br><span class="line">        QDrag *drag = <span class="keyword">new</span> QDrag ( <span class="keyword">this</span> );</span><br><span class="line">        QMimeData *mimeData = <span class="keyword">new</span> QMimeData;</span><br><span class="line">        mimeData-&gt;setText ( commentEdit-&gt;toPlainText() );</span><br><span class="line">        drag-&gt;setMimeData ( mimeData );</span><br><span class="line">        drag-&gt;setPixmap ( iconPixmap );</span><br><span class="line">        Qt::DropAction dropAction = drag-&gt;exec();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Although the user may take some time to complete the dragging operation, as far as the application is concerned the <code>exec()</code> function is a blocking function that returns with one of several values. These indicate how the operation ended, and are described in more detail below.<br>&emsp;&emsp;Note that the <code>exec()</code> function does not block the main event loop.<br>&emsp;&emsp;For widgets that need to distinguish between mouse clicks and drags, it is useful to reimplement the widget’s <code>mousePressEvent()</code> function to record to start position of the drag:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DragWidget::mousePressEvent ( QMouseEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;button() == Qt::LeftButton ) &#123;</span><br><span class="line">        dragStartPosition = event-&gt;pos();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Later, in <code>mouseMoveEvent()</code>, we can determine whether a drag should begin, and construct a drag object to handle the operation:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DragWidget::mouseMoveEvent ( QMouseEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ! ( event-&gt;buttons() &amp; Qt::LeftButton ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( event-&gt;pos() - dragStartPosition ).manhattanLength() &lt; QApplication::startDragDistance() ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    QDrag *drag = <span class="keyword">new</span> QDrag ( <span class="keyword">this</span> );</span><br><span class="line">    QMimeData *mimeData = <span class="keyword">new</span> QMimeData;</span><br><span class="line">    mimeData-&gt;setData ( mimeType, data );</span><br><span class="line">    drag-&gt;setMimeData ( mimeData );</span><br><span class="line">    Qt::DropAction dropAction = drag-&gt;exec ( Qt::CopyAction | Qt::MoveAction );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This particular approach uses the <code>QPoint::manhattanLength()</code> function to get a rough estimate of the distance between where the mouse click occurred and the current cursor position. This function trades accuracy for speed, and is usually suitable for this purpose.</p>
<h3 id="Dropping"><a href="#Dropping" class="headerlink" title="Dropping"></a>Dropping</h3><p>&emsp;&emsp;To be able to receive media dropped on a widget, call <code>setAcceptDrops(true)</code> for the widget, and reimplement the <code>dragEnterEvent()</code> and <code>dropEvent()</code> event handler functions.<br>&emsp;&emsp;For example, the following code enables drop events in the constructor of a <code>QWidget</code> subclass, making it possible to usefully implement drop event handlers:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Window::Window ( QWidget *parent ) : QWidget ( parent ) &#123;</span><br><span class="line">    ...</span><br><span class="line">    setAcceptDrops ( <span class="literal">true</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>dragEnterEvent()</code> function is typically used to inform Qt about the types of data that the widget accepts. You must reimplement this function if you want to receive either <code>QDragMoveEvent</code> or <code>QDropEvent</code> in your reimplementations of <code>dragMoveEvent()</code> and <code>dropEvent()</code>.<br>&emsp;&emsp;The following code shows how <code>dragEnterEvent()</code> can be reimplemented to tell the drag and drop system that we can only handle plain text:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Window::dragEnterEvent ( QDragEnterEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasFormat ( <span class="string">"text/plain"</span> ) ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>dropEvent()</code> is used to unpack dropped data and handle it in way that is suitable for your application.<br>&emsp;&emsp;In the following code, the text supplied in the event is passed to a <code>QTextBrowser</code> and a <code>QComboBox</code> is filled with the list of <code>MIME</code> types that are used to describe the data:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Window::dropEvent ( QDropEvent *event ) &#123;</span><br><span class="line">    textBrowser-&gt;setPlainText ( event-&gt;mimeData()-&gt;text() );</span><br><span class="line">    mimeTypeCombo-&gt;clear();</span><br><span class="line">    mimeTypeCombo-&gt;addItems ( event-&gt;mimeData()-&gt;formats() );</span><br><span class="line">    event-&gt;acceptProposedAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;In this case, we accept the proposed action without checking what it is. In a real world application, it may be necessary to return from the <code>dropEvent()</code> function without accepting the proposed action or handling the data if the action is not relevant. For example, we may choose to ignore <code>Qt::LinkAction</code> actions if we do not support links to external sources in our application.</p>
<h3 id="Overriding-Proposed-Actions"><a href="#Overriding-Proposed-Actions" class="headerlink" title="Overriding Proposed Actions"></a>Overriding Proposed Actions</h3><p>&emsp;&emsp;We may also ignore the proposed action, and perform some other action on the data. To do this, we would call the event object’s <code>setDropAction()</code> with the preferred action from <code>Qt::DropAction</code> before calling <code>accept()</code>. This ensures that the replacement drop action is used instead of the proposed action.<br>&emsp;&emsp;For more sophisticated applications, reimplementing <code>dragMoveEvent()</code> and <code>dragLeaveEvent()</code> will let you make certain parts of your widgets sensitive to drop events, and give you more control over drag and drop in your application.</p>
<h3 id="Subclassing-Complex-Widgets"><a href="#Subclassing-Complex-Widgets" class="headerlink" title="Subclassing Complex Widgets"></a>Subclassing Complex Widgets</h3><p>&emsp;&emsp;Certain standard Qt widgets provide their own support for drag and drop. When subclassing these widgets, it may be necessary to reimplement <code>dragMoveEvent()</code> in addition to <code>dragEnterEvent()</code> and <code>dropEvent()</code> to prevent the base class from providing default drag and drop handling, and to handle any special cases you are interested in.</p>
<h3 id="Drag-and-Drop-Actions"><a href="#Drag-and-Drop-Actions" class="headerlink" title="Drag and Drop Actions"></a>Drag and Drop Actions</h3><p>&emsp;&emsp;In the simplest case, the target of a drag and drop action receives a copy of the data being dragged, and the source decides whether to delete the original. This is described by the <code>CopyAction</code> action. The target may also choose to handle other actions, specifically the <code>MoveAction</code> and <code>LinkAction</code> actions. If the source calls <code>QDrag::exec()</code>, and it returns <code>MoveAction</code>, the source is responsible for deleting any original data if it chooses to do so. The <code>QMimeData</code> and <code>QDrag</code> objects created by the source widget should not be deleted — they will be destroyed by Qt. The target is responsible for taking ownership of the data sent in the drag and drop operation; this is usually done by keeping references to the data.<br>&emsp;&emsp;If the target understands the <code>LinkAction</code> action, it should store its own reference to the original information; the source does not need to perform any further processing on the data. The most common use of drag and drop actions is when performing a <code>Move</code> within the same widget.<br>&emsp;&emsp;The other major use of drag actions is when using a reference type such as text/uri-list, where the dragged data are actually references to files or objects.</p>
<h3 id="Adding-New-Drag-and-Drop-Types"><a href="#Adding-New-Drag-and-Drop-Types" class="headerlink" title="Adding New Drag and Drop Types"></a>Adding New Drag and Drop Types</h3><p>&emsp;&emsp;Drag and drop is not limited to text and images. Any type of information can be transferred in a drag and drop operation. To drag information between applications, the applications must be able to indicate to each other which data formats they can accept and which they can produce. This is achieved using <code>MIME</code> types. The <code>QDrag</code> object constructed by the source contains a list of <code>MIME</code> types that it uses to represent the data (ordered from most appropriate to least appropriate), and the drop target uses one of these to access the data. For common data types, the convenience functions handle the <code>MIME</code> types used transparently but, for custom data types, it is necessary to state them explicitly.<br>&emsp;&emsp;To implement drag and drop actions for a type of information that is not covered by the <code>QDrag</code> convenience functions, the first and most important step is to look for existing formats that are appropriate: The <code>Internet Assigned Numbers Authority</code> (<code>IANA</code>) provides a hierarchical list of <code>MIME</code> media types at the <code>Information Sciences Institute</code> (<code>ISI</code>). Using standard <code>MIME</code> types maximizes the interoperability of your application with other software now and in the future.<br>&emsp;&emsp;To support an additional media type, simply set the data in the <code>QMimeData</code> object with the <code>setData()</code> function, supplying the full <code>MIME</code> type and a <code>QByteArray</code> containing the data in the appropriate format. The following code takes a pixmap from a label and stores it as a <code>Portable Network Graphics</code> (<code>PNG</code>) file in a <code>QMimeData</code> object:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QByteArray output;</span><br><span class="line"><span class="function">QBuffer <span class="title">outputBuffer</span> <span class="params">( &amp;output )</span></span>;</span><br><span class="line">outputBuffer.open ( QIODevice::WriteOnly );</span><br><span class="line">imageLabel-&gt;pixmap()-&gt;toImage().save ( &amp;outputBuffer, <span class="string">"PNG"</span> );</span><br><span class="line">mimeData-&gt;setData ( <span class="string">"image/png"</span>, output );</span><br></pre></td></tr></table></figure>
<p>Of course, for this case we could have simply used <code>setImageData()</code> instead to supply image data in a variety of formats:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimeData-&gt;setImageData ( QVariant ( *imageLabel-&gt;pixmap() ) );</span><br></pre></td></tr></table></figure>
<p>The <code>QByteArray</code> approach is still useful in this case because it provides greater control over the amount of data stored in the <code>QMimeData</code> object. Note that custom datatypes used in item views must be declared as meta objects and that stream operators for them must be implemented.</p>
<h3 id="Drop-Actions"><a href="#Drop-Actions" class="headerlink" title="Drop Actions"></a>Drop Actions</h3><p>&emsp;&emsp;In the clipboard model, the user can cut or copy the source information, then later paste it. Similarly in the drag and drop model, the user can drag a copy of the information or they can drag the information itself to a new place (moving it). The drag and drop model has an additional complication for the programmer: The program doesn’t know whether the user wants to cut or copy the information until the operation is complete. This often makes no difference when dragging information between applications, but within an application it is important to check which drop action was used.<br>&emsp;&emsp;We can reimplement the <code>mouseMoveEvent()</code> for a widget, and start a drag and drop operation with a combination of possible drop actions. For example, we may want to ensure that dragging always moves objects in the widget:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DragWidget::mouseMoveEvent ( QMouseEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ! ( event-&gt;buttons() &amp; Qt::LeftButton ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> ( ( event-&gt;pos() - dragStartPosition ).manhattanLength()</span><br><span class="line">         &lt; QApplication::startDragDistance() ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    QDrag *drag = <span class="keyword">new</span> QDrag ( <span class="keyword">this</span> );</span><br><span class="line">    QMimeData *mimeData = <span class="keyword">new</span> QMimeData;</span><br><span class="line">    mimeData-&gt;setData ( mimeType, data );</span><br><span class="line">    drag-&gt;setMimeData ( mimeData );</span><br><span class="line">    Qt::DropAction dropAction = drag-&gt;exec ( Qt::CopyAction | Qt::MoveAction );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The action returned by the <code>exec()</code> function may default to a <code>CopyAction</code> if the information is dropped into another application but, if it is dropped in another widget in the same application, we may obtain a different drop action.<br>&emsp;&emsp;The proposed drop actions can be filtered in a widget’s <code>dragMoveEvent()</code> function. However, it is possible to accept all proposed actions in the <code>dragEnterEvent()</code> and let the user decide which they want to accept later:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DragWidget::dragEnterEvent ( QDragEnterEvent *event ) &#123;</span><br><span class="line">    event-&gt;acceptProposedAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;When a drop occurs in the widget, the <code>dropEvent()</code> handler function is called, and we can deal with each possible action in turn. First, we deal with drag and drop operations within the same widget:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DragWidget::dropEvent ( QDropEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;source() == <span class="keyword">this</span> &amp;&amp; event-&gt;possibleActions() &amp; Qt::MoveAction )</span><br><span class="line">        <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;In this case, we refuse to deal with move operations. Each type of drop action that we accept is checked and dealt with accordingly:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ( event-&gt;proposedAction() == Qt::MoveAction ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">        <span class="comment">/* Process the data from the event */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( event-&gt;proposedAction() == Qt::CopyAction ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">        <span class="comment">/* Process the data from the event */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Ignore the drop */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that we checked for individual drop actions in the above code. As mentioned above in the section on <code>Overriding Proposed Actions</code>, it is sometimes necessary to override the proposed drop action and choose a different one from the selection of possible drop actions. To do this, you need to check for the presence of each action in the value supplied by the event’s <code>possibleActions()</code>, set the drop action with <code>setDropAction()</code>, and call <code>accept()</code>.</p>
<h3 id="Drop-Rectangles"><a href="#Drop-Rectangles" class="headerlink" title="Drop Rectangles"></a>Drop Rectangles</h3><p>&emsp;&emsp;The widget’s <code>dragMoveEvent()</code> can be used to restrict drops to certain parts of the widget by only accepting the proposed drop actions when the cursor is within those areas. For example, the following code accepts any proposed drop actions when the cursor is over a child widget (dropFrame):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Window::dragMoveEvent ( QDragMoveEvent *event ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( event-&gt;mimeData()-&gt;hasFormat ( <span class="string">"text/plain"</span> ) &amp;&amp; \</span><br><span class="line">         event-&gt;answerRect().intersects ( dropFrame-&gt;geometry() ) ) &#123;</span><br><span class="line">        event-&gt;acceptProposedAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>dragMoveEvent()</code> can also be used if you need to give visual feedback during a drag and drop operation, to scroll the window, or whatever is appropriate.</p>
<h3 id="The-Clipboard"><a href="#The-Clipboard" class="headerlink" title="The Clipboard"></a>The Clipboard</h3><p>&emsp;&emsp;Applications can also communicate with each other by putting data on the clipboard. To access this, you need to obtain a <code>QClipboard</code> object from the <code>QApplication</code> object:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clipboard = QApplication::clipboard();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>QMimeData</code> class is used to represent data that is transferred to and from the clipboard. To put data on the clipboard, you can use the <code>setText()</code>, <code>setImage()</code> and <code>setPixmap()</code> convenience functions for common data types. These functions are similar to those found in the <code>QMimeData</code> class, except that they also take an additional argument that controls where the data is stored: If <code>Clipboard</code> is specified, the data is placed on the clipboard; if <code>Selection</code> is specified, the data is placed in the mouse selection (on <code>X11</code> only). By default, data is put on the clipboard.<br>&emsp;&emsp;For example, we can copy the contents of a <code>QLineEdit</code> to the clipboard with the following code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clipboard-&gt;setText ( lineEdit-&gt;text(), QClipboard::Clipboard );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Data with different <code>MIME</code> types can also be put on the clipboard. Construct a <code>QMimeData</code> object and set data with <code>setData()</code> function in the way described in the previous section; this object can then be put on the clipboard with the <code>setMimeData()</code> function.<br>&emsp;&emsp;The <code>QClipboard</code> class can notify the application about changes to the data it contains via its <code>dataChanged()</code> signal. For example, we can monitor the clipboard by connecting this signal to a slot in a widget:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect ( clipboard, SIGNAL ( dataChanged() ), <span class="keyword">this</span>, SLOT ( updateClipboard() ) );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The slot connected to this signal can read the data on the clipboard using one of the <code>MIME</code> types that can be used to represent it:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ClipWindow::updateClipboard() &#123;</span><br><span class="line">    QStringList formats = clipboard-&gt;mimeData()-&gt;formats();</span><br><span class="line">    QByteArray data = clipboard-&gt;mimeData()-&gt;data ( format );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The <code>selectionChanged()</code> signal can be used on <code>X11</code> to monitor the mouse selection.</p>
<h3 id="Interoperating-with-Other-Applications"><a href="#Interoperating-with-Other-Applications" class="headerlink" title="Interoperating with Other Applications"></a>Interoperating with Other Applications</h3><p>&emsp;&emsp;On <code>X11</code>, the public <code>XDND</code> protocol is used, while on <code>Windows</code> Qt uses the <code>OLE</code> standard, and Qt for <code>Mac OS X</code> uses the <code>Carbon Drag Manager</code>. On <code>X11</code>, <code>XDND</code> uses <code>MIME</code>, so no translation is necessary. The Qt API is the same regardless of the platform. On <code>Windows</code>, <code>MIME-aware</code> applications can communicate by using clipboard format names that are <code>MIME</code> types. Already some Windows applications use <code>MIME</code> naming conventions for their clipboard formats. Internally, Qt uses <code>QWindowsMime</code> and <code>QMacPasteboardMime</code> for translating proprietary clipboard formats to and from <code>MIME</code> types.<br><strong>Note</strong>: The <code>Motif Drag &amp; Drop Protocol</code> only allows receivers to request data in response to a <code>QDropEvent</code>. If you attempt to request data in response to e.g. a <code>QDragMoveEvent</code>, an empty <code>QByteArray</code> is returned.</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/01/Qt语法详解/QString用法/" rel="next" title="QString用法">
                <i class="fa fa-chevron-left"></i> QString用法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/02/Qt语法详解/Qt之QTextDocument/" rel="prev" title="Qt之QTextDocument">
                Qt之QTextDocument <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">949</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Drag-and-Drop"><span class="nav-number">1.</span> <span class="nav-text">Drag and Drop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Drag-and-Drop-Classes"><span class="nav-number">2.</span> <span class="nav-text">Drag and Drop Classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Configuration"><span class="nav-number">3.</span> <span class="nav-text">Configuration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dragging"><span class="nav-number">4.</span> <span class="nav-text">Dragging</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dropping"><span class="nav-number">5.</span> <span class="nav-text">Dropping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Overriding-Proposed-Actions"><span class="nav-number">6.</span> <span class="nav-text">Overriding Proposed Actions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Subclassing-Complex-Widgets"><span class="nav-number">7.</span> <span class="nav-text">Subclassing Complex Widgets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Drag-and-Drop-Actions"><span class="nav-number">8.</span> <span class="nav-text">Drag and Drop Actions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Adding-New-Drag-and-Drop-Types"><span class="nav-number">9.</span> <span class="nav-text">Adding New Drag and Drop Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Drop-Actions"><span class="nav-number">10.</span> <span class="nav-text">Drop Actions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Drop-Rectangles"><span class="nav-number">11.</span> <span class="nav-text">Drop Rectangles</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Clipboard"><span class="nav-number">12.</span> <span class="nav-text">The Clipboard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interoperating-with-Other-Applications"><span class="nav-number">13.</span> <span class="nav-text">Interoperating with Other Applications</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
