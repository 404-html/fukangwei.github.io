<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="&amp;emsp;&amp;emsp;Qt中实现树形结构可以使用QTreeWidget类，也可以使用QTreeView类，QTreeWidget继承自QTreeView类，其效果如下：  树形结构实现&amp;emsp;&amp;emsp;QT的GUI中有treeWidget部件，将该控件在GUI中布局好，假设其对象名为treeWidget。树形结构通过QTreeWidget类和QTreeWidgetItem类实现，QTree">
<meta property="og:type" content="article">
<meta property="og:title" content="Qt之QTreeWidget">
<meta property="og:url" content="http://fukangwei.gitee.io/2019/02/22/Qt语法详解/Qt之QTreeWidget/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:description" content="&amp;emsp;&amp;emsp;Qt中实现树形结构可以使用QTreeWidget类，也可以使用QTreeView类，QTreeWidget继承自QTreeView类，其效果如下：  树形结构实现&amp;emsp;&amp;emsp;QT的GUI中有treeWidget部件，将该控件在GUI中布局好，假设其对象名为treeWidget。树形结构通过QTreeWidget类和QTreeWidgetItem类实现，QTree">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/02/22/Qt语法详解/Qt之QTreeWidget/1.png">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/02/22/Qt语法详解/Qt之QTreeWidget/2.png">
<meta property="og:updated_time" content="2019-04-02T11:29:16.232Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Qt之QTreeWidget">
<meta name="twitter:description" content="&amp;emsp;&amp;emsp;Qt中实现树形结构可以使用QTreeWidget类，也可以使用QTreeView类，QTreeWidget继承自QTreeView类，其效果如下：  树形结构实现&amp;emsp;&amp;emsp;QT的GUI中有treeWidget部件，将该控件在GUI中布局好，假设其对象名为treeWidget。树形结构通过QTreeWidget类和QTreeWidgetItem类实现，QTree">
<meta name="twitter:image" content="http://fukangwei.gitee.io/2019/02/22/Qt语法详解/Qt之QTreeWidget/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/2019/02/22/Qt语法详解/Qt之QTreeWidget/">





  <title>Qt之QTreeWidget | 泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/02/22/Qt语法详解/Qt之QTreeWidget/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Qt之QTreeWidget</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T13:17:33+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&emsp;&emsp;<code>Qt</code>中实现树形结构可以使用<code>QTreeWidget</code>类，也可以使用<code>QTreeView</code>类，<code>QTreeWidget</code>继承自<code>QTreeView</code>类，其效果如下：</p>
<p><img src="/2019/02/22/Qt语法详解/Qt之QTreeWidget/1.png"></p>
<h3 id="树形结构实现"><a href="#树形结构实现" class="headerlink" title="树形结构实现"></a>树形结构实现</h3><p>&emsp;&emsp;<code>QT</code>的<code>GUI</code>中有<code>treeWidget</code>部件，将该控件在<code>GUI</code>中布局好，假设其对象名为<code>treeWidget</code>。树形结构通过<code>QTreeWidget</code>类和<code>QTreeWidgetItem</code>类实现，<code>QTreeWidgetItem</code>类实现结点的添加。上图代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;treeWidget-&gt;setColumnCount ( <span class="number">1</span> ); <span class="comment">/* 设置列数 */</span></span><br><span class="line">ui-&gt;treeWidget-&gt;setHeaderLabel ( tr ( <span class="string">"图像选择"</span> ) ); <span class="comment">/* 设置头的标题 */</span></span><br><span class="line">​</span><br><span class="line">QTreeWidgetItem *imageItem1 = <span class="keyword">new</span> QTreeWidgetItem ( ui-&gt;treeWidget, QStringList ( QString ( <span class="string">"图像1"</span> ) ) );</span><br><span class="line">imageItem1-&gt;setIcon ( <span class="number">0</span>, QIcon ( <span class="string">"xxx.png"</span> ) );</span><br><span class="line">QTreeWidgetItem *imageItem1_1 = <span class="keyword">new</span> QTreeWidgetItem ( imageItem1, QStringList ( QString ( <span class="string">"Band1"</span> ) ) ); <span class="comment">/* 子节点1 */</span></span><br><span class="line">imageItem1-&gt;addChild ( imageItem1_1 ); <span class="comment">/* 添加子节点 */</span></span><br><span class="line">​</span><br><span class="line">QTreeWidgetItem *imageItem2 = <span class="keyword">new</span> QTreeWidgetItem ( ui-&gt;treeWidget, QStringList ( QString ( <span class="string">"图像2"</span> ) ) );</span><br><span class="line">QTreeWidgetItem *imageItem2_1 = <span class="keyword">new</span> QTreeWidgetItem ( imageItem2, QStringList ( QString ( <span class="string">"Band1"</span> ) ) ); <span class="comment">/* 子节点1 */</span></span><br><span class="line">QTreeWidgetItem *imageItem2_2 = <span class="keyword">new</span> QTreeWidgetItem ( imageItem2, QStringList ( QString ( <span class="string">"Band2"</span> ) ) ); <span class="comment">/* 子节点2 */</span></span><br><span class="line">imageItem2-&gt;addChild ( imageItem2_1 ); <span class="comment">/* 添加子节点 */</span></span><br><span class="line">imageItem2-&gt;addChild ( imageItem2_2 );</span><br><span class="line">​</span><br><span class="line">ui-&gt;treeWidget-&gt;expandAll(); <span class="comment">/* 结点全部展开 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;除了使用上面这种方法之外，还可以使用<code>QList&lt;QTreeWidgetItem *&gt; &amp; items</code>实现结点的添加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QTreeWidgetItem *&gt; rootList;</span><br><span class="line">​</span><br><span class="line">QTreeWidgetItem *imageItem1 = <span class="keyword">new</span> QTreeWidgetItem; <span class="comment">/* 添加第一个父节点 */</span></span><br><span class="line">imageItem1-&gt;setText ( <span class="number">0</span>, tr ( <span class="string">"图像1"</span> ) );</span><br><span class="line">rootList.append ( imageItem1 );</span><br><span class="line">​</span><br><span class="line">QTreeWidgetItem *imageItem1_1 = <span class="keyword">new</span> QTreeWidgetItem ( imageItem1, QStringList ( QString ( <span class="string">"Band1"</span> ) ) ); <span class="comment">/* 添加子节点 */</span></span><br><span class="line">imageItem1-&gt;addChild ( imageItem1_1 );</span><br><span class="line">​</span><br><span class="line">QTreeWidgetItem *imageItem2 = <span class="keyword">new</span> QTreeWidgetItem; <span class="comment">/* 添加第二个父节点 */</span></span><br><span class="line">imageItem2-&gt;setText ( <span class="number">0</span>, tr ( <span class="string">"图像2"</span> ) );</span><br><span class="line">rootList.append ( imageItem2 );</span><br><span class="line">​</span><br><span class="line">QTreeWidgetItem *imageItem2_1 = <span class="keyword">new</span> QTreeWidgetItem ( imageItem2, QStringList ( QString ( <span class="string">"Band1"</span> ) ) ); <span class="comment">/* 添加子节点 */</span></span><br><span class="line">QTreeWidgetItem *imageItem2_2 = <span class="keyword">new</span> QTreeWidgetItem ( imageItem2, QStringList ( QString ( <span class="string">"Band2"</span> ) ) );</span><br><span class="line">imageItem2-&gt;addChild ( imageItem2_1 );</span><br><span class="line">imageItem2-&gt;addChild ( imageItem2_2 );</span><br><span class="line">​</span><br><span class="line">ui-&gt;treeWidget-&gt;insertTopLevelItems ( <span class="number">0</span>, rootList ); <span class="comment">/* 将结点插入部件中 */</span></span><br><span class="line">​</span><br><span class="line">ui-&gt;treeWidget-&gt;expandAll(); <span class="comment">/* 全部展开 */</span></span><br></pre></td></tr></table></figure>
<h3 id="点击节点的事件响应"><a href="#点击节点的事件响应" class="headerlink" title="点击节点的事件响应"></a>点击节点的事件响应</h3><p>&emsp;&emsp;首先想到有没有点击某个节点的信号，查看文档后发现有一个<code>void itemClicked ( QTreeWidgetItem * item, int column )</code>信号，它是双击某个节点的信号。将该信号与某个自定义槽相连，当双击节点时触发槽函数。第一个参数为点击的<code>QTreeWidgetItem</code>类对象，第二个参数为节点所在列号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showSelectedImage</span> <span class="params">( QTreeWidgetItem *item, <span class="keyword">int</span> column )</span></span>; <span class="comment">/* 点击树节点事件 */</span></span><br><span class="line">​</span><br><span class="line">connect ( ui-&gt;treeWidget, SIGNAL ( itemDoubleClicked ( QTreeWidgetItem *, <span class="keyword">int</span> ) ), \</span><br><span class="line">          <span class="keyword">this</span>, SLOT ( showSelectedImage ( QTreeWidgetItem *, <span class="keyword">int</span> ) ) );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> MainWindow::showSelectedImage ( QTreeWidgetItem *item, <span class="keyword">int</span> column ) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>&emsp;&emsp;The <code>QTreeWidget</code> class provides a tree view that uses a predefined tree model.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTreeWidget</code></td>
<td><code>QTreeView</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTreeWidget(QWidget * parent = 0)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QTreeWidget()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addTopLevelItem(QTreeWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addTopLevelItems(const QList&lt;QTreeWidgetItem *&gt; &amp; items)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>closePersistentEditor(QTreeWidgetItem * item, int column = 0)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>columnCount() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>currentColumn() const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>currentItem() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>editItem(QTreeWidgetItem * item, int column = 0)</code></td>
</tr>
<tr>
<td><code>QList&lt;QTreeWidgetItem *&gt;</code></td>
<td><code>findItems(const QString &amp; text, Qt::MatchFlags flags, int column = 0) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>headerItem() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>indexOfTopLevelItem(QTreeWidgetItem * item) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertTopLevelItem(int index, QTreeWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertTopLevelItems(int index, const QList&lt;QTreeWidgetItem *&gt; &amp; items)</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>invisibleRootItem() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isFirstItemColumnSpanned(const QTreeWidgetItem * item) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>itemAbove(const QTreeWidgetItem * item) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>itemAt(const QPoint &amp; p) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>itemAt(int x, int y) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>itemBelow(const QTreeWidgetItem * item) const</code></td>
</tr>
<tr>
<td><code>QWidget *</code></td>
<td><code>itemWidget(QTreeWidgetItem * item, int column) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>openPersistentEditor(QTreeWidgetItem * item, int column = 0)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeItemWidget(QTreeWidgetItem * item, int column)</code></td>
</tr>
<tr>
<td><code>QList&lt;QTreeWidgetItem *&gt;</code></td>
<td><code>selectedItems() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setColumnCount(int columns)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentItem(QTreeWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentItem(QTreeWidgetItem * item, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCurrentItem(QTreeWidgetItem * item, int column, QItemSelectionModel::SelectionFlags command)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFirstItemColumnSpanned(const QTreeWidgetItem * item, bool span)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHeaderItem(QTreeWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHeaderLabel(const QString &amp; label)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHeaderLabels(const QStringList &amp; labels)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setItemWidget(QTreeWidgetItem * item, int column, QWidget * widget)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>sortColumn() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>sortItems(int column, Qt::SortOrder order)</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>takeTopLevelItem(int index)</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>topLevelItem(int index) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>topLevelItemCount() const</code></td>
</tr>
<tr>
<td><code>QRect</code></td>
<td><code>visualItemRect(const QTreeWidgetItem * item) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Public-Functions"><a href="#Reimplemented-Public-Functions" class="headerlink" title="Reimplemented Public Functions"></a>Reimplemented Public Functions</h3><ul>
<li><code>virtual void setSelectionModel(QItemSelectionModel * selectionModel)</code></li>
</ul>
<h3 id="Public-Slots"><a href="#Public-Slots" class="headerlink" title="Public Slots"></a>Public Slots</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>collapseItem(const QTreeWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>expandItem(const QTreeWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>scrollToItem(const QTreeWidgetItem * item, QAbstractItemView::ScrollHint hint = EnsureVisible)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>currentItemChanged(QTreeWidgetItem * current, QTreeWidgetItem * previous)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemActivated(QTreeWidgetItem * item, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemChanged(QTreeWidgetItem * item, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemClicked(QTreeWidgetItem * item, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemCollapsed(QTreeWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemDoubleClicked(QTreeWidgetItem * item, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemEntered(QTreeWidgetItem * item, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemExpanded(QTreeWidgetItem * item)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemPressed(QTreeWidgetItem * item, int column)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>itemSelectionChanged()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Protected-Functions"><a href="#Protected-Functions" class="headerlink" title="Protected Functions"></a>Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual bool</code></td>
<td><code>dropMimeData(QTreeWidgetItem * parent, int index, const QMimeData * data, Qt::DropAction action)</code></td>
</tr>
<tr>
<td><code>QModelIndex</code></td>
<td><code>indexFromItem(QTreeWidgetItem * item, int column = 0) const</code></td>
</tr>
<tr>
<td><code>QTreeWidgetItem *</code></td>
<td><code>itemFromIndex(const QModelIndex &amp; index) const</code></td>
</tr>
<tr>
<td><code>virtual QMimeData *</code></td>
<td><code>mimeData(const QList&lt;QTreeWidgetItem *&gt; items) const</code></td>
</tr>
<tr>
<td><code>virtual QStringList</code></td>
<td><code>mimeTypes() const</code></td>
</tr>
<tr>
<td><code>virtual Qt::DropActions</code></td>
<td><code>supportedDropActions() const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Reimplemented-Protected-Functions"><a href="#Reimplemented-Protected-Functions" class="headerlink" title="Reimplemented Protected Functions"></a>Reimplemented Protected Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>virtual void</code></td>
<td><code>dropEvent(QDropEvent * event)</code></td>
</tr>
<tr>
<td><code>virtual bool</code></td>
<td><code>event(QEvent * e)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTreeWidget</code> class provides a tree view that uses a predefined tree model.<br>&emsp;&emsp;The <code>QTreeWidget</code> class is a convenience class that provides a standard tree widget with a classic <code>item-based</code> interface similar to that used by the <code>QListView</code> class in <code>Qt 3</code>. This class is based on <code>Qt&#39;s</code> <code>Model/View</code> architecture and uses a default model to hold items, each of which is a <code>QTreeWidgetItem</code>.<br>&emsp;&emsp;Developers who do not need the flexibility of the <code>Model/View</code> framework can use this class to create simple hierarchical lists very easily. A more flexible approach involves combining a <code>QTreeView</code> with a standard item model. This allows the storage of data to be separated from its representation.<br>&emsp;&emsp;In its simplest form, a tree widget can be constructed in the following way:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QTreeWidget *treeWidget = <span class="keyword">new</span> QTreeWidget();</span><br><span class="line">treeWidget-&gt;setColumnCount ( <span class="number">1</span> );</span><br><span class="line">QList&lt;QTreeWidgetItem *&gt; items;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i ) &#123;</span><br><span class="line">    items.append ( <span class="keyword">new</span> QTreeWidgetItem ( ( QTreeWidget * ) <span class="number">0</span>, QStringList ( QString ( <span class="string">"item: %1"</span> ).arg ( i ) ) ) );</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">treeWidget-&gt;insertTopLevelItems ( <span class="number">0</span>, items );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Before items can be added to the tree widget, the number of columns must be set with <code>setColumnCount()</code>. This allows each item to have one or more labels or other decorations. The number of columns in use can be found with the <code>columnCount()</code> function.<br>&emsp;&emsp;The tree can have a header that contains a section for each column in the widget. It is easiest to set up the labels for each section by supplying a list of strings with <code>setHeaderLabels()</code>, but a custom header can be constructed with a <code>QTreeWidgetItem</code> and inserted into the tree with the <code>setHeaderItem()</code> function.<br>&emsp;&emsp;The items in the tree can be sorted by column according to a predefined sort order. If sorting is enabled, the user can sort the items by clicking on a column header. Sorting can be enabled or disabled by calling <code>setSortingEnabled()</code>. The <code>isSortingEnabled()</code> function indicates whether sorting is enabled.</p>
<p><img src="/2019/02/22/Qt语法详解/Qt之QTreeWidget/2.png" height="157" width="642"></p>
<h3 id="Property-Documentation"><a href="#Property-Documentation" class="headerlink" title="Property Documentation"></a>Property Documentation</h3><ul>
<li><code>columnCount : int</code>: This property holds the number of columns displayed in the tree widget. By default, this property has a value of <code>1</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">columnCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setColumnCount</span><span class="params">(<span class="keyword">int</span> columns)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>topLevelItemCount : const int</code>: This property holds the number of <code>top-level</code> items. By default, this property has a value of <code>0</code>. Access functions:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topLevelItemCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTreeWidget::QTreeWidget(QWidget * parent = 0)</code>: Constructs a tree widget with the given <code>parent</code>.</li>
<li><code>QTreeWidget::~QTreeWidget()</code>: Destroys the tree widget and all its items.</li>
<li><code>void QTreeWidget::addTopLevelItem(QTreeWidgetItem * item)</code>: Appends the <code>item</code> as a <code>top-level</code> item in the widget.</li>
<li><code>void QTreeWidget::addTopLevelItems(const QList&lt;QTreeWidgetItem *&gt; &amp; items)</code>: Appends the list of <code>items</code> as a <code>top-level</code> items in the widget.</li>
<li><code>void QTreeWidget::clear() [slot]</code>: Clears the tree widget by removing all of its items and selections. <strong>Note</strong>: Since each item is removed from the tree widget before being deleted, the return value of <code>QTreeWidgetItem::treeWidget()</code> will be invalid when called from an item’s destructor.</li>
<li><code>void QTreeWidget::closePersistentEditor(QTreeWidgetItem * item, int column = 0)</code>: Closes the persistent editor for the <code>item</code> in the given <code>column</code>. This function has no effect if no persistent editor is open for this combination of <code>item</code> and <code>column</code>.</li>
<li><code>void QTreeWidget::collapseItem(const QTreeWidgetItem * item) [slot]</code>: Closes the <code>item</code>. This causes the tree containing the item’s children to be collapsed.</li>
<li><code>int QTreeWidget::currentColumn() const</code>: Returns the current column in the tree widget.</li>
<li><code>QTreeWidgetItem * QTreeWidget::currentItem() const</code>: Returns the current item in the tree widget.</li>
<li><code>void QTreeWidget::currentItemChanged(QTreeWidgetItem * current, QTreeWidgetItem * previous) [signal]</code>: This signal is emitted when the current item changes. The current item is specified by <code>current</code>, and this replaces the <code>previous</code> current item.</li>
<li><code>void QTreeWidget::dropEvent(QDropEvent * event) [virtual protected]</code>: Reimplemented from QWidget::dropEvent().</li>
<li><code>bool QTreeWidget::dropMimeData(QTreeWidgetItem * parent, int index, const QMimeData * data, Qt::DropAction action) [virtual protected]</code>: Handles the <code>data</code> supplied by a drag and drop operation that ended with the given <code>action</code> in the <code>index</code> in the given <code>parent</code> item. The default implementation returns true if the drop was successfully handled by decoding the mime data and inserting it into the model; otherwise it returns false.</li>
<li><code>void QTreeWidget::editItem(QTreeWidgetItem * item, int column = 0)</code>: Starts editing the <code>item</code> in the given <code>column</code> if it is editable.</li>
<li><code>bool QTreeWidget::event(QEvent * e) [virtual protected]</code>: Reimplemented from <code>QObject::event()</code>.</li>
<li><code>void QTreeWidget::expandItem(const QTreeWidgetItem * item) [slot]</code>: Expands the <code>item</code>. This causes the tree containing the item’s children to be expanded.</li>
<li><code>QList&lt;QTreeWidgetItem *&gt; QTreeWidget::findItems(const QString &amp; text, Qt::MatchFlags flags, int column = 0) const</code>: Returns a list of items that match the given <code>text</code>, using the given <code>flags</code>, in the given <code>column</code>.</li>
<li><code>QTreeWidgetItem * QTreeWidget::headerItem() const</code>: Returns the item used for the tree widget’s header.</li>
<li><code>QModelIndex QTreeWidget::indexFromItem(QTreeWidgetItem * item, int column = 0) const [protected]</code>: Returns the QModelIndex assocated with the given <code>item</code> in the given <code>column</code>.</li>
<li><code>int QTreeWidget::indexOfTopLevelItem(QTreeWidgetItem * item) const</code>: Returns the index of the given <code>top-level</code> <code>item</code>, or <code>-1</code> if the <code>item</code> cannot be found.</li>
<li><code>void QTreeWidget::insertTopLevelItem(int index, QTreeWidgetItem * item)</code>: Inserts the <code>item</code> at index in the top level in the view. If the <code>item</code> has already been inserted somewhere else it wont be inserted.</li>
<li><code>void QTreeWidget::insertTopLevelItems(int index, const QList&lt;QTreeWidgetItem *&gt; &amp; items)</code>: Inserts the list of <code>items</code> at index in the top level in the view. Items that have already been inserted somewhere else wont be inserted.</li>
<li><code>QTreeWidgetItem * QTreeWidget::invisibleRootItem() const</code>: Returns the tree widget’s invisible root item. The invisible root item provides access to the tree widget’s <code>top-level</code> items through the <code>QTreeWidgetItem</code> <code>API</code>, making it possible to write functions that can treat <code>top-level</code> items and their children in a uniform way; for example, recursive functions.</li>
<li><code>bool QTreeWidget::isFirstItemColumnSpanned(const QTreeWidgetItem * item) const</code>: Returns true if the given <code>item</code> is set to show only one section over all columns; otherwise returns false.</li>
<li><code>QTreeWidgetItem * QTreeWidget::itemAbove(const QTreeWidgetItem * item) const</code>: Returns the item above the given <code>item</code>.</li>
<li><code>void QTreeWidget::itemActivated(QTreeWidgetItem * item, int column) [signal]</code>: This signal is emitted when the user activates an <code>item</code> by <code>single-</code> or <code>double-clicking</code> (depending on the platform, i.e. on the <code>QStyle::SH_ItemView_ActivateItemOnSingleClick</code> style hint) or pressing a special key (e.g., Enter). The specified <code>item</code> is the item that was clicked, or <code>0</code> if no item was clicked. The <code>column</code> is the item’s column that was clicked, or <code>-1</code> if no item was clicked.</li>
<li><code>QTreeWidgetItem * QTreeWidget::itemAt(const QPoint &amp; p) const</code>: Returns a pointer to the item at the coordinates <code>p</code>. The coordinates are relative to the tree widget’s <code>viewport()</code>.</li>
<li><code>QTreeWidgetItem * QTreeWidget::itemAt(int x, int y) const</code>: This is an overloaded function. Returns a pointer to the item at the coordinates <code>(x, y)</code>. The coordinates are relative to the tree widget’s <code>viewport()</code>.</li>
<li><code>QTreeWidgetItem * QTreeWidget::itemBelow(const QTreeWidgetItem * item) const</code>: Returns the item visually below the given <code>item</code>.</li>
<li><code>void QTreeWidget::itemChanged(QTreeWidgetItem * item, int column) [signal]</code>: This signal is emitted when the contents of the <code>column</code> in the specified <code>item</code> changes.</li>
<li><code>void QTreeWidget::itemClicked(QTreeWidgetItem * item, int column) [signal]</code>: This signal is emitted when the user clicks inside the widget. The specified <code>item</code> is the item that was clicked. The <code>column</code> is the item’s column that was clicked. If no item was clicked, no signal will be emitted.</li>
<li><code>void QTreeWidget::itemCollapsed(QTreeWidgetItem * item) [signal]</code>: This signal is emitted when the specified <code>item</code> is collapsed so that none of its children are displayed. <strong>Note</strong>: This signal will not be emitted if an item changes its state when <code>collapseAll()</code> is invoked.</li>
<li><code>void QTreeWidget::itemDoubleClicked(QTreeWidgetItem * item, int column) [signal]</code>: This signal is emitted when the user double clicks inside the widget. The specified <code>item</code> is the item that was clicked, or 0 if no item was clicked. The <code>column</code> is the item’s column that was clicked. If no item was double clicked, no signal will be emitted.</li>
<li><code>void QTreeWidget::itemEntered(QTreeWidgetItem * item, int column) [signal]</code>: This signal is emitted when the mouse cursor enters an <code>item</code> over the specified <code>column</code>. <code>QTreeWidget</code> mouse tracking needs to be enabled for this feature to work.</li>
<li><code>void QTreeWidget::itemExpanded(QTreeWidgetItem * item) [signal]</code>: This signal is emitted when the specified <code>item</code> is expanded so that all of its children are displayed. <strong>Note</strong>: This signal will not be emitted if an item changes its state when <code>expandAll()</code> is invoked.</li>
<li><code>QTreeWidgetItem * QTreeWidget::itemFromIndex(const QModelIndex &amp; index) const [protected]</code>: Returns a pointer to the <code>QTreeWidgetItem</code> assocated with the given <code>index</code>.</li>
<li><code>void QTreeWidget::itemPressed(QTreeWidgetItem * item, int column) [signal]</code>: This signal is emitted when the user presses a mouse button inside the widget. The specified <code>item</code> is the item that was clicked, or <code>0</code> if no item was clicked. The <code>column</code> is the item’s column that was clicked, or <code>-1</code> if no item was clicked.</li>
<li><code>void QTreeWidget::itemSelectionChanged() [signal]</code>: This signal is emitted when the selection changes in the tree widget. The current selection can be found with <code>selectedItems()</code>.</li>
<li><code>QWidget * QTreeWidget::itemWidget(QTreeWidgetItem * item, int column) const</code>: Returns the widget displayed in the cell specified by <code>item</code> and the given <code>column</code>. <strong>Note</strong>: The tree takes ownership of the widget.</li>
<li><code>QMimeData * QTreeWidget::mimeData(const QList&lt;QTreeWidgetItem *&gt; items) const [virtual protected]</code>: Returns an object that contains a serialized description of the specified <code>items</code>. The format used to describe the items is obtained from the <code>mimeTypes()</code> function. If the list of <code>items</code> is empty, <code>0</code> is returned rather than a serialized empty list.</li>
<li><code>QStringList QTreeWidget::mimeTypes() const [virtual protected]</code>: Returns a list of <code>MIME</code> types that can be used to describe a list of treewidget items.</li>
<li><code>void QTreeWidget::openPersistentEditor(QTreeWidgetItem * item, int column = 0)</code>: Opens a persistent editor for the <code>item</code> in the given <code>column</code>.</li>
<li><code>void QTreeWidget::removeItemWidget(QTreeWidgetItem * item, int column)</code>: Removes the widget set in the given <code>item</code> in the given <code>column</code>.</li>
<li><code>void QTreeWidget::scrollToItem(const QTreeWidgetItem * item, QAbstractItemView::ScrollHint hint = EnsureVisible) [slot]</code>: Ensures that the <code>item</code> is visible, scrolling the view if necessary using the specified <code>hint</code>.</li>
<li><code>QList&lt;QTreeWidgetItem *&gt; QTreeWidget::selectedItems() const</code>: Returns a list of all selected <code>non-hidden</code> items.</li>
<li><code>void QTreeWidget::setCurrentItem(QTreeWidgetItem * item)</code>: Sets the current <code>item</code> in the tree widget. Unless the selection mode is <code>NoSelection</code>, the item is also be selected.</li>
<li><code>void QTreeWidget::setCurrentItem(QTreeWidgetItem * item, int column)</code>: Sets the current <code>item</code> in the tree widget and the current <code>column</code> to column.</li>
<li><code>void QTreeWidget::setCurrentItem(QTreeWidgetItem * item, int column, QItemSelectionModel::SelectionFlags command)</code>: Sets the current <code>item</code> in the tree widget and the current <code>column</code> to column, using the given <code>command</code>.</li>
<li><code>void QTreeWidget::setFirstItemColumnSpanned(const QTreeWidgetItem * item, bool span)</code>: Sets the given <code>item</code> to only show one section for all columns if <code>span</code> is <code>true</code>; otherwise the item will show one section per column.</li>
<li><code>void QTreeWidget::setHeaderItem(QTreeWidgetItem * item)</code>: Sets the header <code>item</code> for the tree widget. The label for each column in the header is supplied by the corresponding label in the item. The tree widget takes ownership of the item.</li>
<li><code>void QTreeWidget::setHeaderLabel(const QString &amp; label)</code>: Same as <code>setHeaderLabels(QStringList(label))</code>.</li>
<li><code>void QTreeWidget::setHeaderLabels(const QStringList &amp; labels)</code>: Adds a column in the header for each item in the <code>labels</code> list, and sets the label for each column. Note that <code>setHeaderLabels()</code> won’t remove existing columns.</li>
<li><code>void QTreeWidget::setItemWidget(QTreeWidgetItem * item, int column, QWidget * widget)</code>: Sets the given <code>widget</code> to be displayed in the cell specified by the given <code>item</code> and <code>column</code>. The given widget’s <code>autoFillBackground</code> property must be set to <code>true</code>, otherwise the widget’s background will be transparent, showing both the model data and the tree widget item. This function should only be used to display static content in the place of a tree widget item. If you want to display custom dynamic content or implement a custom editor widget, use <code>QTreeView</code> and subclass <code>QItemDelegate</code> instead. This function cannot be called before the item hierarchy has been set up, i.e., the <code>QTreeWidgetItem</code> that will hold widget must have been added to the view before widget is set. <strong>Note</strong>: The tree takes ownership of the widget.</li>
<li><code>void QTreeWidget::setSelectionModel(QItemSelectionModel * selectionModel) [virtual]</code>: Reimplemented from <code>QAbstractItemView::setSelectionModel()</code>.</li>
<li><code>int QTreeWidget::sortColumn() const</code>: Returns the column used to sort the contents of the widget.</li>
<li><code>void QTreeWidget::sortItems(int column, Qt::SortOrder order)</code>: Sorts the items in the widget in the specified <code>order</code> by the values in the given <code>column</code>.</li>
<li><code>Qt::DropActions QTreeWidget::supportedDropActions() const [virtual protected]</code>: Returns the drop actions supported by this view.</li>
<li><code>QTreeWidgetItem * QTreeWidget::takeTopLevelItem(int index)</code>: Removes the <code>top-level</code> item at the given <code>index</code> in the tree and returns it, otherwise returns <code>0</code>.</li>
<li><code>QTreeWidgetItem * QTreeWidget::topLevelItem(int index) const</code>: Returns the top level item at the given <code>index</code>, or <code>0</code> if the item does not exist.</li>
<li><code>QRect QTreeWidget::visualItemRect(const QTreeWidgetItem * item) const</code>: Returns the rectangle on the viewport occupied by the <code>item</code> at item.</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/22/Qt语法详解/Qt之QTextTableFormat/" rel="next" title="Qt之QTextTableFormat">
                <i class="fa fa-chevron-left"></i> Qt之QTextTableFormat
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/23/Qt语法详解/Qt之LineEdit/" rel="prev" title="Qt之LineEdit">
                Qt之LineEdit <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">939</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#树形结构实现"><span class="nav-number">1.</span> <span class="nav-text">树形结构实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#点击节点的事件响应"><span class="nav-number">2.</span> <span class="nav-text">点击节点的事件响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Public-Functions"><span class="nav-number">3.</span> <span class="nav-text">Public Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reimplemented-Public-Functions"><span class="nav-number">4.</span> <span class="nav-text">Reimplemented Public Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Public-Slots"><span class="nav-number">5.</span> <span class="nav-text">Public Slots</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Signals"><span class="nav-number">6.</span> <span class="nav-text">Signals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Protected-Functions"><span class="nav-number">7.</span> <span class="nav-text">Protected Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reimplemented-Protected-Functions"><span class="nav-number">8.</span> <span class="nav-text">Reimplemented Protected Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Detailed-Description"><span class="nav-number">9.</span> <span class="nav-text">Detailed Description</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Property-Documentation"><span class="nav-number">10.</span> <span class="nav-text">Property Documentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Member-Function-Documentation"><span class="nav-number">11.</span> <span class="nav-text">Member Function Documentation</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
