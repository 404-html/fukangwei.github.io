<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="&amp;emsp;&amp;emsp;The QTextCursor class offers an API to access and modify QTextDocuments. The header file is QTextCursor. Note: All functions in this class are reentrant. Public Functions    Return Functio">
<meta property="og:type" content="article">
<meta property="og:title" content="Qt之QTextCursor">
<meta property="og:url" content="http://fukangwei.gitee.io/2019/01/29/Qt语法详解/Qt之QTextCursor/index.html">
<meta property="og:site_name" content="暴徒">
<meta property="og:description" content="&amp;emsp;&amp;emsp;The QTextCursor class offers an API to access and modify QTextDocuments. The header file is QTextCursor. Note: All functions in this class are reentrant. Public Functions    Return Functio">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-01-30T10:54:37.333Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Qt之QTextCursor">
<meta name="twitter:description" content="&amp;emsp;&amp;emsp;The QTextCursor class offers an API to access and modify QTextDocuments. The header file is QTextCursor. Note: All functions in this class are reentrant. Public Functions    Return Functio">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/2019/01/29/Qt语法详解/Qt之QTextCursor/">





  <title>Qt之QTextCursor | 暴徒</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">暴徒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/29/Qt语法详解/Qt之QTextCursor/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Qt之QTextCursor</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-29T11:13:18+08:00">
                2019-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&emsp;&emsp;The <code>QTextCursor</code> class offers an <code>API</code> to access and modify <code>QTextDocuments</code>. The header file is <code>QTextCursor</code>. <strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QTextCursor()</code></td>
</tr>
<tr>
<td></td>
<td><code>QTextCursor(QTextDocument * document)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTextCursor(QTextFrame * frame)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTextCursor(const QTextBlock &amp; block)</code></td>
</tr>
<tr>
<td></td>
<td><code>QTextCursor(const QTextCursor &amp; cursor)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QTextCursor()</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>anchor() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>atBlockEnd() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>atBlockStart() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>atEnd() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>atStart() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>beginEditBlock()</code></td>
</tr>
<tr>
<td><code>QTextBlock</code></td>
<td><code>block() const</code></td>
</tr>
<tr>
<td><code>QTextCharFormat</code></td>
<td><code>blockCharFormat() const</code></td>
</tr>
<tr>
<td><code>QTextBlockFormat</code></td>
<td><code>blockFormat() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>blockNumber() const</code></td>
</tr>
<tr>
<td><code>QTextCharFormat</code></td>
<td><code>charFormat() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clearSelection()</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>columnNumber() const</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>createList(const QTextListFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>createList(QTextListFormat::Style style)</code></td>
</tr>
<tr>
<td><code>QTextFrame *</code></td>
<td><code>currentFrame() const</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>currentList() const</code></td>
</tr>
<tr>
<td><code>QTextTable *</code></td>
<td><code>currentTable() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>deleteChar()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>deletePreviousChar()</code></td>
</tr>
<tr>
<td><code>QTextDocument *</code></td>
<td><code>document() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>endEditBlock()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasComplexSelection() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>hasSelection() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertBlock()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertBlock(const QTextBlockFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertBlock(const QTextBlockFormat &amp; format, const QTextCharFormat &amp; charFormat)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertFragment(const QTextDocumentFragment &amp; fragment)</code></td>
</tr>
<tr>
<td><code>QTextFrame *</code></td>
<td><code>insertFrame(const QTextFrameFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertHtml(const QString &amp; html)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertImage(const QTextImageFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertImage(const QTextImageFormat &amp; format, QTextFrameFormat::Position alignment)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertImage(const QString &amp; name)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertImage(const QImage &amp; image, const QString &amp; name = QString())</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>insertList(const QTextListFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>QTextList *</code></td>
<td><code>insertList(QTextListFormat::Style style)</code></td>
</tr>
<tr>
<td><code>QTextTable *</code></td>
<td><code>insertTable(int rows, int columns, const QTextTableFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>QTextTable *</code></td>
<td><code>insertTable(int rows, int columns)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertText(const QString &amp; text)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insertText(const QString &amp; text, const QTextCharFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isCopyOf(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isNull() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>joinPreviousEditBlock()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>keepPositionOnInsert() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>mergeBlockCharFormat(const QTextCharFormat &amp; modifier)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>mergeBlockFormat(const QTextBlockFormat &amp; modifier)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>mergeCharFormat(const QTextCharFormat &amp; modifier)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>movePosition(MoveOperation operation, MoveMode mode = MoveAnchor, int n = 1)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>position() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>positionInBlock() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeSelectedText()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>select(SelectionType selection)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>selectedTableCells(int * firstRow, int * numRows, int * firstColumn, int * numColumns) const</code></td>
</tr>
<tr>
<td><code>QString</code></td>
<td><code>selectedText() const</code></td>
</tr>
<tr>
<td><code>QTextDocumentFragment</code></td>
<td><code>selection() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>selectionEnd() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>selectionStart() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBlockCharFormat(const QTextCharFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setBlockFormat(const QTextBlockFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCharFormat(const QTextCharFormat &amp; format)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setKeepPositionOnInsert(bool b)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPosition(int pos, MoveMode m = MoveAnchor)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setVerticalMovementX(int x)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setVisualNavigation(bool b)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>verticalMovementX() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>visualNavigation() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&lt;(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&lt;=(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>QTextCursor &amp;</code></td>
<td><code>operator=(const QTextCursor &amp; cursor)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&gt;(const QTextCursor &amp; other) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator&gt;=(const QTextCursor &amp; other) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QTextCursor</code> class offers an <code>API</code> to access and modify <code>QTextDocuments</code>.<br>&emsp;&emsp;Text cursors are objects that are used to access and modify the contents and underlying structure of text documents via a programming interface that mimics the behavior of a cursor in a text editor. <code>QTextCursor</code> contains information about both the cursor’s position within a <code>QTextDocument</code> and any selection that it has made.<br>&emsp;&emsp;<code>QTextCursor</code> is modeled on the way a text cursor behaves in a text editor, providing a programmatic means of performing standard actions through the user interface. A document can be thought of as a single string of characters. The cursor’s current <code>position()</code> then is always either between two consecutive characters in the string, or else before the very first character or after the very last character in the string. Documents can also contain tables, lists, images, and other objects in addition to text but, from the developer’s point of view, the document can be treated as one long string. Some portions of that string can be considered to lie within particular blocks (e.g. paragraphs), or within a table’s cell, or a list’s item, or other structural elements. When we refer to <code>current character</code> we mean the character immediately before the cursor <code>position()</code> in the document. Similarly, the <code>current block</code> is the block that contains the cursor <code>position()</code>.<br>&emsp;&emsp;A <code>QTextCursor</code> also has an <code>anchor()</code> position. The text that is between the <code>anchor()</code> and the <code>position()</code> is the selection. If <code>anchor() == position()</code> there is no selection.<br>&emsp;&emsp;The cursor position can be changed programmatically using <code>setPosition()</code> and <code>movePosition()</code>; the latter can also be used to select text. For selections see <code>selectionStart()</code>, <code>selectionEnd()</code>, <code>hasSelection()</code>, <code>clearSelection()</code>, and <code>removeSelectedText()</code>.<br>&emsp;&emsp;If the <code>position()</code> is at the start of a block <code>atBlockStart()</code> returns <code>true</code>; and if it is at the end of a block <code>atBlockEnd()</code> returns <code>true</code>. The format of the current character is returned by <code>charFormat()</code>, and the format of the current block is returned by <code>blockFormat()</code>.<br>&emsp;&emsp;Formatting can be applied to the current text document using the <code>setCharFormat()</code>, <code>mergeCharFormat()</code>, <code>setBlockFormat()</code> and <code>mergeBlockFormat()</code> functions. The <code>set</code> functions will replace the cursor’s current character or block format, while the <code>merge</code> functions add the given format properties to the cursor’s current format. If the cursor has a selection the given format is applied to the current selection. Note that when only parts of a block is selected the block format is applied to the entire block. The text at the current character position can be turned into a list using <code>createList()</code>.<br>&emsp;&emsp;Deletions can be achieved using <code>deleteChar()</code>, <code>deletePreviousChar()</code>, and <code>removeSelectedText()</code>.<br>&emsp;&emsp;Text strings can be inserted into the document with the <code>insertText()</code> function, blocks (representing new paragraphs) can be inserted with <code>insertBlock()</code>.<br>&emsp;&emsp;Existing fragments of text can be inserted with <code>insertFragment()</code>, but if you want to insert pieces of text in various formats, it is usually still easier to use <code>insertText()</code> and supply a character format.<br>&emsp;&emsp;Various types of <code>higher-level</code> structure can also be inserted into the document with the cursor:</p>
<ul>
<li>Lists are ordered sequences of block elements that are decorated with bullet points or symbols. These are inserted in a specified format with <code>insertList()</code>.</li>
<li>Tables are inserted with the <code>insertTable()</code> function, and can be given an optional format. These contain an array of cells that can be traversed using the cursor.</li>
<li>Inline images are inserted with <code>insertImage()</code>. The image to be used can be specified in an image format, or by name.</li>
<li>Frames are inserted by calling <code>insertFrame()</code> with a specified format.</li>
</ul>
<p>&emsp;&emsp;Actions can be grouped (i.e. treated as a single action for undo/redo) using <code>beginEditBlock()</code> and <code>endEditBlock()</code>.<br>&emsp;&emsp;Cursor movements are limited to valid cursor positions. In <code>Latin</code> writing this is between any two consecutive characters in the text, before the first character, or after the last character. In some other writing systems cursor movements are limited to <code>clusters</code> (e.g. a syllable in Devanagari, or a base letter plus diacritics). Functions such as <code>movePosition()</code> and <code>deleteChar()</code> limit cursor movement to these valid positions.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>enum <code>QTextCursor::MoveMode</code>:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCursor::MoveAnchor</code></td>
<td><code>0</code></td>
<td>Moves the anchor to the same position as the cursor itself.</td>
</tr>
<tr>
<td><code>QTextCursor::KeepAnchor</code></td>
<td><code>1</code></td>
<td>Keeps the anchor where it is.</td>
</tr>
</tbody>
</table>
</div>
<p>If the <code>anchor()</code> is kept where it is and the <code>position()</code> is moved, the text in between will be selected.</p>
<ul>
<li>enum <code>QTextCursor::MoveOperation</code>:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCursor::NoMove</code></td>
<td><code>0</code></td>
<td>Keep the cursor where it is.</td>
</tr>
<tr>
<td><code>QTextCursor::Start</code></td>
<td><code>1</code></td>
<td>Move to the start of the document.</td>
</tr>
<tr>
<td><code>QTextCursor::StartOfLine</code></td>
<td><code>3</code></td>
<td>Move to the start of the current line.</td>
</tr>
<tr>
<td><code>QTextCursor::StartOfBlock</code></td>
<td><code>4</code></td>
<td>Move to the start of the current block.</td>
</tr>
<tr>
<td><code>QTextCursor::StartOfWord</code></td>
<td><code>5</code></td>
<td>Move to the start of the current word.</td>
</tr>
<tr>
<td><code>QTextCursor::PreviousBlock</code></td>
<td><code>6</code></td>
<td>Move to the start of the previous block.</td>
</tr>
<tr>
<td><code>QTextCursor::PreviousCharacter</code></td>
<td><code>7</code></td>
<td>Move to the previous character.</td>
</tr>
<tr>
<td><code>QTextCursor::PreviousWord</code></td>
<td><code>8</code></td>
<td>Move to the beginning of the previous word.</td>
</tr>
<tr>
<td><code>QTextCursor::Up</code></td>
<td><code>2</code></td>
<td>Move up one line.</td>
</tr>
<tr>
<td><code>QTextCursor::Left</code></td>
<td><code>9</code></td>
<td>Move left one character.</td>
</tr>
<tr>
<td><code>QTextCursor::WordLeft</code></td>
<td><code>10</code></td>
<td>Move left one word.</td>
</tr>
<tr>
<td><code>QTextCursor::End</code></td>
<td><code>11</code></td>
<td>Move to the end of the document.</td>
</tr>
<tr>
<td><code>QTextCursor::EndOfLine</code></td>
<td><code>13</code></td>
<td>Move to the end of the current line.</td>
</tr>
<tr>
<td><code>QTextCursor::EndOfWord</code></td>
<td><code>14</code></td>
<td>Move to the end of the current word.</td>
</tr>
<tr>
<td><code>QTextCursor::EndOfBlock</code></td>
<td><code>15</code></td>
<td>Move to the end of the current block.</td>
</tr>
<tr>
<td><code>QTextCursor::NextBlock</code></td>
<td><code>16</code></td>
<td>Move to the beginning of the next block.</td>
</tr>
<tr>
<td><code>QTextCursor::NextCharacter</code></td>
<td><code>17</code></td>
<td>Move to the next character.</td>
</tr>
<tr>
<td><code>QTextCursor::NextWord</code></td>
<td><code>18</code></td>
<td>Move to the next word.</td>
</tr>
<tr>
<td><code>QTextCursor::Down</code></td>
<td><code>12</code></td>
<td>Move down one line.</td>
</tr>
<tr>
<td><code>QTextCursor::Right</code></td>
<td><code>19</code></td>
<td>Move right one character.</td>
</tr>
<tr>
<td><code>QTextCursor::WordRight</code></td>
<td><code>20</code></td>
<td>Move right one word.</td>
</tr>
<tr>
<td><code>QTextCursor::NextCell</code></td>
<td><code>21</code></td>
<td>Move to the beginning of the next table cell inside the current table. If the current cell is the last cell in the row, the cursor will move to the first cell in the next row.</td>
</tr>
<tr>
<td><code>QTextCursor::PreviousCell</code></td>
<td><code>22</code></td>
<td>Move to the beginning of the previous table cell inside the current table. If the current cell is the first cell in the row, the cursor will move to the last cell in the previous row.</td>
</tr>
<tr>
<td><code>QTextCursor::NextRow</code></td>
<td><code>23</code></td>
<td>Move to the first new cell of the next row in the current table.</td>
</tr>
<tr>
<td><code>QTextCursor::PreviousRow</code></td>
<td><code>24</code></td>
<td>Move to the last cell of the previous row in the current table.</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>enum <code>QTextCursor::SelectionType</code>: This enum describes the types of selection that can be applied with the <code>select()</code> function.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QTextCursor::Document</code></td>
<td><code>3</code></td>
<td>Selects the entire document.</td>
</tr>
<tr>
<td><code>QTextCursor::BlockUnderCursor</code></td>
<td><code>2</code></td>
<td>Selects the block of text under the cursor.</td>
</tr>
<tr>
<td><code>QTextCursor::LineUnderCursor</code></td>
<td><code>1</code></td>
<td>Selects the line of text under the cursor.</td>
</tr>
<tr>
<td><code>QTextCursor::WordUnderCursor</code></td>
<td><code>0</code></td>
<td>Selects the word under the cursor. If the cursor is not positioned within a string of selectable characters, no text is selected.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QTextCursor::QTextCursor()</code>: Constructs a null cursor.</li>
<li><code>QTextCursor::QTextCursor(QTextDocument * document)</code>: Constructs a cursor pointing to the beginning of the <code>document</code>.</li>
<li><code>QTextCursor::QTextCursor(QTextFrame * frame)</code>: Constructs a cursor pointing to the beginning of the <code>frame</code>.</li>
<li><code>QTextCursor::QTextCursor(const QTextBlock &amp; block)</code>: Constructs a cursor pointing to the beginning of the <code>block</code>.</li>
<li><code>QTextCursor::QTextCursor(const QTextCursor &amp; cursor)</code>: Constructs a new cursor that is a copy of <code>cursor</code>.</li>
<li><code>QTextCursor::~QTextCursor()</code>: Destroys the <code>QTextCursor</code>.</li>
<li><code>int QTextCursor::anchor() const</code>: Returns the anchor position; this is the same as <code>position()</code> unless there is a selection in which case <code>position()</code> marks one end of the selection and <code>anchor()</code> marks the other end. Just like the cursor position, the anchor position is between characters.</li>
<li><code>bool QTextCursor::atBlockEnd() const</code>: Returns <code>true</code> if the cursor is at the end of a block; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::atBlockStart() const</code>: Returns <code>true</code> if the cursor is at the start of a block; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::atEnd() const</code>: Returns <code>true</code> if the cursor is at the end of the document; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::atStart() const</code>: Returns <code>true</code> if the cursor is at the start of the document; otherwise returns <code>false</code>.</li>
<li><code>void QTextCursor::beginEditBlock()</code>: Indicates the start of a block of editing operations on the document that should appear as a single operation from an undo/redo point of view. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTextCursor <span class="title">cursor</span> <span class="params">( textDocument )</span></span>;</span><br><span class="line">cursor.beginEditBlock();</span><br><span class="line">cursor.insertText ( <span class="string">"Hello"</span> );</span><br><span class="line">cursor.insertText ( <span class="string">"World"</span> );</span><br><span class="line">cursor.endEditBlock();</span><br><span class="line">​</span><br><span class="line">textDocument-&gt;undo();</span><br></pre></td></tr></table></figure>
<p>The call to <code>undo()</code> will cause both insertions to be undone, causing both <code>World</code> and <code>Hello</code> to be removed. It is possible to nest calls to <code>beginEditBlock</code> and <code>endEditBlock</code>. The <code>top-most</code> pair will determine the scope of the undo/redo operation.</p>
<ul>
<li><code>QTextBlock QTextCursor::block() const</code> — Returns the block that contains the cursor.</li>
<li><code>QTextCharFormat QTextCursor::blockCharFormat() const</code>: Returns the block character format of the block the cursor is in. The block char format is the format used when inserting text at the beginning of an empty block.</li>
<li><code>QTextBlockFormat QTextCursor::blockFormat() const</code>: Returns the block format of the block the cursor is in.</li>
<li><code>int QTextCursor::blockNumber() const</code>: Returns the number of the block the cursor is in, or <code>0</code> if the cursor is invalid. Note that this function only makes sense in documents without complex objects such as tables or frames.</li>
<li><code>QTextCharFormat QTextCursor::charFormat() const</code>: Returns the format of the character immediately before the cursor <code>position()</code>. If the cursor is positioned at the beginning of a text block that is not empty then the format of the character immediately after the cursor is returned.</li>
<li><code>void QTextCursor::clearSelection()</code>: Clears the current selection by setting the anchor to the cursor position. Note that it does not delete the text of the selection.</li>
<li><code>int QTextCursor::columnNumber() const</code>: Returns the position of the cursor within its containing line. Note that this is the column number relative to a wrapped line, not relative to the block (i.e. the paragraph). You probably want to call <code>positionInBlock()</code> instead.</li>
<li><code>QTextList * QTextCursor::createList(const QTextListFormat &amp; format)</code>: Creates and returns a new list with the given <code>format</code>, and makes the current paragraph the cursor is in the first list item.</li>
<li><code>QTextList * QTextCursor::createList(QTextListFormat::Style style)</code>: This is an overloaded function. Creates and returns a new list with the given <code>style</code>, making the cursor’s current paragraph the first list item. The <code>style</code> to be used is defined by the <code>QTextListFormat::Style</code> enum.</li>
<li><code>QTextFrame * QTextCursor::currentFrame() const</code>: Returns a pointer to the current frame. Returns <code>0</code> if the cursor is invalid.</li>
<li><code>QTextList * QTextCursor::currentList() const</code>: Returns the current list if the cursor <code>position()</code> is inside a block that is part of a list; otherwise returns <code>0</code>.</li>
<li><code>QTextTable * QTextCursor::currentTable() const</code>: Returns a pointer to the current table if the cursor <code>position()</code> is inside a block that is part of a table; otherwise returns <code>0</code>.</li>
<li><code>void QTextCursor::deleteChar()</code>: If there is no selected text, deletes the character at the current cursor position; otherwise deletes the selected text.</li>
<li><code>void QTextCursor::deletePreviousChar()</code>: If there is no selected text, deletes the character before the current cursor position; otherwise deletes the selected text.</li>
<li><code>QTextDocument * QTextCursor::document() const</code>: Returns the document this cursor is associated with.</li>
<li><code>void QTextCursor::endEditBlock()</code>: Indicates the end of a block of editing operations on the document that should appear as a single operation from an undo/redo point of view.</li>
<li><code>bool QTextCursor::hasComplexSelection() const</code>: Returns <code>true</code> if the cursor contains a selection that is not simply a range from <code>selectionStart()</code> to <code>selectionEnd()</code>; otherwise returns <code>false</code>. Complex selections are ones that span at least two cells in a table; their extent is specified by <code>selectedTableCells()</code>.</li>
<li><code>bool QTextCursor::hasSelection() const</code>: Returns <code>true</code> if the cursor contains a selection; otherwise returns <code>false</code>.</li>
<li><code>void QTextCursor::insertBlock()</code>: Inserts a new empty block at the cursor <code>position()</code> with the current <code>blockFormat()</code> and <code>charFormat()</code>.</li>
<li><code>void QTextCursor::insertBlock(const QTextBlockFormat &amp; format)</code>: This is an overloaded function. Inserts a new empty block at the cursor <code>position()</code> with block <code>format</code> and the current <code>charFormat()</code> as block char format.</li>
<li><code>void QTextCursor::insertBlock(const QTextBlockFormat &amp; format, const QTextCharFormat &amp; charFormat)</code>: This is an overloaded function. Inserts a new empty block at the cursor <code>position()</code> with block <code>format</code> and <code>charFormat</code> as block char format.</li>
<li><code>void QTextCursor::insertFragment(const QTextDocumentFragment &amp; fragment)</code>: Inserts the text <code>fragment</code> at the current <code>position()</code>.</li>
<li><code>QTextFrame * QTextCursor::insertFrame(const QTextFrameFormat &amp; format)</code>: Inserts a frame with the given <code>format</code> at the current cursor <code>position()</code>, moves the cursor <code>position()</code> inside the frame, and returns the frame. If the cursor holds a selection, the whole selection is moved inside the frame.</li>
<li><code>void QTextCursor::insertHtml(const QString &amp; html)</code>: Inserts the text <code>html</code> at the current <code>position()</code>. The text is interpreted as <code>HTML</code>. <strong>Note</strong>: When using this function with a style sheet, the style sheet will only apply to the current block in the document. In order to apply a style sheet throughout a document, use <code>QTextDocument::setDefaultStyleSheet()</code> instead.</li>
<li><code>void QTextCursor::insertImage(const QTextImageFormat &amp; format)</code>: Inserts the image defined by <code>format</code> at the current <code>position()</code>.</li>
<li><code>void QTextCursor::insertImage(const QTextImageFormat &amp; format, QTextFrameFormat::Position alignment)</code>: This is an overloaded function. Inserts the image defined by the given <code>format</code> at the cursor’s current position with the specified <code>alignment</code>.</li>
<li><code>void QTextCursor::insertImage(const QString &amp; name)</code>: This is an overloaded function. Convenience method for inserting the image with the given <code>name</code> at the current <code>position()</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QImage img = ...;</span><br><span class="line">textDocument-&gt;addResource ( QTextDocument::ImageResource, QUrl ( <span class="string">"myimage"</span> ), img );</span><br><span class="line">cursor.insertImage ( <span class="string">"myimage"</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void QTextCursor::insertImage(const QImage &amp; image, const QString &amp; name = QString())</code>: This is an overloaded function. Convenience function for inserting the given <code>image</code> with an optional <code>name</code> at the current <code>position()</code>.</li>
<li><code>QTextList * QTextCursor::insertList(const QTextListFormat &amp; format)</code>: Inserts a new block at the current position and makes it the first list item of a newly created list with the given <code>format</code>. Returns the created list.</li>
<li><code>QTextList * QTextCursor::insertList(QTextListFormat::Style style)</code>: This is an overloaded function. Inserts a new block at the current position and makes it the first list item of a newly created list with the given <code>style</code>. Returns the created list.</li>
<li><code>QTextTable * QTextCursor::insertTable(int rows, int columns, const QTextTableFormat &amp; format)</code>: Creates a new table with the given number of <code>rows</code> and <code>columns</code> in the specified <code>format</code>, inserts it at the current cursor <code>position()</code> in the document, and returns the table object. The cursor is moved to the beginning of the first cell. There must be at least one row and one column in the table.</li>
<li><code>QTextTable * QTextCursor::insertTable(int rows, int columns)</code>: This is an overloaded function. Creates a new table with the given number of <code>rows</code> and <code>columns</code>, inserts it at the current cursor <code>position()</code> in the document, and returns the table object. The cursor is moved to the beginning of the first cell. There must be at least one row and one column in the table.</li>
<li><code>void QTextCursor::insertText(const QString &amp; text)</code>: Inserts <code>text</code> at the current position, using the current character format. If there is a selection, the selection is deleted and replaced by <code>text</code>, for example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cursor.clearSelection();</span><br><span class="line">cursor.movePosition ( QTextCursor::NextWord, QTextCursor::KeepAnchor );</span><br><span class="line">cursor.insertText ( <span class="string">"Hello World"</span> );</span><br></pre></td></tr></table></figure>
<p>This clears any existing selection, selects the word at the cursor (i.e. from <code>position()</code> forward), and replaces the selection with the phrase <code>Hello World</code>. Any <code>ASCII</code> linefeed characters (<code>\n</code>) in the inserted text are transformed into unicode block separators, corresponding to <code>insertBlock()</code> calls.</p>
<ul>
<li><code>void QTextCursor::insertText(const QString &amp; text, const QTextCharFormat &amp; format)</code>: This is an overloaded function. Inserts <code>text</code> at the current position with the given <code>format</code>.</li>
<li><code>bool QTextCursor::isCopyOf(const QTextCursor &amp; other) const</code>: Returns true if this cursor and <code>other</code> are copies of each <code>other</code>, i.e. one of them was created as a copy of the <code>other</code> and neither has moved since. This is much stricter than equality.</li>
<li><code>bool QTextCursor::isNull() const</code>: Returns <code>true</code> if the cursor is null; otherwise returns <code>false</code>. A null cursor is created by the default constructor.</li>
<li><code>void QTextCursor::joinPreviousEditBlock()</code>: Like <code>beginEditBlock()</code> indicates the start of a block of editing operations that should appear as a single operation for undo/redo. However unlike <code>beginEditBlock()</code> it does not start a new block but reverses the previous call to <code>endEditBlock()</code> and therefore makes following operations part of the previous edit block created. For example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QTextCursor <span class="title">cursor</span> <span class="params">( textDocument )</span></span>;</span><br><span class="line">cursor.beginEditBlock();</span><br><span class="line">cursor.insertText ( <span class="string">"Hello"</span> );</span><br><span class="line">cursor.insertText ( <span class="string">"World"</span> );</span><br><span class="line">cursor.endEditBlock();</span><br><span class="line">...</span><br><span class="line">cursor.joinPreviousEditBlock();</span><br><span class="line">cursor.insertText ( <span class="string">"Hey"</span> );</span><br><span class="line">cursor.endEditBlock();</span><br><span class="line">​</span><br><span class="line">textDocument-&gt;undo();</span><br></pre></td></tr></table></figure>
<p>The call to <code>undo()</code> will cause all three insertions to be undone.</p>
<ul>
<li><code>bool QTextCursor::keepPositionOnInsert() const</code>: Returns whether the cursor should keep its current position when text gets inserted at the position of the cursor. The default is <code>false</code>.</li>
<li><code>void QTextCursor::mergeBlockCharFormat(const QTextCharFormat &amp; modifier)</code>: Modifies the block char format of the current block (or all blocks that are contained in the selection) with the block format specified by <code>modifier</code>.</li>
<li><code>void QTextCursor::mergeBlockFormat(const QTextBlockFormat &amp; modifier)</code>: Modifies the block format of the current block (or all blocks that are contained in the selection) with the block format specified by <code>modifier</code>.</li>
<li><code>void QTextCursor::mergeCharFormat(const QTextCharFormat &amp; modifier)</code>: Merges the cursor’s current character format with the properties described by format <code>modifier</code>. If the cursor has a selection, this function applies all the properties set in <code>modifier</code> to all the character formats that are part of the selection.</li>
<li><code>bool QTextCursor::movePosition(MoveOperation operation, MoveMode mode = MoveAnchor, int n = 1)</code>: Moves the cursor by performing the given <code>operation</code> <code>n</code> times, using the specified <code>mode</code>, and returns <code>true</code> if all operations were completed successfully; otherwise returns <code>false</code>. For example, if this function is repeatedly used to seek to the end of the next word, it will eventually fail when the end of the document is reached. By default, the move <code>operation</code> is performed once (<code>n = 1</code>). If <code>mode</code> is <code>KeepAnchor</code>, the cursor selects the text it moves over. This is the same effect that the user achieves when they hold down the <code>Shift</code> key and move the cursor with the cursor keys.</li>
<li><code>int QTextCursor::position() const</code>: Returns the absolute position of the cursor within the document. The cursor is positioned between characters.</li>
<li><code>int QTextCursor::positionInBlock() const</code>: Returns the relative position of the cursor within the block. The cursor is positioned between characters.</li>
<li><code>void QTextCursor::removeSelectedText()</code>: If there is a selection, its content is deleted; otherwise does nothing.</li>
<li><code>void QTextCursor::select(SelectionType selection)</code>: Selects text in the document according to the given <code>selection</code>.</li>
<li><code>void QTextCursor::selectedTableCells(int * firstRow, int * numRows, int * firstColumn, int * numColumns) const</code>: If the selection spans over table cells, <code>firstRow</code> is populated with the number of the first row in the selection, <code>firstColumn</code> with the number of the first column in the selection, and <code>numRows</code> and <code>numColumns</code> with the number of rows and columns in the selection. If the selection does not span any table cells the results are harmless but undefined.</li>
<li><code>QString QTextCursor::selectedText() const</code>: Returns the current selection’s text (which may be empty). This only returns the text, with no rich text formatting information. If you want a document fragment (i.e. formatted rich text) use <code>selection()</code> instead. <strong>Note</strong>: If the selection obtained from an editor spans a line break, the text will contain a <code>Unicode U+2029</code> paragraph separator character instead of a newline <code>\n</code> character. Use <code>QString::replace()</code> to replace these characters with newlines.</li>
<li><code>QTextDocumentFragment QTextCursor::selection() const</code>: Returns the current selection (which may be empty) with all its formatting information. If you just want the selected text (i.e. plain text) use <code>selectedText()</code> instead. <strong>Note</strong>: Unlike <code>QTextDocumentFragment::toPlainText()</code>, <code>selectedText()</code> may include special unicode characters such as <code>QChar::ParagraphSeparator</code>.</li>
<li><code>int QTextCursor::selectionEnd() const</code>: Returns the end of the <code>selection</code> or <code>position()</code> if the cursor doesn’t have a selection.</li>
<li><code>int QTextCursor::selectionStart() const</code>: Returns the start of the <code>selection</code> or <code>position()</code> if the cursor doesn’t have a selection.</li>
<li><code>void QTextCursor::setBlockCharFormat(const QTextCharFormat &amp; format)</code>: Sets the block char <code>format</code> of the current block (or all blocks that are contained in the selection) to <code>format</code>.</li>
<li><code>void QTextCursor::setBlockFormat(const QTextBlockFormat &amp; format)</code>: Sets the block <code>format</code> of the current block (or all blocks that are contained in the selection) to <code>format</code>.</li>
<li><code>void QTextCursor::setCharFormat(const QTextCharFormat &amp; format)</code>: Sets the cursor’s current character <code>format</code> to the given <code>format</code>. If the cursor has a selection, the given <code>format</code> is applied to the current selection.</li>
<li><code>void QTextCursor::setKeepPositionOnInsert(bool b)</code>: Defines whether the cursor should keep its current position when text gets inserted at the current position of the cursor. If <code>b</code> is <code>true</code>, the cursor keeps its current position when text gets inserted at the positing of the cursor. If <code>b</code> is <code>false</code>, the cursor moves along with the inserted text. The default is <code>false</code>. Note that a cursor always moves when text is inserted before the current position of the cursor, and it always keeps its position when text is inserted after the current position of the cursor.</li>
<li><code>void QTextCursor::setPosition(int pos, MoveMode m = MoveAnchor)</code>: Moves the cursor to the absolute position in the document specified by <code>pos</code> using a <code>MoveMode</code> specified by <code>m</code>. The cursor is positioned between characters.</li>
<li><code>void QTextCursor::setVerticalMovementX(int x)</code>: Sets the visual <code>x</code> position for vertical cursor movements to <code>x</code>. The vertical movement <code>x</code> position is cleared automatically when the cursor moves horizontally, and kept unchanged when the cursor moves vertically. The mechanism allows the cursor to move up and down on a visually straight line with proportional fonts, and to gently <code>jump</code> over short lines. A value of <code>-1</code> indicates no predefined <code>x</code> position. It will then be set automatically the next time the cursor moves up or down.</li>
<li><code>void QTextCursor::setVisualNavigation(bool b)</code>: Sets visual navigation to <code>b</code>. Visual navigation means skipping over hidden text pragraphs. The default is <code>false</code>.</li>
<li><code>int QTextCursor::verticalMovementX() const</code>: Returns the visual <code>x</code> position for vertical cursor movements. A value of <code>-1</code> indicates no predefined <code>x</code> position. It will then be set automatically the next time the cursor moves up or down.</li>
<li><code>bool QTextCursor::visualNavigation() const</code>: Returns <code>true</code> if the cursor does visual navigation; otherwise returns <code>false</code>. Visual navigation means skipping over hidden text pragraphs. The default is <code>false</code>.</li>
<li><code>bool QTextCursor::operator!=(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is at a different position in the document as this cursor; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::operator&lt;(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is positioned later in the document than this cursor; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::operator&lt;=(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is positioned later or at the same position in the document as this cursor; otherwise returns <code>false</code>.</li>
<li><code>QTextCursor &amp; QTextCursor::operator=(const QTextCursor &amp; cursor)</code>: Makes a copy of <code>cursor</code> and assigns it to this <code>QTextCursor</code>. Note that <code>QTextCursor</code> is an implicitly shared class.</li>
<li><code>bool QTextCursor::operator==(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is at the same position in the document as this cursor; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::operator&gt;(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is positioned earlier in the document than this cursor; otherwise returns <code>false</code>.</li>
<li><code>bool QTextCursor::operator&gt;=(const QTextCursor &amp; other) const</code>: Returns <code>true</code> if the <code>other</code> cursor is positioned earlier or at the same position in the document as this cursor; otherwise returns <code>false</code>.</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/28/Qt语法详解/Qt之QHash/" rel="next" title="Qt之QHash">
                <i class="fa fa-chevron-left"></i> Qt之QHash
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/30/Qt语法详解/Qt之QVector/" rel="prev" title="Qt之QVector">
                Qt之QVector <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">939</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Public-Functions"><span class="nav-number">1.</span> <span class="nav-text">Public Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Detailed-Description"><span class="nav-number">2.</span> <span class="nav-text">Detailed Description</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Member-Type-Documentation"><span class="nav-number">3.</span> <span class="nav-text">Member Type Documentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Member-Function-Documentation"><span class="nav-number">4.</span> <span class="nav-text">Member Function Documentation</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
