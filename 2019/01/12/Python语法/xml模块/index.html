<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="什么是XML？&amp;emsp;&amp;emsp;XML指可扩展标记语言(Extensible Markup Language)，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。它被设计用于传输和存储数据。&amp;emsp;&amp;emsp;XML是一套定义语义标记的规则，这些标记将文档分成许多部件，并对这些部件加以标识。它也是元标记语言，即定义了用于定义其他与特定领域有关的、语义的、结构化的标记">
<meta property="og:type" content="article">
<meta property="og:title" content="xml模块">
<meta property="og:url" content="http://fukangwei.gitee.io/2019/01/12/Python语法/xml模块/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:description" content="什么是XML？&amp;emsp;&amp;emsp;XML指可扩展标记语言(Extensible Markup Language)，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。它被设计用于传输和存储数据。&amp;emsp;&amp;emsp;XML是一套定义语义标记的规则，这些标记将文档分成许多部件，并对这些部件加以标识。它也是元标记语言，即定义了用于定义其他与特定领域有关的、语义的、结构化的标记">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-03-30T00:35:58.502Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xml模块">
<meta name="twitter:description" content="什么是XML？&amp;emsp;&amp;emsp;XML指可扩展标记语言(Extensible Markup Language)，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。它被设计用于传输和存储数据。&amp;emsp;&amp;emsp;XML是一套定义语义标记的规则，这些标记将文档分成许多部件，并对这些部件加以标识。它也是元标记语言，即定义了用于定义其他与特定领域有关的、语义的、结构化的标记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/2019/01/12/Python语法/xml模块/">





  <title>xml模块 | 泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/12/Python语法/xml模块/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">xml模块</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-12T14:08:01+08:00">
                2019-01-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Python语法/" itemprop="url" rel="index">
                    <span itemprop="name">Python语法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="什么是XML？"><a href="#什么是XML？" class="headerlink" title="什么是XML？"></a>什么是XML？</h3><p>&emsp;&emsp;<code>XML</code>指可扩展标记语言(<code>Extensible Markup Language</code>)，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。它被设计用于传输和存储数据。<br>&emsp;&emsp;<code>XML</code>是一套定义语义标记的规则，这些标记将文档分成许多部件，并对这些部件加以标识。它也是元标记语言，即定义了用于定义其他与特定领域有关的、语义的、结构化的标记语言的句法语言。</p>
<h3 id="python对XML的解析"><a href="#python对XML的解析" class="headerlink" title="python对XML的解析"></a>python对XML的解析</h3><p>&emsp;&emsp;常见的<code>XML</code>编程接口有<code>DOM</code>和<code>SAX</code>，这两种接口处理<code>XML</code>文件的方式不同，当然使用场合也不同。<code>python</code>有三种方法解析<code>XML</code>：<code>SAX</code>、<code>DOM</code>以及<code>ElementTree</code>：</p>
<ul>
<li><code>SAX(Simple API for XML)</code>：<code>python</code>标准库包含<code>SAX</code>解析器，<code>SAX</code>用事件驱动模型，通过在解析<code>XML</code>的过程中触发一个个的事件，并调用用户定义的回调函数来处理<code>XML</code>文件。</li>
<li><code>DOM(Document Object Model)</code>：将<code>XML</code>数据在内存中解析成一个树，通过对树的操作来操作<code>XML</code>。</li>
</ul>
<p>本章节使用到的<code>XML</code>实例文件<code>movies.xml</code>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">shelf</span>=<span class="string">"New Arrivals"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">movie</span> <span class="attr">title</span>=<span class="string">"Enemy Behind"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>War, Thriller<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">format</span>&gt;</span>DVD<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rating</span>&gt;</span>PG<span class="tag">&lt;/<span class="name">rating</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">stars</span>&gt;</span>10<span class="tag">&lt;/<span class="name">stars</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Talk about a US-Japan war<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">movie</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">movie</span> <span class="attr">title</span>=<span class="string">"Transformers"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>Anime, Science Fiction<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">format</span>&gt;</span>DVD<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">year</span>&gt;</span>1989<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rating</span>&gt;</span>R<span class="tag">&lt;/<span class="name">rating</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">stars</span>&gt;</span>8<span class="tag">&lt;/<span class="name">stars</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>A schientific fiction<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">movie</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">movie</span> <span class="attr">title</span>=<span class="string">"Trigun"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>Anime, Action<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">format</span>&gt;</span>DVD<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">episodes</span>&gt;</span>4<span class="tag">&lt;/<span class="name">episodes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rating</span>&gt;</span>PG<span class="tag">&lt;/<span class="name">rating</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">stars</span>&gt;</span>10<span class="tag">&lt;/<span class="name">stars</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Vash the Stampede!<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">movie</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">movie</span> <span class="attr">title</span>=<span class="string">"Ishtar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>Comedy<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">format</span>&gt;</span>VHS<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rating</span>&gt;</span>PG<span class="tag">&lt;/<span class="name">rating</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">stars</span>&gt;</span>2<span class="tag">&lt;/<span class="name">stars</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Viewable boredom<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">movie</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="python使用SAX解析xml"><a href="#python使用SAX解析xml" class="headerlink" title="python使用SAX解析xml"></a>python使用SAX解析xml</h3><p>&emsp;&emsp;<code>SAX</code>是一种基于事件驱动的<code>API</code>。利用<code>SAX</code>解析<code>XML</code>文档牵涉到两个部分，即<code>解析器</code>和<code>事件处理器</code>。</p>
<ul>
<li>解析器负责读取XML文档，并向事件处理器发送事件，例如元素开始和元素结束事件。</li>
<li>事件处理器则负责对事件作出相应，对传递的XML数据进行处理。</li>
</ul>
<p>&emsp;&emsp;在<code>python</code>中使用<code>SAX</code>方式处理<code>XML</code>，要先引入<code>xml.sax</code>中的<code>parse</code>函数，还有<code>xml.sax.handler</code>中的<code>ContentHandler</code>。</p>
<h4 id="ContentHandler类方法介绍"><a href="#ContentHandler类方法介绍" class="headerlink" title="ContentHandler类方法介绍"></a>ContentHandler类方法介绍</h4><ul>
<li><code>characters(content)</code>方法：调用时机是：从行开始，在遇到标签之前，如果存在字符，<code>content</code>的值为这些字符串；从一个标签开始，在遇到下一个标签之前，如果存在字符，<code>content</code>的值为这些字符串；从一个标签，在遇到行结束符之前，如果存在字符，<code>content</code>的值为这些字符串。标签可以是开始标签，也可以是结束标签。</li>
<li><code>startDocument</code>方法：文档启动的时候调用。</li>
<li><code>endDocument</code>方法：解析器到达文档结尾时调用。</li>
<li><code>startElement(name, attrs)</code>方法：遇到<code>XML</code>开始标签时调用，<code>name</code>是标签的名字，<code>attrs</code>是标签的属性值字典。</li>
<li><code>endElement(name)</code>方法：遇到<code>XML</code>结束标签时调用。</li>
</ul>
<h4 id="make-parser方法"><a href="#make-parser方法" class="headerlink" title="make_parser方法"></a>make_parser方法</h4><p>&emsp;&emsp;以下方法创建一个新的解析器对象并返回：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.sax.make_parser([parser_list])</span><br></pre></td></tr></table></figure>
<p>参数<code>parser_list</code>是可选参数，即解析器列表。</p>
<h4 id="parser方法"><a href="#parser方法" class="headerlink" title="parser方法"></a>parser方法</h4><p>&emsp;&emsp;以下方法创建一个<code>SAX</code>解析器，并解析<code>xml</code>文档：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.sax.parse(xmlfile, contenthandler[, errorhandler])</span><br></pre></td></tr></table></figure>
<p>参数<code>xmlfile</code>是<code>xml</code>文件名；<code>contenthandler</code>必须是一个<code>ContentHandler</code>的对象；对于<code>errorhandler</code>，如果指定该参数，<code>errorhandler</code>必须是一个<code>SAX ErrorHandler</code>对象。</p>
<h4 id="parseString方法"><a href="#parseString方法" class="headerlink" title="parseString方法"></a>parseString方法</h4><p>&emsp;&emsp;<code>parseString</code>方法创建一个<code>XML</code>解析器，并解析<code>xml</code>字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.sax.parseString(xmlstring, contenthandler[, errorhandler])</span><br></pre></td></tr></table></figure>
<p>参数<code>xmlstring</code>是<code>xml</code>字符串；<code>contenthandler</code>必须是一个<code>ContentHandler</code>的对象；对于<code>errorhandler</code>，如果指定该参数，<code>errorhandler</code>必须是一个<code>SAX ErrorHandler</code>对象。</p>
<h3 id="Python解析XML实例"><a href="#Python解析XML实例" class="headerlink" title="Python解析XML实例"></a>Python解析XML实例</h3><p>&emsp;&emsp;代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.sax</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieHandler</span><span class="params">(xml.sax.ContentHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.CurrentData = <span class="string">""</span></span><br><span class="line">        self.type = <span class="string">""</span></span><br><span class="line">        self.format = <span class="string">""</span></span><br><span class="line">        self.year = <span class="string">""</span></span><br><span class="line">        self.rating = <span class="string">""</span></span><br><span class="line">        self.stars = <span class="string">""</span></span><br><span class="line">        self.description = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startElement</span><span class="params">(self, tag, attributes)</span>:</span>  <span class="comment"># 元素开始调用</span></span><br><span class="line">        self.CurrentData = tag</span><br><span class="line">        <span class="keyword">if</span> tag == <span class="string">"movie"</span>:</span><br><span class="line">            print(<span class="string">"*****Movie*****"</span>)</span><br><span class="line">            title = attributes[<span class="string">"title"</span>]</span><br><span class="line">            print(<span class="string">"Title:"</span>, title)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">endElement</span><span class="params">(self, tag)</span>:</span>  <span class="comment"># 元素结束调用</span></span><br><span class="line">        <span class="keyword">if</span> self.CurrentData == <span class="string">"type"</span>:</span><br><span class="line">            print(<span class="string">"Type:"</span>, self.type)</span><br><span class="line">        <span class="keyword">elif</span> self.CurrentData == <span class="string">"format"</span>:</span><br><span class="line">            print(<span class="string">"Format:"</span>, self.format)</span><br><span class="line">        <span class="keyword">elif</span> self.CurrentData == <span class="string">"year"</span>:</span><br><span class="line">            print(<span class="string">"Year:"</span>, self.year)</span><br><span class="line">        <span class="keyword">elif</span> self.CurrentData == <span class="string">"rating"</span>:</span><br><span class="line">            print(<span class="string">"Rating:"</span>, self.rating)</span><br><span class="line">        <span class="keyword">elif</span> self.CurrentData == <span class="string">"stars"</span>:</span><br><span class="line">            print(<span class="string">"Stars:"</span>, self.stars)</span><br><span class="line">        <span class="keyword">elif</span> self.CurrentData == <span class="string">"description"</span>:</span><br><span class="line">            print(<span class="string">"Description:"</span>, self.description)</span><br><span class="line">        self.CurrentData = <span class="string">""</span></span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">characters</span><span class="params">(self, content)</span>:</span>  <span class="comment"># 读取字符时调用</span></span><br><span class="line">        <span class="keyword">if</span> self.CurrentData == <span class="string">"type"</span>:</span><br><span class="line">            self.type = content</span><br><span class="line">        <span class="keyword">elif</span> self.CurrentData == <span class="string">"format"</span>:</span><br><span class="line">            self.format = content</span><br><span class="line">        <span class="keyword">elif</span> self.CurrentData == <span class="string">"year"</span>:</span><br><span class="line">            self.year = content</span><br><span class="line">        <span class="keyword">elif</span> self.CurrentData == <span class="string">"rating"</span>:</span><br><span class="line">            self.rating = content</span><br><span class="line">        <span class="keyword">elif</span> self.CurrentData == <span class="string">"stars"</span>:</span><br><span class="line">            self.stars = content</span><br><span class="line">        <span class="keyword">elif</span> self.CurrentData == <span class="string">"description"</span>:</span><br><span class="line">            self.description = content</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    parser = xml.sax.make_parser()  <span class="comment"># 创建一个XMLReader</span></span><br><span class="line">    <span class="comment"># turn off namepsaces</span></span><br><span class="line">    parser.setFeature(xml.sax.handler.feature_namespaces, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 重写ContextHandler</span></span><br><span class="line">    Handler = MovieHandler()</span><br><span class="line">    parser.setContentHandler(Handler)</span><br><span class="line">    parser.parse(<span class="string">"movies.xml"</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">*****Movie*****</span><br><span class="line">Title: Enemy Behind</span><br><span class="line">Type: War, Thriller</span><br><span class="line">Format: DVD</span><br><span class="line">Year: <span class="number">2003</span></span><br><span class="line">Rating: PG</span><br><span class="line">Stars: <span class="number">10</span></span><br><span class="line">Description: Talk about a US-Japan war</span><br><span class="line">*****Movie*****</span><br><span class="line">Title: Transformers</span><br><span class="line">Type: Anime, Science Fiction</span><br><span class="line">Format: DVD</span><br><span class="line">Year: <span class="number">1989</span></span><br><span class="line">Rating: R</span><br><span class="line">Stars: <span class="number">8</span></span><br><span class="line">Description: A schientific fiction</span><br><span class="line">*****Movie*****</span><br><span class="line">Title: Trigun</span><br><span class="line">Type: Anime, Action</span><br><span class="line">Format: DVD</span><br><span class="line">Rating: PG</span><br><span class="line">Stars: <span class="number">10</span></span><br><span class="line">Description: Vash the Stampede!</span><br><span class="line">*****Movie*****</span><br><span class="line">Title: Ishtar</span><br><span class="line">Type: Comedy</span><br><span class="line">Format: VHS</span><br><span class="line">Rating: PG</span><br><span class="line">Stars: <span class="number">2</span></span><br><span class="line">Description: Viewable boredom</span><br></pre></td></tr></table></figure>
<h3 id="使用xml-dom解析xml"><a href="#使用xml-dom解析xml" class="headerlink" title="使用xml.dom解析xml"></a>使用xml.dom解析xml</h3><p>&emsp;&emsp;文件对象模型(<code>Document Object Model</code>，即<code>DOM</code>)是<code>W3C</code>组织推荐的处理可扩展置标语言的标准编程接口。<br>&emsp;&emsp;一个<code>DOM</code>的解析器在解析一个<code>XML</code>文档时，一次性读取整个文档，把文档中所有元素保存在内存中的一个树结构里，之后可以利用<code>DOM</code>提供的不同的函数来读取或修改文档的内容和结构，也可以把修改过的内容写入<code>xml</code>文件。<br>&emsp;&emsp;<code>python</code>中用<code>xml.dom.minidom</code>来解析<code>xml</code>文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.dom.minidom <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">import</span> xml.dom.minidom</span><br><span class="line">​</span><br><span class="line">DOMTree = xml.dom.minidom.parse(<span class="string">"movies.xml"</span>)  <span class="comment"># 使用minidom解析器打开XML文档</span></span><br><span class="line">collection = DOMTree.documentElement</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> collection.hasAttribute(<span class="string">"shelf"</span>):</span><br><span class="line">    print(<span class="string">"Root element : %s"</span> % collection.getAttribute(<span class="string">"shelf"</span>))</span><br><span class="line">​</span><br><span class="line">movies = collection.getElementsByTagName(<span class="string">"movie"</span>)  <span class="comment"># 在集合中获取所有电影</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> movie <span class="keyword">in</span> movies:  <span class="comment"># 打印每部电影的详细信息</span></span><br><span class="line">    print(<span class="string">"*****Movie*****"</span>)</span><br><span class="line">    <span class="keyword">if</span> movie.hasAttribute(<span class="string">"title"</span>):</span><br><span class="line">        print(<span class="string">"Title: %s"</span> % movie.getAttribute(<span class="string">"title"</span>))</span><br><span class="line">​</span><br><span class="line">    type = movie.getElementsByTagName(<span class="string">'type'</span>)[<span class="number">0</span>]</span><br><span class="line">    print(<span class="string">"Type: %s"</span> % type.childNodes[<span class="number">0</span>].data)</span><br><span class="line">    format = movie.getElementsByTagName(<span class="string">'format'</span>)[<span class="number">0</span>]</span><br><span class="line">    print(<span class="string">"Format: %s"</span> % format.childNodes[<span class="number">0</span>].data)</span><br><span class="line">    rating = movie.getElementsByTagName(<span class="string">'rating'</span>)[<span class="number">0</span>]</span><br><span class="line">    print(<span class="string">"Rating: %s"</span> % rating.childNodes[<span class="number">0</span>].data)</span><br><span class="line">    description = movie.getElementsByTagName(<span class="string">'description'</span>)[<span class="number">0</span>]</span><br><span class="line">    print(<span class="string">"Description: %s"</span> % description.childNodes[<span class="number">0</span>].data)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Root element : New Arrivals</span><br><span class="line">*****Movie*****</span><br><span class="line">Title: Enemy Behind</span><br><span class="line">Type: War, Thriller</span><br><span class="line">Format: DVD</span><br><span class="line">Rating: PG</span><br><span class="line">Description: Talk about a US-Japan war</span><br><span class="line">*****Movie*****</span><br><span class="line">Title: Transformers</span><br><span class="line">Type: Anime, Science Fiction</span><br><span class="line">Format: DVD</span><br><span class="line">Rating: R</span><br><span class="line">Description: A schientific fiction</span><br><span class="line">*****Movie*****</span><br><span class="line">Title: Trigun</span><br><span class="line">Type: Anime, Action</span><br><span class="line">Format: DVD</span><br><span class="line">Rating: PG</span><br><span class="line">Description: Vash the Stampede!</span><br><span class="line">*****Movie*****</span><br><span class="line">Title: Ishtar</span><br><span class="line">Type: Comedy</span><br><span class="line">Format: VHS</span><br><span class="line">Rating: PG</span><br><span class="line">Description: Viewable boredom</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="xml-etree-ElementTree-—-The-ElementTree-XML-API"><a href="#xml-etree-ElementTree-—-The-ElementTree-XML-API" class="headerlink" title="xml.etree.ElementTree — The ElementTree XML API"></a>xml.etree.ElementTree — The ElementTree XML API</h3><p>&emsp;&emsp;The <code>xml.etree.ElementTree</code> module implements a simple and efficient <code>API</code> for parsing and creating <code>XML</code> data.<br>&emsp;&emsp;Changed in <code>version 3.3</code>: This module will use a fast implementation whenever available. The <code>xml.etree.cElementTree</code> module is deprecated.<br>&emsp;&emsp;<strong>Warning</strong>: The <code>xml.etree.ElementTree</code> module is not secure against maliciously constructed data. If you need to parse untrusted or unauthenticated data.</p>
<h3 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h3><p>&emsp;&emsp;This is a short tutorial for using <code>xml.etree.ElementTree</code> (<code>ET</code> in short). The goal is to demonstrate some of the building blocks and basic concepts of the module.</p>
<h4 id="XML-tree-and-elements"><a href="#XML-tree-and-elements" class="headerlink" title="XML tree and elements"></a>XML tree and elements</h4><p>&emsp;&emsp;<code>XML</code> is an inherently hierarchical data format, and the most natural way to represent it is with a tree. <code>ET</code> has two classes for this purpose - <code>ElementTree</code> represents the whole <code>XML</code> document as a tree, and <code>Element</code> represents a single node in this tree. Interactions with the whole document (reading and writing to/from files) are usually done on the <code>ElementTree</code> level. Interactions with a single <code>XML</code> element and its <code>sub-elements</code> are done on the <code>Element</code> level.</p>
<h4 id="Parsing-XML"><a href="#Parsing-XML" class="headerlink" title="Parsing XML"></a>Parsing XML</h4><p>&emsp;&emsp;We’ll be using the following <code>XML</code> document as the sample data for this section:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">country</span> <span class="attr">name</span>=<span class="string">"Liechtenstein"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rank</span>&gt;</span>1<span class="tag">&lt;/<span class="name">rank</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2008<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gdppc</span>&gt;</span>141100<span class="tag">&lt;/<span class="name">gdppc</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">name</span>=<span class="string">"Austria"</span> <span class="attr">direction</span>=<span class="string">"E"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">name</span>=<span class="string">"Switzerland"</span> <span class="attr">direction</span>=<span class="string">"W"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">country</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">country</span> <span class="attr">name</span>=<span class="string">"Singapore"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rank</span>&gt;</span>4<span class="tag">&lt;/<span class="name">rank</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2011<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gdppc</span>&gt;</span>59900<span class="tag">&lt;/<span class="name">gdppc</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">name</span>=<span class="string">"Malaysia"</span> <span class="attr">direction</span>=<span class="string">"N"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">country</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">country</span> <span class="attr">name</span>=<span class="string">"Panama"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rank</span>&gt;</span>68<span class="tag">&lt;/<span class="name">rank</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2011<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gdppc</span>&gt;</span>13600<span class="tag">&lt;/<span class="name">gdppc</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">name</span>=<span class="string">"Costa Rica"</span> <span class="attr">direction</span>=<span class="string">"W"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">name</span>=<span class="string">"Colombia"</span> <span class="attr">direction</span>=<span class="string">"E"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">country</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>We can import this data by reading from a file:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line">tree = ET.parse(<span class="string">'country_data.xml'</span>)</span><br><span class="line">root = tree.getroot()</span><br><span class="line">Or directly <span class="keyword">from</span> a string:</span><br><span class="line">root = ET.fromstring(country_data_as_string)</span><br></pre></td></tr></table></figure>
<p><code>fromstring()</code> parses <code>XML</code> from a string directly into an <code>Element</code>, which is the root element of the parsed tree. Other parsing functions may create an <code>ElementTree</code>.<br>&emsp;&emsp;As an <code>Element</code>, root has a tag and a dictionary of attributes:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root.tag</span><br><span class="line"><span class="string">'data'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root.attrib</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>It also has children nodes over which we can iterate:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> child <span class="keyword">in</span> root:</span><br><span class="line"><span class="meta">... </span>    print(child.tag, child.attrib)</span><br><span class="line">...</span><br><span class="line">country &#123;<span class="string">'name'</span>: <span class="string">'Liechtenstein'</span>&#125;</span><br><span class="line">country &#123;<span class="string">'name'</span>: <span class="string">'Singapore'</span>&#125;</span><br><span class="line">country &#123;<span class="string">'name'</span>: <span class="string">'Panama'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>Children are nested, and we can access specific child nodes by <code>index</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root[<span class="number">0</span>][<span class="number">1</span>].text</span><br><span class="line"><span class="string">'2008'</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>Note</strong>: Not all elements of the <code>XML</code> input will end up as elements of the parsed tree. Currently, this module skips over any <code>XML</code> comments, processing instructions, and document type declarations in the input. Nevertheless, trees built using this module’s <code>API</code> rather than parsing from <code>XML</code> text can have comments and processing instructions in them; they will be included when generating <code>XML</code> output. A document type declaration may be accessed by passing a custom <code>TreeBuilder</code> instance to the <code>XMLParser</code> constructor.</p>
<h4 id="Pull-API-for-non-blocking-parsing"><a href="#Pull-API-for-non-blocking-parsing" class="headerlink" title="Pull API for non-blocking parsing"></a>Pull API for non-blocking parsing</h4><p>&emsp;&emsp;Most parsing functions provided by this module require the whole document to be read at once before returning any result. It is possible to use an <code>XMLParser</code> and feed data into it incrementally, but it is a push <code>API</code> that calls methods on a callback target, which is too <code>low-level</code> and inconvenient for most needs. Sometimes what the user really wants is to be able to parse <code>XML</code> incrementally, without blocking operations, while enjoying the convenience of fully constructed <code>Element</code> objects.<br>&emsp;&emsp;The most powerful tool for doing this is <code>XMLPullParser</code>. It does not require a blocking read to obtain the <code>XML</code> data, and is instead fed with data incrementally with <code>XMLPullParser.feed()</code> calls. To get the parsed <code>XML</code> elements, call <code>XMLPullParser.read_events()</code>. Here is an example:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = ET.XMLPullParser([<span class="string">'start'</span>, <span class="string">'end'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&lt;mytag&gt;sometext'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(parser.read_events())</span><br><span class="line">[(<span class="string">'start'</span>, &lt;Element <span class="string">'mytag'</span> at <span class="number">0x7fa66db2be58</span>&gt;)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">' more text&lt;/mytag&gt;'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> event, elem <span class="keyword">in</span> parser.read_events():</span><br><span class="line"><span class="meta">... </span>    print(event)</span><br><span class="line"><span class="meta">... </span>    print(elem.tag, <span class="string">'text='</span>, elem.text)</span><br><span class="line">...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>The obvious use case is applications that operate in a <code>non-blocking</code> fashion where the <code>XML</code> data is being received from a socket or read incrementally from some storage device. In such cases, <code>blocking</code> reads are unacceptable.<br>&emsp;&emsp;Because it’s so flexible, <code>XMLPullParser</code> can be inconvenient to use for simpler <code>use-cases</code>. If you don’t mind your application <code>blocking</code> on reading <code>XML</code> data but would still like to have incremental parsing capabilities, take a look at <code>iterparse()</code>. It can be useful when you’re reading a large <code>XML</code> document and don’t want to hold it wholly in memory.</p>
<h4 id="Finding-interesting-elements"><a href="#Finding-interesting-elements" class="headerlink" title="Finding interesting elements"></a>Finding interesting elements</h4><p>&emsp;&emsp;<code>Element</code> has some useful methods that help iterate recursively over all the <code>sub-tree</code> below it (its children, their children, and so on). For example, <code>Element.iter()</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> neighbor <span class="keyword">in</span> root.iter(<span class="string">'neighbor'</span>):</span><br><span class="line"><span class="meta">... </span>    print(neighbor.attrib)</span><br><span class="line">...</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Austria'</span>, <span class="string">'direction'</span>: <span class="string">'E'</span>&#125;</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Switzerland'</span>, <span class="string">'direction'</span>: <span class="string">'W'</span>&#125;</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Malaysia'</span>, <span class="string">'direction'</span>: <span class="string">'N'</span>&#125;</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Costa Rica'</span>, <span class="string">'direction'</span>: <span class="string">'W'</span>&#125;</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Colombia'</span>, <span class="string">'direction'</span>: <span class="string">'E'</span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>Element.findall()</code> finds only elements with a tag which are direct children of the current element. <code>Element.find()</code> finds the first child with a particular tag, and <code>Element.text</code> accesses the element’s text content. <code>Element.get()</code> accesses the element’s attributes:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> country <span class="keyword">in</span> root.findall(<span class="string">'country'</span>):</span><br><span class="line"><span class="meta">... </span>    rank = country.find(<span class="string">'rank'</span>).text</span><br><span class="line"><span class="meta">... </span>    name = country.get(<span class="string">'name'</span>)</span><br><span class="line"><span class="meta">... </span>    print(name, rank)</span><br><span class="line">...</span><br><span class="line">Liechtenstein <span class="number">1</span></span><br><span class="line">Singapore <span class="number">4</span></span><br><span class="line">Panama <span class="number">68</span></span><br></pre></td></tr></table></figure>
<p>More sophisticated specification of which elements to look for is possible by using <code>XPath</code>.</p>
<h4 id="Modifying-an-XML-File"><a href="#Modifying-an-XML-File" class="headerlink" title="Modifying an XML File"></a>Modifying an XML File</h4><p>&emsp;&emsp;<code>ElementTree</code> provides a simple way to build <code>XML</code> documents and write them to files. The <code>ElementTree.write()</code> method serves this purpose.<br>&emsp;&emsp;Once created, an <code>Element</code> object may be manipulated by directly changing its fields (such as <code>Element.text</code>), adding and modifying attributes (<code>Element.set()</code> method), as well as adding new children (for example with <code>Element.append()</code>).<br>&emsp;&emsp;Let’s say we want to add one to each country’s rank, and add an updated attribute to the rank element:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> rank <span class="keyword">in</span> root.iter(<span class="string">'rank'</span>):</span><br><span class="line"><span class="meta">... </span>    new_rank = int(rank.text) + <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    rank.text = str(new_rank)</span><br><span class="line"><span class="meta">... </span>    rank.set(<span class="string">'updated'</span>, <span class="string">'yes'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree.write(<span class="string">'output.xml'</span>)</span><br></pre></td></tr></table></figure>
<p>Our <code>XML</code> now looks like this:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">country</span> <span class="attr">name</span>=<span class="string">"Liechtenstein"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rank</span> <span class="attr">updated</span>=<span class="string">"yes"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">rank</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2008<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gdppc</span>&gt;</span>141100<span class="tag">&lt;/<span class="name">gdppc</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">name</span>=<span class="string">"Austria"</span> <span class="attr">direction</span>=<span class="string">"E"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">name</span>=<span class="string">"Switzerland"</span> <span class="attr">direction</span>=<span class="string">"W"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">country</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">country</span> <span class="attr">name</span>=<span class="string">"Singapore"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rank</span> <span class="attr">updated</span>=<span class="string">"yes"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">rank</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2011<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gdppc</span>&gt;</span>59900<span class="tag">&lt;/<span class="name">gdppc</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">name</span>=<span class="string">"Malaysia"</span> <span class="attr">direction</span>=<span class="string">"N"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">country</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">country</span> <span class="attr">name</span>=<span class="string">"Panama"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rank</span> <span class="attr">updated</span>=<span class="string">"yes"</span>&gt;</span>69<span class="tag">&lt;/<span class="name">rank</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2011<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gdppc</span>&gt;</span>13600<span class="tag">&lt;/<span class="name">gdppc</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">name</span>=<span class="string">"Costa Rica"</span> <span class="attr">direction</span>=<span class="string">"W"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">name</span>=<span class="string">"Colombia"</span> <span class="attr">direction</span>=<span class="string">"E"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">country</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>We can remove elements using <code>Element.remove()</code>. Let’s say we want to remove all countries with a rank higher than <code>50</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> country <span class="keyword">in</span> root.findall(<span class="string">'country'</span>):</span><br><span class="line"><span class="meta">... </span>    rank = int(country.find(<span class="string">'rank'</span>).text)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> rank &gt; <span class="number">50</span>:</span><br><span class="line"><span class="meta">... </span>        root.remove(country)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree.write(<span class="string">'output.xml'</span>)</span><br></pre></td></tr></table></figure>
<p>Our <code>XML</code> now looks like this:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">country</span> <span class="attr">name</span>=<span class="string">"Liechtenstein"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rank</span> <span class="attr">updated</span>=<span class="string">"yes"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">rank</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2008<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gdppc</span>&gt;</span>141100<span class="tag">&lt;/<span class="name">gdppc</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">name</span>=<span class="string">"Austria"</span> <span class="attr">direction</span>=<span class="string">"E"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">name</span>=<span class="string">"Switzerland"</span> <span class="attr">direction</span>=<span class="string">"W"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">country</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">country</span> <span class="attr">name</span>=<span class="string">"Singapore"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rank</span> <span class="attr">updated</span>=<span class="string">"yes"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">rank</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2011<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gdppc</span>&gt;</span>59900<span class="tag">&lt;/<span class="name">gdppc</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">name</span>=<span class="string">"Malaysia"</span> <span class="attr">direction</span>=<span class="string">"N"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">country</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Building-XML-documents"><a href="#Building-XML-documents" class="headerlink" title="Building XML documents"></a>Building XML documents</h4><p>&emsp;&emsp;The <code>SubElement()</code> function also provides a convenient way to create new <code>sub-elements</code> for a given element:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = ET.Element(<span class="string">'a'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = ET.SubElement(a, <span class="string">'b'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = ET.SubElement(a, <span class="string">'c'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = ET.SubElement(c, <span class="string">'d'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ET.dump(a)</span><br><span class="line">&lt;a&gt;&lt;b /&gt;&lt;c&gt;&lt;d /&gt;&lt;/c&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Parsing-XML-with-Namespaces"><a href="#Parsing-XML-with-Namespaces" class="headerlink" title="Parsing XML with Namespaces"></a>Parsing XML with Namespaces</h4><p>&emsp;&emsp;If the <code>XML</code> input has <code>namespaces</code>, <code>tags</code> and <code>attributes</code> with prefixes in the form <code>prefix:sometag</code> get expanded to <code>{uri}sometag</code> where the prefix is replaced by the full <code>URI</code>. Also, if there is a default namespace, that full <code>URI</code> gets prepended to all of the <code>non-prefixed</code> tags.<br>&emsp;&emsp;Here is an <code>XML</code> example that incorporates two namespaces, one with the prefix <code>fictional</code> and the other serving as the default namespace:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">actors</span> <span class="attr">xmlns:fictional</span>=<span class="string">"http://characters.example.com"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">"http://people.example.com"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">actor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>John Cleese<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fictional:character</span>&gt;</span>Lancelot<span class="tag">&lt;/<span class="name">fictional:character</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fictional:character</span>&gt;</span>Archie Leach<span class="tag">&lt;/<span class="name">fictional:character</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">actor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Eric Idle<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fictional:character</span>&gt;</span>Sir Robin<span class="tag">&lt;/<span class="name">fictional:character</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fictional:character</span>&gt;</span>Gunther<span class="tag">&lt;/<span class="name">fictional:character</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fictional:character</span>&gt;</span>Commander Clement<span class="tag">&lt;/<span class="name">fictional:character</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">actors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>One way to search and explore this <code>XML</code> example is to manually add the <code>URI</code> to every tag or attribute in the xpath of a <code>find()</code> or <code>findall()</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root = fromstring(xml_text)</span><br><span class="line"><span class="keyword">for</span> actor <span class="keyword">in</span> root.findall(<span class="string">'&#123;http://people.example.com&#125;actor'</span>):</span><br><span class="line">    name = actor.find(<span class="string">'&#123;http://people.example.com&#125;name'</span>)</span><br><span class="line">    print(name.text)</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> actor.findall(<span class="string">'&#123;http://characters.example.com&#125;character'</span>):</span><br><span class="line">        print(<span class="string">' |--&gt;'</span>, char.text)</span><br></pre></td></tr></table></figure>
<p>A better way to search the namespaced <code>XML</code> example is to create a dictionary with your own prefixes and use those in the search functions:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ns = &#123;<span class="string">'real_person'</span>: <span class="string">'http://people.example.com'</span>, <span class="string">'role'</span>: <span class="string">'http://characters.example.com'</span>&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> actor <span class="keyword">in</span> root.findall(<span class="string">'real_person:actor'</span>, ns):</span><br><span class="line">    name = actor.find(<span class="string">'real_person:name'</span>, ns)</span><br><span class="line">    print(name.text)</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> actor.findall(<span class="string">'role:character'</span>, ns):</span><br><span class="line">        print(<span class="string">' |--&gt;'</span>, char.text)</span><br></pre></td></tr></table></figure>
<p>These two approaches both output:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">John Cleese</span><br><span class="line"> |--&gt; Lancelot</span><br><span class="line"> |--&gt; Archie Leach</span><br><span class="line">Eric Idle</span><br><span class="line"> |--&gt; Sir Robin</span><br><span class="line"> |--&gt; Gunther</span><br><span class="line"> |--&gt; Commander Clement</span><br></pre></td></tr></table></figure>
<h3 id="XPath-support"><a href="#XPath-support" class="headerlink" title="XPath support"></a>XPath support</h3><p>&emsp;&emsp;This module provides limited support for <code>XPath</code> expressions for locating elements in a tree. The goal is to support a small subset of the abbreviated syntax; a full <code>XPath</code> engine is outside the scope of the module.</p>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>&emsp;&emsp;Here’s an example that demonstrates some of the <code>XPath</code> capabilities of the module. We’ll be using the countrydata <code>XML</code> document from the Parsing <code>XML</code> section:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line">​</span><br><span class="line">root = ET.fromstring(countrydata)</span><br><span class="line">root.findall(<span class="string">"."</span>)  <span class="comment"># Top-level elements</span></span><br><span class="line"><span class="comment"># All 'neighbor' grand-children of 'country' children of the top-level elements</span></span><br><span class="line">root.findall(<span class="string">"./country/neighbor"</span>)</span><br><span class="line"><span class="comment"># Nodes with name='Singapore' that have a 'year' child</span></span><br><span class="line">root.findall(<span class="string">".//year/..[@name='Singapore']"</span>)</span><br><span class="line"><span class="comment"># 'year' nodes that are children of nodes with name='Singapore'</span></span><br><span class="line">root.findall(<span class="string">".//*[@name='Singapore']/year"</span>)</span><br><span class="line"><span class="comment"># All 'neighbor' nodes that are the second child of their parent</span></span><br><span class="line">root.findall(<span class="string">".//neighbor[2]"</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Supported-XPath-syntax"><a href="#Supported-XPath-syntax" class="headerlink" title="Supported XPath syntax"></a>Supported XPath syntax</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tag</code></td>
<td>Selects all child elements with the given <code>tag</code>. For example, <code>spam</code> selects all child elements named <code>spam</code>, and <code>spam/egg</code> selects all grandchildren named <code>egg</code> in all children named <code>spam</code>.</td>
</tr>
<tr>
<td><code>*</code></td>
<td>Selects all child elements. For example, <code>*/egg</code> selects all grandchildren named <code>egg</code>.</td>
</tr>
<tr>
<td><code>.</code></td>
<td>Selects the current node. This is mostly useful at the <code>beginning</code> of the path, to indicate that it’s a relative path.</td>
</tr>
<tr>
<td><code>//</code></td>
<td>Selects all subelements, on all levels beneath the current element. For example, <code>.//egg</code> selects all <code>egg</code> elements in the entire tree.</td>
</tr>
<tr>
<td><code>..</code></td>
<td>Selects the parent element. Returns <code>None</code> if the path attempts to reach the ancestors of the <code>start</code> element (the element find was called on).</td>
</tr>
<tr>
<td><code>[@attrib]</code></td>
<td>Selects all elements that have the given <code>attribute</code>.</td>
</tr>
<tr>
<td><code>[@attrib=&#39;value&#39;]</code></td>
<td>Selects all elements for which the given <code>attribute</code> has the given <code>value</code>. The value cannot contain quotes.</td>
</tr>
<tr>
<td><code>[tag]</code></td>
<td>Selects all elements that have a child named <code>tag</code>. Only immediate children are supported.</td>
</tr>
<tr>
<td><code>[tag=&#39;text&#39;]</code></td>
<td>Selects all elements that have a child named <code>tag</code> whose complete <code>text</code> content, including descendants, equals the given <code>text</code>.</td>
</tr>
<tr>
<td><code>[position]</code></td>
<td>Selects all elements that are located at the given <code>position</code>. The <code>position</code> can be either an <code>integer</code> (<code>1</code> is the <code>first position</code>), the expression <code>last()</code> (for the <code>last position</code>), or a <code>position</code> relative to the <code>last position</code> (e.g. <code>last() - 1</code>).</td>
</tr>
</tbody>
</table>
</div>
<p>Predicates (expressions within square brackets) must be preceded by a tag name, an asterisk, or another predicate. position predicates must be preceded by a tag name.</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><h4 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h4><p>&emsp;&emsp;<code>xml.etree.ElementTree.Comment(text=None)</code>: <code>Comment</code> <code>element</code> factory. This factory function creates a special <code>element</code> that will be serialized as an <code>XML</code> <code>comment</code> by the standard serializer. The <code>comment</code> string can be either a <code>bytestring</code> or a <code>Unicode string</code>. <code>text</code> is a string containing the <code>comment</code> string. Returns an <code>element</code> instance representing a <code>comment</code>.<br>&emsp;&emsp;Note that <code>XMLParser</code> skips over <code>comments</code> in the input instead of creating <code>comment</code> objects for them. An <code>ElementTree</code> will only contain <code>comment</code> nodes if they have been inserted into to the <code>tree</code> using one of the <code>Element</code> methods.<br>&emsp;&emsp;<code>xml.etree.ElementTree.dump(elem)</code>: Writes an <code>element</code> tree or <code>element</code> structure to <code>sys.stdout</code>. This function should be used for debugging only. The exact output format is implementation dependent. In this version, it’s written as an ordinary <code>XML</code> file. <code>elem</code> is an <code>element</code> tree or an individual <code>element</code>.<br>&emsp;&emsp;<code>xml.etree.ElementTree.fromstring(text)</code>: Parses an <code>XML</code> section from a <code>string</code> constant. Same as <code>XML()</code>. <code>text</code> is a <code>string</code> containing <code>XML</code> data. Returns an <code>Element</code> instance.<br>&emsp;&emsp;<code>xml.etree.ElementTree.fromstringlist(sequence, parser=None)</code>: Parses an <code>XML</code> document from a <code>sequence</code> of <code>string</code> fragments. <code>sequence</code> is a list or other <code>sequence</code> containing <code>XML</code> data fragments. <code>parser</code> is an optional <code>parser</code> instance. If not given, the standard <code>XMLParser</code> <code>parser</code> is used. Returns an <code>Element</code> instance.<br>&emsp;&emsp;<code>xml.etree.ElementTree.iselement(element)</code>: Checks if an object appears to be a valid <code>element</code> object. <code>element</code> is an <code>element</code> instance. Returns a <code>true</code> value if this is an <code>element</code> object.<br>&emsp;&emsp;<code>xml.etree.ElementTree.iterparse(source, events=None, parser=None)</code>: Parses an <code>XML</code> section into an <code>element tree</code> incrementally, and reports what’s going on to the user. <code>source</code> is a filename or file object containing <code>XML</code> data. <code>events</code> is a sequence of <code>events</code> to report back. The supported <code>events</code> are the strings <code>start</code>, <code>end</code>, <code>start-ns</code> and <code>end-ns</code> (the <code>ns</code> events are used to get detailed namespace information). If <code>events</code> is omitted, only <code>end events</code> are reported. <code>parser</code> is an optional <code>parser</code> instance. If not given, the standard <code>XMLParser</code> parser is used. <code>parser</code> must be a subclass of <code>XMLParser</code> and can only use the default <code>TreeBuilder</code> as a target. Returns an iterator providing <code>(event, elem)</code> pairs.<br>&emsp;&emsp;Note that while <code>iterparse()</code> builds the <code>tree</code> incrementally, it issues blocking reads on source (or the file it names). As such, it’s unsuitable for applications where blocking reads can’t be made. For fully <code>non-blocking</code> parsing, see <code>XMLPullParser</code>.<br>&emsp;&emsp;<strong>Note</strong>: <code>iterparse()</code> only guarantees that it has seen the <code>&gt;</code> character of a starting tag when it emits a <code>start</code> event, so the attributes are defined, but the contents of the <code>text</code> and <code>tail</code> attributes are undefined at that point. The same applies to the <code>element</code> children; they may or may not be present. If you need a fully populated <code>element</code>, look for <code>end</code> events instead.<br>&emsp;&emsp;<code>xml.etree.ElementTree.parse(source, parser=None)</code>: Parses an <code>XML</code> section into an <code>element</code> tree. <code>source</code> is a filename or file object containing <code>XML</code> data. <code>parser</code> is an optional <code>parser</code> instance. If not given, the standard <code>XMLParser</code> parser is used. Returns an <code>ElementTree</code> instance.<br>&emsp;&emsp;<code>xml.etree.ElementTree.ProcessingInstruction(target, text=None)</code>: <code>PI</code> element factory. This factory function creates a special <code>element</code> that will be serialized as an <code>XML</code> processing instruction. <code>target</code> is a string containing the <code>PI</code> target. <code>text</code> is a string containing the <code>PI</code> contents, if given. Returns an <code>element</code> instance, representing a processing instruction.<br>&emsp;&emsp;Note that XMLParser skips over processing instructions in the input instead of creating comment objects for them. An ElementTree will only contain processing instruction nodes if they have been inserted into to the tree using one of the Element methods.<br>&emsp;&emsp;<code>xml.etree.ElementTree.register_namespace(prefix, uri)</code>: Registers a <code>namespace prefix</code>. The <code>registry</code> is global, and any existing mapping for either the given <code>prefix</code> or the <code>namespace URI</code> will be removed. <code>prefix</code> is a <code>namespace prefix</code>. <code>uri</code> is a <code>namespace uri</code>. Tags and attributes in this <code>namespace</code> will be serialized with the given <code>prefix</code>, if at all possible.<br>&emsp;&emsp;<code>xml.etree.ElementTree.SubElement(parent, tag, attrib={}, **extra)</code>: <code>Subelement</code> factory. This function creates an <code>element</code> instance, and appends it to an existing <code>element</code>.<br>&emsp;&emsp;The <code>element</code> name, attribute names, and attribute values can be either <code>bytestrings</code> or <code>Unicode strings</code>. <code>parent</code> is the <code>parent</code> element. <code>tag</code> is the subelement name. <code>attrib</code> is an optional dictionary, containing <code>element</code> attributes. <code>extra</code> contains additional attributes, given as keyword arguments. Returns an <code>element</code> instance.<br>&emsp;&emsp;<code>xml.etree.ElementTree.tostring(element, encoding=&quot;us-ascii&quot;, method=&quot;xml&quot;, *, short_empty_elements=True)</code>: Generates a <code>string</code> representation of an <code>XML</code> element, including all subelements. <code>element</code> is an <code>Element</code> instance. <code>encoding</code> is the output <code>encoding</code> (default is <code>US-ASCII</code>). Use <code>encoding=&quot;unicode&quot;</code> to generate a <code>Unicode string</code> (otherwise, a <code>bytestring</code> is generated). <code>method</code> is either <code>xml</code>, <code>html</code> or <code>text</code> (default is <code>xml</code>). <code>short_empty_elements</code> has the same meaning as in <code>ElementTree.write()</code>. Returns an (optionally) <code>encoded string</code> containing the <code>XML</code> data.<br>&emsp;&emsp;<code>xml.etree.ElementTree.tostringlist(element, encoding=&quot;us-ascii&quot;, method=&quot;xml&quot;, *, short_empty_elements=True)</code>: Generates a <code>string</code> representation of an <code>XML</code> element, including all subelements. <code>element</code> is an <code>Element</code> instance. <code>encoding</code> is the output <code>encoding</code> (default is <code>US-ASCII</code>). Use <code>encoding=&quot;unicode&quot;</code> to generate a <code>Unicode string</code> (otherwise, a <code>bytestring</code> is <code>generated</code>). <code>method</code> is either <code>xml</code>, <code>html</code> or <code>text</code> (default is <code>xml</code>). <code>short_empty_elements</code> has the same meaning as in <code>ElementTree.write()</code>. Returns a list of (optionally) <code>encoded strings</code> containing the <code>XML</code> data. It does not guarantee any specific sequence, except that <code>b&quot;&quot;.join(tostringlist(element)) == tostring(element)</code>.<br>&emsp;&emsp;<code>xml.etree.ElementTree.XML(text, parser=None)</code>: Parses an <code>XML</code> section from a string constant. This function can be used to embed <code>XML literals</code> in Python code. <code>text</code> is a string containing <code>XML</code> data. <code>parser</code> is an optional <code>parser</code> instance. If not given, the standard <code>XMLParser</code> parser is used. Returns an <code>Element</code> instance.<br>&emsp;&emsp;<code>xml.etree.ElementTree.XMLID(text, parser=None)</code>: Parses an <code>XML</code> section from a string constant, and also returns a <code>dictionary</code> which maps from element <code>id:s</code> to elements. <code>text</code> is a string containing <code>XML</code> data. <code>parser</code> is an optional <code>parser</code> instance. If not given, the standard <code>XMLParser</code> parser is used. Returns a <code>tuple</code> containing an <code>Element</code> instance and a <code>dictionary</code>.</p>
<h3 id="Element-Objects"><a href="#Element-Objects" class="headerlink" title="Element Objects"></a>Element Objects</h3><h4 id="class-xml-etree-ElementTree-Element-tag-attrib-extra"><a href="#class-xml-etree-ElementTree-Element-tag-attrib-extra" class="headerlink" title="class xml.etree.ElementTree.Element(tag, attrib={}, **extra)"></a>class xml.etree.ElementTree.Element(tag, attrib={}, **extra)</h4><p>&emsp;&emsp;Element <code>class</code>. This <code>class</code> defines the <code>Element</code> interface, and provides a reference implementation of this interface.<br>&emsp;&emsp;The <code>element name</code>, <code>attribute names</code>, and <code>attribute values</code> can be either <code>bytestrings</code> or <code>Unicode strings</code>. <code>tag</code> is the element name. <code>attrib</code> is an optional <code>dictionary</code>, containing <code>element</code> attributes. <code>extra</code> contains additional attributes, given as keyword arguments.<br>&emsp;&emsp;<code>tag</code>: A <code>string</code> identifying what kind of data this <code>element</code> represents (the <code>element</code> type, in other words).<br>&emsp;&emsp;<code>tail</code>: These attributes can be used to hold additional data associated with the <code>element</code>. Their values are usually strings but may be any <code>application-specific</code> object. If the <code>element</code> is created from an <code>XML</code> file, the text attribute holds either the text between the element’s <code>start tag</code> and its first child or <code>end tag</code>, or <code>None</code>, and the <code>tail</code> attribute holds either the text between the element’s <code>end tag</code> and the <code>next tag</code>, or <code>None</code>. For the <code>XML</code> data</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>1<span class="tag">&lt;<span class="name">c</span>&gt;</span>2<span class="tag">&lt;<span class="name">d</span>/&gt;</span>3<span class="tag">&lt;/<span class="name">c</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span>4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>the <code>a</code> element has <code>None</code> for both text and tail attributes, the <code>b</code> element has text <code>1</code> and tail <code>4</code>, the <code>c</code> element has text <code>2</code> and tail <code>None</code>, and the <code>d</code> element has text <code>None</code> and tail <code>3</code>.<br>&emsp;&emsp;To collect the inner text of an element, see <code>itertext()</code>, for example <code>&quot;&quot;.join(element.itertext())</code>.<br>&emsp;&emsp;<code>attrib</code>: A <code>dictionary</code> containing the element’s attributes. Note that while the <code>attrib</code> value is always a real mutable <code>Python dictionary</code>, an <code>ElementTree</code> implementation may choose to use another internal representation, and create the <code>dictionary</code> only if someone asks for it. To take advantage of such implementations, use the <code>dictionary</code> methods below whenever possible.<br>&emsp;&emsp;The following <code>dictionary-like</code> methods work on the element attributes.<br>&emsp;&emsp;<code>clear()</code>: Resets an <code>element</code>. This function removes all subelements, <code>clears</code> all attributes, and sets the text and tail attributes to <code>None</code>.<br>&emsp;&emsp;<code>get(key, default=None)</code>: Gets the <code>element</code> attribute named <code>key</code>. Returns the attribute value, or default if the attribute was not found.<br>&emsp;&emsp;<code>items()</code>: Returns the <code>element</code> attributes as a sequence of <code>(name, value)</code> pairs. The attributes are returned in an arbitrary order.<br>&emsp;&emsp;<code>keys()</code>: Returns the <code>elements</code> attribute names as a list. The names are returned in an arbitrary order.<br>&emsp;&emsp;<code>set(key, value)</code>: Set the attribute <code>key</code> on the element to <code>value</code>.<br>&emsp;&emsp;The following methods work on the element’s children (<code>subelements</code>).<br>&emsp;&emsp;<code>append(subelement)</code>: Adds the element <code>subelement</code> to the end of this element’s internal list of <code>subelements</code>. Raises <code>TypeError</code> if <code>subelement</code> is not an <code>Element</code>.<br>&emsp;&emsp;<code>extend(subelements)</code>: Appends <code>subelements</code> from a sequence object with zero or more <code>elements</code>. Raises <code>TypeError</code> if a <code>subelement</code> is not an <code>Element</code>.<br>&emsp;&emsp;<code>find(match, namespaces=None)</code>: Finds the first subelement matching <code>match</code>. <code>match</code> may be a tag name or a path. Returns an <code>element</code> instance or <code>None</code>. <code>namespaces</code> is an optional mapping from <code>namespace prefix</code> to full name.<br>&emsp;&emsp;<code>findall(match, namespaces=None)</code>: Finds all matching subelements, by tag name or path. Returns a list containing all matching elements in document order. <code>namespaces</code> is an optional mapping from <code>namespace prefix</code> to full name.<br>&emsp;&emsp;<code>findtext(match, default=None, namespaces=None)</code>: Finds text for the first subelement matching <code>match</code>. <code>match</code> may be a tag name or a path. Returns the <code>text</code> content of the first matching <code>element</code>, or <code>default</code> if no <code>element</code> was found. Note that if the matching <code>element</code> has no <code>text</code> content an empty string is returned. <code>namespaces</code> is an optional mapping from <code>namespace prefix</code> to full name.<br>&emsp;&emsp;<code>getchildren()</code>: Deprecated since version <code>3.2</code>: Use <code>list(elem)</code> or <code>iteration</code>.<br>&emsp;&emsp;<code>getiterator(tag=None)</code>: Deprecated since version <code>3.2</code>: Use method <code>Element.iter()</code> instead.<br>&emsp;&emsp;<code>insert(index, subelement)</code>: Inserts <code>subelement</code> at the given position in this <code>element</code>. Raises <code>TypeError</code> if <code>subelement</code> is not an <code>Element</code>.<br>&emsp;&emsp;<code>iter(tag=None)</code>: Creates a tree <code>iterator</code> with the current <code>element</code> as the <code>root</code>. The <code>iterator</code> iterates over this <code>element</code> and all <code>elements</code> below it, in document <code>(depth first)</code> order. If <code>tag</code> is not <code>None</code> or <code>*</code>, only <code>elements</code> whose <code>tag</code> equals <code>tag</code> are returned from the <code>iterator</code>. If the tree structure is modified during iteration, the result is undefined.<br>&emsp;&emsp;<code>iterfind(match, namespaces=None)</code>: Finds all matching subelements, by tag name or path. Returns an iterable yielding all matching <code>elements</code> in document order. <code>namespaces</code> is an optional mapping from <code>namespace prefix</code> to full name.<br>&emsp;&emsp;<code>itertext()</code>: Creates a text <code>iterator</code>. The <code>iterator</code> loops over this <code>element</code> and all subelements, in document order, and returns all inner <code>text</code>.<br>&emsp;&emsp;<code>makeelement(tag, attrib)</code>: Creates a new <code>element</code> object of the same type as this <code>element</code>. Do not call this method, use the <code>SubElement()</code> factory function instead.<br>&emsp;&emsp;<code>remove(subelement)</code>: Removes <code>subelement</code> from the <code>element</code>. Unlike the <code>find*</code> methods, this method compares elements based on the instance identity, not on tag value or contents.<br>&emsp;&emsp;Element objects also support the following sequence type methods for working with subelements: <code>__delitem__()</code>, <code>__getitem__()</code>, <code>__setitem__()</code>, <code>__len__()</code>.<br>&emsp;&emsp;<strong>Caution</strong>: Elements with no subelements will test as <code>False</code>. This behavior will change in future versions. Use specific <code>len(elem)</code> or elem is <code>None</code> test instead.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">element = root.find(<span class="string">'foo'</span>)</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> element:  <span class="comment"># careful!</span></span><br><span class="line">    print(<span class="string">"element not found, or element has no subelements"</span>)</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> element <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    print(<span class="string">"element not found"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="ElementTree-Objects"><a href="#ElementTree-Objects" class="headerlink" title="ElementTree Objects"></a>ElementTree Objects</h3><h4 id="class-xml-etree-ElementTree-ElementTree-element-None-file-None"><a href="#class-xml-etree-ElementTree-ElementTree-element-None-file-None" class="headerlink" title="class xml.etree.ElementTree.ElementTree(element=None, file=None)"></a>class xml.etree.ElementTree.ElementTree(element=None, file=None)</h4><p>&emsp;&emsp;<code>ElementTree</code> wrapper class. This class represents an entire <code>element</code> hierarchy, and adds some extra support for serialization to and from standard <code>XML</code>.<br>&emsp;&emsp;<code>element</code> is the <code>root element</code>. The <code>tree</code> is initialized with the contents of the <code>XML</code> file if given.<br>&emsp;&emsp;<code>_setroot(element)</code>: Replaces the <code>root element</code> for this tree. This discards the current contents of the tree, and replaces it with the given <code>element</code>. Use with care. <code>element</code> is an <code>element</code> instance.<br>&emsp;&emsp;<code>find(match, namespaces=None)</code>: Same as <code>Element.find()</code>, starting at the root of the tree.<br>&emsp;&emsp;<code>findall(match, namespaces=None)</code>: Same as <code>Element.findall()</code>, starting at the root of the tree.<br>&emsp;&emsp;<code>findtext(match, default=None, namespaces=None)</code>: Same as <code>Element.findtext()</code>, starting at the root of the tree.<br>&emsp;&emsp;<code>getiterator(tag=None)</code>: Deprecated since version <code>3.2</code>: Use method <code>ElementTree.iter()</code> instead.<br>&emsp;&emsp;<code>getroot()</code>: Returns the <code>root element</code> for this tree.<br>&emsp;&emsp;<code>iter(tag=None)</code>: Creates and returns a tree <code>iterator</code> for the <code>root element</code>. The <code>iterator</code> loops over all elements in this tree, in section order. <code>tag</code> is the <code>tag</code> to look for (default is to return all elements).<br>&emsp;&emsp;<code>iterfind(match, namespaces=None)</code>: Same as <code>Element.iterfind()</code>, starting at the root of the tree.<br>&emsp;&emsp;<code>parse(source, parser=None)</code>: Loads an external <code>XML</code> section into this <code>element</code> tree. <code>source</code> is a file name or file object. <code>parser</code> is an optional <code>parser</code> instance. If not given, the standard <code>XMLParser</code> parser is used. Returns the section <code>root element</code>.<br>&emsp;&emsp;<code>write(file, encoding=&quot;us-ascii&quot;, xml_declaration=None, default_namespace=None, method=&quot;xml&quot;, *, short_empty_elements=True)</code>: Writes the element tree to a file, as <code>XML</code>. <code>file</code> is a <code>file name</code>, or a <code>file object</code> opened for writing. <code>encoding</code> is the output <code>encoding</code> (default is <code>US-ASCII</code>). <code>xml_declaration</code> controls if an <code>XML</code> declaration should be added to the <code>file</code>. Use False for never, <code>True</code> for always, <code>None</code> for only if not <code>US-ASCII</code> or <code>UTF-8</code> or <code>Unicode</code> (default is <code>None</code>). <code>default_namespace</code> sets the default <code>XML</code> namespace (for <code>xmlns</code>). <code>method</code> is either <code>xml</code>, <code>html</code> or <code>text</code> (default is <code>xml</code>). The <code>keyword-only</code> <code>short_empty_elements</code> parameter controls the formatting of elements that contain no content. If <code>True</code> (the default), they are emitted as a single <code>self-closed</code> tag, otherwise they are emitted as a pair of start/end tags.<br>&emsp;&emsp;The output is either a <code>string</code> (<code>str</code>) or <code>binary</code> (<code>bytes</code>). This is controlled by the encoding argument. If encoding is <code>unicode</code>, the output is a <code>string</code>; otherwise, it’s <code>binary</code>. Note that this may conflict with the type of file if it’s an open file object; make sure you do not try to write a <code>string</code> to a <code>binary</code> stream and vice versa.<br>&emsp;&emsp;This is the <code>XML</code> file that is going to be manipulated:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Moved to <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://example.org/"</span>&gt;</span>example.org<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        or <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://example.com/"</span>&gt;</span>example.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Example of changing the attribute <code>target</code> of every link in first paragraph:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> xml.etree.ElementTree <span class="keyword">import</span> ElementTree</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree = ElementTree()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree.parse(<span class="string">"index.xhtml"</span>)</span><br><span class="line">&lt;Element <span class="string">'html'</span> at <span class="number">0xb77e6fac</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = tree.find(<span class="string">"body/p"</span>)  <span class="comment"># Finds first occurrence of tag p in body</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p</span><br><span class="line">&lt;Element <span class="string">'p'</span> at <span class="number">0xb77ec26c</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>links = list(p.iter(<span class="string">"a"</span>))  <span class="comment"># Returns list of all links</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>links</span><br><span class="line">[&lt;Element <span class="string">'a'</span> at <span class="number">0xb77ec2ac</span>&gt;, &lt;Element <span class="string">'a'</span> at <span class="number">0xb77ec1cc</span>&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> links:  <span class="comment"># Iterates through all found links</span></span><br><span class="line"><span class="meta">... </span>    i.attrib[<span class="string">"target"</span>] = <span class="string">"blank"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree.write(<span class="string">"output.xhtml"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="QName-Objects"><a href="#QName-Objects" class="headerlink" title="QName Objects"></a>QName Objects</h3><h4 id="class-xml-etree-ElementTree-QName-text-or-uri-tag-None"><a href="#class-xml-etree-ElementTree-QName-text-or-uri-tag-None" class="headerlink" title="class xml.etree.ElementTree.QName(text_or_uri, tag=None)"></a>class xml.etree.ElementTree.QName(text_or_uri, tag=None)</h4><p>&emsp;&emsp;<code>QName</code> wrapper. This can be used to wrap a <code>QName</code> attribute value, in order to get proper namespace handling on output. <code>text_or_uri</code> is a string containing the <code>QName</code> value, in the form <code>{uri}local</code>, or, if the <code>tag</code> argument is given, the <code>URI</code> part of a <code>QName</code>. If <code>tag</code> is given, the first argument is interpreted as a <code>URI</code>, and this argument is interpreted as a local name. <code>QName</code> instances are opaque.</p>
<h3 id="TreeBuilder-Objects"><a href="#TreeBuilder-Objects" class="headerlink" title="TreeBuilder Objects"></a>TreeBuilder Objects</h3><h4 id="class-xml-etree-ElementTree-TreeBuilder-element-factory-None"><a href="#class-xml-etree-ElementTree-TreeBuilder-element-factory-None" class="headerlink" title="class xml.etree.ElementTree.TreeBuilder(element_factory=None)"></a>class xml.etree.ElementTree.TreeBuilder(element_factory=None)</h4><p>&emsp;&emsp;Generic <code>element</code> structure <code>builder</code>. This builder converts a sequence of start, data, and end method calls to a <code>well-formed</code> element structure. You can use this class to build an <code>element</code> structure using a custom <code>XML</code> parser, or a parser for some other <code>XML-like</code> format. <code>element_factory</code>, when given, must be a callable accepting two positional arguments: a <code>tag</code> and a <code>dict</code> of attributes. It is expected to return a new <code>element</code> instance.<br>&emsp;&emsp;<code>close()</code>: Flushes the builder buffers, and returns the toplevel document <code>element</code>. Returns an <code>Element</code> instance.<br>&emsp;&emsp;<code>data(data)</code>: Adds text to the current <code>element</code>. <code>data</code> is a string. This should be either a <code>bytestring</code>, or a <code>Unicode</code> string.<br>&emsp;&emsp;<code>end(tag)</code>: Closes the current <code>element</code>. <code>tag</code> is the <code>element</code> name. Returns the closed element.<br>&emsp;&emsp;<code>start(tag, attrs)</code>: Opens a new <code>element</code>. <code>tag</code> is the <code>element</code> name. <code>attrs</code> is a dictionary containing <code>element</code> attributes. Returns the opened <code>element</code>.<br>&emsp;&emsp;In addition, a custom <code>TreeBuilder</code> object can provide the following method:<br>&emsp;&emsp;<code>doctype(name, pubid, system)</code>: Handles a <code>doctype</code> declaration. <code>name</code> is the <code>doctype</code> name. <code>pubid</code> is the <code>public</code> identifier. <code>system</code> is the <code>system</code> identifier. This method does not exist on the default <code>TreeBuilder</code> class.</p>
<h3 id="XMLParser-Objects"><a href="#XMLParser-Objects" class="headerlink" title="XMLParser Objects"></a>XMLParser Objects</h3><h4 id="class-xml-etree-ElementTree-XMLParser-html-0-target-None-encoding-None"><a href="#class-xml-etree-ElementTree-XMLParser-html-0-target-None-encoding-None" class="headerlink" title="class xml.etree.ElementTree.XMLParser(html=0, target=None, encoding=None)"></a>class xml.etree.ElementTree.XMLParser(html=0, target=None, encoding=None)</h4><p>&emsp;&emsp;This class is the <code>low-level</code> building block of the module. It uses <code>xml.parsers.expat</code> for efficient, <code>event-based</code> parsing of <code>XML</code>. It can be fed <code>XML</code> data incrementally with the <code>feed()</code> method, and parsing events are translated to a push <code>API</code> - by invoking callbacks on the <code>target</code> object. If <code>target</code> is omitted, the standard <code>TreeBuilder</code> is used. The html argument was historically used for backwards compatibility and is now deprecated. If <code>encoding</code> is given, the value overrides the <code>encoding</code> specified in the <code>XML</code> file.<br>&emsp;&emsp;Deprecated since version <code>3.4</code>: The html argument. The remaining arguments should be passed via keyword to prepare for the removal of the html argument.<br>&emsp;&emsp;<code>close()</code>: Finishes feeding data to the <code>parser</code>. Returns the result of calling the <code>close()</code> method of the <code>target</code> passed during construction; by default, this is the toplevel document element.<br>&emsp;&emsp;<code>doctype(name, pubid, system)</code>: Deprecated since version <code>3.2</code>: Define the <code>TreeBuilder.doctype()</code> method on a custom <code>TreeBuilder</code> target.<br>&emsp;&emsp;<code>feed(data)</code>: Feeds <code>data</code> to the <code>parser</code>. <code>data</code> is encoded <code>data</code>.<br>&emsp;&emsp;<code>XMLParser.feed()</code> calls target’s <code>start(tag, attrs_dict)</code> method for each opening tag, its <code>end(tag)</code> method for each closing tag, and data is processed by method <code>data(data)</code>. <code>XMLParser.close()</code> calls target’s method <code>close()</code>. <code>XMLParser</code> can be used not only for building a tree structure. This is an example of counting the maximum depth of an <code>XML</code> file:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> xml.etree.ElementTree <span class="keyword">import</span> XMLParser</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MaxDepth</span>:</span>  <span class="comment"># The target object of the parser</span></span><br><span class="line"><span class="meta">... </span>    maxDepth = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    depth = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self, tag, attrib)</span>:</span>  <span class="comment"># Called for each opening tag.</span></span><br><span class="line"><span class="meta">... </span>        self.depth += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> self.depth &gt; self.maxDepth:</span><br><span class="line"><span class="meta">... </span>            self.maxDepth = self.depth</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">end</span><span class="params">(self, tag)</span>:</span>  <span class="comment"># Called for each closing tag.</span></span><br><span class="line"><span class="meta">... </span>        self.depth -= <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">data</span><span class="params">(self, data)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">pass</span>  <span class="comment"># We do not need to do anything with data.</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span>  <span class="comment"># Called when all data has been parsed.</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.maxDepth</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target = MaxDepth()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = XMLParser(target=target)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exampleXml = <span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;a&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  &lt;b&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  &lt;/b&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  &lt;b&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;c&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>      &lt;d&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>      &lt;/d&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;/c&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  &lt;/b&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;/a&gt;"""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(exampleXml)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.close()</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="XMLPullParser-Objects"><a href="#XMLPullParser-Objects" class="headerlink" title="XMLPullParser Objects"></a>XMLPullParser Objects</h3><h4 id="class-xml-etree-ElementTree-XMLPullParser-events-None"><a href="#class-xml-etree-ElementTree-XMLPullParser-events-None" class="headerlink" title="class xml.etree.ElementTree.XMLPullParser(events=None)"></a>class xml.etree.ElementTree.XMLPullParser(events=None)</h4><p>&emsp;&emsp;A <code>pull parser</code> suitable for <code>non-blocking</code> applications. Its <code>input-side API</code> is similar to that of <code>XMLParser</code>, but instead of pushing calls to a callback target, <code>XMLPullParser</code> collects an internal list of parsing <code>events</code> and lets the user read from it. <code>events</code> is a sequence of <code>events</code> to report back. The supported <code>events</code> are the strings <code>start</code>, <code>end</code>, <code>start-ns</code> and <code>end-ns</code> (the <code>ns</code> events are used to get detailed namespace information). If <code>events</code> is omitted, only <code>end</code> events are reported.<br>&emsp;&emsp;<code>feed(data)</code>: Feed the given <code>bytes data</code> to the <code>parser</code>.<br>&emsp;&emsp;<code>close()</code>: Signal the <code>parser</code> that the data stream is terminated. Unlike <code>XMLParser.close()</code>, this method always returns <code>None</code>. Any events not yet retrieved when the <code>parser</code> is closed can still be read with <code>read_events()</code>.<br>&emsp;&emsp;<code>read_events()</code>: Return an iterator over the <code>events</code> which have been encountered in the data fed to the <code>parser</code>. The iterator yields <code>(event, elem)</code> pairs, where <code>event</code> is a string representing the type of <code>event</code> (e.g. <code>end</code>) and <code>elem</code> is the encountered <code>Element</code> object.<br>&emsp;&emsp;<code>Events</code> provided in a previous call to <code>read_events()</code> will not be yielded again. <code>Events</code> are consumed from the internal queue only when they are retrieved from the iterator, so multiple readers iterating in parallel over iterators obtained from <code>read_events()</code> will have unpredictable results.<br>&emsp;&emsp;<strong>Note</strong>: <code>XMLPullParser</code> only guarantees that it has seen the <code>&gt;</code> character of a starting tag when it emits a <code>start</code> event, so the attributes are defined, but the contents of the text and tail attributes are undefined at that point. The same applies to the <code>element</code> children; they may or may not be present. If you need a fully populated <code>element</code>, look for <code>end</code> events instead.</p>
<h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><h4 id="class-xml-etree-ElementTree-ParseError"><a href="#class-xml-etree-ElementTree-ParseError" class="headerlink" title="class xml.etree.ElementTree.ParseError"></a>class xml.etree.ElementTree.ParseError</h4><p>&emsp;&emsp;<code>XML</code> parse error, raised by the various parsing methods in this module when parsing fails. The string representation of an instance of this exception will contain a <code>user-friendly</code> error message. In addition, it will have the following <code>attributes</code> available:<br>&emsp;&emsp;<code>code</code>: A numeric error <code>code</code> from the expat <code>parser</code>. See the documentation of <code>xml.parsers.expat</code> for the list of error codes and their meanings.<br>&emsp;&emsp;<code>position</code>: A tuple of line, column numbers, specifying where the error occurred.</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/12/Python语法/sqlite3模块/" rel="next" title="sqlite3模块">
                <i class="fa fa-chevron-left"></i> sqlite3模块
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/13/软件与硬件问题/Python环境搭建/" rel="prev" title="Python环境搭建">
                Python环境搭建 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">939</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是XML？"><span class="nav-number">1.</span> <span class="nav-text">什么是XML？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python对XML的解析"><span class="nav-number">2.</span> <span class="nav-text">python对XML的解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python使用SAX解析xml"><span class="nav-number">3.</span> <span class="nav-text">python使用SAX解析xml</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ContentHandler类方法介绍"><span class="nav-number">3.1.</span> <span class="nav-text">ContentHandler类方法介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#make-parser方法"><span class="nav-number">3.2.</span> <span class="nav-text">make_parser方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#parser方法"><span class="nav-number">3.3.</span> <span class="nav-text">parser方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#parseString方法"><span class="nav-number">3.4.</span> <span class="nav-text">parseString方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python解析XML实例"><span class="nav-number">4.</span> <span class="nav-text">Python解析XML实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用xml-dom解析xml"><span class="nav-number">5.</span> <span class="nav-text">使用xml.dom解析xml</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#xml-etree-ElementTree-—-The-ElementTree-XML-API"><span class="nav-number">6.</span> <span class="nav-text">xml.etree.ElementTree — The ElementTree XML API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tutorial"><span class="nav-number">7.</span> <span class="nav-text">Tutorial</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#XML-tree-and-elements"><span class="nav-number">7.1.</span> <span class="nav-text">XML tree and elements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parsing-XML"><span class="nav-number">7.2.</span> <span class="nav-text">Parsing XML</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pull-API-for-non-blocking-parsing"><span class="nav-number">7.3.</span> <span class="nav-text">Pull API for non-blocking parsing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Finding-interesting-elements"><span class="nav-number">7.4.</span> <span class="nav-text">Finding interesting elements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Modifying-an-XML-File"><span class="nav-number">7.5.</span> <span class="nav-text">Modifying an XML File</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Building-XML-documents"><span class="nav-number">7.6.</span> <span class="nav-text">Building XML documents</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parsing-XML-with-Namespaces"><span class="nav-number">7.7.</span> <span class="nav-text">Parsing XML with Namespaces</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XPath-support"><span class="nav-number">8.</span> <span class="nav-text">XPath support</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Example"><span class="nav-number">8.1.</span> <span class="nav-text">Example</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Supported-XPath-syntax"><span class="nav-number">8.2.</span> <span class="nav-text">Supported XPath syntax</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reference"><span class="nav-number">9.</span> <span class="nav-text">Reference</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Functions"><span class="nav-number">9.1.</span> <span class="nav-text">Functions</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-Objects"><span class="nav-number">10.</span> <span class="nav-text">Element Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#class-xml-etree-ElementTree-Element-tag-attrib-extra"><span class="nav-number">10.1.</span> <span class="nav-text">class xml.etree.ElementTree.Element(tag, attrib={}, **extra)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ElementTree-Objects"><span class="nav-number">11.</span> <span class="nav-text">ElementTree Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#class-xml-etree-ElementTree-ElementTree-element-None-file-None"><span class="nav-number">11.1.</span> <span class="nav-text">class xml.etree.ElementTree.ElementTree(element=None, file=None)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QName-Objects"><span class="nav-number">12.</span> <span class="nav-text">QName Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#class-xml-etree-ElementTree-QName-text-or-uri-tag-None"><span class="nav-number">12.1.</span> <span class="nav-text">class xml.etree.ElementTree.QName(text_or_uri, tag=None)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeBuilder-Objects"><span class="nav-number">13.</span> <span class="nav-text">TreeBuilder Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#class-xml-etree-ElementTree-TreeBuilder-element-factory-None"><span class="nav-number">13.1.</span> <span class="nav-text">class xml.etree.ElementTree.TreeBuilder(element_factory=None)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XMLParser-Objects"><span class="nav-number">14.</span> <span class="nav-text">XMLParser Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#class-xml-etree-ElementTree-XMLParser-html-0-target-None-encoding-None"><span class="nav-number">14.1.</span> <span class="nav-text">class xml.etree.ElementTree.XMLParser(html=0, target=None, encoding=None)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XMLPullParser-Objects"><span class="nav-number">15.</span> <span class="nav-text">XMLPullParser Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#class-xml-etree-ElementTree-XMLPullParser-events-None"><span class="nav-number">15.1.</span> <span class="nav-text">class xml.etree.ElementTree.XMLPullParser(events=None)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exceptions"><span class="nav-number">16.</span> <span class="nav-text">Exceptions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#class-xml-etree-ElementTree-ParseError"><span class="nav-number">16.1.</span> <span class="nav-text">class xml.etree.ElementTree.ParseError</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
