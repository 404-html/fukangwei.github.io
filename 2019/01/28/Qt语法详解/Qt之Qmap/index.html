<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="&amp;emsp;&amp;emsp;The QMap class is a template class that provides a skip-list-based dictionary.     Header Inherited By     QMap QMultiMap     Note: All functions in this class are reentrant. Public Functi">
<meta property="og:type" content="article">
<meta property="og:title" content="Qt之Qmap">
<meta property="og:url" content="http://fukangwei.gitee.io/2019/01/28/Qt语法详解/Qt之Qmap/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:description" content="&amp;emsp;&amp;emsp;The QMap class is a template class that provides a skip-list-based dictionary.     Header Inherited By     QMap QMultiMap     Note: All functions in this class are reentrant. Public Functi">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-01-28T09:24:17.321Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Qt之Qmap">
<meta name="twitter:description" content="&amp;emsp;&amp;emsp;The QMap class is a template class that provides a skip-list-based dictionary.     Header Inherited By     QMap QMultiMap     Note: All functions in this class are reentrant. Public Functi">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/2019/01/28/Qt语法详解/Qt之Qmap/">





  <title>Qt之Qmap | 泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/28/Qt语法详解/Qt之Qmap/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Qt之Qmap</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-28T10:46:17+08:00">
                2019-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&emsp;&emsp;The <code>QMap</code> class is a template class that provides a <code>skip-list-based</code> dictionary.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QMap</code></td>
<td><code>QMultiMap</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QMap()</code></td>
</tr>
<tr>
<td></td>
<td><code>QMap(const QMap&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td></td>
<td><code>QMap(const std::map&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QMap()</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>begin()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constBegin() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constEnd() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constFind(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>contains(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>empty() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>end()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator pos)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>find(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>find(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insert(const Key &amp; key, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insertMulti(const Key &amp; key, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>const Key</code></td>
<td><code>key(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>const Key</code></td>
<td><code>key(const T &amp; value, const Key &amp; defaultKey) const</code></td>
</tr>
<tr>
<td><code>QList&lt;Key&gt;</code></td>
<td><code>keys() const</code></td>
</tr>
<tr>
<td><code>QList&lt;Key&gt;</code></td>
<td><code>keys(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>lowerBound(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>lowerBound(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>remove(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(QMap&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>take(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>std::map&lt;Key, T&gt;</code></td>
<td><code>toStdMap() const</code></td>
</tr>
<tr>
<td><code>QList&lt;Key&gt;</code></td>
<td><code>uniqueKeys() const</code></td>
</tr>
<tr>
<td><code>QMap&lt;Key, T&gt; &amp;</code></td>
<td><code>unite(const QMap&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>upperBound(const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>upperBound(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>const T</code></td>
<td><code>value(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>const T</code></td>
<td><code>value(const Key &amp; key, const T &amp; defaultValue) const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>values() const</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>values(const Key &amp; key) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QMap&lt;Key, T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QMap&lt;Key, T&gt; &amp;</code></td>
<td><code>operator=(const QMap&lt;Key, T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QMap&lt;Key, T&gt; &amp;</code></td>
<td><code>operator=(QMap&lt;Key, T&gt; &amp;&amp; other)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QMap&lt;Key, T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>operator[](const Key &amp; key)</code></td>
</tr>
<tr>
<td><code>const T</code></td>
<td><code>operator[](const Key &amp; key) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QDataStream</code></td>
<td><code>&amp;operator&lt;&lt; ( QDataStream &amp;out, const QMap&lt;Key, T&gt; &amp;map );</code></td>
</tr>
<tr>
<td><code>QDataStream</code></td>
<td><code>&amp;operator&gt;&gt; ( QDataStream &amp;in, QMap&lt;Key, T&gt; &amp;map );</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QMap</code> class is a template class that provides a <code>skip-list-based</code> dictionary.<br>&emsp;&emsp;<code>QMap&lt;Key, T&gt;</code> is one of <code>Qt&#39;s</code> generic container classes. It stores <code>(key, value)</code> pairs and provides fast lookup of the value associated with a key.<br>&emsp;&emsp;<code>QMap</code> and <code>QHash</code> provide very similar functionality. The differences are:</p>
<ul>
<li><code>QHash</code> provides faster lookups than <code>QMap</code>.</li>
<li>When iterating over a <code>QHash</code>, the items are arbitrarily ordered. With <code>QMap</code>, the items are always sorted by key.</li>
<li>The key type of a <code>QHash</code> must provide <code>operator==()</code> and a global <code>qHash(Key)</code> function. The key type of a <code>QMap</code> must provide <code>operator&lt;()</code> specifying a total order.</li>
</ul>
<p>&emsp;&emsp;Here’s an example <code>QMap</code> with <code>QString</code> keys and int values:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br></pre></td></tr></table></figure>
<p>To insert a <code>(key, value)</code> pair into the map, you can use <code>operator[]()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>[<span class="string">"one"</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">map</span>[<span class="string">"three"</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">map</span>[<span class="string">"seven"</span>] = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;This inserts the following three <code>(key, value)</code> pairs into the <code>QMap</code>: <code>(&quot;one&quot;, 1)</code>, <code>(&quot;three&quot;, 3)</code>, and <code>(&quot;seven&quot;, 7)</code>. Another way to insert items into the map is to use <code>insert()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.insert ( <span class="string">"twelve"</span>, <span class="number">12</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;To look up a value, use <code>operator[]()</code> or <code>value()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = <span class="built_in">map</span>[<span class="string">"thirteen"</span>];</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="built_in">map</span>.value ( <span class="string">"thirteen"</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If there is no item with the specified key in the map, these functions return a <code>default-constructed</code> value.<br>&emsp;&emsp;If you want to check whether the map contains a certain key, use <code>contains()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> timeout = <span class="number">30</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">map</span>.contains ( <span class="string">"TIMEOUT"</span> ) ) &#123;</span><br><span class="line">    timeout = <span class="built_in">map</span>.value ( <span class="string">"TIMEOUT"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;There is also a <code>value()</code> overload that uses its second argument as a default value if there is no item with the specified key:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> timeout = <span class="built_in">map</span>.value ( <span class="string">"TIMEOUT"</span>, <span class="number">30</span> );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;In general, we recommend that you use <code>contains()</code> and <code>value()</code> rather than <code>operator[]()</code> for looking up a key in a map. The reason is that <code>operator[]()</code> silently inserts an item into the map if no item exists with the same key (unless the map is const). For example, the following code snippet will create <code>1000</code> items in memory:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WRONG */</span></span><br><span class="line">QMap&lt;<span class="keyword">int</span>, QWidget *&gt; <span class="built_in">map</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">map</span>[i] == okButton ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found button at index "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;To avoid this problem, replace <code>map[i]</code> with <code>map.value(i)</code> in the code above.<br>&emsp;&emsp;If you want to navigate through all the <code>(key, value)</code> pairs stored in a <code>QMap</code>, you can use an iterator. <code>QMap</code> provides both <code>Java-style</code> iterators (<code>QMapIterator</code> and <code>QMutableMapIterator</code>) and <code>STL-style</code> iterators (<code>QMap::const_iterator</code> and <code>QMap::iterator</code>). Here’s how to iterate over a <code>QMap&lt;QString, int&gt;</code> using a <code>Java-style</code> iterator:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QMapIterator&lt;QString, <span class="keyword">int</span>&gt; i ( <span class="built_in">map</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i.hasNext() ) &#123;</span><br><span class="line">    i.next();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.key() &lt;&lt; <span class="string">": "</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Here’s the same code, but using an <code>STL-style</code> iterator this time:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt;::const_iterator i = <span class="built_in">map</span>.constBegin();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != <span class="built_in">map</span>.constEnd() ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.key() &lt;&lt; <span class="string">": "</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The items are traversed in ascending key order.<br>&emsp;&emsp;Normally, a <code>QMap</code> allows only one value per key. If you call <code>insert()</code> with a key that already exists in the <code>QMap</code>, the previous value will be erased. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.insert ( <span class="string">"plenty"</span>, <span class="number">100</span> );</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="string">"plenty"</span>, <span class="number">2000</span> ); <span class="comment">/* map.value("plenty") == 2000 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;However, you can store multiple values per key by using <code>insertMulti()</code> instead of <code>insert()</code> (or using the convenience subclass <code>QMultiMap</code>). If you want to retrieve all the values for a single key, you can use <code>values(const Key &amp;key)</code>, which returns a <code>QList&lt;T&gt;</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;<span class="keyword">int</span>&gt; values = <span class="built_in">map</span>.values ( <span class="string">"plenty"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.size(); ++i ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values.at ( i ) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;The items that share the same key are available from most recently to least recently inserted. Another approach is to call <code>find()</code> to get the <code>STL-style</code> iterator for the first item with a key and iterate from there:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt;::iterator i = <span class="built_in">map</span>.find ( <span class="string">"plenty"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != <span class="built_in">map</span>.end() &amp;&amp; i.key() == <span class="string">"plenty"</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If you only need to extract the values from a map (not the keys), you can also use <code>foreach</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">​</span><br><span class="line">foreach ( <span class="keyword">int</span> value, <span class="built_in">map</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Items can be removed from the map in several ways. One way is to call <code>remove()</code>; this will remove any item with the given key. Another way is to use <code>QMutableMapIterator::remove()</code>. In addition, you can clear the entire map using <code>clear()</code>.<br>&emsp;&emsp;<code>QMap&#39;s</code> key and value data types must be assignable data types. This covers most data types you are likely to encounter, but the compiler won’t let you, for example, store a <code>QWidget</code> as a value; instead, store a <code>QWidget *</code>. In addition, <code>QMap&#39;s</code> key type must provide <code>operator&lt;()</code>. <code>QMap</code> uses it to keep its items sorted, and assumes that two keys <code>x</code> and <code>y</code> are equal if neither <code>x &lt; y</code> nor <code>y &lt; x</code> is <code>true</code>. Example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EMPLOYEE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EMPLOYEE_H</span></span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Employee() &#123;&#125;</span><br><span class="line">    Employee ( <span class="keyword">const</span> QString &amp;name, <span class="keyword">const</span> QDate &amp;dateOfBirth );</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString myName;</span><br><span class="line">    QDate myDateOfBirth;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; ( <span class="keyword">const</span> Employee &amp;e1, <span class="keyword">const</span> Employee &amp;e2 ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( e1.name() != e2.name() ) &#123;</span><br><span class="line">        <span class="keyword">return</span> e1.name() &lt; e2.name();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> e1.dateOfBirth() &lt; e2.dateOfBirth();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// EMPLOYEE_H</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;In the example, we start by comparing the employees’ names. If they’re equal, we compare their dates of birth to break the tie.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>typedef <code>QMap::ConstIterator</code>: <code>Qt-style</code> synonym for <code>QMap::const_iterator</code>.</li>
<li>typedef <code>QMap::Iterator</code>: <code>Qt-style</code> synonym for <code>QMap::iterator</code>.</li>
<li>typedef <code>QMap::difference_type</code>: Typedef for <code>ptrdiff_t</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QMap::key_type</code>: Typedef for <code>Key</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QMap::mapped_type</code>: Typedef for <code>T</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QMap::size_type</code>: Typedef for <code>int</code>. Provided for <code>STL</code> compatibility.</li>
</ul>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QMap::QMap()</code>: Constructs an empty map.</li>
<li><code>QMap::QMap(const QMap&lt;Key, T&gt; &amp; other)</code>: Constructs a copy of <code>other</code>. This operation occurs in constant time, because <code>QMap</code> is implicitly shared. This makes returning a <code>QMap</code> from a function very fast. If a shared instance is modified, it will be copied (<code>copy-on-write</code>), and this takes linear time.</li>
<li><code>QMap::QMap(const std::map&lt;Key, T&gt; &amp; other)</code>: Constructs a copy of <code>other</code>. This function is only available if <code>Qt</code> is configured with <code>STL</code> compatibility enabled.</li>
<li><code>QMap::~QMap()</code>: Destroys the map. References to the values in the map, and all iterators over this map, become invalid.</li>
<li><code>iterator QMap::begin()</code>: Returns an <code>STL-style</code> iterator pointing to the first item in the map.</li>
<li><code>const_iterator QMap::begin() const</code>: This is an overloaded function.</li>
<li><code>void QMap::clear()</code>: Removes all items from the map.</li>
<li><code>const_iterator QMap::constBegin() const</code>: Returns a const <code>STL-style</code> iterator pointing to the first item in the map.</li>
<li><code>const_iterator QMap::constEnd() const</code>: Returns a const <code>STL-style</code> iterator pointing to the imaginary item after the last item in the map.</li>
<li><code>const_iterator QMap::constFind(const Key &amp; key) const</code>: Returns an const iterator pointing to the item with <code>key</code> in the map. If the map contains no item with <code>key</code>, the function returns <code>constEnd()</code>.</li>
<li><code>bool QMap::contains(const Key &amp; key) const</code>: Returns <code>true</code> if the map contains an item with <code>key</code>; otherwise returns <code>false</code>.</li>
<li><code>int QMap::count(const Key &amp; key) const</code>: Returns the number of items associated with <code>key</code>.</li>
<li><code>int QMap::count() const</code>: This is an overloaded function. Same as <code>size()</code>.</li>
<li><code>bool QMap::empty() const</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>isEmpty()</code>, returning <code>true</code> if the map is empty; otherwise returning <code>false</code>.</li>
<li><code>iterator QMap::end()</code>: Returns an <code>STL-style</code> iterator pointing to the imaginary item after the last item in the map.</li>
<li><code>const_iterator QMap::end() const</code>: This is an overloaded function.</li>
<li><code>iterator QMap::erase(iterator pos)</code>: Removes the <code>(key, value)</code> pair pointed to by the iterator <code>pos</code> from the map, and returns an iterator to the next item in the map.</li>
<li><code>iterator QMap::find(const Key &amp; key)</code>: Returns an iterator pointing to the item with <code>key</code> in the map. If the map contains no item with <code>key</code>, the function returns <code>end()</code>. If the map contains multiple items with <code>key</code>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here’s some code that iterates over all the items with the same <code>key</code>:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">​</span><br><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt;::const_iterator i = <span class="built_in">map</span>.find ( <span class="string">"HDR"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != <span class="built_in">map</span>.end() &amp;&amp; i.key() == <span class="string">"HDR"</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>const_iterator QMap::find(const Key &amp; key) const</code>: This is an overloaded function.</li>
<li><code>iterator QMap::insert(const Key &amp; key, const T &amp; value)</code>: Inserts a new item with the <code>key</code> and a <code>value</code> of value. If there is already an item with the <code>key</code>, that item’s value is replaced with <code>value</code>. If there are multiple items with the <code>key</code>, the most recently inserted item’s value is replaced with <code>value</code>.</li>
<li><code>iterator QMap::insertMulti(const Key &amp; key, const T &amp; value)</code>: Inserts a new item with the <code>key</code> and a <code>value</code> of value. If there is already an item with the same <code>key</code> in the map, this function will simply create a new one (This behavior is different from <code>insert()</code>, which overwrites the value of an existing item).</li>
<li><code>bool QMap::isEmpty() const</code>: Returns <code>true</code> if the map contains no items; otherwise returns <code>false</code>.</li>
<li><code>const Key QMap::key(const T &amp; value) const</code>: Returns the first key with <code>value</code>. If the map contains no item with <code>value</code>, the function returns a <code>default-constructed</code> key. This function can be slow (linear time), because <code>QMap&#39;s</code> internal data structure is optimized for fast lookup by key, not by value.</li>
<li><code>const Key QMap::key(const T &amp; value, const Key &amp; defaultKey) const</code>: This is an overloaded function. Returns the first key with <code>value</code>, or defaultKey if the map contains no item with <code>value</code>. This function can be slow (linear time), because <code>QMap&#39;s</code> internal data structure is optimized for fast lookup by key, not by value.</li>
<li><code>QList&lt;Key&gt; QMap::keys() const</code>: Returns a list containing all the keys in the map in ascending order. Keys that occur multiple times in the map (because items were inserted with <code>insertMulti()</code>, or <code>unite()</code> was used) also occur multiple times in the list. To obtain a list of unique keys, where each key from the map only occurs once, use <code>uniqueKeys()</code>. The order is guaranteed to be the same as that used by <code>values()</code>.</li>
<li><code>QList&lt;Key&gt; QMap::keys(const T &amp; value) const</code>: This is an overloaded function. Returns a list containing all the keys associated with <code>value</code> in ascending order. This function can be slow (linear time), because <code>QMap&#39;s</code> internal data structure is optimized for fast lookup by key, not by value.</li>
<li><code>iterator QMap::lowerBound(const Key &amp; key)</code>: Returns an iterator pointing to the first item with <code>key</code> in the map. If the map contains no item with <code>key</code>, the function returns an iterator to the nearest item with a greater key. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;<span class="keyword">int</span>, QString&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">1</span>, <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">5</span>, <span class="string">"five"</span> );</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">10</span>, <span class="string">"ten"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="built_in">map</span>.lowerBound ( <span class="number">0</span> ); <span class="comment">/* returns iterator to (1, "one") */</span></span><br><span class="line"><span class="built_in">map</span>.lowerBound ( <span class="number">1</span> ); <span class="comment">/* returns iterator to (1, "one") */</span></span><br><span class="line"><span class="built_in">map</span>.lowerBound ( <span class="number">2</span> ); <span class="comment">/* returns iterator to (5, "five") */</span></span><br><span class="line"><span class="built_in">map</span>.lowerBound ( <span class="number">10</span> ); <span class="comment">/* returns iterator to (10, "ten") */</span></span><br><span class="line"><span class="built_in">map</span>.lowerBound ( <span class="number">999</span> ); <span class="comment">/* returns end() */</span></span><br></pre></td></tr></table></figure>
<p>If the map contains multiple items with <code>key</code>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here’s some code that iterates over all the items with the same key:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">​</span><br><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt;::const_iterator i = <span class="built_in">map</span>.lowerBound ( <span class="string">"HDR"</span> );</span><br><span class="line">QMap&lt;QString, <span class="keyword">int</span>&gt;::const_iterator upperBound = <span class="built_in">map</span>.upperBound ( <span class="string">"HDR"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> ( i != upperBound ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>const_iterator QMap::lowerBound(const Key &amp; key) const</code>: This is an overloaded function.</li>
<li><code>int QMap::remove(const Key &amp; key)</code>: Removes all the items that have the <code>key</code> from the map. Returns the number of items removed which is usually <code>1</code> but will be <code>0</code> if the <code>key</code> isn’t in the map, or <code>&gt; 1</code> if <code>insertMulti()</code> has been used with the <code>key</code>.</li>
<li><code>int QMap::size() const</code>: Returns the number of <code>(key, value)</code> pairs in the map.</li>
<li><code>void QMap::swap(QMap&lt;Key, T&gt; &amp; other)</code>: Swaps map <code>other</code> with this map. This operation is very fast and never fails.</li>
<li><code>T QMap::take(const Key &amp; key)</code>: Removes the item with the <code>key</code> from the map and returns the value associated with it. If the item does not exist in the map, the function simply returns a <code>default-constructed</code> value. If there are multiple items for <code>key</code> in the map, only the most recently inserted one is removed and returned. If you don’t use the return value, <code>remove()</code> is more efficient.</li>
<li><code>std::map&lt;Key, T&gt; QMap::toStdMap() const</code>: Returns an <code>STL</code> map equivalent to this <code>QMap</code>. This function is only available if <code>Qt</code> is configured with <code>STL</code> compatibility enabled.</li>
<li><code>QList&lt;Key&gt; QMap::uniqueKeys() const</code>: Returns a list containing all the keys in the map in ascending order. Keys that occur multiple times in the map (because items were inserted with <code>insertMulti()</code>, or <code>unite()</code> was used) occur only once in the returned list.</li>
<li><code>QMap&lt;Key, T&gt; &amp; QMap::unite(const QMap&lt;Key, T&gt; &amp; other)</code>: Inserts all the items in the <code>other</code> map into this map. If a key is common to both maps, the resulting map will contain the key multiple times.</li>
<li><code>iterator QMap::upperBound(const Key &amp; key)</code>: Returns an iterator pointing to the item that immediately follows the last item with <code>key</code> in the map. If the map contains no item with <code>key</code>, the function returns an iterator to the nearest item with a greater key. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;<span class="keyword">int</span>, QString&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">1</span>, <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">5</span>, <span class="string">"five"</span> );</span><br><span class="line"><span class="built_in">map</span>.insert ( <span class="number">10</span>, <span class="string">"ten"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="built_in">map</span>.upperBound ( <span class="number">0</span> ); <span class="comment">/* returns iterator to (1, "one") */</span></span><br><span class="line"><span class="built_in">map</span>.upperBound ( <span class="number">1</span> ); <span class="comment">/* returns iterator to (5, "five") */</span></span><br><span class="line"><span class="built_in">map</span>.upperBound ( <span class="number">2</span> ); <span class="comment">/* returns iterator to (5, "five") */</span></span><br><span class="line"><span class="built_in">map</span>.upperBound ( <span class="number">10</span> ); <span class="comment">/* returns end() */</span></span><br><span class="line"><span class="built_in">map</span>.upperBound ( <span class="number">999</span> ); <span class="comment">/* returns end() */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>const_iterator QMap::upperBound(const Key &amp; key) const</code>: This is an overloaded function.</li>
<li><code>const T QMap::value(const Key &amp; key) const</code>: Returns the value associated with the <code>key</code>. If the map contains no item with <code>key</code>, the function returns a <code>default-constructed</code> value. If there are multiple items for key in the map, the value of the most recently inserted one is returned.</li>
<li><code>const T QMap::value(const Key &amp; key, const T &amp; defaultValue) const</code>: This is an overloaded function. If the map contains no item with <code>key</code>, the function returns <code>defaultValue</code>.</li>
<li><code>QList&lt;T&gt; QMap::values() const</code>: Returns a list containing all the values in the map, in ascending order of their keys. If a key is associated with multiple values, all of its values will be in the list, and not just the most recently inserted one.</li>
<li><code>QList&lt;T&gt; QMap::values(const Key &amp; key) const</code>: This is an overloaded function. Returns a list containing all the values associated with <code>key</code>, from the most recently inserted to the least recently inserted one.</li>
<li><code>bool QMap::operator!=(const QMap&lt;Key, T&gt; &amp; other) const</code>: Returns true if <code>other</code> is not equal to this map; otherwise returns false. Two maps are considered equal if they contain the same <code>(key, value)</code> pairs. This function requires the value type to implement <code>operator==()</code>.</li>
<li><code>QMap&lt;Key, T&gt; &amp; QMap::operator=(const QMap&lt;Key, T&gt; &amp; other)</code>: Assigns <code>other</code> to this map and returns a reference to this map.</li>
<li><code>QMap&lt;Key, T&gt; &amp; QMap::operator=(QMap&lt;Key, T&gt; &amp;&amp; other)</code>: bool <code>QMap::operator==(const QMap&lt;Key, T&gt; &amp; other)</code> const Returns <code>true</code> if other is equal to this map; otherwise returns <code>false</code>. Two maps are considered equal if they contain the same <code>(key, value)</code> pairs. This function requires the value type to implement <code>operator==()</code>.</li>
<li><code>T &amp; QMap::operator[](const Key &amp; key)</code>: Returns the value associated with the key key as a modifiable reference. If the map contains no item with <code>key</code>, the function inserts a <code>default-constructed</code> value into the map with <code>key</code>, and returns a reference to it. If the map contains multiple items with <code>key</code>, this function returns a reference to the most recently inserted value.</li>
<li><code>const T QMap::operator[](const Key &amp; key) const</code>: This is an overloaded function.</li>
</ul>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; out, const QMap&lt;Key, T&gt; &amp; map)</code>: Writes the <code>map</code> to stream <code>out</code>. This function requires the key and value types to implement <code>operator&lt;&lt;()</code>.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; in, QMap&lt;Key, T&gt; &amp; map)</code>: Reads a map from stream <code>in</code> into <code>map</code>. This function requires the key and value types to implement <code>operator&gt;&gt;()</code>.</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/27/Qt语法详解/Qt之QFtp/" rel="next" title="Qt之QFtp">
                <i class="fa fa-chevron-left"></i> Qt之QFtp
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/28/Qt语法详解/Qt之QHash/" rel="prev" title="Qt之QHash">
                Qt之QHash <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">939</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Public-Functions"><span class="nav-number">1.</span> <span class="nav-text">Public Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Related-Non-Members"><span class="nav-number">2.</span> <span class="nav-text">Related Non-Members</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Detailed-Description"><span class="nav-number">3.</span> <span class="nav-text">Detailed Description</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Member-Type-Documentation"><span class="nav-number">4.</span> <span class="nav-text">Member Type Documentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Member-Function-Documentation"><span class="nav-number">5.</span> <span class="nav-text">Member Function Documentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Related-Non-Members-1"><span class="nav-number">6.</span> <span class="nav-text">Related Non-Members</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
