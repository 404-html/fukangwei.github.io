<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="&amp;emsp;&amp;emsp;The QVector class is a template class that provides a dynamic array.     Header Inherited By     QVector Q3ValueVector, QPolygon, QPolygonF, QStack, and QXmlStreamAttributes     Note: All">
<meta property="og:type" content="article">
<meta property="og:title" content="Qt之QVector">
<meta property="og:url" content="http://fukangwei.gitee.io/2019/01/30/Qt语法详解/Qt之QVector/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:description" content="&amp;emsp;&amp;emsp;The QVector class is a template class that provides a dynamic array.     Header Inherited By     QVector Q3ValueVector, QPolygon, QPolygonF, QStack, and QXmlStreamAttributes     Note: All">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-04-02T11:03:20.674Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Qt之QVector">
<meta name="twitter:description" content="&amp;emsp;&amp;emsp;The QVector class is a template class that provides a dynamic array.     Header Inherited By     QVector Q3ValueVector, QPolygon, QPolygonF, QStack, and QXmlStreamAttributes     Note: All">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/2019/01/30/Qt语法详解/Qt之QVector/">





  <title>Qt之QVector | 泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/01/30/Qt语法详解/Qt之QVector/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Qt之QVector</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-30T20:04:17+08:00">
                2019-01-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt语法详解/" itemprop="url" rel="index">
                    <span itemprop="name">Qt语法详解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&emsp;&emsp;The <code>QVector</code> class is a template class that provides a dynamic array.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Header</th>
<th>Inherited By</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QVector</code></td>
<td><code>Q3ValueVector</code>, <code>QPolygon</code>, <code>QPolygonF</code>, <code>QStack</code>, and <code>QXmlStreamAttributes</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: All functions in this class are reentrant.</p>
<h3 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>QVector()</code></td>
</tr>
<tr>
<td></td>
<td><code>QVector(int size)</code></td>
</tr>
<tr>
<td></td>
<td><code>QVector(int size, const T &amp; value)</code></td>
</tr>
<tr>
<td></td>
<td><code>QVector(const QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td></td>
<td><code>QVector(std::initializer_list&lt;T&gt; args)</code></td>
</tr>
<tr>
<td></td>
<td><code>~QVector()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>append(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>at(int i) const</code></td>
</tr>
<tr>
<td><code>reference</code></td>
<td><code>back()</code></td>
</tr>
<tr>
<td><code>const_reference</code></td>
<td><code>back() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>begin()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>begin() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>capacity() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constBegin() const</code></td>
</tr>
<tr>
<td><code>const T *</code></td>
<td><code>constData() const</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>constEnd() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>contains(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>count() const</code></td>
</tr>
<tr>
<td><code>T *</code></td>
<td><code>data()</code></td>
</tr>
<tr>
<td><code>const T *</code></td>
<td><code>data() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>empty() const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>end()</code></td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td><code>end() const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>endsWith(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator pos)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>erase(iterator begin, iterator end)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>fill(const T &amp; value, int size = -1)</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>first()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>first() const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>front()</code></td>
</tr>
<tr>
<td><code>const_reference</code></td>
<td><code>front() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>indexOf(const T &amp; value, int from = 0) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insert(int i, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insert(iterator before, int count, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>insert(int i, int count, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>iterator</code></td>
<td><code>insert(iterator before, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>isEmpty() const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>last()</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>last() const</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lastIndexOf(const T &amp; value, int from = -1) const</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>mid(int pos, int length = -1) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>pop_back()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>pop_front()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>prepend(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>push_back(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>push_front(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>remove(int i)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>remove(int i, int count)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>replace(int i, const T &amp; value)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>reserve(int size)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>resize(int size)</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size() const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>squeeze()</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>startsWith(const T &amp; value) const</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>swap(QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QList&lt;T&gt;</code></td>
<td><code>toList() const</code></td>
</tr>
<tr>
<td><code>std::vector&lt;T&gt;</code></td>
<td><code>toStdVector() const</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>value(int i) const</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>value(int i, const T &amp; defaultValue) const</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator!=(const QVector&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>operator+(const QVector&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator+=(const QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator+=(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator&lt;&lt;(const T &amp; value)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator&lt;&lt;(const QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt; &amp;</code></td>
<td><code>operator=(const QVector&lt;T&gt; &amp; other)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>operator=(QVector&lt;T&gt; &amp;&amp; other)</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>operator==(const QVector&lt;T&gt; &amp; other) const</code></td>
</tr>
<tr>
<td><code>T &amp;</code></td>
<td><code>operator[](int i)</code></td>
</tr>
<tr>
<td><code>const T &amp;</code></td>
<td><code>operator[](int i) const</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Static-Public-Members"><a href="#Static-Public-Members" class="headerlink" title="Static Public Members"></a>Static Public Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>fromList(const QList&lt;T&gt; &amp; list)</code></td>
</tr>
<tr>
<td><code>QVector&lt;T&gt;</code></td>
<td><code>fromStdVector(const std::vector&lt;T&gt; &amp; vector)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Related-Non-Members"><a href="#Related-Non-Members" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Return</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&lt;&lt;(QDataStream &amp; out, const QVector&lt;T&gt; &amp; vector)</code></td>
</tr>
<tr>
<td><code>QDataStream &amp;</code></td>
<td><code>operator&gt;&gt;(QDataStream &amp; in, QVector&lt;T&gt; &amp; vector)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Detailed-Description"><a href="#Detailed-Description" class="headerlink" title="Detailed Description"></a>Detailed Description</h3><p>&emsp;&emsp;The <code>QVector</code> class is a template class that provides a dynamic array.<br>&emsp;&emsp;<code>QVector&lt;T&gt;</code> is one of Qt’s generic container classes. It stores its items in adjacent memory locations and provides fast <code>index-based</code> access.<br>&emsp;&emsp;<code>QList&lt;T&gt;</code>, <code>QLinkedList&lt;T&gt;</code>, and <code>QVarLengthArray&lt;T&gt;</code> provide similar functionality. Here’s an overview:</p>
<ul>
<li>For most purposes, <code>QList</code> is the right class to use. Operations like <code>prepend()</code> and <code>insert()</code> are usually faster than with <code>QVector</code> because of the way <code>QList</code> stores its items in memory, and its <code>index-based</code> <code>API</code> is more convenient than <code>QLinkedList&#39;s</code> <code>iterator-based</code> <code>API</code>. It also expands to less code in your executable.</li>
<li>If you need a real linked list, with guarantees of constant time insertions in the middle of the list and iterators to items rather than indexes, use <code>QLinkedList</code>.</li>
<li>If you want the items to occupy adjacent memory positions, or if your items are larger than a pointer and you want to avoid the overhead of allocating them on the heap individually at insertion time, then use <code>QVector</code>.</li>
<li>If you want a <code>low-level</code> <code>variable-size</code> array, <code>QVarLengthArray</code> may be sufficient.</li>
</ul>
<p>&emsp;&emsp;Here’s an example of a <code>QVector</code> that stores integers and a <code>QVector</code> that stores <code>QString</code> values:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; integerVector;</span><br><span class="line">QVector&lt;QString&gt; stringVector;</span><br></pre></td></tr></table></figure>
<p><code>QVector</code> stores a vector (or array) of items. Typically, vectors are created with an initial size. For example, the following code constructs a <code>QVector</code> with <code>200</code> elements:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span> ( <span class="number">200</span> );</span><br></pre></td></tr></table></figure>
<p>The elements are automatically initialized with a <code>default-constructed</code> value. If you want to initialize the vector with a different value, pass that value as the second argument to the constructor:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span> ( <span class="number">200</span>, <span class="string">"Pass"</span> );</span><br></pre></td></tr></table></figure>
<p>You can also call <code>fill()</code> at any time to fill the vector with a value.<br>&emsp;&emsp;<code>QVector</code> uses <code>0-based</code> indexes, just like <code>C++</code> arrays. To access the item at a particular index position, you can use <code>operator[]()</code>. On <code>non-const</code> vectors, <code>operator[]()</code> returns a reference to the item that can be used on the left side of an assignment:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">vector</span>[<span class="number">0</span>] == <span class="string">"Liz"</span> ) &#123;</span><br><span class="line">    <span class="built_in">vector</span>[<span class="number">0</span>] = <span class="string">"Elizabeth"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For <code>read-only</code> access, an alternative syntax is to use <code>at()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.size(); ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">vector</span>.at ( i ) == <span class="string">"Alfonso"</span> ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found Alfonso at position "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>at()</code> can be faster than <code>operator[]()</code>, because it never causes a deep copy to occur.<br>&emsp;&emsp;Another way to access the data stored in a <code>QVector</code> is to call <code>data()</code>. The function returns a pointer to the first item in the vector. You can use the pointer to directly access and modify the elements stored in the vector. The pointer is also useful if you need to pass a <code>QVector</code> to a function that accepts a plain <code>C++</code> array.<br>&emsp;&emsp;If you want to find all occurrences of a particular value in a vector, use <code>indexOf()</code> or <code>lastIndexOf()</code>. The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return <code>-1</code>. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="built_in">vector</span>.indexOf ( <span class="string">"Harumi"</span> );</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> ( i != <span class="number">-1</span> ) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"First occurrence of Harumi is at position "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;If you simply want to check whether a vector contains a particular value, use <code>contains()</code>. If you want to find out how many times a particular value occurs in the vector, use <code>count()</code>.<br>&emsp;&emsp;<code>QVector</code> provides these basic functions to add, move, and remove items: <code>insert()</code>, <code>replace()</code>, <code>remove()</code>, <code>prepend()</code>, <code>append()</code>. With the exception of <code>append()</code> and <code>replace()</code>, these functions can be slow (linear time) for large vectors, because they require moving many items in the vector by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use <code>QList</code> or <code>QLinkedList</code> instead.<br>&emsp;&emsp;Unlike plain <code>C++</code> arrays, <code>QVectors</code> can be resized at any time by calling <code>resize()</code>. If the new size is larger than the old size, <code>QVector</code> might need to reallocate the whole vector. <code>QVector</code> tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.<br>&emsp;&emsp;If you know in advance approximately how many items the <code>QVector</code> will contain, you can call <code>reserve()</code>, asking <code>QVector</code> to preallocate a certain amount of memory. You can also call <code>capacity()</code> to find out how much memory <code>QVector</code> actually allocated.<br>&emsp;&emsp;Note that using <code>non-const</code> operators and functions can cause <code>QVector</code> to do a deep copy of the data. This is due to implicit sharing.<br>&emsp;&emsp;<code>QVector&#39;s</code> value type must be an assignable data type. This covers most data types that are commonly used, but the compiler won’t let you, for example, store a <code>QWidget</code> as a value; instead, store a <code>QWidget *</code>. A few functions have additional requirements; for example, <code>indexOf()</code> and <code>lastIndexOf()</code> expect the value type to support <code>operator==()</code>. These requirements are documented on a <code>per-function</code> basis.<br>&emsp;&emsp;Like the other container classes, <code>QVector</code> provides <code>Java-style</code> iterators (<code>QVectorIterator</code> and <code>QMutableVectorIterator</code>) and <code>STL-style</code> iterators (<code>QVector::const_iterator</code> and <code>QVector::iterator</code>). In practice, these are rarely used, because you can use indexes into the <code>QVector</code>.<br>&emsp;&emsp;In addition to <code>QVector</code>, Qt also provides <code>QVarLengthArray</code>, a very <code>low-level</code> class with little functionality that is optimized for speed.<br>&emsp;&emsp;<code>QVector</code> does not support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.</p>
<h3 id="Member-Type-Documentation"><a href="#Member-Type-Documentation" class="headerlink" title="Member Type Documentation"></a>Member Type Documentation</h3><ul>
<li>typedef <code>QVector::ConstIterator</code>: <code>Qt-style</code> synonym for <code>QVector::const_iterator</code>.</li>
<li>typedef <code>QVector::Iterator</code>: <code>Qt-style</code> synonym for <code>QVector::iterator</code>.</li>
<li>typedef <code>QVector::const_iterator</code>: The <code>QVector::const_iterator</code> typedef provides an <code>STL-style</code> const iterator for <code>QVector</code> and <code>QStack</code>. <code>QVector</code> provides both <code>STL-style</code> iterators and <code>Java-style</code> iterators. The <code>STL-style</code> const iterator is simply a typedef for <code>const T *</code> (pointer to <code>const T</code>).</li>
<li>typedef <code>QVector::const_pointer</code>: Typedef for <code>const T *</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::const_reference</code>: Typedef for <code>T &amp;</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::difference_type</code>: Typedef for <code>ptrdiff_t</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::iterator</code>: The <code>QVector::iterator</code> typedef provides an <code>STL-style</code> <code>non-const</code> iterator for <code>QVector</code> and <code>QStack</code>. <code>QVector</code> provides both <code>STL-style</code> iterators and <code>Java-style</code> iterators. The <code>STL-style</code> <code>non-const</code> iterator is simply a typedef for <code>T *</code> (pointer to <code>T</code>).</li>
<li>typedef <code>QVector::pointer</code>: Typedef for <code>T *</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::reference</code>: Typedef for <code>T &amp;</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::size_type</code>: Typedef for <code>int</code>. Provided for <code>STL</code> compatibility.</li>
<li>typedef <code>QVector::value_type</code>: Typedef for <code>T</code>. Provided for <code>STL</code> compatibility.</li>
</ul>
<h3 id="Member-Function-Documentation"><a href="#Member-Function-Documentation" class="headerlink" title="Member Function Documentation"></a>Member Function Documentation</h3><ul>
<li><code>QVector::QVector()</code>: Constructs an empty vector.</li>
<li><code>QVector::QVector(int size)</code>: Constructs a vector with an initial size of <code>size</code> elements. The elements are initialized with a <code>default-constructed</code> value.</li>
<li><code>QVector::QVector(int size, const T &amp; value)</code>: Constructs a vector with an initial size of <code>size</code> elements. Each element is initialized with <code>value</code>.</li>
<li><code>QVector::QVector(const QVector&lt;T&gt; &amp; other)</code>: Constructs a copy of <code>other</code>. This operation takes constant time, because <code>QVector</code> is implicitly shared. This makes returning a <code>QVector</code> from a function very fast. If a shared instance is modified, it will be copied (<code>copy-on-write</code>), and that takes linear time.</li>
<li><code>QVector::QVector(std::initializer_list&lt;T&gt; args)</code>: Construct a vector from the <code>std::initilizer_list</code> given by <code>args</code>. This constructor is only enabled if the compiler supports <code>C++0x</code>.</li>
<li><code>QVector::~QVector()</code>: Destroys the vector.</li>
<li><code>void QVector::append(const T &amp; value)</code>: Inserts <code>value</code> at the end of the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span> ( <span class="number">0</span> );</span><br><span class="line"><span class="built_in">vector</span>.append ( <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">vector</span>.append ( <span class="string">"two"</span> );</span><br><span class="line"><span class="built_in">vector</span>.append ( <span class="string">"three"</span> ); <span class="comment">/* vector: ["one", "two", "three"] */</span></span><br></pre></td></tr></table></figure>
<p>This is the same as calling <code>resize(size() + 1)</code> and assigning value to the new last element in the vector. This operation is relatively fast, because <code>QVector</code> typically allocates more memory than necessary, so it can grow without reallocating the entire vector each time.</p>
<ul>
<li><code>const T &amp; QVector::at(int i) const</code>: Returns the item at index position <code>i</code> in the vector. <code>i</code> must be a valid index position in the vector (i.e., <code>0 &lt;= i &lt; size()</code>).</li>
<li><code>reference QVector::back()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>last()</code>.</li>
<li><code>const_reference QVector::back() const</code>: This is an overloaded function.</li>
<li><code>iterator QVector::begin()</code>: Returns an <code>STL-style</code> iterator pointing to the first item in the vector.</li>
<li><code>const_iterator QVector::begin() const</code>: This is an overloaded function.</li>
<li><code>int QVector::capacity() const</code>: Returns the maximum number of items that can be stored in the vector without forcing a reallocation. The sole purpose of this function is to provide a means of fine tuning <code>QVector&#39;s</code> memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the vector, call <code>size()</code>.</li>
<li><code>void QVector::clear()</code>: Removes all the elements from the vector and releases the memory used by the vector.</li>
<li><code>const_iterator QVector::constBegin() const</code>: Returns a const <code>STL-style</code> iterator pointing to the first item in the vector.</li>
<li><code>const T * QVector::constData() const</code>: Returns a const pointer to the data stored in the vector. The pointer can be used to access the items in the vector. The pointer remains valid as long as the vector isn’t reallocated. This function is mostly useful to pass a vector to a function that accepts a plain <code>C++</code> array.</li>
<li><code>const_iterator QVector::constEnd() const</code>: Returns a const <code>STL-style</code> iterator pointing to the imaginary item after the last item in the vector.</li>
<li><code>bool QVector::contains(const T &amp; value) const</code>: Returns <code>true</code> if the vector contains an occurrence of <code>value</code>; otherwise returns <code>false</code>. This function requires the <code>value</code> type to have an implementation of <code>operator==()</code>.</li>
<li><code>int QVector::count(const T &amp; value) const</code>: Returns the number of occurrences of <code>value</code> in the vector. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>int QVector::count() const</code>: This is an overloaded function. Same as <code>size()</code>.</li>
<li><code>T * QVector::data()</code>: Returns a pointer to the data stored in the vector. The pointer can be used to access and modify the items in the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">int</span>&gt; <span class="built_in">vector</span> ( <span class="number">10</span> );</span><br><span class="line"><span class="keyword">int</span> *data = <span class="built_in">vector</span>.data();</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i ) &#123;</span><br><span class="line">    data[i] = <span class="number">2</span> * i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The pointer remains valid as long as the vector isn’t reallocated. This function is mostly useful to pass a vector to a function that accepts a plain <code>C++</code> array.</p>
<ul>
<li><code>const T * QVector::data() const</code>: This is an overloaded function.</li>
<li><code>bool QVector::empty() const</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>isEmpty()</code>, returning <code>true</code> if the vector is empty; otherwise returns <code>false</code>.</li>
<li><code>iterator QVector::end()</code>: Returns an <code>STL-style</code> iterator pointing to the imaginary item after the last item in the vector.</li>
<li><code>const_iterator QVector::end() const</code>: This is an overloaded function.</li>
<li><code>bool QVector::endsWith(const T &amp; value) const</code>: Returns <code>true</code> if this vector is not empty and its last item is equal to <code>value</code>; otherwise returns <code>false</code>.</li>
<li><code>iterator QVector::erase(iterator pos)</code>: Removes the item pointed to by the iterator <code>pos</code> from the vector, and returns an iterator to the next item in the vector (which may be <code>end()</code>).</li>
<li><code>iterator QVector::erase(iterator begin, iterator end)</code>: This is an overloaded function. Removes all the items from <code>begin</code> up to (but not including) <code>end</code>. Returns an iterator to the same item that end referred to before the call.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::fill(const T &amp; value, int size = -1)</code>: Assigns <code>value</code> to all items in the vector. If <code>size</code> is different from <code>-1</code> (the default), the vector is resized to <code>size</code> beforehand. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span> ( <span class="number">3</span> );</span><br><span class="line"><span class="built_in">vector</span>.fill ( <span class="string">"Yes"</span> ); <span class="comment">/* vector: ["Yes", "Yes", "Yes"] */</span></span><br><span class="line"><span class="built_in">vector</span>.fill ( <span class="string">"oh"</span>, <span class="number">5</span> ); <span class="comment">/* vector: ["oh", "oh", "oh", "oh", "oh"] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>T &amp; QVector::first()</code>: Returns a reference to the first item in the vector. This function assumes that the vector isn’t empty.</li>
<li><code>const T &amp; QVector::first() const</code>: This is an overloaded function.</li>
<li><code>QVector&lt;T&gt; QVector::fromList(const QList&lt;T&gt; &amp; list) [static]</code>: Returns a <code>QVector</code> object with the data contained in <code>list</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QStringList <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> &lt;&lt; "Sven" &lt;&lt; "Kim" &lt;&lt; "Ola";</span><br><span class="line">QVector&lt;QString&gt; vect = QVector&lt;QString&gt;::fromList ( <span class="built_in">list</span> ); <span class="comment">/* vect: ["Sven", "Kim", "Ola"] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>QVector&lt;T&gt; QVector::fromStdVector(const std::vector&lt;T&gt; &amp; vector) [static]</code>: Returns a <code>QVector</code> object with the data contained in <code>vector</code>. The order of the elements in the <code>QVector</code> is the same as in vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; stdvector;</span><br><span class="line"><span class="built_in">vector</span>.push_back ( <span class="number">1.2</span> );</span><br><span class="line"><span class="built_in">vector</span>.push_back ( <span class="number">0.5</span> );</span><br><span class="line"><span class="built_in">vector</span>.push_back ( <span class="number">3.14</span> );</span><br><span class="line">QVector&lt;<span class="keyword">double</span>&gt; <span class="built_in">vector</span> = QVector&lt;<span class="keyword">double</span>&gt;::fromStdVector ( stdvector );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>T &amp; QVector::front()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>first()</code>.</li>
<li><code>const_reference QVector::front() const</code>: This is an overloaded function.</li>
<li><code>int QVector::indexOf(const T &amp; value, int from = 0) const</code>: Returns the index position of the first occurrence of <code>value</code> in the vector, searching forward <code>from</code> index position <code>from</code>. Returns <code>-1</code> if no item matched. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "B" &lt;&lt; "A";</span><br><span class="line"><span class="built_in">vector</span>.indexOf ( "B" );    // returns 1</span><br><span class="line"><span class="built_in">vector</span>.indexOf ( "B", 1 ); // returns 1</span><br><span class="line"><span class="built_in">vector</span>.indexOf ( "B", 2 ); // returns 3</span><br><span class="line"><span class="built_in">vector</span>.indexOf ( "X" );    // returns -1</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>.</p>
<ul>
<li><code>void QVector::insert(int i, const T &amp; value)</code>: Inserts <code>value</code> at index position <code>i</code> in the vector. If <code>i</code> is <code>0</code>, the <code>value</code> is prepended to the vector. If <code>i</code> is <code>size()</code>, the <code>value</code> is appended to the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; "alpha" &lt;&lt; "beta" &lt;&lt; "delta";</span><br><span class="line"><span class="built_in">vector</span>.insert ( 2, "gamma" ); /* <span class="built_in">vector</span>: ["alpha", "beta", "gamma", "delta"] */</span><br></pre></td></tr></table></figure>
<p>For large vectors, this operation can be slow (linear time), because it requires moving all the items at indexes i and above by one position further in memory. If you want a container class that provides a fast <code>insert()</code> function, use <code>QLinkedList</code> instead.</p>
<ul>
<li><code>iterator QVector::insert(iterator before, int count, const T &amp; value)</code>: Inserts <code>count</code> copies of <code>value</code> in front of the item pointed to by the iterator <code>before</code>. Returns an iterator pointing at the first of the inserted items.</li>
<li><code>void QVector::insert(int i, int count, const T &amp; value)</code>: This is an overloaded function. Inserts <code>count</code> copies of <code>value</code> at index position <code>i</code> in the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">double</span>&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; 2.718 &lt;&lt; 1.442 &lt;&lt; 0.4342;</span><br><span class="line"><span class="built_in">vector</span>.insert ( 1, 3, 9.9 ); /* <span class="built_in">vector</span>: [2.718, 9.9, 9.9, 9.9, 1.442, 0.4342] */</span><br></pre></td></tr></table></figure>
<ul>
<li><code>iterator QVector::insert(iterator before, const T &amp; value)</code>: This is an overloaded function. Inserts <code>value</code> in front of the item pointed to by the iterator <code>before</code>. Returns an iterator pointing at the inserted item.</li>
<li><code>bool QVector::isEmpty() const</code>: Returns <code>true</code> if the vector has size <code>0</code>; otherwise returns <code>false</code>.</li>
<li><code>T &amp; QVector::last()</code>: Returns a reference to the last item in the vector. This function assumes that the vector isn’t empty.</li>
<li><code>const T &amp; QVector::last() const</code>: This is an overloaded function.</li>
<li><code>int QVector::lastIndexOf(const T &amp; value, int from = -1) const</code>: Returns the index position of the last occurrence of the <code>value</code> in the vector, searching backward from index position <code>from</code>. If <code>from</code> is <code>-1</code> (the default), the search starts at the last item. Returns <code>-1</code> if no item matched. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; "A" &lt;&lt; "B" &lt;&lt; "C" &lt;&lt; "B" &lt;&lt; "A";</span><br><span class="line"><span class="built_in">vector</span>.lastIndexOf ( "B" );    // returns 3</span><br><span class="line"><span class="built_in">vector</span>.lastIndexOf ( "B", 3 ); // returns 3</span><br><span class="line"><span class="built_in">vector</span>.lastIndexOf ( "B", 2 ); // returns 1</span><br><span class="line"><span class="built_in">vector</span>.lastIndexOf ( "X" );    // returns -1</span><br></pre></td></tr></table></figure>
<p>This function requires the value type to have an implementation of <code>operator==()</code>.</p>
<ul>
<li><code>QVector&lt;T&gt; QVector::mid(int pos, int length = -1) const</code>: Returns a vector whose elements are copied from this vector, starting at position <code>pos</code>. If <code>length</code> is <code>-1</code> (the default), all elements after <code>pos</code> are copied; otherwise <code>length</code> elements (or all remaining elements if there are less than <code>length</code> elements) are copied.</li>
<li><code>void QVector::pop_back()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>erase(end() - 1)</code>.</li>
<li><code>void QVector::pop_front()</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>erase(begin())</code>.</li>
<li><code>void QVector::prepend(const T &amp; value)</code>: Inserts <code>value</code> at the beginning of the vector. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span>.prepend ( <span class="string">"one"</span> );</span><br><span class="line"><span class="built_in">vector</span>.prepend ( <span class="string">"two"</span> );</span><br><span class="line"><span class="built_in">vector</span>.prepend ( <span class="string">"three"</span> ); <span class="comment">/* vector: ["three", "two", "one"] */</span></span><br></pre></td></tr></table></figure>
<p>This is the same as <code>vector.insert(0, value)</code>. For large vectors, this operation can be slow (linear time), because it requires moving all the items in the vector by one position further in memory. If you want a container class that provides a fast <code>prepend()</code> function, use <code>QList</code> or <code>QLinkedList</code> instead.</p>
<ul>
<li><code>void QVector::push_back(const T &amp; value)</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>append(value)</code>.</li>
<li><code>void QVector::push_front(const T &amp; value)</code>: This function is provided for <code>STL</code> compatibility. It is equivalent to <code>prepend(value)</code>.</li>
<li><code>void QVector::remove(int i)</code>: This is an overloaded function. Removes the element at index position <code>i</code>.</li>
<li><code>void QVector::remove(int i, int count)</code>: This is an overloaded function. Removes <code>count</code> elements from the middle of the vector, starting at index position <code>i</code>.</li>
<li><code>void QVector::replace(int i, const T &amp; value)</code>: Replaces the item at index position <code>i</code> with <code>value</code>. <code>i</code> must be a valid index position in the vector (i.e., <code>0 &lt;= i &lt; size()</code>).</li>
<li><code>void QVector::reserve(int size)</code>: Attempts to allocate memory for at least <code>size</code> elements. If you know in advance how large the vector will be, you can call this function, and if you call <code>resize()</code> often you are likely to get better performance. If size is an underestimate, the worst that will happen is that the <code>QVector</code> will be a bit slower. The sole purpose of this function is to provide a means of fine tuning <code>QVector&#39;s</code> memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the vector, call <code>resize()</code>.</li>
<li><code>void QVector::resize(int size)</code>: Sets the size of the vector to <code>size</code>. If <code>size</code> is greater than the current size, elements are added to the end; the new elements are initialized with a <code>default-constructed</code> value. If <code>size</code> is less than the current size, elements are removed from the end.</li>
<li><code>int QVector::size() const</code>: Returns the number of items in the vector.</li>
<li><code>void QVector::squeeze()</code>: Releases any memory not required to store the items. The sole purpose of this function is to provide a means of fine tuning <code>QVector&#39;s</code> memory usage. In general, you will rarely ever need to call this function.</li>
<li><code>bool QVector::startsWith(const T &amp; value) const</code>: Returns <code>true</code> if this vector is not empty and its first item is equal to <code>value</code>; otherwise returns <code>false</code>.</li>
<li><code>void QVector::swap(QVector&lt;T&gt; &amp; other)</code>: Swaps vector <code>other</code> with this vector. This operation is very fast and never fails.</li>
<li><code>QList&lt;T&gt; QVector::toList() const</code>: Returns a <code>QList</code> object with the data contained in this <code>QVector</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;QString&gt; vect;</span><br><span class="line">vect &lt;&lt; <span class="string">"red"</span> &lt;&lt; <span class="string">"green"</span> &lt;&lt; <span class="string">"blue"</span> &lt;&lt; <span class="string">"black"</span>;</span><br><span class="line">QList&lt;QString&gt; <span class="built_in">list</span> = vect.toList(); <span class="comment">/* list: ["red", "green", "blue", "black"] */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::vector&lt;T&gt; QVector::toStdVector() const</code>: Returns a <code>std::vector</code> object with the data contained in this <code>QVector</code>. Example:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="keyword">double</span>&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;&lt; 1.2 &lt;&lt; 0.5 &lt;&lt; 3.14;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; stdvector = <span class="built_in">vector</span>.toStdVector();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>T QVector::value(int i) const</code>: Returns the value at index position <code>i</code> in the vector. If the index <code>i</code> is out of bounds, the function returns a <code>default-constructed</code> value. If you are certain that <code>i</code> is within bounds, you can use <code>at()</code> instead, which is slightly faster.</li>
<li><code>T QVector::value(int i, const T &amp; defaultValue) const</code>: This is an overloaded function. If the index <code>i</code> is out of bounds, the function returns <code>defaultValue</code>.</li>
<li><code>bool QVector::operator!=(const QVector&lt;T&gt; &amp; other) const</code>: Returns <code>true</code> if <code>other</code> is not equal to this vector; otherwise returns <code>false</code>. Two vectors are considered equal if they contain the same values in the same order. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>QVector&lt;T&gt; QVector::operator+(const QVector&lt;T&gt; &amp; other) const</code>: Returns a vector that contains all the items in this vector followed by all the items in the <code>other</code> vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator+=(const QVector&lt;T&gt; &amp; other)</code>: Appends the items of the <code>other</code> vector to this vector and returns a reference to this vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator+=(const T &amp; value)</code>: This is an overloaded function. Appends <code>value</code> to the vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator&lt;&lt;(const T &amp; value)</code>: Appends <code>value</code> to the vector and returns a reference to this vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator&lt;&lt;(const QVector&lt;T&gt; &amp; other)</code>: Appends <code>other</code> to the vector and returns a reference to the vector.</li>
<li><code>QVector&lt;T&gt; &amp; QVector::operator=(const QVector&lt;T&gt; &amp; other)</code>: Assigns <code>other</code> to this vector and returns a reference to this vector.</li>
<li><code>bool QVector::operator==(const QVector&lt;T&gt; &amp; other) const</code>: Returns <code>true</code> if <code>other</code> is equal to this vector; otherwise returns <code>false</code>. Two vectors are considered equal if they contain the same values in the same order. This function requires the value type to have an implementation of <code>operator==()</code>.</li>
<li><code>T &amp; QVector::operator[](int i)</code>: Returns the item at index position <code>i</code> as a modifiable reference. <code>i</code> must be a valid index position in the vector (i.e., <code>0 &lt;= i &lt; size()</code>). Note that using <code>non-const</code> operators can cause <code>QVector</code> to do a deep copy.</li>
<li><code>const T &amp; QVector::operator[](int i) const</code>: This is an overloaded function. Same as <code>at(i)</code>.</li>
</ul>
<h3 id="Related-Non-Members-1"><a href="#Related-Non-Members-1" class="headerlink" title="Related Non-Members"></a>Related Non-Members</h3><ul>
<li><code>QDataStream &amp; operator&lt;&lt;(QDataStream &amp; out, const QVector&lt;T&gt; &amp; vector)</code>: Writes the <code>vector</code> to stream <code>out</code>. This function requires the value type to implement <code>operator&lt;&lt;()</code>.</li>
<li><code>QDataStream &amp; operator&gt;&gt;(QDataStream &amp; in, QVector&lt;T&gt; &amp; vector)</code>: Reads a vector from stream <code>in</code> into <code>vector</code>. This function requires the value type to implement <code>operator&gt;&gt;()</code>.</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/29/Qt语法详解/Qt之QTextCursor/" rel="next" title="Qt之QTextCursor">
                <i class="fa fa-chevron-left"></i> Qt之QTextCursor
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/31/Qt语法详解/Qt之QList/" rel="prev" title="Qt之QList">
                Qt之QList <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">958</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Public-Functions"><span class="nav-number">1.</span> <span class="nav-text">Public Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Static-Public-Members"><span class="nav-number">2.</span> <span class="nav-text">Static Public Members</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Related-Non-Members"><span class="nav-number">3.</span> <span class="nav-text">Related Non-Members</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Detailed-Description"><span class="nav-number">4.</span> <span class="nav-text">Detailed Description</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Member-Type-Documentation"><span class="nav-number">5.</span> <span class="nav-text">Member Type Documentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Member-Function-Documentation"><span class="nav-number">6.</span> <span class="nav-text">Member Function Documentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Related-Non-Members-1"><span class="nav-number">7.</span> <span class="nav-text">Related Non-Members</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
