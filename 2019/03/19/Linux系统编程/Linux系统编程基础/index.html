<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="系统调用之文件访问文件编程&amp;emsp;&amp;emsp;Linux文件编程可以使用两种方法：Linux系统调用和C语言库函数，前者依赖于Linux系统，后者与操作系统是独立的，在任何操作系统下，使用C语言库函数操作文件的方法都是相同的。 创建文件1int creat ( const char *filename, mode_t mode ); 参数filename是要创建的文件名(包含路径，缺省为当前路">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux系统编程基础">
<meta property="og:url" content="http://fukangwei.gitee.io/2019/03/19/Linux系统编程/Linux系统编程基础/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:description" content="系统调用之文件访问文件编程&amp;emsp;&amp;emsp;Linux文件编程可以使用两种方法：Linux系统调用和C语言库函数，前者依赖于Linux系统，后者与操作系统是独立的，在任何操作系统下，使用C语言库函数操作文件的方法都是相同的。 创建文件1int creat ( const char *filename, mode_t mode ); 参数filename是要创建的文件名(包含路径，缺省为当前路">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/03/19/Linux系统编程/Linux系统编程基础/1.png">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/03/19/Linux系统编程/Linux系统编程基础/2.png">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/03/19/Linux系统编程/Linux系统编程基础/3.png">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/03/19/Linux系统编程/Linux系统编程基础/4.png">
<meta property="og:updated_time" content="2019-03-20T00:36:04.678Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux系统编程基础">
<meta name="twitter:description" content="系统调用之文件访问文件编程&amp;emsp;&amp;emsp;Linux文件编程可以使用两种方法：Linux系统调用和C语言库函数，前者依赖于Linux系统，后者与操作系统是独立的，在任何操作系统下，使用C语言库函数操作文件的方法都是相同的。 创建文件1int creat ( const char *filename, mode_t mode ); 参数filename是要创建的文件名(包含路径，缺省为当前路">
<meta name="twitter:image" content="http://fukangwei.gitee.io/2019/03/19/Linux系统编程/Linux系统编程基础/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/2019/03/19/Linux系统编程/Linux系统编程基础/">





  <title>Linux系统编程基础 | 泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/19/Linux系统编程/Linux系统编程基础/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux系统编程基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T13:43:45+08:00">
                2019-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="系统调用之文件访问"><a href="#系统调用之文件访问" class="headerlink" title="系统调用之文件访问"></a>系统调用之文件访问</h3><h4 id="文件编程"><a href="#文件编程" class="headerlink" title="文件编程"></a>文件编程</h4><p>&emsp;&emsp;<code>Linux</code>文件编程可以使用两种方法：<code>Linux</code>系统调用和<code>C</code>语言库函数，前者依赖于<code>Linux</code>系统，后者与操作系统是独立的，在任何操作系统下，使用<code>C</code>语言库函数操作文件的方法都是相同的。</p>
<h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">mode_t</span> mode )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>filename</code>是要创建的文件名(包含路径，缺省为当前路径)，<code>mode</code>为创建模式。常见创建模式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_IRUSR</code></td>
<td>可读</td>
</tr>
<tr>
<td><code>S_IWUSR</code></td>
<td>可写</td>
</tr>
<tr>
<td><code>S_IXUSR</code></td>
<td>可执行</td>
</tr>
<tr>
<td><code>S_IRWXU</code></td>
<td>可读、写、执行</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;除了可以使用上述宏以外，还可以直接使用数字来表示文件的访问权限：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数字</th>
<th>权限</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1</code></td>
<td>可执行</td>
</tr>
<tr>
<td><code>2</code></td>
<td>可写</td>
</tr>
<tr>
<td><code>4</code></td>
<td>可读</td>
</tr>
<tr>
<td><code>6</code></td>
<td>可写可读(即<code>4 + 2</code>)</td>
</tr>
<tr>
<td><code>0</code></td>
<td>无任何权限</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;使用<code>creat</code>函数创建文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_file</span> <span class="params">( <span class="keyword">char</span> *filename )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( creat ( filename, <span class="number">0755</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"create file %s failure!\n"</span>, filename );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"create file %s success!\n"</span>, filename );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> ( argc &lt; <span class="number">2</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"you haven't input the filename, please try again!\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; argc; i++ ) &#123;</span><br><span class="line">        create_file ( argv[i] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span> ( EXIT_SUCCESS );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文件描述"><a href="#文件描述" class="headerlink" title="文件描述"></a>文件描述</h4><p>&emsp;&emsp;在<code>Linux</code>系统中，所有打开的文件都对应一个文件描述符。文件描述符的本质是一个非负整数。当打开一个文件时，该整数由系统来分配。文件描述符的范围是<code>0</code>至<code>OPEN_MAX</code>。早期<code>UNIX</code>的<code>OPEN_MAX</code>为<code>19</code>，即允许每个进程同时打开<code>20</code>个文件，现在很多系统则将其增加至<code>1024</code>。</p>
<h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>pathname</code>是要打开的文件名(包含路径，缺省为当前路径)，<code>flags</code>是打开标志。常见的打开标志：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_RDONLY</code></td>
<td>只读方式打开</td>
</tr>
<tr>
<td><code>O_WRONLY</code></td>
<td>只写方式打开</td>
</tr>
<tr>
<td><code>O_RDWR</code></td>
<td>读写方式打开</td>
</tr>
<tr>
<td><code>O_APPEND</code></td>
<td>追加方式打开</td>
</tr>
<tr>
<td><code>O_CREAT</code></td>
<td>创建一个文件</td>
</tr>
<tr>
<td><code>O_NOBLOCK</code></td>
<td>非阻塞方式打开</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;如果使用了<code>O_CREATE</code>标志，则使用的函数是<code>int open(const char *pathname, int flags, mode_t mode);</code>，这时需要指定<code>mode</code>来表示文件的访问权限。</p>
<h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p>&emsp;&emsp;当我们操作完文件以后，需要关闭文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span> <span class="params">( <span class="keyword">int</span> fd )</span></span>; <span class="comment">/* fd是文件描述符 */</span></span><br></pre></td></tr></table></figure>
<p>对文件进行打开或关闭操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc , <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ( argc &lt; <span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="built_in">puts</span> ( <span class="string">"please input the open file pathname!\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果flag参数里有O_CREAT，表示该文件如果不存在，系统则会创建该文件，</span></span><br><span class="line"><span class="comment">       该文件的权限由第三个参数决定，此处为0755。如果flah参数里没有O_CREAT参数，</span></span><br><span class="line"><span class="comment">       则第三个参数不起作用。此时，如果要打开的文件不存在，则会报错。</span></span><br><span class="line"><span class="comment">       所以“fd = open(argv[1], O_RDWR)”仅仅只是打开指定文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( fd = open ( argv[<span class="number">1</span>], O_CREAT | O_RDWR, <span class="number">0755</span> ) ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"open file failure!\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"open file %d  success!\n"</span>, fd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close ( fd );</span><br><span class="line">    <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span> <span class="params">( <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> length )</span></span>;</span><br></pre></td></tr></table></figure>
<p>从文件描述符<code>fd</code>所指定的文件中读取<code>length</code>个字节到<code>buf</code>所指向的缓冲区中，返回值为实际读取的字节数。</p>
<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span> <span class="params">( <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> length )</span></span>;</span><br></pre></td></tr></table></figure>
<p>把<code>length</code>个字节从<code>buf</code>指向的缓冲区中写到文件描述符<code>fd</code>所指向的文件中，返回值为实际写入的字节数。</p>
<h4 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lseek</span> <span class="params">( <span class="keyword">int</span> fd, <span class="keyword">offset_t</span> offset, <span class="keyword">int</span> whence )</span></span>;</span><br></pre></td></tr></table></figure>
<p>将文件读写指针相对<code>whence</code>移动<code>offset</code>个字节。操作成功时，返回文件指针相对于文件头的位置。<code>whence</code>可使用下述值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>whence</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SEEK_SET</code></td>
<td>相对文件开头</td>
</tr>
<tr>
<td><code>SEEK_CUR</code></td>
<td>相对文件读写指针的当前位置</td>
</tr>
<tr>
<td><code>SEEK_END</code></td>
<td>相对文件末尾</td>
</tr>
</tbody>
</table>
</div>
<p><code>offset</code>可取负值，表示向前移动。例如下述调用可将文件指针相对当前位置向前移动<code>5</code>个字节：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek ( fd, <span class="number">-5</span>, SEEK_CUR );</span><br></pre></td></tr></table></figure>
<p>由于<code>lseek</code>函数的返回值为文件指针相对于文件头的位置，因此下面调用的返回值就是文件的长度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lseek ( fd, <span class="number">0</span>, SEEK_END );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对文件进行读写操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fcntl.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO_DUP 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> NO_DUP</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="string">"123456789"</span>;</span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">10</span>];</span><br><span class="line">    fd = open ( <span class="string">"./test.txt"</span>, O_RDWR | O_CREAT, <span class="number">0755</span> ); <span class="comment">/* 打开文件 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"open file fail\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write ( fd, buf, <span class="number">7</span> ); <span class="comment">/* 写入文件 */</span></span><br><span class="line">    lseek ( fd, <span class="number">0</span>, SEEK_SET ); <span class="comment">/* 重定位文件指针 */</span></span><br><span class="line">    read ( fd, buf1, <span class="number">5</span> ); <span class="comment">/* 读文件 */</span></span><br><span class="line">    buf1[<span class="number">5</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"buf1 is %s\n"</span>, buf1 );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> fd1;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="string">"123456789"</span>;</span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">10</span>];</span><br><span class="line">    fd = open ( <span class="string">"./test.txt"</span>, O_RDWR | O_CREAT, <span class="number">0755</span> ); <span class="comment">/* 打开文件 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"open file fail\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd1 = dup ( fd );</span><br><span class="line">    write ( fd1, buf, <span class="number">7</span> ); <span class="comment">/* 写入文件 */</span></span><br><span class="line">    lseek ( fd1, <span class="number">0</span>, SEEK_SET ); <span class="comment">/* 重定位文件指针 */</span></span><br><span class="line">    read ( fd1, buf1, <span class="number">5</span> ); <span class="comment">/* 读文件 */</span></span><br><span class="line">    buf1[<span class="number">5</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"buf1 is %s\n"</span>, buf1 );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="文件访问判断"><a href="#文件访问判断" class="headerlink" title="文件访问判断"></a>文件访问判断</h4><p>&emsp;&emsp;有时需要判断文件是否可以进行某种操作(读、写等)，这时可以使用<code>access</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>pathname</code>是文件名称；<code>mode</code>是要判断的访问权限，可以取以下值或者是它们的组合：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>mode</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>R_OK</code></td>
<td>文件可读</td>
</tr>
<tr>
<td><code>W_OK</code></td>
<td>文件可写</td>
</tr>
<tr>
<td><code>X_OK</code></td>
<td>文件可执行</td>
</tr>
<tr>
<td><code>F_OK</code></td>
<td>文件存在</td>
</tr>
</tbody>
</table>
</div>
<p>当我们测试成功时，函数返回<code>0</code>，否则如果一个条件不符时，返回<code>-1</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( access ( <span class="string">"/etc/passwd"</span>, R_OK ) == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"/etc/passwd can be read!\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;使用系统调用实现对文件的复制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> from_fd, to_fd;</span><br><span class="line">    <span class="keyword">int</span> bytes_read, bytes_write;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">3</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Usage:%s fromfile tofile/n/a"</span>, argv[<span class="number">0</span>] );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ( from_fd = open ( argv[<span class="number">1</span>], O_RDONLY ) ) == <span class="number">-1</span> ) &#123; <span class="comment">/* 打开源文件 */</span></span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Open %s Error:%s/n"</span>, argv[<span class="number">1</span>], strerror ( errno ) );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建目的文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( to_fd = open ( argv[<span class="number">2</span>], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR ) ) == <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> ( <span class="built_in">stderr</span>, <span class="string">"Open %s Error:%s/n"</span>, argv[<span class="number">2</span>], strerror ( errno ) );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以下代码是一个经典的拷贝文件的代码 */</span></span><br><span class="line">    <span class="keyword">while</span> ( bytes_read = read ( from_fd, buffer, BUFFER_SIZE ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( ( bytes_read == <span class="number">-1</span> ) &amp;&amp; ( errno != EINTR ) ) &#123; <span class="comment">/* 一个致命的错误发生了 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( bytes_read &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            ptr = buffer;</span><br><span class="line">            <span class="keyword">while</span> ( bytes_write = write ( to_fd, ptr, bytes_read ) ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( ( bytes_write == <span class="number">-1</span> ) &amp;&amp; ( errno != EINTR ) ) &#123; <span class="comment">/* 一个致命错误发生了 */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( bytes_write == bytes_read ) &#123; <span class="comment">/* 写完了所有读的字节 */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( bytes_write &gt; <span class="number">0</span> ) &#123; <span class="comment">/* 只写了一部分，继续写 */</span></span><br><span class="line">                    ptr += bytes_write;</span><br><span class="line">                    bytes_read -= bytes_write;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( bytes_write == <span class="number">-1</span> ) &#123; <span class="comment">/* 写的时候发生的致命错误 */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close ( from_fd );</span><br><span class="line">    close ( to_fd );</span><br><span class="line">    <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="库函数之文件访问"><a href="#库函数之文件访问" class="headerlink" title="库函数之文件访问"></a>库函数之文件访问</h3><h4 id="文件创建和打开"><a href="#文件创建和打开" class="headerlink" title="文件创建和打开"></a>文件创建和打开</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>filename</code>为打开的文件名(包含路径，缺省为当前路径)；<code>mode</code>是打开模式，常见打开模式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>r</code>、<code>rb</code></td>
<td>只读方式打开</td>
</tr>
<tr>
<td><code>w</code>、<code>wb</code></td>
<td>只写方式打开，如果文件不存在，则创建该文件</td>
</tr>
<tr>
<td><code>a</code>、<code>ab</code></td>
<td>追加方式打开，如果文件不存在，则创建该文件</td>
</tr>
<tr>
<td><code>r+</code>、<code>r+b</code>、<code>rb+</code></td>
<td>读写方式打开</td>
</tr>
<tr>
<td><code>w+</code>、<code>w+b</code>、<code>wb+</code></td>
<td>读写方式打开，如果文件不存在，则创建该文件</td>
</tr>
<tr>
<td><code>a+</code>、<code>a+b</code>、<code>ab+</code></td>
<td>读和追加方式打开，如果文件不存在，则创建该文件</td>
</tr>
</tbody>
</table>
</div>
<p><code>b</code>用于区分二进制文件和文本文件，这一点在<code>DOS</code>、<code>Windows</code>系统中是有区分的，但<code>Linux</code>不区分二进制文件和文本文件。</p>
<h4 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fread ( <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> n, FILE *stream );</span><br></pre></td></tr></table></figure>
<p>从<code>stream</code>指向的文件中读取<code>n</code>个字段，每个字段为<code>size</code>字节，并将读取的数据放入<code>ptr</code>所指的字符数组中，返回实际已读取的字节数。</p>
<h4 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fwrite ( <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> n, FILE *stream );</span><br></pre></td></tr></table></figure>
<p>从缓冲区<code>ptr</code>所指的数组中把<code>n</code>个字段写到<code>stream</code>指向的文件中，每个字段长为<code>size</code>个字节，返回实际写入的字段数。</p>
<h4 id="读字符"><a href="#读字符" class="headerlink" title="读字符"></a>读字符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span> <span class="params">( FILE *stream )</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能是从指定的文件中读一个字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ( fp = fopen ( <span class="string">"1.txt"</span>, <span class="string">"r+"</span> ) ) == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Cannot open file strike any key exit!\n"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ch = fgetc ( fp );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( ch != EOF ) &#123;</span><br><span class="line">        <span class="built_in">putchar</span> ( ch );</span><br><span class="line">        ch = fgetc ( fp );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose ( fp );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="写字符"><a href="#写字符" class="headerlink" title="写字符"></a>写字符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span> <span class="params">( <span class="keyword">int</span> c, FILE *stream )</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能是向指定的文件中写入一个字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ( fp = fopen ( <span class="string">"1.txt"</span>, <span class="string">"w+"</span> ) ) == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Cannot open file￡?strike any key exit!"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"input a string:\n"</span> );</span><br><span class="line">    ch = getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( ch != <span class="string">'\n'</span> ) &#123;</span><br><span class="line">        fputc ( ch, fp );</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"\n"</span> );</span><br><span class="line">    fclose ( fp );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从输入直接复制到输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        fputc ( fgetc ( <span class="built_in">stdin</span> ), <span class="built_in">stdout</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式化读"><a href="#格式化读" class="headerlink" title="格式化读"></a>格式化读</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fscanf</span> ( FILE *stream, <span class="keyword">char</span> *format[, argument...] );</span><br></pre></td></tr></table></figure>
<p>功能是从一个流中进行格式化输入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Input an integer: "</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">fscanf</span> ( <span class="built_in">stdin</span>, <span class="string">"%d"</span>, &amp;i ) ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"The integer read was: %i\n"</span>, i );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式化写"><a href="#格式化写" class="headerlink" title="格式化写"></a>格式化写</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span> <span class="params">( FILE *stream, <span class="keyword">char</span> *format[, argument, ...] )</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能是格式化输出到一个流中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *stream;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> fp = <span class="number">1.5</span>;</span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"this is a string"</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'\n'</span>;</span><br><span class="line">    stream = fopen ( <span class="string">"1.txt"</span>, <span class="string">"w"</span> );</span><br><span class="line">    <span class="built_in">fprintf</span> ( stream, <span class="string">"%s%c"</span>, s, c );</span><br><span class="line">    <span class="built_in">fprintf</span> ( stream, <span class="string">"%d\n"</span>, i );</span><br><span class="line">    <span class="built_in">fprintf</span> ( stream, <span class="string">"%f\n"</span>, fp );</span><br><span class="line">    fclose ( stream );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文件定位-1"><a href="#文件定位-1" class="headerlink" title="文件定位"></a>文件定位</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span> <span class="params">( FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence )</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>whence</code>有如下选项：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>whence</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SEEK_SET</code></td>
<td>从文件的开始处开始搜索</td>
</tr>
<tr>
<td><code>SEEK_CUR</code></td>
<td>从当前位置开始搜索</td>
</tr>
<tr>
<td><code>SEEK_END</code></td>
<td>从文件的结束处开始搜索</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSEEK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FSEEK</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> *c_buf = <span class="string">"987654321"</span>;</span><br><span class="line">    fp = fopen ( <span class="string">"./test.bin"</span>, <span class="string">"r+"</span> );</span><br><span class="line">    <span class="comment">/* 如果使用“W+”，则test.bin会被抹掉 */</span></span><br><span class="line">    fseek ( fp, <span class="number">0</span>, SEEK_SET );</span><br><span class="line">    fwrite ( c_buf, <span class="number">5</span>, <span class="number">1</span>, fp );</span><br><span class="line">    fclose ( fp );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> c_buf[<span class="number">15</span>];</span><br><span class="line">    fp = fopen ( <span class="string">"./test.bin"</span>, <span class="string">"r+"</span> );</span><br><span class="line">    <span class="comment">/* 如果使用“W+”，则test.bin会被抹掉 */</span></span><br><span class="line">    fread ( c_buf, <span class="number">1</span>, <span class="number">10</span>, fp );</span><br><span class="line">    c_buf[<span class="number">10</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"now we read %s\n"</span>, c_buf );</span><br><span class="line">    fclose ( fp );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>使用库函数实现对文件的复制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</span><br><span class="line">    FILE *from_fd;</span><br><span class="line">    FILE *to_fd;</span><br><span class="line">    <span class="keyword">long</span> file_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">3</span> ) &#123; <span class="comment">/* 判断输入参数 */</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Usage:%s fromfile tofile\n"</span>, argv[<span class="number">0</span>] );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打开源文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( from_fd = fopen ( argv[<span class="number">1</span>], <span class="string">"rb"</span> ) ) == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Open %s Error\n"</span>, argv[<span class="number">1</span>] );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 创建目的文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( to_fd = fopen ( argv[<span class="number">2</span>], <span class="string">"wb"</span> ) ) == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"Open %s Error\n"</span>, argv[<span class="number">2</span>] );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 测得文件大小 */</span></span><br><span class="line">    fseek ( from_fd, <span class="number">0L</span>, SEEK_END );</span><br><span class="line">    file_len = ftell ( from_fd );</span><br><span class="line">    fseek ( from_fd, <span class="number">0L</span>, SEEK_SET );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"from file size is=%d\n"</span>, file_len );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( !feof ( from_fd ) ) &#123; <span class="comment">/* 进行文件拷贝 */</span></span><br><span class="line">        fread ( buffer, BUFFER_SIZE, <span class="number">1</span>, from_fd );</span><br><span class="line">        <span class="keyword">if</span> ( BUFFER_SIZE &gt;= file_len ) &#123;</span><br><span class="line">            fwrite ( buffer, file_len, <span class="number">1</span>, to_fd );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fwrite ( buffer, BUFFER_SIZE, <span class="number">1</span>, to_fd );</span><br><span class="line">            file_len = file_len - BUFFER_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        bzero ( buffer, BUFFER_SIZE );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose ( from_fd );</span><br><span class="line">    fclose ( to_fd );</span><br><span class="line">    <span class="built_in">exit</span> ( <span class="number">0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程控制理论基础"><a href="#进程控制理论基础" class="headerlink" title="进程控制理论基础"></a>进程控制理论基础</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>&emsp;&emsp;进程是一个具有一定独立功能的程序的一次运行活动。其特点有：动态性、并发性、独立性和异步性。进程的状态变换如下：</p>
<p><img src="/2019/03/19/Linux系统编程/Linux系统编程基础/1.png" height="244" width="306"></p>
<h4 id="进程ID"><a href="#进程ID" class="headerlink" title="进程ID"></a>进程ID</h4><p>&emsp;&emsp;进程<code>ID</code>(<code>PID</code>)是标识进程的唯一数字；<code>PPID</code>是父进程的<code>ID</code>，<code>UID</code>是启动进程的用户<code>ID</code>。</p>
<h4 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h4><p>&emsp;&emsp;进程互斥是指当有若干进程都要使用某一共享资源时，任何时刻最多允许一个进程使用，其他要使用该资源的进程必须等待，直到占用该资源者释放了该资源为止。</p>
<h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h4><p>&emsp;&emsp;操作系统中将一次只允许一个进程访问的资源称为<code>临界资源</code>。进程中访问临界资源的那段程序代码称为<code>临界区</code>。为实现对临界资源的互斥访问，应保证诸进程互斥地进入各自的临界区。</p>
<h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p>&emsp;&emsp;一组并发进程按一定的顺序执行的过程称为进程间的同步。具有同步关系的一组并发进程称为合作进程，合作进程间互相发送的信号称为消息或事件。</p>
<h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>&emsp;&emsp;概念：按一定算法，从一组待运行的进程中选出一个来占有<code>CPU</code>运行。调度方式主要有<code>抢占式</code>和<code>非抢占式</code>。调度算法主要有<code>先来先服务调度算法</code>、<code>短进程优先调度算法</code>、<code>高优先级优先调度算法</code>和<code>时间片轮转法</code>。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>&emsp;&emsp;多个进程因竞争资源而形成一种僵局，若无外力作用，这些进程都将永远不能再向前推进。</p>
<h4 id="进程控制编程"><a href="#进程控制编程" class="headerlink" title="进程控制编程"></a>进程控制编程</h4><p>&emsp;&emsp;获取<code>ID</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getpid ( <span class="keyword">void</span> ); <span class="comment">/* 获取本进程ID */</span></span><br><span class="line"><span class="keyword">pid_t</span> getppid ( <span class="keyword">void</span> ); <span class="comment">/* 获取父进程ID */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;使用例程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"PID = %d\n"</span>, getpid() );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"PPID = %d\n"</span>, getppid() );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程间通讯概述"><a href="#进程间通讯概述" class="headerlink" title="进程间通讯概述"></a>进程间通讯概述</h3><p>&emsp;&emsp;为什么进程间需要通信？</p>
<ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程。</li>
<li>资源共享：多个进程之间共享同样的资源。</li>
<li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它们发生了某种事件。</li>
<li>进程控制：有些进程希望完全控制另一个进程的执行(如<code>Debug</code>进程)，此时控制进程希望能够拦截另一个进程的所有操作，并能够及时知道它的状态改变。</li>
</ul>
<h4 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h4><p>&emsp;&emsp;<code>Linux</code>进程间通信(<code>IPC</code>)由以下几部分发展而来：</p>
<ul>
<li><code>UNIX</code>进程间通信。</li>
<li>基于<code>System V</code>进程间通信。</li>
<li><code>POSIX</code>进程间通信。</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>&emsp;&emsp;现在<code>Linux</code>使用的进程间通信方式包括：管道(<code>pipe</code>)和有名管道(<code>FIFO</code>)、信号(<code>signal</code>)、消息队列、共享内存、信号量、套接字(<code>socket</code>)。</p>
<h3 id="线程理论基础"><a href="#线程理论基础" class="headerlink" title="线程理论基础"></a>线程理论基础</h3><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>&emsp;&emsp;线程(<code>thread</code>)技术早在<code>60</code>年代就被提出，但真正应用多线程到操作系统中去，是在<code>80</code>年代中期，<code>solaris</code>是这方面的佼佼者。传统的<code>Unix</code>也支持线程的概念，但是在一个进程(<code>process</code>)中只允许有一个线程，这样多线程就意味着多进程。现在，多线程技术已经被许多操作系统所支持，包括<code>Windows NT</code>、<code>Linux</code>。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>&emsp;&emsp;使用多线程的理由之一：和进程相比，它是一种非常<code>节俭</code>的多任务操作方式。在<code>Linux</code>系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种<code>昂贵</code>的多任务工作方式。运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的<code>30</code>倍左右。<br>&emsp;&emsp;使用多线程的理由之二：线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。线程之间共享数据段，全局变量是数据段，局部变量是在栈里。多线程共享也有优先级，先用数据段(全局变量)，再用局部变量(栈)，进程的共享与之相反。<br>&emsp;&emsp;除了以上所说的优点外，多线程程序作为一种多任务、并发的工作方式，有如下优点：</p>
<ul>
<li>使多<code>CPU</code>系统更加有效：操作系统会保证当线程数不大于<code>CPU</code>数目时，不同的线程运行于不同的<code>CPU</code>上。</li>
<li>改善程序结构：一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。</li>
</ul>
<p>&emsp;&emsp;<code>Linux</code>系统下的多线程遵循<code>POSIX</code>线程接口，称为<code>pthread</code>。编写<code>Linux</code>下的多线程程序，需要使用头文件<code>pthread.h</code>，连接时需要使用库<code>libpthread.a</code>。默认情况下，<code>GCC</code>在编译的时候使用的是<code>C</code>库。</p>
<h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">pthread_t</span> *tidp, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> * ( *start_rtn ) ( <span class="keyword">void</span> ), <span class="keyword">void</span> *arg )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>tidp</code>是线程<code>id</code>，<code>attr</code>是线程属性(通常为空)，<code>start_rtn</code>是线程要执行的函数，<code>arg</code>是<code>start_rtn</code>的参数。<br>&emsp;&emsp;<code>pthread_create</code>创建线程并使线程进入就绪态，而不是执行态。在进程执行到<code>sleep</code>函数时，它交出<code>cpu</code>控制权，于是线程得以执行。执行完线程后，这个线程也消失了。<br>&emsp;&emsp;线程的使用(无参数)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* getpid() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">create</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"New thread .... \n"</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"This thread's id is %u\n"</span>, ( <span class="keyword">unsigned</span> <span class="keyword">int</span> ) pthread_self() );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"The process pid is %d\n"</span>, getpid() );</span><br><span class="line">    <span class="keyword">return</span> ( <span class="keyword">void</span> * ) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"Main thread is starting ... \n"</span> );</span><br><span class="line">    error = pthread_create ( &amp;tid, <span class="literal">NULL</span>, create, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( error ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"thread is not created ... \n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"The main process's pid is %d  \n"</span>, getpid() );</span><br><span class="line">    sleep ( <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;线程的使用(使用参数)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">create</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">    num = ( <span class="keyword">int</span> * ) arg;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"create parameter is %d \n"</span>, *num );</span><br><span class="line">    <span class="keyword">return</span> ( <span class="keyword">void</span> * ) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc , <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tidp;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">int</span> test = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> *attr = &amp;test;</span><br><span class="line">    error = pthread_create ( &amp;tidp, <span class="literal">NULL</span>, create, ( <span class="keyword">void</span> * ) attr );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( error ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"pthread_create is created is not created ... \n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep ( <span class="number">1</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"pthread_create is created ...\n"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;线程的使用(使用复杂参数)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">menber</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">create</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123; <span class="comment">/* 线程执行函数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">menber</span> *<span class="title">temp</span>;</span></span><br><span class="line">    temp = ( struct menber * ) arg;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"menber-&gt;a = %d  \n"</span>, temp-&gt;a );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"menber-&gt;s = %s  \n"</span>, temp-&gt;s );</span><br><span class="line">    <span class="keyword">return</span> ( <span class="keyword">void</span> * ) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tidp;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">menber</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="comment">/* 为结构体指针b分配内存并赋值 */</span></span><br><span class="line">    b = ( struct menber * ) <span class="built_in">malloc</span> ( <span class="keyword">sizeof</span> ( struct menber ) );</span><br><span class="line">    b-&gt;a = <span class="number">4</span>;</span><br><span class="line">    b-&gt;s = <span class="string">"zieckey"</span>;</span><br><span class="line">    <span class="comment">/* 创建线程并运行线程执行函数 */</span></span><br><span class="line">    error = pthread_create ( &amp;tidp, <span class="literal">NULL</span>, create, ( <span class="keyword">void</span> * ) b );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( error ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"phread is not created...\n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep ( <span class="number">1</span> ); <span class="comment">/* 进程睡眠一秒使线程执行完后进程才会结束 */</span></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"pthread is created...\n"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译多线程代码"><a href="#编译多线程代码" class="headerlink" title="编译多线程代码"></a>编译多线程代码</h4><p>&emsp;&emsp;因为<code>pthread</code>的库不是<code>linux</code>系统的库，所以在进行编译的时候要加上<code>-lpthread</code>，如<code>gcc filename -lpthread</code>。</p>
<h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><p>&emsp;&emsp;如果进程中任何一个线程中调用<code>exit</code>或<code>_exit</code>，那么整个进程都会终止。线程的正常退出方式有：</p>
<ul>
<li>线程从启动例程中返回。</li>
<li>线程可以被另一个进程终止。</li>
<li>线程自己调用<code>pthread_exit</code>函数。</li>
</ul>
<h4 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span> <span class="params">( <span class="keyword">void</span> *rval_ptr )</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能为终止调用线程。参数<code>rval_ptr</code>是线程退出返回值的指针。<br>&emsp;&emsp;线程的设置与退出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> message[<span class="number">32</span>] = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_function</span> <span class="params">( <span class="keyword">void</span> *arg )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> a_thread;</span><br><span class="line">    <span class="keyword">void</span> *thread_result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( pthread_create ( &amp;a_thread, <span class="literal">NULL</span>, thread_function, ( <span class="keyword">void</span> * ) message ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fail to pthread_create"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"waiting for thread to finish\n"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( pthread_join ( a_thread, &amp;thread_result ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fail to pthread_join"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"MESSAGE is now %s\n"</span>, message );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_function</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"thread_function is running, argument is %s\n"</span>, ( <span class="keyword">char</span> * ) arg );</span><br><span class="line">    <span class="built_in">strcpy</span> ( message, <span class="string">"marked by thread"</span> );</span><br><span class="line">    pthread_exit ( <span class="string">"Thank you for the cpu time"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span> <span class="params">( <span class="keyword">pthread_t</span> tid, <span class="keyword">void</span> **rval_ptr )</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能是阻塞调用线程，直到指定的线程终止。参数<code>tid</code>是等待退出的线程<code>id</code>，<code>rval_ptr</code>是线程退出的返回值的指针。<br>&emsp;&emsp;<code>pthread_join</code>的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span> <span class="params">( <span class="keyword">void</span> *str )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i ) &#123;</span><br><span class="line">        sleep ( <span class="number">1</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"This in the thread : %d\n"</span> , i );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pth;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create ( &amp;pth, <span class="literal">NULL</span>, thread, ( <span class="keyword">void</span> * ) ( <span class="number">0</span> ) );</span><br><span class="line">    pthread_join ( pth, <span class="literal">NULL</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"\n"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i ) &#123;</span><br><span class="line">        sleep ( <span class="number">1</span> );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"This in the main : %d\n"</span> , i );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;带有参数的<code>pthread_join</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">create</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"new thread is created ... \n"</span> );</span><br><span class="line">    <span class="keyword">return</span> ( <span class="keyword">void</span> * ) <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">void</span> *temp;</span><br><span class="line">    error = pthread_create ( &amp;tid, <span class="literal">NULL</span>, create, <span class="literal">NULL</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"main thread!\n"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( error ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"thread is not created ... \n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error = pthread_join ( tid, &amp;temp );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( error ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"thread is not exit ... \n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"thread is exit code %d \n"</span>, ( <span class="keyword">int</span> ) temp );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self ( <span class="keyword">void</span> );</span><br></pre></td></tr></table></figure>
<p>功能是获取调用线程的<code>thread identifier</code>，返回线程的<code>ID</code>。</p>
<h4 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h4><p>&emsp;&emsp;线程终止有两种情况：正常终止和非正常终止。线程主动调用<code>pthread_exit</code>或者从线程函数中<code>return</code>都将使线程正常退出，这是可预见的退出方式；非正常终止是线程在其他线程的干预下，或者由于自身运行出错(比如访问非法地址)而退出，这种退出方式是不可预见的(非正常的例子有访问空指针)。<br>&emsp;&emsp;不论是可预见的线程终止还是异常终止，都会存在资源释放的问题，如何保证线程终止时能顺利的释放掉自己所占用的资源，是一个必须考虑解决的问题。<br>&emsp;&emsp;从<code>pthread_cleanup_push</code>的调用点到<code>pthread_cleanup_pop</code>之间的程序段中的终止动作(包括调用<code>pthread_exit</code>和异常终止，不包括<code>return</code>)都将执行<code>pthread_cleanup_push</code>所指定的清理函数。当某段代码有不可预知的非正常终止行为，就用<code>push</code>和<code>pop</code>保护起来。保护了之后，如果这段代码有不可预知的终止，我们就可以固定地在它终止之前去执行某一个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span> <span class="params">( <span class="keyword">void</span> ( *rtn ) ( <span class="keyword">void</span> * ), <span class="keyword">void</span> *arg )</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能是将清除函数压入清除栈。参数<code>Rtn</code>是清除函数，<code>Arg</code>是清除函数的参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span> <span class="params">( <span class="keyword">int</span> execute )</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能是将清除函数弹出清除栈。参数<code>execute</code>决定执行到<code>pthread_cleanup_pop</code>时是否在弹出清理函数的同时执行该函数，非<code>0</code>为执行，<code>0</code>为不执行。<br>&emsp;&emsp;线程的清除：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">clean</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"cleanup :%s  \n"</span>, ( <span class="keyword">char</span> * ) arg );</span><br><span class="line">    <span class="keyword">return</span> ( <span class="keyword">void</span> * ) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn1</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"thread 1 start  \n"</span> );</span><br><span class="line">    pthread_cleanup_push ( ( <span class="keyword">void</span> * ) clean, <span class="string">"thread 1 first handler"</span> );</span><br><span class="line">    pthread_cleanup_push ( ( <span class="keyword">void</span> * ) clean, <span class="string">"thread 1 second hadler"</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"thread 1 push complete  \n"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( arg ) &#123;</span><br><span class="line">        <span class="keyword">return</span> ( ( <span class="keyword">void</span> * ) <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop ( <span class="number">0</span> );</span><br><span class="line">    pthread_cleanup_pop ( <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">return</span> ( <span class="keyword">void</span> * ) <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn2</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"thread 2 start  \n"</span> );</span><br><span class="line">    pthread_cleanup_push ( ( <span class="keyword">void</span> * ) clean, <span class="string">"thread 2 first handler"</span> );</span><br><span class="line">    pthread_cleanup_push ( ( <span class="keyword">void</span> * ) clean, <span class="string">"thread 2 second handler"</span> );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"thread 2 push complete  \n"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( arg ) &#123;</span><br><span class="line">        pthread_exit ( ( <span class="keyword">void</span> * ) <span class="number">2</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop ( <span class="number">0</span> );</span><br><span class="line">    pthread_cleanup_pop ( <span class="number">0</span> );</span><br><span class="line">    pthread_exit ( ( <span class="keyword">void</span> * ) <span class="number">2</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="keyword">void</span> *tret;</span><br><span class="line">    err = pthread_create ( &amp;tid1, <span class="literal">NULL</span>, thr_fn1, ( <span class="keyword">void</span> * ) <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( err != <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"error .... \n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = pthread_create ( &amp;tid2, <span class="literal">NULL</span>, thr_fn2, ( <span class="keyword">void</span> * ) <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( err != <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"error .... \n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = pthread_join ( tid1, &amp;tret );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( err != <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"error .... \n"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"thread 1 exit code %d  \n"</span>, ( <span class="keyword">int</span> ) tret );</span><br><span class="line">    err = pthread_join ( tid2, &amp;tret );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( err != <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"error .... "</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"thread 2 exit code %d  \n"</span>, ( <span class="keyword">int</span> ) tret );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;具体解释如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push ( A );</span><br><span class="line">可能出现异常终止的代码;</span><br><span class="line">pop ( <span class="number">0</span>或非<span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p>假如<code>push</code>函数指明了<code>A</code>函数，在异常终止时，函数得到调用，可以在函数里释放资源，由<code>A</code>函数执行清除工作。如果没有出现异常，当执行到<code>pop</code>函数时，<code>pop</code>函数会决定<code>A</code>函数是否还要执行。</p>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>&emsp;&emsp;进行多线程编程，因为无法知道哪个线程会在哪个时候对共享资源进行操作，因此让如何保护共享资源变得复杂，通过下面这些技术的使用，可以解决线程之间对资源的竞争：</p>
<ul>
<li>互斥量<code>Mutex</code>。</li>
<li>信号灯<code>Semaphore</code>。</li>
<li>条件变量<code>Conditions</code>。</li>
</ul>
<p>&emsp;&emsp;线程的同步：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"semaphore.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">60</span>];</span><br><span class="line"><span class="keyword">sem_t</span> sem;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">function</span> <span class="params">( <span class="keyword">void</span> *arg )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> a_thread;</span><br><span class="line">    <span class="keyword">void</span> *thread_result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( sem_init ( &amp;sem, <span class="number">0</span>, <span class="number">0</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fail to sem_init"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( pthread_create ( &amp;a_thread, <span class="literal">NULL</span>, function, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fail to pthread_creat"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"input 'quit' to exit\n"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        fgets ( buf, <span class="number">60</span>, <span class="built_in">stdin</span> );</span><br><span class="line">        sem_post ( &amp;sem );</span><br><span class="line">    &#125; <span class="keyword">while</span> ( <span class="built_in">strncmp</span> ( buf, <span class="string">"quit"</span>, <span class="number">4</span> ) != <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">function</span> <span class="params">( <span class="keyword">void</span> *argc )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        sem_wait ( &amp;sem );</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"You enter %d character\n"</span>, <span class="built_in">strlen</span> ( buf ) - <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h4><p>&emsp;&emsp;为什么需要互斥量？代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Item *p = queue_list;</span><br><span class="line">Queue_list = queue_list-&gt;next;</span><br><span class="line">process_job ( p );</span><br><span class="line"><span class="built_in">free</span> ( p );</span><br></pre></td></tr></table></figure>
<p>当线程<code>1</code>处理完<code>Item *p = queue_list</code>后，系统停止线程1的运行，改而运行线程<code>2</code>。线程<code>2</code>照样取出头节点，然后进行处理，最后释放了该节点。过了一段时间，线程<code>1</code>重新得到运行。而这个时候，<code>p</code>所指向的节点已经被线程<code>2</code>释放掉，而线程<code>1</code>对此毫无知晓，它会接着运行<code>process_job(p)</code>，而这将导致无法预料的后果！<br>&emsp;&emsp;对于这种情况，系统给我们提供了互斥量。线程在取出头节点前必须要等待互斥量，如果此时有其他线程已经获得该互斥量，那么该线程将会阻塞在这里。只有等到其他线程释放掉该互斥量后，该线程才有可能得到该互斥量。互斥量从本质上说就是一把锁，提供对共享资源的保护访问。</p>
<h4 id="创建互斥量"><a href="#创建互斥量" class="headerlink" title="创建互斥量"></a>创建互斥量</h4><p>&emsp;&emsp;在<code>Linux</code>中，互斥量使用类型<code>pthread_mutex_t</code>表示。在使用前，要对它进行初始化：</p>
<ul>
<li>对于静态分配的互斥量，可以把它设置为默认的<code>mutex</code>对象<code>PTHREAD_MUTEX_INITIALIZER</code>。</li>
<li>对于动态分配的互斥，在申请内存(<code>malloc</code>)之后，通过<code>pthread_mutex_init</code>进行初始化，并且在释放内存(<code>free</code>)前需要调用<code>pthread_mutex_destroy</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span> <span class="params">( <span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span> <span class="params">( <span class="keyword">pthread_mutex_t</span> *mutex )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>&emsp;&emsp;对共享资源的访问，要使用互斥量进行加锁，如果互斥量已经上了锁，调用线程会阻塞，直到互斥量被解锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span> <span class="params">( <span class="keyword">pthread_mutex_t</span> *mutex )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span> <span class="params">( <span class="keyword">pthread_mutex_t</span> *mutex )</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数执行成功则返回<code>0</code>，出错则返回错误编号。<br>&emsp;&emsp;<code>trylock</code>是非阻塞调用模式，如果互斥量没被锁住，<code>trylock</code>函数将对互斥量加锁，并获得对共享资源的访问权限；如果互斥量被锁住了，<code>trylock</code>函数将不会阻塞等待而直接返回<code>EBUSY</code>，表示共享资源处于忙状态。</p>
<h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>&emsp;&emsp;在操作完成后，必须给互斥量解锁，也就是前面所说的释放。这样，其他等待该锁的线程才有机会获得该锁，否则其他线程将会永远阻塞。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span> <span class="params">( <span class="keyword">pthread_mutex_t</span> *mutex )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="互斥量-vs-信号量"><a href="#互斥量-vs-信号量" class="headerlink" title="互斥量 vs 信号量"></a>互斥量 vs 信号量</h4><p>&emsp;&emsp;<code>Mutex</code>是一把钥匙，一个人拿了就可进入一个房间，出来的时候把钥匙交给队列的第一个。<code>Semaphore</code>是一件可以容纳<code>N</code>人的房间，如果人不满就可以进去；如果人满了，就要等待有人出来。对于<code>N = 1</code>的情况，称为<code>binary semaphore</code>。<code>Binary semaphore</code>与<code>Mutex</code>的差异：<code>mutex</code>要由获得锁的线程来释放(谁获得，谁释放)，<code>semaphore</code>可以由其它线程释放；初始状态可能不一样，<code>mutex</code>的初始值是<code>1</code>，而<code>semaphore</code>的初始值可能是<code>0</code>(或者为<code>1</code>)。<br>&emsp;&emsp;线程的互斥：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LOCK_ 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value1 = <span class="number">1</span>, value2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">function</span> <span class="params">( <span class="keyword">void</span> *arg )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> a_thread;</span><br><span class="line">    <span class="keyword">void</span> *thread_result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( pthread_mutex_init ( &amp;mutex, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fail to mutex_init"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( pthread_create ( &amp;a_thread, <span class="literal">NULL</span>, function, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        perror ( <span class="string">"fail to pthread_create"</span> );</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        sleep ( <span class="number">1</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LOCK_</span></span><br><span class="line">        pthread_mutex_lock ( &amp;mutex );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        value1 = count;</span><br><span class="line">        value2 = count;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"count = %d, value1 = %d, value2 = %d\n"</span>, count, value1, value2 );</span><br><span class="line">        value1 = ++count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LOCK_</span></span><br><span class="line">        pthread_mutex_unlock ( &amp;mutex );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">function</span> <span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">        sleep ( <span class="number">1</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LOCK_</span></span><br><span class="line">        pthread_mutex_lock ( &amp;mutex );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> ( value1 != value2 ) &#123;</span><br><span class="line">            <span class="built_in">printf</span> ( <span class="string">"count = %d, value1 = %d, value2 = %d\n"</span>, count, value1, value2 );</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LOCK_</span></span><br><span class="line">        pthread_mutex_unlock ( &amp;mutex );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Linux网络编程"><a href="#Linux网络编程" class="headerlink" title="Linux网络编程"></a>Linux网络编程</h3><h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h4><p><img src="/2019/03/19/Linux系统编程/Linux系统编程基础/2.png" height="262" width="926"></p>
<h4 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h4><p>&emsp;&emsp;<code>TCP/IP</code>实际上一个协同工作的通信家族，为网络数据通信提供通路。为讨论方便可<code>TCP/IP</code>协议组大体上分为三部分：</p>
<ul>
<li><code>Internet</code>协议(<code>IP</code>)。</li>
<li>传输控制协议(<code>TCP</code>)和用户数据报协议(<code>UDP</code>)。</li>
<li>处于<code>TCP</code>和<code>UDP</code>之上的一组应用协议，它们包括<code>TELNET</code>、文件传送协议(<code>FTP</code>)、域名服务(<code>DNS</code>)和简单邮件传送程序(<code>SMTP</code>)等。</li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>&emsp;&emsp;第一部分称为网络层。主要包括<code>Internet</code>协议(<code>IP</code>)、网际控制报文协议(<code>ICMP</code>)和地址解析协议(<code>ARP</code>)。</p>
<ul>
<li><code>Internet</code>协议(<code>IP</code>)：该协议被设计成互联分组交换通信网，以形成一个网际通信环境。它负责在源主机和目的地主机之间传输来自其较高层软件的称为数据报文的数据块，它在源和目的地之间提供非连接型传递服务。</li>
<li>网际控制报文协议(<code>ICMP</code>)：它实际上不是<code>IP</code>层部分，但直接同<code>IP</code>层一起工作，报告网络上的某些出错情况。允许网际路由器传输差错信息或测试报文。</li>
<li>地址解析协议(<code>ARP</code>)：<code>ARP</code>实际上不是网络层部分，它处于<code>IP</code>和数据链路层之间，它是在<code>32</code>位<code>IP</code>地址和<code>48</code>位物理地址之间执行翻译的协议。</li>
</ul>
<h4 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h4><p>&emsp;&emsp;第二部分是传输层协议，包括传输控制协议和用户数据报文协议。</p>
<ul>
<li>传输控制协议(<code>TCP</code>)：该协议对建立网络上用户进程之间的对话负责，它确保进程之间的可靠通信，所提供的功能如下：监听输入对话建立请求、请求另一网络站点对话、可靠的发送和接收数据和适度的关闭对话。</li>
<li>用户数据报文协议(<code>UDP</code>)：<code>UDP</code>提供不可靠的非连接型传输层服务，它允许在源和目的地之间传送数据，而不必在传送数据之前建立对话。它主要用于那些非连接型的应用程序，如视频点播。</li>
</ul>
<h4 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h4><p>&emsp;&emsp;这部分主要包括<code>Telnet</code>、文件传送协议(<code>FTP</code>和<code>TFTP</code>)，简单文件传送协议(<code>SMTP</code>)和域名服务(<code>DNS</code>)等协议。</p>
<h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>&emsp;&emsp;<code>IP</code>主要有以下四个主要功能：数据传送、寻址、路由选择和数据报文的分段。<br>&emsp;&emsp;<code>IP</code>的主要目的是为数据<code>输入/输出</code>网络提供基本算法，为高层协议提供无连接的传送服务。这意味着在<code>IP</code>将数据递交给接收站点以前不在传输站点和接收站点之间建立对话。它只是封装和传递数据，但不向发送者或接收者报告包的状态，不处理所遇到的故障。</p>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>&emsp;&emsp;<code>TCP</code>是重要的传输层协议，目的是允许数据同网络上的其他节点进行可靠的交换。它能提供端口编号的译码，以识别主机的应用程序，而且完成数据的可靠传输。<code>TCP</code>协议具有严格的内装差错检验算法确保数据的完整性。<code>TCP</code>是面向字节的顺序协议，这意味着包内的每个字节被分配一个顺序编号，并分配给每包一个顺序编号。</p>
<h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>&emsp;&emsp;<code>UDP</code>也是传输层协议，它是无连接的，不可靠的传输服务。当接收数据时它不向发送方提供确认信息，它不提供输入包的顺序，如果出现丢失包或重份包的情况，也不会向发送方发出差错报文。由于它执行功能时具有较低的开销，因而执行速度比<code>TCP</code>快。</p>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>&emsp;&emsp;<code>Linux</code>中的网络编程通过<code>Socket</code>接口实现，<code>Socket</code>是一种文件描述符。套接字<code>socket</code>有三种类型：</p>
<ul>
<li>流式套接字(<code>SOCK_STREAM</code>)：流式的套接字可以提供可靠的、面向连接的通讯流。它使用了<code>TCP</code>协议。<code>TCP</code>保证了数据传输的正确性和顺序性。</li>
<li>数据报套接字(<code>SOCK_DGRAM</code>)：数据报套接字定义了一种无连接的服务，数据通过相互独立的报文进行传输，是无序的，并且不保证可靠，无差错，它使用数据报协议<code>UDP</code>。</li>
<li>原始套接字：原始套接字允许对低层协议如<code>IP</code>或<code>ICMP</code>直接访问，主要用于新的网络协议的测试等。</li>
</ul>
<h4 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    u_short sa_family; <span class="comment">/* 地址族，采用“AF_xxx”的形式，如AF_INET */</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">/* 14字节的特定协议地址 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s_addr; <span class="comment">/* 32位的地址 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sin_family; <span class="comment">/* Internet地址族 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port; <span class="comment">/* 端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* IP地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/* 填0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编程中一般并不直接针对<code>sockaddr</code>数据结构操作，而是使用与<code>sockaddr</code>等价的<code>sockaddr_in</code>数据结构。</p>
<h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p>&emsp;&emsp;<code>IP</code>地址通常由数字加点(<code>192.168.0.1</code>)的形式表示，而在<code>struct in_addr</code>中使用的是<code>IP</code>地址是由<code>32</code>位的整数表示的。为了进行转换，我们可以使用下面两个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span> <span class="params">( struct in_addr in )</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数里面的<code>a</code>代表<code>ascii</code>，<code>n</code>代表<code>network</code>。第一个函数表示将<code>a.b.c.d</code>形式的<code>IP</code>转换为<code>32</code>位的<code>IP</code>，存储在<code>inp</code>指针里面。第二个是将<code>32</code>位<code>IP</code>转换为<code>a.b.c.d</code>的格式。</p>
<h4 id="字节序转换"><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h4><p>&emsp;&emsp;不同类型的<code>CPU</code>对变量的字节存储顺序可能不同：有的系统是高位在前，低位在后，而有的系统是低位在前，高位在后，而网络传输的数据顺序是一定要统一的。所以当内部字节存储顺序和网络字节顺序不同时，就一定要进行转换。<br>&emsp;&emsp;网络字节顺序是<code>TCP/IP</code>中规定好的一种数据表示格式，它与具体的<code>CPU</code>类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用<code>big endian</code>排序方式。</p>
<ul>
<li><code>htons</code>：把<code>unsigned short</code>类型从主机序转换到网络序。</li>
<li><code>htonl</code>：把<code>unsigned long</code>类型从主机序转换到网络序。</li>
<li><code>ntohs</code>：把<code>unsigned short</code>类型从网络序转换到主机序。</li>
<li><code>ntohl</code>：把<code>unsigned long</code>类型从网络序转换到主机序。</li>
</ul>
<h4 id="IP与主机名"><a href="#IP与主机名" class="headerlink" title="IP与主机名"></a>IP与主机名</h4><p>&emsp;&emsp;在网络上标识一台机器可以用<code>IP</code>，也可以使用主机名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *h_name;       <span class="comment">/* 主机的正式名称 */</span></span><br><span class="line">    <span class="keyword">char</span> *h_aliases;    <span class="comment">/* 主机的别名 */</span></span><br><span class="line">    <span class="keyword">int</span> h_addrtype;     <span class="comment">/* 主机的地址类型 */</span></span><br><span class="line">    <span class="keyword">int</span> h_length;       <span class="comment">/* 主机的地址长度 */</span></span><br><span class="line">    <span class="keyword">char</span> **h_addr_list; <span class="comment">/* 主机的IP地址列表 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> h_addr h_addr_list[0] <span class="comment">/* 主机的第一个IP地址 */</span></span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *hostname )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h4><p>&emsp;&emsp;进行<code>Socket</code>编程的常用函数有：</p>
<ul>
<li><code>socket</code>：创建一个<code>socket</code>。</li>
<li><code>bind</code>：用于绑定<code>IP</code>地址和端口号到<code>socket</code>。</li>
<li><code>connect</code>：该函数用于绑定之后的<code>client</code>端，与服务器建立连接。</li>
<li><code>listen</code>：设置能处理的最大连接要求，<code>Listen</code>并未开始接收连线，只是设置<code>socket</code>为<code>listen</code>模式。</li>
<li><code>accept</code>：用来接受<code>socket</code>连接。</li>
<li><code>send</code>：发送数据。</li>
<li><code>recv</code>：接收数据。</li>
</ul>
<h4 id="基于TCP的服务器"><a href="#基于TCP的服务器" class="headerlink" title="基于TCP的服务器"></a>基于TCP的服务器</h4><ol>
<li>创建一个<code>socket</code>，用函数<code>socket</code>。</li>
<li>绑定<code>IP</code>地址、端口等信息到<code>socket</code>上，用函数<code>bind</code>。</li>
<li>设置允许的最大连接数，用函数<code>listen</code>。</li>
<li>接收客户端上来的连接，用函数<code>accept</code>。</li>
<li>收发数据，用函数<code>send</code>和<code>recv</code>，或者<code>read</code>和<code>write</code>。</li>
<li>关闭网络连接。</li>
</ol>
<h4 id="基于TCP的客户端"><a href="#基于TCP的客户端" class="headerlink" title="基于TCP的客户端"></a>基于TCP的客户端</h4><ol>
<li>创建一个<code>socket</code>，用函数<code>socket</code>。</li>
<li>设置要连接的对方的<code>IP</code>地址和端口等属性。</li>
<li>连接服务器，用函数<code>connect</code>。</li>
<li>收发数据，用函数<code>send</code>和<code>recv</code>，或者<code>read</code>和<code>write</code>。</li>
<li>关闭网络连接。</li>
</ol>
<p><img src="/2019/03/19/Linux系统编程/Linux系统编程基础/3.png" height="244" width="277"></p>
<h4 id="基于UDP的服务器"><a href="#基于UDP的服务器" class="headerlink" title="基于UDP的服务器"></a>基于UDP的服务器</h4><ol>
<li>创建一个<code>socket</code>，用函数<code>socket</code>。</li>
<li>绑定<code>IP</code>地址、端口等信息到<code>socket</code>上，用函数<code>bind</code>。</li>
<li>设置对方的<code>IP</code>地址和端口等属性。</li>
<li>发送数据，用函数<code>sendto</code>。</li>
<li>关闭网络连接。</li>
</ol>
<p><img src="/2019/03/19/Linux系统编程/Linux系统编程基础/4.png" height="296" width="374"></p>
<h4 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h4><p>&emsp;&emsp;在网络程序里面，一般来说都是许多客户对应一个服务器，为了处理客户的请求，对服务端的程序就提出了特殊的要求。目前最常用的服务器模型有：</p>
<ul>
<li>循环服务器：服务器在同一个时刻只可以响应一个客户端的请求。</li>
<li>并发服务器：服务器在同一个时刻可以响应多个客户端的请求。</li>
</ul>
<h4 id="UDP循环服务器"><a href="#UDP循环服务器" class="headerlink" title="UDP循环服务器"></a>UDP循环服务器</h4><p>&emsp;&emsp;<code>UDP</code>循环服务器的实现方法：<code>UDP</code>服务器每次从套接字上读取一个客户端的请求，然后进行处理，最后将结果返回给客户机。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">socket ( ... );</span><br><span class="line">bind ( ... );</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">    recvfrom ( ... );</span><br><span class="line">    process ( ... );</span><br><span class="line">    sendto ( ... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>UDP</code>是非面向连接的，没有一个客户端可以老是占住服务端，服务器对于每一个客户机的请求总是能够满足。</p>
<h4 id="TCP循环服务器"><a href="#TCP循环服务器" class="headerlink" title="TCP循环服务器"></a>TCP循环服务器</h4><p>&emsp;&emsp;<code>TCP</code>服务器接受一个客户端的连接，然后处理，完成了这个客户的所有请求后，断开连接。算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">socket ( ... );</span><br><span class="line">bind ( ... );</span><br><span class="line">listen ( ... );</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">    accept ( ... );</span><br><span class="line">    process ( ... );</span><br><span class="line">    close ( ... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TCP</code>循环服务器一次只能处理一个客户端的请求。只有在这个客户的所有请求都满足后，服务器才可以继续后面的请求。这样如果有一个客户端占住服务器不放时，其它的客户机都不能工作了，因此<code>TCP</code>服务器一般很少用循环服务器模型的。</p>
<h4 id="TCP并发服务器"><a href="#TCP并发服务器" class="headerlink" title="TCP并发服务器"></a>TCP并发服务器</h4><p>&emsp;&emsp;并发服务器的思想是每一个客户机的请求并不由服务器直接处理，而是由服务器创建一个子进程来处理。算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">socket ( ... );</span><br><span class="line">bind ( ... );</span><br><span class="line">listen ( ... );</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">    accept ( ... );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( fork ( .. ) == <span class="number">0</span> ) &#123;</span><br><span class="line">        process ( ... );</span><br><span class="line">        close ( ... );</span><br><span class="line">        <span class="built_in">exit</span> ( ... );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close ( ... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TCP</code>并发服务器可以解决<code>TCP</code>循环服务器客户机独占服务器的情况。但同时也带来了问题：为了响应客户的请求，服务器要创建子进程来处理，而创建子进程是一种非常消耗资源的操作。</p>
<h4 id="多路复用I-O"><a href="#多路复用I-O" class="headerlink" title="多路复用I/O"></a>多路复用I/O</h4><p>&emsp;&emsp;阻塞函数在完成其指定的任务以前不允许程序继续向下执行。例如，当服务器运行到<code>accept</code>语句时，而没有客户请求连接，服务器就会停止在<code>accept</code>语句上等待连接请求的到来，这种情况称为阻塞(<code>blocking</code>)。而非阻塞操作则可以立即完成，例如，如果你希望服务器仅仅检查是否有客户在等待连接，有就接受连接，否则就继续做其他事情，则可以通过使用<code>select</code>系统调用来实现。除此之外，<code>select</code>还可以同时监视多个套接字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> maxfd, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">    fe_set *exceptfds, <span class="keyword">const</span> struct timeval *timeout )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>Maxfd</code>是文件描述符的范围，比待检的最大文件描述符大<code>1</code>；<code>Readfds</code>是被读监控的文件描述符集；<code>Writefds</code>是被写监控的文件描述符集；<code>Exceptfds</code>是被异常监控的文件描述符集；<code>Timeout</code>是定时器，取不同的值，该调用有不同的表现：</p>
<ul>
<li><code>Timeout</code>值为<code>0</code>，不管是否有文件满足要求，都立刻返回，无文件满足要求返回<code>0</code>，有文件满足要求返回一个正值。</li>
<li><code>Timeout</code>为<code>NULL</code>，<code>select</code>将阻塞进程，直到某个文件满足要求。</li>
<li><code>Timeout</code>值为正整数，就是等待的最长时间，即<code>select</code>在<code>timeout</code>时间内阻塞进程。</li>
</ul>
<p>&emsp;&emsp;<code>Select</code>调用返回时，返回值有如下情况：</p>
<ul>
<li>正常情况下返回满足要求的文件描述符个数。</li>
<li>经过了<code>timeout</code>等待后仍无文件满足要求，返回值为<code>0</code>。</li>
<li>如果<code>select</code>被某个信号中断，它将返回<code>-1</code>，并设置<code>errno</code>为<code>EINTR</code>。</li>
<li>如果出错，返回<code>-1</code>并设置相应的<code>errno</code>。</li>
</ul>
<p>&emsp;&emsp;多路复用的步骤为：</p>
<ol>
<li>设置要监控的文件。</li>
<li>调用<code>Select</code>开始监控。</li>
<li>判断文件是否发生变化。</li>
</ol>
<p>&emsp;&emsp;系统提供了<code>4</code>个宏对描述符集进行操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span> <span class="params">( <span class="keyword">int</span> fd, fd_set *fdset )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span> <span class="params">( <span class="keyword">int</span> fd, fd_set *fdset )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span> <span class="params">( fd_set *fdset )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ISSET</span> <span class="params">( <span class="keyword">int</span> fd, fd_set *fdset )</span></span>;</span><br></pre></td></tr></table></figure>
<p>宏<code>FD_SET</code>将文件描述符<code>fd</code>添加到文件描述符集<code>fdset</code>中；宏<code>FD_CLR</code>从文件描述符集<code>fdset</code>中清除文件描述符<code>fd</code>；宏<code>FD_ZERO</code>清空文件描述符集<code>fdset</code>；在调用<code>select</code>后使用<code>FD_ISSET</code>来检测文件描述符集<code>fdset</code>中的文件<code>fd</code>发生了变化。<br>&emsp;&emsp;编程模型为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">FD_ZERO ( &amp;fds ); <span class="comment">/* 清空集合 */</span></span><br><span class="line">sock1 = socket ( ... );</span><br><span class="line">sock2 = socket ( ... );</span><br><span class="line">bind ( sock1, ... );</span><br><span class="line">bind ( sock2, ... );</span><br><span class="line">listen ( sock1, ... );</span><br><span class="line">listen ( sock1, ... );</span><br><span class="line">FD_SET ( sock1, &amp;fds ); <span class="comment">/* 设置描述符 */</span></span><br><span class="line">FD_SET ( sock2, &amp;fds ); <span class="comment">/* 设置描述符 */</span></span><br><span class="line"></span><br><span class="line">maxfdp = ( sock1 &gt; sock2 ? sock1 : sock2 ) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ( select ( maxfdp, &amp;fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout ) ) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">/* select发送错误，退出程序 */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> ( FD_ISSET ( sock1, &amp;fds ) ) &#123; <span class="comment">/* 测试sock1是否可读 */</span></span><br><span class="line">            accpet ( sock1, ... );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/19/嵌入式笔记/对ARM堆栈的理解/" rel="next" title="对ARM堆栈的理解">
                <i class="fa fa-chevron-left"></i> 对ARM堆栈的理解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/20/嵌入式笔记/ARM基础教程/" rel="prev" title="ARM基础教程">
                ARM基础教程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">943</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#系统调用之文件访问"><span class="nav-number">1.</span> <span class="nav-text">系统调用之文件访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件编程"><span class="nav-number">1.1.</span> <span class="nav-text">文件编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建文件"><span class="nav-number">1.2.</span> <span class="nav-text">创建文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件描述"><span class="nav-number">1.3.</span> <span class="nav-text">文件描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#打开文件"><span class="nav-number">1.4.</span> <span class="nav-text">打开文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关闭文件"><span class="nav-number">1.5.</span> <span class="nav-text">关闭文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读文件"><span class="nav-number">1.6.</span> <span class="nav-text">读文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写文件"><span class="nav-number">1.7.</span> <span class="nav-text">写文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件定位"><span class="nav-number">1.8.</span> <span class="nav-text">文件定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件访问判断"><span class="nav-number">1.9.</span> <span class="nav-text">文件访问判断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#库函数之文件访问"><span class="nav-number">2.</span> <span class="nav-text">库函数之文件访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件创建和打开"><span class="nav-number">2.1.</span> <span class="nav-text">文件创建和打开</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读文件-1"><span class="nav-number">2.2.</span> <span class="nav-text">读文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写文件-1"><span class="nav-number">2.3.</span> <span class="nav-text">写文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读字符"><span class="nav-number">2.4.</span> <span class="nav-text">读字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写字符"><span class="nav-number">2.5.</span> <span class="nav-text">写字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#格式化读"><span class="nav-number">2.6.</span> <span class="nav-text">格式化读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#格式化写"><span class="nav-number">2.7.</span> <span class="nav-text">格式化写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件定位-1"><span class="nav-number">2.8.</span> <span class="nav-text">文件定位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程控制理论基础"><span class="nav-number">3.</span> <span class="nav-text">进程控制理论基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义"><span class="nav-number">3.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程ID"><span class="nav-number">3.2.</span> <span class="nav-text">进程ID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程互斥"><span class="nav-number">3.3.</span> <span class="nav-text">进程互斥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#临界资源"><span class="nav-number">3.4.</span> <span class="nav-text">临界资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程同步"><span class="nav-number">3.5.</span> <span class="nav-text">进程同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程调度"><span class="nav-number">3.6.</span> <span class="nav-text">进程调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁"><span class="nav-number">3.7.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程控制编程"><span class="nav-number">3.8.</span> <span class="nav-text">进程控制编程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程间通讯概述"><span class="nav-number">4.</span> <span class="nav-text">进程间通讯概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发展"><span class="nav-number">4.1.</span> <span class="nav-text">发展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分类"><span class="nav-number">4.2.</span> <span class="nav-text">分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程理论基础"><span class="nav-number">5.</span> <span class="nav-text">线程理论基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程"><span class="nav-number">5.1.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点"><span class="nav-number">5.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建线程"><span class="nav-number">5.3.</span> <span class="nav-text">创建线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编译多线程代码"><span class="nav-number">5.4.</span> <span class="nav-text">编译多线程代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#终止线程"><span class="nav-number">5.5.</span> <span class="nav-text">终止线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程退出"><span class="nav-number">5.6.</span> <span class="nav-text">线程退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程等待"><span class="nav-number">5.7.</span> <span class="nav-text">线程等待</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程标识"><span class="nav-number">5.8.</span> <span class="nav-text">线程标识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#清除"><span class="nav-number">5.9.</span> <span class="nav-text">清除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程同步"><span class="nav-number">5.10.</span> <span class="nav-text">线程同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#互斥量"><span class="nav-number">5.11.</span> <span class="nav-text">互斥量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建互斥量"><span class="nav-number">5.12.</span> <span class="nav-text">创建互斥量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加锁"><span class="nav-number">5.13.</span> <span class="nav-text">加锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解锁"><span class="nav-number">5.14.</span> <span class="nav-text">解锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#互斥量-vs-信号量"><span class="nav-number">5.15.</span> <span class="nav-text">互斥量 vs 信号量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux网络编程"><span class="nav-number">6.</span> <span class="nav-text">Linux网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#网络模型"><span class="nav-number">6.1.</span> <span class="nav-text">网络模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-IP协议族"><span class="nav-number">6.2.</span> <span class="nav-text">TCP/IP协议族</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络层"><span class="nav-number">6.3.</span> <span class="nav-text">网络层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传输层协议"><span class="nav-number">6.4.</span> <span class="nav-text">传输层协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用协议"><span class="nav-number">6.5.</span> <span class="nav-text">应用协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IP协议"><span class="nav-number">6.6.</span> <span class="nav-text">IP协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP协议"><span class="nav-number">6.7.</span> <span class="nav-text">TCP协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP协议"><span class="nav-number">6.8.</span> <span class="nav-text">UDP协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Socket"><span class="nav-number">6.9.</span> <span class="nav-text">Socket</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#地址结构"><span class="nav-number">6.10.</span> <span class="nav-text">地址结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#地址转换"><span class="nav-number">6.11.</span> <span class="nav-text">地址转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字节序转换"><span class="nav-number">6.12.</span> <span class="nav-text">字节序转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IP与主机名"><span class="nav-number">6.13.</span> <span class="nav-text">IP与主机名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作函数"><span class="nav-number">6.14.</span> <span class="nav-text">操作函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于TCP的服务器"><span class="nav-number">6.15.</span> <span class="nav-text">基于TCP的服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于TCP的客户端"><span class="nav-number">6.16.</span> <span class="nav-text">基于TCP的客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于UDP的服务器"><span class="nav-number">6.17.</span> <span class="nav-text">基于UDP的服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务器模型"><span class="nav-number">6.18.</span> <span class="nav-text">服务器模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP循环服务器"><span class="nav-number">6.19.</span> <span class="nav-text">UDP循环服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP循环服务器"><span class="nav-number">6.20.</span> <span class="nav-text">TCP循环服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP并发服务器"><span class="nav-number">6.21.</span> <span class="nav-text">TCP并发服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多路复用I-O"><span class="nav-number">6.22.</span> <span class="nav-text">多路复用I/O</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
