<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Basics of Brute-Force Matcher&amp;emsp;&amp;emsp;Brute-Force matcher is simple. It takes the descriptor of one feature in first set and is matched with all other features in second set using some distance cal">
<meta property="og:type" content="article">
<meta property="og:title" content="Feature Matching">
<meta property="og:url" content="http://fukangwei.gitee.io/2019/03/06/opencv和图像处理/Feature Matching/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:description" content="Basics of Brute-Force Matcher&amp;emsp;&amp;emsp;Brute-Force matcher is simple. It takes the descriptor of one feature in first set and is matched with all other features in second set using some distance cal">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/03/06/opencv和图像处理/Feature%20Matching/1.png">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/03/06/opencv和图像处理/Feature%20Matching/2.png">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/03/06/opencv和图像处理/Feature%20Matching/3.png">
<meta property="og:updated_time" content="2019-03-06T13:34:24.634Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Feature Matching">
<meta name="twitter:description" content="Basics of Brute-Force Matcher&amp;emsp;&amp;emsp;Brute-Force matcher is simple. It takes the descriptor of one feature in first set and is matched with all other features in second set using some distance cal">
<meta name="twitter:image" content="http://fukangwei.gitee.io/2019/03/06/opencv和图像处理/Feature%20Matching/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/2019/03/06/opencv和图像处理/Feature Matching/">





  <title>Feature Matching | 泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/06/opencv和图像处理/Feature Matching/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Feature Matching</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T17:47:16+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="Basics-of-Brute-Force-Matcher"><a href="#Basics-of-Brute-Force-Matcher" class="headerlink" title="Basics of Brute-Force Matcher"></a>Basics of Brute-Force Matcher</h3><p>&emsp;&emsp;<code>Brute-Force</code> matcher is simple. It takes the descriptor of one feature in first set and is matched with all other features in second set using some distance calculation. And the closest one is returned.<br>&emsp;&emsp;For <code>BF</code> matcher, first we have to create the <code>BFMatcher</code> object using <code>cv2.BFMatcher()</code>. It takes two optional params. First one is <code>normType</code>. It specifies the distance measurement to be used. By default, it is <code>cv2.NORM_L2</code>. It is good for <code>SIFT</code>, <code>SURF</code> etc (<code>cv2.NORM_L1</code> is also there). For binary string based descriptors like <code>ORB</code>, <code>BRIEF</code>, <code>BRISK</code> etc, <code>cv2.NORM_HAMMING</code> should be used, which used <code>Hamming</code> distance as measurement. If <code>ORB</code> is using <code>WTA_K == 3</code> or <code>4</code>, <code>cv2.NORM_HAMMING2</code> should be used.<br>&emsp;&emsp;Second param is <code>boolean</code> variable, <code>crossCheck</code> which is <code>false</code> by default. If it is <code>true</code>, <code>Matcher</code> returns only those matches with value <code>(i, j)</code> such that <code>i-th</code> descriptor in set <code>A</code> has <code>j-th</code> descriptor in set <code>B</code> as the best match and <code>vice-versa</code>. That is, the two features in both sets should match each other. It provides consistant result, and is a good alternative to ratio test proposed by <code>D.Lowe</code> in <code>SIFT</code> paper.<br>&emsp;&emsp;Once it is created, two important methods are <code>BFMatcher.match()</code> and <code>BFMatcher.knnMatch()</code>. First one returns the best match. Second method returns <code>k</code> best matches where <code>k</code> is specified by the user. It may be useful when we need to do additional work on that.<br>&emsp;&emsp;Like we used <code>cv2.drawKeypoints()</code> to draw keypoints, <code>cv2.drawMatches()</code> helps us to draw the matches. It stacks two images horizontally and draw lines from first image to second image showing best matches. There is also <code>cv2.drawMatchesKnn</code> which draws all the <code>k</code> best matches. If <code>k = 2</code>, it will draw two <code>match-lines</code> for each keypoint. So we have to pass a mask if we want to selectively draw it.<br>&emsp;&emsp;Let’s see one example for each of <code>SURF</code> and <code>ORB</code> (Both use different distance measurements).</p>
<h3 id="Brute-Force-Matching-with-ORB-Descriptors"><a href="#Brute-Force-Matching-with-ORB-Descriptors" class="headerlink" title="Brute-Force Matching with ORB Descriptors"></a>Brute-Force Matching with ORB Descriptors</h3><p>&emsp;&emsp;Here, we will see a simple example on how to match features between two images. In this case, I have a <code>queryImage</code> and a <code>trainImage</code>. We will try to find the <code>queryImage</code> in <code>trainImage</code> using feature matching (The images are <code>/samples/c/box.png</code> and <code>/samples/c/box_in_scene.png</code>)<br>&emsp;&emsp;We are using <code>SIFT</code> descriptors to match features. So let’s start with loading images, finding descriptors etc.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img1 = cv2.imread(<span class="string">'box.png'</span>, <span class="number">0</span>)  <span class="comment"># queryImage</span></span><br><span class="line">img2 = cv2.imread(<span class="string">'box_in_scene.png'</span>, <span class="number">0</span>)  <span class="comment"># trainImage</span></span><br><span class="line">orb = cv2.ORB()  <span class="comment"># Initiate SIFT detector</span></span><br><span class="line"><span class="comment"># find the keypoints and descriptors with SIFT</span></span><br><span class="line">kp1, des1 = orb.detectAndCompute(img1, <span class="keyword">None</span>)</span><br><span class="line">kp2, des2 = orb.detectAndCompute(img2, <span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<p>Next we create a <code>BFMatcher</code> object with distance measurement <code>cv2.NORM_HAMMING</code> (since we are using <code>ORB</code>) and <code>crossCheck</code> is switched on for better results. Then we use <code>Matcher.match()</code> method to get the best matches in two images. We sort them in ascending order of their distances so that best matches (with low distance) come to front. Then we draw only first <code>10</code> matches (Just for sake of visibility. You can increase it as you like):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create BFMatcher object</span></span><br><span class="line">bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># Match descriptors.</span></span><br><span class="line">matches = bf.match(des1, des2)</span><br><span class="line"><span class="comment"># Sort them in the order of their distance.</span></span><br><span class="line">matches = sorted(matches, key=<span class="keyword">lambda</span> x: x.distance)</span><br><span class="line"><span class="comment"># Draw first 10 matches.</span></span><br><span class="line">img3 = cv2.drawMatches(img1, kp1, img2, kp2, matches[:<span class="number">10</span>], flags=<span class="number">2</span>)</span><br><span class="line">plt.imshow(img3), plt.show()</span><br></pre></td></tr></table></figure>
<p>Below is the result I got:</p>
<p><img src="/2019/03/06/opencv和图像处理/Feature Matching/1.png" height="218" width="327"></p>
<h3 id="What-is-this-Matcher-Object"><a href="#What-is-this-Matcher-Object" class="headerlink" title="What is this Matcher Object"></a>What is this Matcher Object</h3><p>&emsp;&emsp;The result of <code>matches = bf.match(des1, des2)</code> line is a list of <code>DMatch</code> objects. This <code>DMatch</code> object has following attributes:</p>
<ul>
<li><code>DMatch.distance</code>: Distance between descriptors. The lower, the better it is.</li>
<li><code>DMatch.trainIdx</code>: Index of the descriptor in train descriptors.</li>
<li><code>DMatch.queryIdx</code>: Index of the descriptor in query descriptors.</li>
<li><code>DMatch.imgIdx</code>: Index of the train image.</li>
</ul>
<h3 id="Brute-Force-Matching-with-SIFT-Descriptors-and-Ratio-Test"><a href="#Brute-Force-Matching-with-SIFT-Descriptors-and-Ratio-Test" class="headerlink" title="Brute-Force Matching with SIFT Descriptors and Ratio Test"></a>Brute-Force Matching with SIFT Descriptors and Ratio Test</h3><p>&emsp;&emsp;This time, we will use <code>BFMatcher.knnMatch()</code> to get <code>k</code> best matches. In this example, we will take <code>k=2</code> so that we can apply ratio test explained by <code>D.Lowe</code> in his paper.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">​</span><br><span class="line">img1 = cv2.imread(<span class="string">'box.png'</span>, <span class="number">0</span>)  <span class="comment"># queryImage</span></span><br><span class="line">img2 = cv2.imread(<span class="string">'box_in_scene.png'</span>, <span class="number">0</span>)  <span class="comment"># trainImage</span></span><br><span class="line">​</span><br><span class="line"><span class="comment"># Initiate SIFT detector</span></span><br><span class="line">sift = cv2.SIFT()</span><br><span class="line">​</span><br><span class="line"><span class="comment"># find the keypoints and descriptors with SIFT</span></span><br><span class="line">kp1, des1 = sift.detectAndCompute(img1, <span class="keyword">None</span>)</span><br><span class="line">kp2, des2 = sift.detectAndCompute(img2, <span class="keyword">None</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># BFMatcher with default params</span></span><br><span class="line">bf = cv2.BFMatcher()</span><br><span class="line">matches = bf.knnMatch(des1, des2, k=<span class="number">2</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Apply ratio test</span></span><br><span class="line">good = []</span><br><span class="line"><span class="keyword">for</span> m, n <span class="keyword">in</span> matches:</span><br><span class="line">    <span class="keyword">if</span> m.distance &lt; <span class="number">0.75</span> * n.distance:</span><br><span class="line">        good.append([m])</span><br><span class="line">​</span><br><span class="line"><span class="comment"># cv2.drawMatchesKnn expects list of lists as matches.</span></span><br><span class="line">img3 = cv2.drawMatchesKnn(img1, kp1, img2, kp2, good, flags=<span class="number">2</span>)</span><br><span class="line">​</span><br><span class="line">plt.imshow(img3), plt.show()</span><br></pre></td></tr></table></figure>
<p>See the result below:</p>
<p><img src="/2019/03/06/opencv和图像处理/Feature Matching/2.png"></p>
<h3 id="FLANN-based-Matcher"><a href="#FLANN-based-Matcher" class="headerlink" title="FLANN based Matcher"></a>FLANN based Matcher</h3><p>&emsp;&emsp;<code>FLANN</code> stands for <code>Fast Library</code> for <code>Approximate Nearest Neighbors</code>. It contains a collection of algorithms optimized for fast nearest neighbor search in large datasets and for high dimensional features. It works more faster than <code>BFMatcher</code> for large datasets. We will see the second example with <code>FLANN</code> based matcher.<br>&emsp;&emsp;For <code>FLANN</code> based matcher, we need to pass two dictionaries which specifies the algorithm to be used, its related parameters etc. First one is <code>IndexParams</code>. For various algorithms, the information to be passed is explained in <code>FLANN</code> docs. As a summary, for algorithms like <code>SIFT</code>, <code>SURF</code> etc. you can pass following:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index_params = dict(algorithm = FLANN_INDEX_KDTREE, trees = <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;While using <code>ORB</code>, you can pass the following. The commented values are recommended as per the docs, but it didn’t provide required results in some cases. Other values worked fine.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index_params = dict(algorithm=FLANN_INDEX_LSH,</span><br><span class="line">                    table_number=<span class="number">6</span>,  <span class="comment"># 12</span></span><br><span class="line">                    key_size=<span class="number">12</span>,  <span class="comment"># 20</span></span><br><span class="line">                    multi_probe_level=<span class="number">1</span>)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Second dictionary is the <code>SearchParams</code>. It specifies the number of times the trees in the index should be recursively traversed. Higher values gives better precision, but also takes more time. If you want to change the value, pass <code>search_params = dict(checks=100)</code>.<br>&emsp;&emsp;With these informations, we are good to go.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">​</span><br><span class="line">img1 = cv2.imread(<span class="string">'box.png'</span>, <span class="number">0</span>)  <span class="comment"># queryImage</span></span><br><span class="line">img2 = cv2.imread(<span class="string">'box_in_scene.png'</span>, <span class="number">0</span>)  <span class="comment"># trainImage</span></span><br><span class="line">​</span><br><span class="line"><span class="comment"># Initiate SIFT detector</span></span><br><span class="line">sift = cv2.SIFT()</span><br><span class="line">​</span><br><span class="line"><span class="comment"># find the keypoints and descriptors with SIFT</span></span><br><span class="line">kp1, des1 = sift.detectAndCompute(img1, <span class="keyword">None</span>)</span><br><span class="line">kp2, des2 = sift.detectAndCompute(img2, <span class="keyword">None</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># FLANN parameters</span></span><br><span class="line">FLANN_INDEX_KDTREE = <span class="number">0</span></span><br><span class="line">index_params = dict(algorithm=FLANN_INDEX_KDTREE, trees=<span class="number">5</span>)</span><br><span class="line">search_params = dict(checks=<span class="number">50</span>)  <span class="comment"># or pass empty dictionary</span></span><br><span class="line">​</span><br><span class="line">flann = cv2.FlannBasedMatcher(index_params, search_params)</span><br><span class="line">​</span><br><span class="line">matches = flann.knnMatch(des1, des2, k=<span class="number">2</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment"># Need to draw only good matches, so create a mask</span></span><br><span class="line">matchesMask = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matches))]</span><br><span class="line">​</span><br><span class="line"><span class="comment"># ratio test as per Lowe's paper</span></span><br><span class="line"><span class="keyword">for</span> i, (m, n) <span class="keyword">in</span> enumerate(matches):</span><br><span class="line">    <span class="keyword">if</span> m.distance &lt; <span class="number">0.7</span> * n.distance:</span><br><span class="line">        matchesMask[i] = [<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">​</span><br><span class="line">draw_params = dict(matchColor=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), singlePointColor=(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), matchesMask=matchesMask, flags=<span class="number">0</span>)</span><br><span class="line">​</span><br><span class="line">img3 = cv2.drawMatchesKnn(img1, kp1, img2, kp2, matches, <span class="keyword">None</span>, **draw_params)</span><br><span class="line">​</span><br><span class="line">plt.imshow(img3, ), plt.show()</span><br></pre></td></tr></table></figure>
<p>See the result below:</p>
<p><img src="/2019/03/06/opencv和图像处理/Feature Matching/3.png"></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/06/opencv和图像处理/cvConvertImage和cvflip函数/" rel="next" title="cvConvertImage和cvflip函数">
                <i class="fa fa-chevron-left"></i> cvConvertImage和cvflip函数
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/06/opencv和图像处理/Sobel算子/" rel="prev" title="Sobel算子">
                Sobel算子 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">955</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basics-of-Brute-Force-Matcher"><span class="nav-number">1.</span> <span class="nav-text">Basics of Brute-Force Matcher</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Brute-Force-Matching-with-ORB-Descriptors"><span class="nav-number">2.</span> <span class="nav-text">Brute-Force Matching with ORB Descriptors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#What-is-this-Matcher-Object"><span class="nav-number">3.</span> <span class="nav-text">What is this Matcher Object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Brute-Force-Matching-with-SIFT-Descriptors-and-Ratio-Test"><span class="nav-number">4.</span> <span class="nav-text">Brute-Force Matching with SIFT Descriptors and Ratio Test</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FLANN-based-Matcher"><span class="nav-number">5.</span> <span class="nav-text">FLANN based Matcher</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
