<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="驱动程序介绍&amp;emsp;&amp;emsp;设备驱动分为：字符设备驱动、网络接口驱动和块设备驱动。  字符设备：字符设备是一种按字节来访问的设备，字符驱动则负责驱动字符设备，这样的驱动通常实现open、close、read和write系统调用。 块设备：在大部分的Unix系统，块设备不能按字节处理数据，只能一次传送一个或多个长度是512字节(或一个更大的2次幂的数)的整块数据，而Linux则允许块设备传送">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux设备驱动基础">
<meta property="og:url" content="http://fukangwei.gitee.io/2019/03/21/Linux驱动程序/Linux设备驱动基础/index.html">
<meta property="og:site_name" content="泥腿子出身">
<meta property="og:description" content="驱动程序介绍&amp;emsp;&amp;emsp;设备驱动分为：字符设备驱动、网络接口驱动和块设备驱动。  字符设备：字符设备是一种按字节来访问的设备，字符驱动则负责驱动字符设备，这样的驱动通常实现open、close、read和write系统调用。 块设备：在大部分的Unix系统，块设备不能按字节处理数据，只能一次传送一个或多个长度是512字节(或一个更大的2次幂的数)的整块数据，而Linux则允许块设备传送">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/03/21/Linux驱动程序/Linux设备驱动基础/1.png">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/03/21/Linux驱动程序/Linux设备驱动基础/2.png">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/03/21/Linux驱动程序/Linux设备驱动基础/3.png">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/03/21/Linux驱动程序/Linux设备驱动基础/4.png">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/03/21/Linux驱动程序/Linux设备驱动基础/5.png">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/03/21/Linux驱动程序/Linux设备驱动基础/6.png">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/03/21/Linux驱动程序/Linux设备驱动基础/7.png">
<meta property="og:image" content="http://fukangwei.gitee.io/2019/03/21/Linux驱动程序/Linux设备驱动基础/8.png">
<meta property="og:updated_time" content="2019-03-23T09:31:32.502Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux设备驱动基础">
<meta name="twitter:description" content="驱动程序介绍&amp;emsp;&amp;emsp;设备驱动分为：字符设备驱动、网络接口驱动和块设备驱动。  字符设备：字符设备是一种按字节来访问的设备，字符驱动则负责驱动字符设备，这样的驱动通常实现open、close、read和write系统调用。 块设备：在大部分的Unix系统，块设备不能按字节处理数据，只能一次传送一个或多个长度是512字节(或一个更大的2次幂的数)的整块数据，而Linux则允许块设备传送">
<meta name="twitter:image" content="http://fukangwei.gitee.io/2019/03/21/Linux驱动程序/Linux设备驱动基础/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '561O3H1PZB',
      apiKey: '7631d3cf19ac49bd39ada7163ec937a7',
      indexName: 'fuxinzi',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://fukangwei.gitee.io/2019/03/21/Linux驱动程序/Linux设备驱动基础/">





  <title>Linux设备驱动基础 | 泥腿子出身</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">泥腿子出身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fukangwei.gitee.io/2019/03/21/Linux驱动程序/Linux设备驱动基础/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="付康为">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="泥腿子出身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux设备驱动基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-21T17:39:00+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="驱动程序介绍"><a href="#驱动程序介绍" class="headerlink" title="驱动程序介绍"></a>驱动程序介绍</h3><p>&emsp;&emsp;设备驱动分为：字符设备驱动、网络接口驱动和块设备驱动。</p>
<ul>
<li>字符设备：字符设备是一种按字节来访问的设备，字符驱动则负责驱动字符设备，这样的驱动通常实现<code>open</code>、<code>close</code>、<code>read</code>和<code>write</code>系统调用。</li>
<li>块设备：在大部分的<code>Unix</code>系统，块设备不能按字节处理数据，只能一次传送一个或多个长度是<code>512</code>字节(或一个更大的<code>2</code>次幂的数)的整块数据，而<code>Linux</code>则允许块设备传送任意数目的字节。因此，块和字符设备的区别仅仅是驱动的与内核的接口不同。</li>
<li>网络接口：任何网络事务都通过一个接口来进行，一个接口通常是一个硬件设备(<code>eth0</code>)，但是它也可以是一个纯粹的软件设备，比如回环接口(<code>lo</code>)。一个网络接口负责发送和接收数据报文。</li>
</ul>
<p>&emsp;&emsp;<code>Linux</code>用户程序通过设备文件(又称为<code>设备节点</code>)来使用驱动程序操作字符设备和块设备。</p>
<p><img src="/2019/03/21/Linux驱动程序/Linux设备驱动基础/1.png" height="243" width="449"></p>
<h3 id="字符设备驱动程序"><a href="#字符设备驱动程序" class="headerlink" title="字符设备驱动程序"></a>字符设备驱动程序</h3><h4 id="主次设备号"><a href="#主次设备号" class="headerlink" title="主次设备号"></a>主次设备号</h4><p>&emsp;&emsp;字符设备通过字符设备文件来存取。字符设备文件由使用<code>ls -l</code>的输出的第一列的<code>c</code>标识。如果使用<code>ls -l</code>命令，会看到在设备文件项中有<code>2</code>个数(由一个逗号分隔)。这些数字就是设备文件的主次设备编号。</p>
<h4 id="设备号作用"><a href="#设备号作用" class="headerlink" title="设备号作用"></a>设备号作用</h4><p>&emsp;&emsp;主设备号用来标识与设备文件相连的驱动程序，次编号被驱动程序用来辨别操作的是哪个设备。主设备号用来反映设备类型，次设备号用来区分同类型的设备。内核中使用<code>dev_t</code>类型描述设备号，<code>dev_t</code>其实质为<code>unsigned int</code>的<code>32</code>位整数，其中高<code>12</code>位为主设备号，低<code>20</code>位为次设备号。可以使用<code>MAJOR(dev_t dev)</code>从<code>dev_t</code>中分解出主设备号，使用<code>MINOR(dev_t dev)</code>从<code>dev_t</code>中分解出次设备号。</p>
<h4 id="分配主设备号"><a href="#分配主设备号" class="headerlink" title="分配主设备号"></a>分配主设备号</h4><p>&emsp;&emsp;<code>Linux</code>内核可以采用静态申请、动态分配两种方法给设备分配主设备号。</p>
<h4 id="静态申请"><a href="#静态申请" class="headerlink" title="静态申请"></a>静态申请</h4><p>&emsp;&emsp;方法主要有：根据<code>Documentation/devices.txt</code>，确定一个没有使用的主设备号；使用<code>register_chrdev_region</code>函数注册设备号。优点是简单，缺点是一旦驱动被广泛使用，这个随机选定的主设备号可能会导致设备号冲突，而使驱动程序无法注册。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_chrdev_region</span> <span class="params">( <span class="keyword">dev_t</span> from, <span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br></pre></td></tr></table></figure>
<p>申请使用从<code>from</code>开始的<code>count</code>个设备号(主设备号不变，次设备号增加)。</p>
<ul>
<li><code>from</code>：希望申请使用的设备号。</li>
<li><code>count</code>：希望申请使用设备号数目。</li>
<li><code>name</code>：设备名(体现在<code>/proc/devices</code>)。</li>
</ul>
<h4 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h4><p>&emsp;&emsp;使用<code>alloc_chrdev_region</code>分配设备号。优点是简单，易于驱动推广。缺点是无法在安装驱动前创建设备文件(因为安装前还没有分配到主设备号)。解决办法：安装驱动后，从<code>/proc/devices</code>中查询设备号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_chrdev_region</span> <span class="params">( <span class="keyword">dev_t</span> *dev, <span class="keyword">unsigned</span> baseminor, <span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br></pre></td></tr></table></figure>
<p>请求内核动态分配<code>count</code>个设备号，且次设备号从<code>baseminor</code>开始。</p>
<ul>
<li><code>dev</code>：分配到的设备号。</li>
<li><code>baseminor</code>：起始次设备号。</li>
<li><code>count</code>：需要分配的设备号数目。</li>
<li><code>name</code>：设备名(体现在<code>/proc/devices</code>)。</li>
</ul>
<h4 id="注销设备号"><a href="#注销设备号" class="headerlink" title="注销设备号"></a>注销设备号</h4><p>&emsp;&emsp;不论使用何种方法分配设备号，都应该在不再使用它们时释放这些设备号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister_chrdev_region</span> <span class="params">( <span class="keyword">dev_t</span> from, <span class="keyword">unsigned</span> count )</span></span>;</span><br></pre></td></tr></table></figure>
<p>释放从<code>from</code>开始的<code>count</code>个设备号。</p>
<h4 id="创建设备文件"><a href="#创建设备文件" class="headerlink" title="创建设备文件"></a>创建设备文件</h4><p>&emsp;&emsp;<code>2</code>种方法分别是：使用<code>mknod</code>命令手工创建；自动创建。</p>
<h4 id="手工创建"><a href="#手工创建" class="headerlink" title="手工创建"></a>手工创建</h4><p>&emsp;&emsp;<code>mknod</code>用法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod filename <span class="built_in">type</span> major minor</span><br></pre></td></tr></table></figure>
<ul>
<li><code>filename</code>：设备文件名。</li>
<li><code>type</code>：设备文件类型。</li>
<li><code>major</code>：主设备号。</li>
<li><code>minor</code>：次设备号。</li>
</ul>
<p>&emsp;&emsp;使用范例为<code>mknod serial0 c 100 0</code>。</p>
<h4 id="重要结构"><a href="#重要结构" class="headerlink" title="重要结构"></a>重要结构</h4><p>&emsp;&emsp;在<code>Linux</code>字符设备驱动程序设计中，有<code>3</code>种非常重要的数据结构：<code>struct file</code>、<code>struct inode</code>和<code>struct file_operations</code>。</p>
<h4 id="Struct-File"><a href="#Struct-File" class="headerlink" title="Struct File"></a>Struct File</h4><p>&emsp;&emsp;代表一个打开的文件。系统中每个打开的文件在内核空间都有一个关联的<code>struct file</code>。它由内核在打开文件时创建，在文件关闭后释放。重要成员有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loff_t</span> f_pos; <span class="comment">/* 文件读写位置 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span></span><br></pre></td></tr></table></figure>
<h4 id="Struct-Inode"><a href="#Struct-Inode" class="headerlink" title="Struct Inode"></a>Struct Inode</h4><p>&emsp;&emsp;用来记录文件的物理上的信息。因此，它和代表打开文件的<code>file</code>结构是不同的。一个文件可以对应多个<code>file</code>结构，但只有一个<code>inode</code>结构。重要成员有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dev_t</span> i_rdev; <span class="comment">/* 设备号 */</span></span><br></pre></td></tr></table></figure>
<h4 id="Struct-file-operations"><a href="#Struct-file-operations" class="headerlink" title="Struct file_operations"></a>Struct file_operations</h4><p>&emsp;&emsp;一个函数指针的集合，定义能在设备上进行的操作。结构中的成员指向驱动中的函数，这些函数实现一个特别的操作，对于不支持的操作保留为<code>NULL</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mem_fops</span> = &#123;</span></span><br><span class="line">    .owner   = THIS_MODULE,</span><br><span class="line">    .llseek  = mem_seek,</span><br><span class="line">    .read    = mem_read,</span><br><span class="line">    .write   = mem_write,</span><br><span class="line">    .ioctl   = mem_ioctl,</span><br><span class="line">    .open    = mem_open,</span><br><span class="line">    .release = mem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="设备注册"><a href="#设备注册" class="headerlink" title="设备注册"></a>设备注册</h4><p>&emsp;&emsp;在<code>linux 2.6</code>内核中，字符设备使用<code>struct cdev</code>来描述。字符设备的注册可分为如下<code>3</code>个步骤：</p>
<ol>
<li>分配<code>cdev</code>。</li>
<li>初始化<code>cdev</code>。</li>
<li>添加<code>cdev</code>。</li>
</ol>
<p>&emsp;&emsp;<code>Struct cdev</code>的分配可使用<code>cdev_alloc</code>函数来完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct cdev *<span class="title">cdev_alloc</span> <span class="params">( <span class="keyword">void</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>Struct cdev</code>的初始化使用<code>cdev_init</code>函数来完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span> <span class="params">( struct cdev *cdev, <span class="keyword">const</span> struct file_operations *fops )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cdev</code>：待初始化的<code>cdev</code>结构。</li>
<li><code>fops</code>：设备对应的操作函数集</li>
</ul>
<p>&emsp;&emsp;<code>struct cdev</code>的注册使用<code>cdev_add</code>函数来完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span> <span class="params">( struct cdev *p, <span class="keyword">dev_t</span> dev, <span class="keyword">unsigned</span> count )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>p</code>：待添加到内核的字符设备结构。</li>
<li><code>dev</code>：设备号。</li>
<li><code>count</code>：添加的设备个数。</li>
</ul>
<h4 id="设备操作"><a href="#设备操作" class="headerlink" title="设备操作"></a>设备操作</h4><ul>
<li><code>int ( *open ) ( struct inode *, struct file * );</code>：在设备文件上的第一个操作，并不要求驱动程序一定要实现这个方法。如果该项为NULL，设备的打开操作永远成功。</li>
<li><code>void ( *release ) ( struct inode *, struct file * );</code>：当设备文件被关闭时调用这个操作。与<code>open</code>相仿，<code>release</code>也可以没有。</li>
<li><code>ssize_t ( *read ) ( struct file *, char __user *, size_t, loff_t * );</code>：从设备中读取数据。函数返回一个非负值，表示成功地从设备中读取多少字节。</li>
<li><code>ssize_t ( *write ) ( struct file *, const char __user *, size_t, loff_t * );</code>：向设备发送数据。</li>
<li><code>unsigned int ( *poll ) ( struct file *, struct poll_table_struct * );</code>：对应<code>select</code>系统调用。</li>
<li><code>int ( *ioctl ) ( struct inode *, struct file *, unsigned int, unsigned long );</code>：控制设备。</li>
<li><code>int ( *mmap ) ( struct file *, struct vm_area_struct * );</code>：将设备映射到进程虚拟地址空间中。</li>
<li><code>off_t ( *llseek ) ( struct file *, loff_t, int );</code>：修改文件的当前读写位置，并将新位置作为返回值。</li>
<li><code>int ( *select ) ( struct inode *, struct file *, int, select_table * );</code>：一般用于程序询问设备是否可读或可写。</li>
</ul>
<h4 id="Open方法"><a href="#Open方法" class="headerlink" title="Open方法"></a>Open方法</h4><p>&emsp;&emsp;<code>Open</code>方法是驱动程序用来为以后的操作完成初始化准备工作的。在大部分驱动程序中，<code>open</code>完成如下工作：初始化设备；标明次设备号。</p>
<h4 id="Release方法"><a href="#Release方法" class="headerlink" title="Release方法"></a>Release方法</h4><p>&emsp;&emsp;<code>Release</code>方法的作用正好与<code>open</code>相反。这个设备方法有时也称为<code>close</code>，它关闭设备。</p>
<h4 id="读和写"><a href="#读和写" class="headerlink" title="读和写"></a>读和写</h4><p>&emsp;&emsp;读和写方法都完成类似的工作：从设备中读取数据到用户空间；将数据传递给驱动程序。它们的原型也相当相似：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> xxx_read ( struct file *filp, <span class="keyword">char</span> __user *buff, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *offp );</span><br><span class="line"><span class="keyword">ssize_t</span> xxx_write ( struct file *filp, <span class="keyword">char</span> __user *buff, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *offp );</span><br></pre></td></tr></table></figure>
<p><code>filp</code>是文件指针，<code>count</code>是请求传输的数据量，<code>buff</code>参数指向数据缓存，<code>offp</code>指出文件当前的访问位置。<br>&emsp;&emsp;<code>Read</code>和<code>Write</code>方法的<code>buff</code>参数是用户空间指针。因此，它不能被内核代码直接引用，理由如下：用户空间指针在内核空间时可能根本是无效的，这是因为没有那个地址的映射。内核提供了专门的函数用于访问用户空间的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_from_user</span> <span class="params">( <span class="keyword">void</span> *to, <span class="keyword">const</span> <span class="keyword">void</span> __user *from, <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_to_user</span> <span class="params">( <span class="keyword">void</span> __user *to, <span class="keyword">const</span> <span class="keyword">void</span> *from, <span class="keyword">int</span> n )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="读数据模型"><a href="#读数据模型" class="headerlink" title="读数据模型"></a>读数据模型</h4><p>&emsp;&emsp;读数据模型如下：</p>
<p><img src="/2019/03/21/Linux驱动程序/Linux设备驱动基础/2.png" height="252" width="480"></p>
<h4 id="设备注消"><a href="#设备注消" class="headerlink" title="设备注消"></a>设备注消</h4><p>&emsp;&emsp;字符设备的注销使用<code>cdev_del</code>函数来完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_del</span> <span class="params">( struct cdev *p )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>p</code>：要注销的字符设备结构。</li>
</ul>
<h3 id="驱动调试技术"><a href="#驱动调试技术" class="headerlink" title="驱动调试技术"></a>驱动调试技术</h3><h4 id="调试技术分类"><a href="#调试技术分类" class="headerlink" title="调试技术分类"></a>调试技术分类</h4><p>&emsp;&emsp;对于驱动程序设计来说，核心问题之一就是如何完成调试。当前常用的驱动调试技术可分为：打印调试、调试器调试和查询调试。</p>
<h4 id="打印调试"><a href="#打印调试" class="headerlink" title="打印调试"></a>打印调试</h4><p>&emsp;&emsp;在调试应用程序时，最常用的调试技术是打印，就是在应用程序中合适的点调用<code>printf</code>。当调试内核代码的时候，可以用<code>printk</code>完成类似任务。</p>
<h4 id="合理使用Printk"><a href="#合理使用Printk" class="headerlink" title="合理使用Printk"></a>合理使用Printk</h4><p>&emsp;&emsp;在驱动开发时，<code>printk</code>非常有助于调试。但当正式发行驱动程序时，应当去掉这些打印语句。但你有可能很快又发现，你又需要在驱动程序中实现一个新功能(或者修复一个<code>bug</code>)，这时你又要用到那些被删除的打印语句。这里介绍一种使用<code>printk</code>的合理方法，可以全局地打开或关闭它们，而不是简单地删除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PDEBUG</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> PLOG(fmt, args...) printk(KERN_DEBUG <span class="meta-string">"scull:"</span>fmt, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> PLOG(fmt, args...) <span class="comment">/* do nothing */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>Makefile</code>作如下修改：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEBUG = y</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>, y)</span><br><span class="line">   DEBFLAGS = -O2 -g -DPDEBUG</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   DEBFLAGS = -O2</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">CFLAGS += <span class="variable">$(DEBFLAGS)</span></span><br></pre></td></tr></table></figure>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><h4 id="并发与竞态"><a href="#并发与竞态" class="headerlink" title="并发与竞态"></a>并发与竞态</h4><p>&emsp;&emsp;并发是指多个执行单元同时被执行；竞态是指并发的执行单元对共享资源(硬件资源和软件上的全局变量等)的访问导致的竞争状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( copy_from_user ( &amp; ( dev-&gt;data[pos] ), buf, count ) ) &#123;</span><br><span class="line">   ret = -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有<code>2</code>个进程试图同时向一个设备的相同位置写入数据，就会造成数据混乱。<br>&emsp;&emsp;处理并发的常用技术是加锁或者互斥，即确保在任何时间只有一个执行单元可以操作共享资源。在<code>Linux</code>内核中主要通过<code>semaphore</code>机制和<code>spin_lock</code>机制实现。</p>
<p>&emsp;&emsp;<code>linux</code>内核什么时候会发生竞态？</p>
<ul>
<li>对称多<code>cpu</code>(<code>SMP</code>)的多个<code>cpu</code>之间的竞态。</li>
<li>单<code>CPU</code>内进程间的竞态。</li>
<li>中断(硬中断、软中断、<code>Tasklet</code>、底半部)与进程之间的竞态。</li>
</ul>
<h4 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h4><p>&emsp;&emsp;可解决中断与进程之间的并发；也可解决内核抢占进程之间的并发。</p>
<ul>
<li><code>local_irq_disable()</code>：禁止中断。</li>
<li><code>local_irq_enable()</code>：打开中断。</li>
<li><code>local_irq_save(flags)</code>：禁止中断并保存中断寄存器信息到<code>flags</code>。</li>
<li><code>local_irq_restore(flags)</code>：打开中断并恢复<code>flags</code>值到中断寄存器信息。</li>
<li><code>loacl_bh_disable()</code>：仅禁止中断底半部中断。</li>
<li><code>loacl_bh_enable()</code>：打开中断底半部中断。</li>
</ul>
<p>&emsp;&emsp;使用范例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local_irq_disbale(); <span class="comment">/* 屏蔽中断 */</span></span><br><span class="line">...                  <span class="comment">/* 临界资源 */</span></span><br><span class="line">local_irq_enbale();  <span class="comment">/* 打开中断 */</span></span><br></pre></td></tr></table></figure>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>&emsp;&emsp;<code>Linux</code>内核的信号量在概念和原理上与用户态的信号量是一样的，但是它不能在内核之外使用，它是一种睡眠锁。如果有一个任务想要获得已经被占用的信号量时，信号量会将这个进程放入一个等待队列，然后让其睡眠。当持有信号量的进程将信号释放后，处于等待队列中的任务将被唤醒，并让其获得信号量。<br>&emsp;&emsp;信号量在创建时需要设置一个初始值，表示允许有几个任务同时访问该信号量保护的共享资源，初始值为<code>1</code>就变成互斥锁(<code>Mutex</code>)，即同时只能有一个任务可以访问信号量保护的共享资源。当任务访问完被信号量保护的共享资源后，必须释放信号量，释放信号量通过把信号量的值加<code>1</code>实现，如果释放后信号量的值为非正数，表明有任务等待当前信号量，因此要唤醒等待该信号量的任务。<br>&emsp;&emsp;信号量的实现也是与体系结构相关的，定义在<code>&lt;asm/semaphore.h&gt;</code>中，<code>struct semaphore</code>类型用来表示信号量。<br>&emsp;&emsp;1. 定义信号量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 初始化信号量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 该函用于数初始化设置信号量的初值，它设置信号量sem的值为val */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_init</span> <span class="params">( struct semaphore *sem, <span class="keyword">int</span> val )</span></span>;</span><br><span class="line"><span class="comment">/* 该函数用于初始化一个互斥锁，即它把信号量sem的值设置为1 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_MUTEX</span> <span class="params">( struct semaphore *sem )</span></span>;</span><br><span class="line"><span class="comment">/* 该函数也用于初始化一个互斥锁，但它把信号量sem的值设置为0，即一开始就处在已锁状态 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_MUTEX_LOCKED</span> <span class="params">( struct semaphore *sem )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;定义与初始化的工作可由如下宏一步完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义一个信号量name，并初始化它的值为1 */</span></span><br><span class="line">DECLARE_MUTEX ( name );</span><br><span class="line"><span class="comment">/* 定义一个信号量name，但把它的初始值设置为0，即锁在创建时就处在已锁状态 */</span></span><br><span class="line">DECLARE_MUTEX_LOCKED ( name );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3. 获取信号量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取信号量sem，可能会导致进程睡眠，因此不能在中断上下文使用该函数。该函数将把sem的值减1，</span></span><br><span class="line"><span class="comment">   如果信号量sem的值非负，就直接返回，否则调用者将被挂起，直到别的任务释放该信号量才能继续运行 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span> <span class="params">( struct semaphore *sem )</span></span>;</span><br><span class="line"><span class="comment">/* 获取信号量sem。如果信号量不可用，进程将被置为TASK_INTERRUPTIBLE类型的睡眠状态。</span></span><br><span class="line"><span class="comment">   该函数由返回值来区分是正常返回还是被信号中断返回，如果返回0，</span></span><br><span class="line"><span class="comment">   表示获得信号量正常返回，如果被信号打断，返回“-EINTR” */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">down_interruptible</span> <span class="params">( struct semaphore *sem )</span></span>;</span><br><span class="line"><span class="comment">/* 获取信号量sem。如果信号量不可用，进程将被置为TASK_KILLABLE类型的睡眠状态 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">down_killable</span> <span class="params">( struct semaphore *sem )</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意，<code>down</code>函数现已不建议继续使用。建议使用<code>down_killable</code>或<code>down_interruptible</code>函数。<br>&emsp;&emsp;4. 释放信号量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 该函数释放信号量sem，即把sem的值加1，如果sem的值为非正数，</span></span><br><span class="line"><span class="comment">   表明有任务等待该信号量，因此唤醒这些等待者 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span> <span class="params">( struct semaphore *sem )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;信号量使用模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_MUTEX ( sem )</span><br><span class="line"><span class="keyword">if</span> ( down_interruptible ( &amp;sem ) ) &#123;</span><br><span class="line">   <span class="keyword">return</span> -ERESTARTSYS;</span><br><span class="line">&#125;</span><br><span class="line">... <span class="comment">/* 临界资源 */</span></span><br><span class="line">up ( &amp;sem );</span><br></pre></td></tr></table></figure>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>&emsp;&emsp;自旋锁最多只能被一个可执行单元持有。自旋锁不会引起调用者睡眠，如果一个执行线程试图获得一个已经被持有的自旋锁，那么线程就会一直进行忙循环，一直等待下去，在那里看是否该自旋锁的保持者已经释放了锁，<code>自旋</code>就是这个意思。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 该宏用于初始化自旋锁x，自旋锁在使用前必须先初始化 */</span></span><br><span class="line">spin_lock_init ( x );</span><br><span class="line"><span class="comment">/* 获取自旋锁lock，如果成功，立即获得锁，并马上返回，否则它将一直自旋在那里，直到该自旋锁的保持者释放 */</span></span><br><span class="line">spin_lock ( lock );</span><br><span class="line"><span class="comment">/* 试图获取自旋锁lock，如果能立即获得锁，并返回真，否则立即返回假。它不会一直等待被释放 */</span></span><br><span class="line">spin_trylock ( lock );</span><br><span class="line">spin_unlock ( lock ); <span class="comment">/* 释放自旋锁lock，它与spin_trylock或spin_lock配对使用 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;读写自旋锁示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">rwlock_t</span> rwlock;</span><br><span class="line">rwlock_init ( &amp;rwlock );</span><br><span class="line">read_lock ( &amp;rwlock );</span><br><span class="line"><span class="comment">/* 临界资源 */</span></span><br><span class="line">read_unlock ( &amp;rwlock );</span><br><span class="line">write_lock_irqsave ( &amp;rwlock, flags );</span><br><span class="line"><span class="comment">/* 临界资源 */</span></span><br><span class="line">write_unlock_irqrestore ( &amp;rwlock, flags );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;自旋锁模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">spinlock_t</span> lock;</span><br><span class="line">spin_lock_init ( &amp;lock );</span><br><span class="line">spin_lock ( &amp;lock );</span><br><span class="line"><span class="comment">/* 临界资源 */</span></span><br><span class="line">spin_unlock ( &amp;lock );</span><br></pre></td></tr></table></figure>
<h4 id="读入者-写入者信号量"><a href="#读入者-写入者信号量" class="headerlink" title="读入者/写入者信号量"></a>读入者/写入者信号量</h4><p>&emsp;&emsp;读操作并发，写操作互斥，即一个<code>rwsem</code>可允许一个写入者或无数个读取者拥有该信号量。写入者的级别更高，当有大量写入者竞争该信号量时，会导致读取者饿死，即长时间拒绝读取者的访问。但是驱动程序很少用该机制，一般在很少需要写访问且写入者只会短期拥有信号量的时候使用<code>rwsem</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rw_semaphere_t</span> rw_sem;</span><br><span class="line">init_rwsem ( &amp;rw_sem );</span><br><span class="line"><span class="comment">/* 读时获取信号量 */</span></span><br><span class="line">down_read ( &amp;rw_sem );</span><br><span class="line"><span class="comment">/* 临界资源 */</span></span><br><span class="line">up_read ( &amp;rw_sem );</span><br><span class="line"><span class="comment">/* 写时获取信号量 */</span></span><br><span class="line">down_write ( &amp;rw_sem );</span><br><span class="line"><span class="comment">/* 临界资源 */</span></span><br><span class="line">up_write ( &amp;rw_sem );</span><br></pre></td></tr></table></figure>
<h4 id="信号量-PK-自旋锁"><a href="#信号量-PK-自旋锁" class="headerlink" title="信号量 PK 自旋锁"></a>信号量 PK 自旋锁</h4><p>&emsp;&emsp;信号量可能允许有多个持有者，而自旋锁在任何时候只能允许一个持有者。当然也有信号量叫互斥信号量(只能一个持有者)，允许有多个持有者的信号量叫计数信号量。信号量适合于保持时间较长的情况；而自旋锁适合于保持时间非常短的情况，在实际应用中自旋锁控制的代码只有几行，而持有自旋锁的时间也一般不会超过两次上下文切换的时间，因为线程一旦要进行切换，就至少花费切出切入两次，自旋锁的占用时间如果远远长于两次上下文切换，我们就应该选择信号量。<br>&emsp;&emsp;开销成本：</p>
<ul>
<li>使用信号量的开销是进程上下文切换时间。</li>
<li>自旋锁的开销是忙等待获取自旋锁。</li>
</ul>
<p>&emsp;&emsp;等待时机不同：</p>
<ul>
<li>信号量可能导致阻塞，所以在不允许阻塞的代码中不能用可能引起阻塞的信号量处理方式。</li>
<li>自旋锁是忙等待。</li>
</ul>
<h3 id="设备Ioctl控制"><a href="#设备Ioctl控制" class="headerlink" title="设备Ioctl控制"></a>设备Ioctl控制</h3><h4 id="ioctl功能"><a href="#ioctl功能" class="headerlink" title="ioctl功能"></a>ioctl功能</h4><p>&emsp;&emsp;大部分驱动除了需要具备读写设备的能力外，还需要具备对硬件控制的能力。例如，要求设备报告错误信息，改变波特率，这些操作常常通过<code>ioctl</code>方法来实现。</p>
<h4 id="用户使用方法"><a href="#用户使用方法" class="headerlink" title="用户使用方法"></a>用户使用方法</h4><p>&emsp;&emsp;在用户空间，使用<code>ioctl</code>系统调用来控制设备：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span> <span class="params">( <span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> cmd, ... )</span></span>;</span><br></pre></td></tr></table></figure>
<p>原型中的点表示这是一个可选的参数，存在与否依赖于控制命令(第<code>2</code>个参数)是否涉及到与设备的数据交互。</p>
<h4 id="驱动ioctl方法"><a href="#驱动ioctl方法" class="headerlink" title="驱动ioctl方法"></a>驱动ioctl方法</h4><p>&emsp;&emsp;<code>ioctl</code>驱动方法有和用户空间版本不同的原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ( *ioctl ) ( struct inode *inode, struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg );</span><br></pre></td></tr></table></figure>
<p><code>cmd</code>参数从用户空间传下来，可选的参数<code>arg</code>以一个<code>unsigned long</code>的形式传递，不管它是一个整数或一个指针。如果<code>cmd</code>命令不涉及数据传输，则参数<code>arg</code>的值无任何意义。</p>
<h4 id="定义命令"><a href="#定义命令" class="headerlink" title="定义命令"></a>定义命令</h4><p>&emsp;&emsp;在编写<code>ioctl</code>代码之前，首先需要定义命令。为了防止对错误的设备使用正确的命令，命令号应该在系统范围内是唯一的。<code>ioctl</code>命令编码被划分为几个位段，<code>include/asm/ioctl.h</code>中定义了这些位字段：类型(幻数)、序号、传送方向、参数的大小。<code>Documentation/ioctl-number.txt</code>文件中罗列了在内核中已经使用了的幻数。定义<code>ioctl</code>命令的正确方法是使用<code>4</code>个位段，这个列表中介绍的符号定义在<code>linux/ioctl.h</code>中：</p>
<ul>
<li><code>Type</code>：幻数(类型)，表明哪个设备的命令，在参考了<code>ioctlnumber.txt</code>之后选出，<code>8</code>位宽。</li>
<li><code>Number</code>：序号，表明设备命令中的第几个，<code>8</code>位宽。</li>
<li><code>Direction</code>：数据传送的方向，可能的值是<code>_IOC_NONE</code>(没有数据传输)、<code>_IOC_READ</code>或<code>_IOC_WRITE</code>。数据传送是从应用程序的观点来看待的，<code>_IOC_READ</code>意思是从设备读。</li>
<li><code>Size</code>：用户数据的大小(<code>13/14</code>位宽，视处理器而定)。</li>
</ul>
<p>&emsp;&emsp;内核提供了下列宏来帮助定义命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO   ( type, nr )           <span class="comment">/* 没有参数的命令 */</span></span><br><span class="line">_IOR  ( type, nr, datatype ) <span class="comment">/* 从驱动中读数据 */</span></span><br><span class="line">_IOW  ( type, nr, datatype ) <span class="comment">/* 写数据到驱动 */</span></span><br><span class="line">_IOWR ( type, nr, datatype ) <span class="comment">/* 双向传送，type和number成员作为参数被传递 */</span></span><br></pre></td></tr></table></figure>
<h4 id="定义命令示例"><a href="#定义命令示例" class="headerlink" title="定义命令示例"></a>定义命令示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_IOC_MAGIC <span class="meta-string">'m'</span> <span class="comment">/* 定义幻数 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_IOCSET    _IOW ( MEM_IOC_MAGIC, 0, int ) <span class="comment">/* int是指传递参数的类型 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_IOCGQSET  _IOR ( MEM_IOC_MAGIC, 1, int )</span></span><br></pre></td></tr></table></figure>
<h4 id="Ioctl函数实现"><a href="#Ioctl函数实现" class="headerlink" title="Ioctl函数实现"></a>Ioctl函数实现</h4><p>&emsp;&emsp;定义好了命令，下一步就是要实现<code>Ioctl</code>函数了，<code>Ioctl</code>函数的实现包括如下<code>3</code>个技术环节：返回值、参数使用和命令操作。<br>&emsp;&emsp;<code>Ioctl</code>函数的实现通常是根据命令执行的一个<code>switch</code>语句。但是，当命令号不能匹配任何一个设备所支持的命令时，通常返回<code>-EINVAL</code>，意思是非法参数。<br>&emsp;&emsp;如何使用<code>Ioctl</code>中的参数？如果是一个整数，可以直接使用。如果是指针，我们必须确保这个用户地址是有效的，因此使用前需进行正确的检查。</p>
<h4 id="Ioctl函数实现-参数检查"><a href="#Ioctl函数实现-参数检查" class="headerlink" title="Ioctl函数实现(参数检查)"></a>Ioctl函数实现(参数检查)</h4><p>&emsp;&emsp;不需要检测的函数由<code>copy_from_user</code>(等价于<code>get_user</code>)、<code>copy_to_user</code>(等价于<code>put_user</code>)、<code>get_user</code>和<code>put_user</code>，需要检测的函数有<code>__get_user</code>和<code>__put_user</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( _IOC_DIR ( cmd ) &amp; _IOC_READ ) &#123; <span class="comment">/* “_IOC_DIR”是用来提取命令的方向 */</span></span><br><span class="line">   err = !access_ok ( VERIFY_WRITE, ( <span class="keyword">void</span> __user * ) arg, _IOC_SIZE ( cmd ) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( _IOC_DIR ( cmd ) &amp; _IOC_WRITE ) &#123;</span><br><span class="line">   err = !access_ok ( VERIFY_READ, ( <span class="keyword">void</span> __user * ) arg, _IOC_SIZE ( cmd ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( err ) &#123;</span><br><span class="line">   <span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Ioctl函数实现-命令操作"><a href="#Ioctl函数实现-命令操作" class="headerlink" title="Ioctl函数实现(命令操作)"></a>Ioctl函数实现(命令操作)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( cmd ) &#123;</span><br><span class="line">   <span class="keyword">case</span> MEM_IOCSQUANTUM: <span class="comment">/* Set: arg points to the value */</span></span><br><span class="line">      retval = __get_user ( scull_quantum, ( <span class="keyword">int</span> * ) arg );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> MEM_IOCGQUANTUM: <span class="comment">/* Get: arg is pointer to result */</span></span><br><span class="line">      retval = __put_user ( scull_quantum, ( <span class="keyword">int</span> * ) arg );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> –EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内核等待队列"><a href="#内核等待队列" class="headerlink" title="内核等待队列"></a>内核等待队列</h3><h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>&emsp;&emsp;在<code>Linux</code>驱动程序设计中，可以使用等待队列来实现进程的阻塞，等待队列可看作保存进程的容器，在阻塞进程时，将进程放入等待队列，当唤醒进程时，从等待等列中取出进程。<code>Linux 2.6</code>内核提供了如下关于等待队列的操作：<br>&emsp;&emsp;1. 定义等待队列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wait_queue_head_t</span> my_queue;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 初始化等待队列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_waitqueue_head ( &amp;my_queue );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3. 定义并初始化等待队列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WAIT_QUEUE_HEAD ( my_queue );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;4. 有条件睡眠：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当condition(一个布尔表达式)为真时，立即返回；否则让进程进入</span></span><br><span class="line"><span class="comment">   TASK_UNINTERRUPTIBLE模式的睡眠，并挂在queue参数所指定的等待队列上 */</span></span><br><span class="line">wait_event(<span class="built_in">queue</span>, condition);</span><br><span class="line"><span class="comment">/* 当condition(一个布尔表达式)为真时，立即返回；否则让进程进入</span></span><br><span class="line"><span class="comment">   TASK_INTERRUPTIBLE的睡眠，并挂在queue参数所指定的等待队列上 */</span></span><br><span class="line">wait_event_interruptible(<span class="built_in">queue</span>, condition);</span><br><span class="line"><span class="comment">/* 当condition(一个布尔表达式)为真时，立即返回；否则让进程进入</span></span><br><span class="line"><span class="comment">   TASK_KILLABLE的睡眠，并挂在queue参数所指定的等待队列上 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wait_event_killable</span><span class="params">(<span class="keyword">wait_queue_t</span> <span class="built_in">queue</span>, condition)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;5. 无条件睡眠(老版本，建议不再使用):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sleep_on ( <span class="keyword">wait_queue_head_t</span> *q ); <span class="comment">/* 让进程进入不可中断的睡眠，并把它放入等待队列q */</span></span><br><span class="line">interruptible_sleep_on ( <span class="keyword">wait_queue_head_t</span> *q ); <span class="comment">/* 让进程进入可中断的睡眠，并把它放入等待队列q */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;6. 从等待队列中唤醒进程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从等待队列q中唤醒状态为TASK_UNINTERRUPTIBLE、TASK_INTERRUPTIBLE和TASK_KILLABLE的所有进程 */</span></span><br><span class="line">wake_up ( <span class="keyword">wait_queue_t</span> *q );</span><br><span class="line"><span class="comment">/* 从等待队列q中唤醒状态为TASK_INTERRUPTIBLE的进程 */</span></span><br><span class="line">wake_up_interruptible ( <span class="keyword">wait_queue_t</span> *q );</span><br></pre></td></tr></table></figure>
<h3 id="阻塞型字符设备驱动"><a href="#阻塞型字符设备驱动" class="headerlink" title="阻塞型字符设备驱动"></a>阻塞型字符设备驱动</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>&emsp;&emsp;前一节我们在设计简单字符驱动程序时，跳过了一个重要的问题：当一个设备无法立刻满足用户的读写请求时应当如何处理？例如，调用<code>read</code>时没有数据可读，但以后可能会有；或者一个进程试图向设备写入数据，但是设备暂时没有准备好接收数据。应用程序通常不关心这种问题，应用程序只是调用<code>read</code>或<code>write</code>并得到返回值。驱动程序应当(缺省地)阻塞进程，使它进入睡眠，直到请求可以得到满足。</p>
<h4 id="阻塞方式"><a href="#阻塞方式" class="headerlink" title="阻塞方式"></a>阻塞方式</h4><p>&emsp;&emsp;在阻塞型驱动程序中，<code>Read</code>实现方式如下：如果进程调用<code>read</code>，但设备没有数据或数据不足，进程阻塞。当新数据到达后，唤醒被阻塞进程。<br>&emsp;&emsp;在阻塞型驱动程序中，<code>Write</code>实现方式如下：如果进程调用了<code>write</code>，但设备没有足够的空间供其写入数据，进程阻塞。当设备中的数据被读走后，缓冲区中空出部分空间，则唤醒进程。</p>
<h4 id="非阻塞方式"><a href="#非阻塞方式" class="headerlink" title="非阻塞方式"></a>非阻塞方式</h4><p>&emsp;&emsp;阻塞方式是文件读写操作的默认方式，但应用程序员可通过使用<code>O_NONBLOCK</code>标志来人为的设置读写操作为非阻塞方式(该标志定义在<code>linux/fcntl.h</code>中，在打开文件时指定)。<br>&emsp;&emsp;如果设置了<code>O_NONBLOCK</code>标志，<code>read</code>和<code>write</code>的行为是不同的。如果进程在没有数据就绪时调用了<code>read</code>，或者在缓冲区没有空间时调用了<code>write</code>，系统只是简单地返回<code>-EAGAIN</code>，而不会阻塞进程。</p>
<h4 id="Poll设备操作"><a href="#Poll设备操作" class="headerlink" title="Poll设备操作"></a>Poll设备操作</h4><p>&emsp;&emsp;什么是<code>Poll</code>方法，功能是什么？</p>
<h4 id="Select系统调用-功能"><a href="#Select系统调用-功能" class="headerlink" title="Select系统调用(功能)"></a>Select系统调用(功能)</h4><p>&emsp;&emsp;<code>Select</code>系统调用用于多路监控，当没有一个文件满足要求时，<code>select</code>将阻塞调用进程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">int</span> maxfd, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">   fe_set *exceptfds, <span class="keyword">const</span> struct timeval *timeout )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Maxfd</code>：文件描述符的范围，比待检测的最大文件描述符大<code>1</code>。</li>
<li><code>Readfds</code>：被读监控的文件描述符集。</li>
<li><code>Writefds</code>：被写监控的文件描述符集。</li>
<li><code>Exceptfds</code>：被异常监控的文件描述符集。</li>
<li><code>Timeout</code>：定时器。</li>
</ul>
<p>&emsp;&emsp;<code>Timeout</code>取不同的值，该调用有不同的表现：</p>
<ul>
<li><code>Timeout</code>值为<code>0</code>，不管是否有文件满足要求，都立刻返回，无文件满足要求返回<code>0</code>，有文件满足要求返回一个正值。</li>
<li><code>Timeout</code>为<code>NULL</code>，<code>select</code>将阻塞进程，直到某个文件满足要求。</li>
<li><code>Timeout</code>值为正整数，就是等待的最长时间，即<code>select</code>在<code>timeout</code>时间内阻塞进程。</li>
</ul>
<p>&emsp;&emsp;<code>Select</code>调用返回时，返回值有如下情况：</p>
<ul>
<li>正常情况下返回满足要求的文件描述符个数；</li>
<li>经过了<code>timeout</code>等待后仍无文件满足要求，返回值为<code>0</code>；</li>
<li>如果<code>select</code>被某个信号中断，它将返回<code>-1</code>，并设置<code>errno</code>为<code>EINTR</code>。</li>
<li>如果出错，返回<code>-1</code>并设置相应的<code>errno</code>。</li>
</ul>
<h4 id="Select系统调用-使用方法"><a href="#Select系统调用-使用方法" class="headerlink" title="Select系统调用(使用方法)"></a>Select系统调用(使用方法)</h4><ol>
<li>将要监控的文件添加到文件描述符集。</li>
<li>调用<code>Select</code>开始监控。</li>
<li>判断文件是否发生变化。</li>
</ol>
<p>&emsp;&emsp;系统提供了<code>4</code>个宏对描述符集进行操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span> <span class="params">( <span class="keyword">int</span> fd, fd_set *fdset )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span> <span class="params">( <span class="keyword">int</span> fd, fd_set *fdset )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span> <span class="params">( fd_set *fdset )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ISSET</span> <span class="params">( <span class="keyword">int</span> fd, fd_set *fdset )</span></span>;</span><br></pre></td></tr></table></figure>
<p>宏<code>FD_SET</code>将文件描述符<code>fd</code>添加到文件描述符集<code>fdset</code>中；宏<code>FD_CLR</code>从文件描述符集<code>fdset</code>中清除文件描述符<code>fd</code>；宏<code>FD_ZERO</code>清空文件描述符集<code>fdset</code>；在调用<code>select</code>后使用<code>FD_ISSET</code>来检测文件描述符集<code>fdset</code>中的文件<code>fd</code>发生了变化。<br>&emsp;&emsp;使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FD_ZERO ( &amp;fds ); <span class="comment">/* 清空集合 */</span></span><br><span class="line">FD_SET ( fd1, &amp;fds ); <span class="comment">/* 设置描述符 */</span></span><br><span class="line">FD_SET ( fd2, &amp;fds ); <span class="comment">/* 设置描述符 */</span></span><br><span class="line">maxfdp = fd1 + <span class="number">1</span>; <span class="comment">/* 描述符最大值加1，假设fd1大于fd2 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ( select ( maxfdp, &amp;fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout ) ) &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">      <span class="built_in">exit</span> ( <span class="number">-1</span> );</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">/* select错误，退出程序 */</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">if</span> ( FD_ISSET ( fd1, &amp;fds ) ) &#123; <span class="comment">/* 测试fd1是否可读 */</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Poll方法"><a href="#Poll方法" class="headerlink" title="Poll方法"></a>Poll方法</h4><p>&emsp;&emsp;<code>Poll</code>设备方法负责完成：</p>
<ol>
<li>使用<code>poll_wait</code>将等待队列添加到<code>poll_table</code>中。</li>
<li>返回描述设备是否可读或可写的掩码。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>位掩码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>POLLIN</code></td>
<td>设备可读</td>
</tr>
<tr>
<td><code>POLLRDNORM</code></td>
<td>数据可读</td>
</tr>
<tr>
<td><code>POLLOUT</code></td>
<td>设备可写</td>
</tr>
<tr>
<td><code>POLLWRNORM</code></td>
<td>数据可写</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;设备可读通常返回<code>(POLLIN | POLLRDNORM)</code>，设备可写通常返回<code>(POLLOUT | POLLWRNORM)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mem_poll</span> <span class="params">( struct file *filp, poll_table *wait )</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">scull_pipe</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   poll_wait ( filp, &amp;dev-&gt;inq, wait ); <span class="comment">/* 把进程添加到等待队列 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 返回掩码 */</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="comment">/* 有数据可读 */</span> ) &#123;</span><br><span class="line">      mask = POLLIN | POLLRDNORM; <span class="comment">/* 设备可读 */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Poll</code>方法只是做一个登记，真正的阻塞发生在<code>select.c</code>中的<code>do_select</code>函数。</p>
<h3 id="自动创建设备文件"><a href="#自动创建设备文件" class="headerlink" title="自动创建设备文件"></a>自动创建设备文件</h3><h4 id="自动创建-2-4内核"><a href="#自动创建-2-4内核" class="headerlink" title="自动创建(2.4内核)"></a>自动创建(2.4内核)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devfs_register (</span><br><span class="line">   <span class="keyword">devfs_handle_t</span> dir, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> major, <span class="keyword">unsigned</span> <span class="keyword">int</span> minor,</span><br><span class="line">   <span class="keyword">umode_t</span> mode, <span class="keyword">void</span> *ops, <span class="keyword">void</span> *info );</span><br></pre></td></tr></table></figure>
<p>在指定的目录中创建设备文件。</p>
<ul>
<li><code>dir</code>：目录名，为空表示在<code>/dev</code>目录下创建。</li>
<li><code>name</code>：文件名。</li>
<li><code>flags</code>：创建标志。</li>
<li><code>major</code>：主设备号。</li>
<li><code>minor</code>：次设备号。</li>
<li><code>mode</code>：创建模式。</li>
<li><code>ops</code>：操作函数集。</li>
<li><code>info</code>：通常为空。</li>
</ul>
<h4 id="自动创建-2-6内核"><a href="#自动创建-2-6内核" class="headerlink" title="自动创建(2.6内核)"></a>自动创建(2.6内核)</h4><p>&emsp;&emsp;从<code>Linux 2.6.13</code>开始，<code>devfs</code>不复存在，<code>udev</code>成为<code>devfs</code>的替代。相比<code>devfs</code>，<code>udev(mdev)</code>存在于应用层。利用<code>udev(mdev)</code>来实现设备文件的自动创建很简单，在驱动初始化的代码里调用<code>class_create</code>为该设备创建一个<code>class</code>，再为每个设备调用<code>device_create</code>创建对应的设备。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">myclass</span> = <span class="title">class_create</span> ( <span class="title">THIS_MODULE</span>, "<span class="title">my_device_driver</span>" );</span></span><br><span class="line">device_create ( myclass, <span class="literal">NULL</span>, MKDEV ( major_num, <span class="number">0</span> ), <span class="literal">NULL</span>, <span class="string">"my_device"</span> );</span><br></pre></td></tr></table></figure>
<p>当驱动被加载时，<code>udev(mdev)</code>就会自动在<code>/dev</code>下创建<code>my_device</code>设备文件。注意，应先配置<code>busybox</code>，使它支持<code>mdev</code>。</p>
<h3 id="mmap设备操作"><a href="#mmap设备操作" class="headerlink" title="mmap设备操作"></a>mmap设备操作</h3><h4 id="mmap系统调用-功能"><a href="#mmap系统调用-功能" class="headerlink" title="mmap系统调用(功能)"></a>mmap系统调用(功能)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset )</span></span>;</span><br></pre></td></tr></table></figure>
<p>内存映射函数<code>mmap</code>，负责把文件内容映射到进程的虚拟内存空间，通过对这段内存的读取和修改，来实现对文件的读取和修改，而不需要再调用<code>read</code>、<code>write</code>等操作。<code>mmap</code>不影响原文件的长度。</p>
<p><img src="/2019/03/21/Linux驱动程序/Linux设备驱动基础/3.png" height="251" width="394"></p>
<ul>
<li><code>addr</code>：指定映射的起始地，通常设为<code>NULL</code>，由系统指定。</li>
<li><code>len</code>：映射到内存的文件长度。</li>
<li><code>prot</code>：映射区的保护方式：</li>
</ul>
<ol>
<li><code>PROT_EXEC</code>：映射区可被执行。</li>
<li><code>PROT_READ</code>：映射区可被读取。</li>
<li><code>PROT_WRITE</code>：映射区可被写入。</li>
<li><code>PROT_NONE</code>：映射区不能存取。</li>
</ol>
<ul>
<li><code>flags</code>：映射区的特性：</li>
</ul>
<p><code>MAP_SHARED</code>：写入映射区的数据会复制回文件，且允许其他映射该文件的进程共享)。<br><code>MAP_PRIVATE</code>：对映射区的写入操作会产生一个映射区的复制(<code>copy-on-write</code>)，对此区域所做的修改不会写回原文件。即使映射区的数据被修改，也要复制回文件，修改文件内容。</p>
<ul>
<li><code>fd</code>：由<code>open</code>返回的文件描述符，代表要映射的文件。</li>
<li><code>offset</code>：以文件开始处的偏移量，必须是分页大小的整数倍，通常为<code>0</code>，表示从文件头开始映射。</li>
</ul>
<h4 id="解除映射"><a href="#解除映射" class="headerlink" title="解除映射"></a>解除映射</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span> <span class="params">( <span class="keyword">void</span> *start, <span class="keyword">size_t</span> length )</span></span>;</span><br></pre></td></tr></table></figure>
<p>取消参数<code>start</code>所指向的映射内存(<code>start</code>源于<code>mmap</code>的返回值)，参数<code>length</code>表示欲取消的内存大小。<br>&emsp;&emsp;返回值：解除成功返回<code>0</code>，否则返回<code>-1</code>，错误原因存于<code>errno</code>中。<br>&emsp;&emsp;当进行结束时，映射内存会自动解除，但关闭对应的文件描述词时不会解除映射。</p>
<h4 id="虚拟内存区域"><a href="#虚拟内存区域" class="headerlink" title="虚拟内存区域"></a>虚拟内存区域</h4><p>&emsp;&emsp;虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围(可以理解为<code>具有自己属性的内存对象</code>)。一个进程的内存映象由下面几部分组成：程序代码、数据、<code>BSS</code>和栈区域，以及内存映射的区域。一个进程的内存区域可以通过查看文件<code>/proc/pid/maps</code>(如<code>/proc/643/maps</code>)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">08048000</span><span class="number">-0804f</span>000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">573748</span> /sbin/rpc.statd <span class="meta">#text</span></span><br><span class="line"><span class="number">0804f</span>000<span class="number">-08050000</span> rw-p <span class="number">00007000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">573748</span> /sbin/rpc.statd <span class="meta">#data</span></span><br><span class="line"><span class="number">08050000</span><span class="number">-08055000</span> rwxp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> <span class="meta">#bss</span></span><br><span class="line"><span class="number">040000000</span><span class="number">-40015000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">933965</span> /lib/ld2<span class="number">.3</span><span class="number">.2</span>.so <span class="meta">#text</span></span><br><span class="line"><span class="number">40015000</span><span class="number">-40016000</span> rw-p <span class="number">00014000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">933965</span> /lib/ld<span class="number">-2.3</span><span class="number">.2</span>.so <span class="meta">#data</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;每一行的域为<code>start_end perm offset major:minor inode</code>：</p>
<ul>
<li><code>Start</code>：该区域起始虚拟地址。</li>
<li><code>End</code>：该区域结束虚拟地址。</li>
<li><code>Perm</code>：读、写和执行权限；表示对这个区域，允许进程做什么。这个域的最后一个字符要么是<code>p</code>表示私有的，要么是<code>s</code>表示共享的。</li>
<li><code>Offset</code>：被映射部分在文件中的起始地址。</li>
<li><code>Major</code>、<code>minor</code>：主次设备号。</li>
<li><code>Inode</code>：索引结点。</li>
</ul>
<h4 id="vm-area-struct"><a href="#vm-area-struct" class="headerlink" title="vm_area_struct"></a>vm_area_struct</h4><p>&emsp;&emsp;<code>Linux</code>内核使用结构<code>vm_area_struct</code>(<code>linux/mm_types.h</code>)来描述虚拟内存区域，其中几个主要成员如下：</p>
<ul>
<li><code>unsigned long vm_start</code>：虚拟内存区域起始地址。</li>
<li><code>unsigned long vm_end</code>：虚拟内存区域结束地址(一个<code>VMA</code>描述的区别介于<code>VMA-&gt;vm_start</code>和<code>VMA-&gt;vm_end</code>之间)。</li>
<li><code>unsigned long vm_flags</code>：该区域的标记，如<code>VM_IO</code>和<code>VM_RESERVED</code>。<code>VM_IO</code>将该<code>VMA</code>标记为内存映射的<code>IO</code>区域，<code>VM_IO</code>会阻止系统将该区域包含在进程的存放转存(<code>core dump</code>)中，<code>VM_RESERVED</code>标志内存区域不能被换出(用户程序用于虚拟地址，设备用的是实际地址)。</li>
</ul>
<h4 id="mmap设备操作-使用方法"><a href="#mmap设备操作-使用方法" class="headerlink" title="mmap设备操作(使用方法)"></a>mmap设备操作(使用方法)</h4><p>&emsp;&emsp;映射一个设备是指把用户空间的一段地址关联到设备内存上。当程序读写这段用户空间的地址时，它实际上是在访问设备。但并不是每个设备都适合<code>mmap</code>，例如对于串口或其他面向流的设备来说，它的确没有意义。<br>&emsp;&emsp;<code>mmap</code>设备方法需要完成什么功能？<code>mmap</code>方法是<code>file_oprations</code>结构的成员，在<code>mmap</code>系统调用发出时被调用。在此之前，内核已经完成了很多工作。<code>mmap</code>设备方法所需要做的就是建立虚拟地址到物理地址的页表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ( *mmap ) ( struct file *, struct vm_area_struct * );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>mmap</code>如何完成页表的建立？方法有两个：</p>
<ul>
<li>使用<code>remap_pfn_range</code>一次建立所有页表。</li>
<li>使用<code>nopage VMA</code>方法每次建立一个页表。</li>
</ul>
<p>&emsp;&emsp;构造页表的工作可由<code>remap_pfn_range</code>函数完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remap_pfn_range</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">unsigned</span> <span class="keyword">long</span> pfn, <span class="keyword">unsigned</span> <span class="keyword">long</span> size, <span class="keyword">pgprot_t</span> prot )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="硬件访问"><a href="#硬件访问" class="headerlink" title="硬件访问"></a>硬件访问</h3><h4 id="寄存器与内存"><a href="#寄存器与内存" class="headerlink" title="寄存器与内存"></a>寄存器与内存</h4><p>&emsp;&emsp;寄存器与内存的区别在哪里呢？寄存器和<code>RAM</code>的主要不同在于寄存器操作有副作用(<code>side effect</code>或边际效果)：读取某个地址时可能导致该地址内容发生变化，比如很多设备的中断状态寄存器只要一读取，便自动清零。</p>
<h4 id="内存与I-O"><a href="#内存与I-O" class="headerlink" title="内存与I/O"></a>内存与I/O</h4><p>&emsp;&emsp;在<code>X86</code>处理器中存在<code>I/O</code>空间的概念，<code>I/O</code>空间是相对内存空间而言的，它们是彼此独立的地址空间，在<code>32</code>位的<code>x86</code>系统中，<code>I/O</code>空间大小为<code>64K</code>，内存空间大小为<code>4G</code>。</p>
<p><img src="/2019/03/21/Linux驱动程序/Linux设备驱动基础/4.png" height="271" width="565"></p>
<ul>
<li><code>X86</code>：支持内存空间、<code>IO</code>空间。</li>
<li><code>ARM</code>：只支持内存空间。</li>
<li><code>MIPS</code>：只支持内存空间。</li>
<li><code>PowerPC</code>：只支持内存空间。</li>
</ul>
<h4 id="IO端口与IO内存"><a href="#IO端口与IO内存" class="headerlink" title="IO端口与IO内存"></a>IO端口与IO内存</h4><ul>
<li><code>IO</code>端口：当一个寄存器或内存位于<code>IO</code>空间时，称其为<code>IO</code>端口。</li>
<li><code>IO</code>内存：当一个寄存器或内存位于内存空间时，称其为<code>IO</code>内存。</li>
</ul>
<h4 id="操作I-O端口"><a href="#操作I-O端口" class="headerlink" title="操作I/O端口"></a>操作I/O端口</h4><p>&emsp;&emsp;对<code>I/O</code>端口的操作需按如下步骤完成：申请、访问和释放。</p>
<h4 id="申请I-O端口"><a href="#申请I-O端口" class="headerlink" title="申请I/O端口"></a>申请I/O端口</h4><p>&emsp;&emsp;内核提供了一套函数来允许驱动申请它需要的I/O端口，其中核心的函数是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct resource *<span class="title">request_region</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">long</span> first, <span class="keyword">unsigned</span> <span class="keyword">long</span> n, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数告诉内核，你要使用从<code>first</code>开始的<code>n</code>个端口，<code>name</code>参数是设备的名字。如果申请成功，返回非<code>NULL</code>；申请失败，返回<code>NULL</code>。<br>&emsp;&emsp;系统中端口的分配情况记录在<code>/proc/ioports</code>中。如果不能分配需要的端口，可以来这里查看谁在使用。</p>
<h4 id="访问I-O端口"><a href="#访问I-O端口" class="headerlink" title="访问I/O端口"></a>访问I/O端口</h4><p>&emsp;&emsp;<code>I/O</code>端口可分为<code>8</code>位、<code>16</code>位和<code>32</code>位端口。<code>Linux</code>内核头文件(体系依赖的头文件<code>asm/io.h</code>)定义了下列内联函数来访问<code>I/O</code>端口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inb</span> <span class="params">( <span class="keyword">unsigned</span> port )</span></span>; <span class="comment">/* 读字节端口(8位宽) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outb</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">char</span> byte, <span class="keyword">unsigned</span> port )</span></span>; <span class="comment">/* 写字节端口(8位宽) */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inw</span> <span class="params">( <span class="keyword">unsigned</span> port )</span></span>; <span class="comment">/* 读字节端口(16位宽) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outw</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">short</span> word, <span class="keyword">unsigned</span> port )</span></span>; <span class="comment">/* 写字节端口(16位宽) */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inl</span> <span class="params">( <span class="keyword">unsigned</span> port )</span></span>; <span class="comment">/* 读字节端口(32位宽) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outl</span> <span class="params">( <span class="keyword">unsigned</span> longword, <span class="keyword">unsigned</span> port )</span></span>; <span class="comment">/* 写字节端口(32位宽) */</span></span><br></pre></td></tr></table></figure>
<h4 id="释放I-O端口"><a href="#释放I-O端口" class="headerlink" title="释放I/O端口"></a>释放I/O端口</h4><p>&emsp;&emsp;当用完一组<code>I/O</code>端口(通常在驱动卸载时)，应使用如下函数把它们返还给系统：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_region</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> n )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="操作I-O内存"><a href="#操作I-O内存" class="headerlink" title="操作I/O内存"></a>操作I/O内存</h4><p>&emsp;&emsp;对<code>I/O</code>内存的操作需按如下步骤完成：申请、映射、访问和释放。</p>
<h4 id="申请I-O内存"><a href="#申请I-O内存" class="headerlink" title="申请I/O内存"></a>申请I/O内存</h4><p>&emsp;&emsp;内核提供了一套函数来允许驱动申请它需要的<code>I/O</code>内存，其中核心的函数是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct resource *<span class="title">request_mem_region</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">char</span> *name )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数申请一个从<code>start</code>开始，长度为<code>len</code>字节的内存区。如果成功，返回非<code>NULL</code>；否则返回<code>NULL</code>，所有已经在使用的<code>I/O</code>内存在<code>/proc/iomem</code>中列出。</p>
<h4 id="映射I-O内存"><a href="#映射I-O内存" class="headerlink" title="映射I/O内存"></a>映射I/O内存</h4><p>&emsp;&emsp;在访问<code>I/O</code>内存之前，必须进行物理地址到虚拟地址的映射，<code>ioremap</code>函数具有此功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ioremap</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">long</span> phys_addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> size )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="访问I-O内存"><a href="#访问I-O内存" class="headerlink" title="访问I/O内存"></a>访问I/O内存</h4><p>&emsp;&emsp;访问<code>I/O</code>内存的正确方法是通过一系列内核提供的函数：<br>&emsp;&emsp;1. 从<code>I/O</code>内存读，使用下列之一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">ioread8</span> <span class="params">( <span class="keyword">void</span> *addr )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">ioread16</span> <span class="params">( <span class="keyword">void</span> *addr )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">ioread32</span> <span class="params">( <span class="keyword">void</span> *addr )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 写<code>I/O</code>内存，使用下列之一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iowrite8</span> <span class="params">( u8 value, <span class="keyword">void</span> *addr )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iowrite16</span> <span class="params">( u16 value, <span class="keyword">void</span> *addr )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iowrite32</span> <span class="params">( u32 value, <span class="keyword">void</span> *addr )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3. 老版本的<code>I/O</code>内存访问函数：从<code>I/O</code>内存读，使用下列之一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">readb</span> <span class="params">( address )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">readw</span> <span class="params">( address )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">readl</span> <span class="params">( address )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;写<code>I/O</code>内存，使用下列之一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">writeb</span> <span class="params">( <span class="keyword">unsigned</span> value, address )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">writew</span> <span class="params">( <span class="keyword">unsigned</span> value, address )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">writel</span> <span class="params">( <span class="keyword">unsigned</span> value, address )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="释放I-O内存"><a href="#释放I-O内存" class="headerlink" title="释放I/O内存"></a>释放I/O内存</h4><p>&emsp;&emsp;<code>I/O</code>内存不再需要使用时应当释放，步骤如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iounmap</span> <span class="params">( <span class="keyword">void</span> *addr )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_mem_region</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> len )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="混杂设备驱动"><a href="#混杂设备驱动" class="headerlink" title="混杂设备驱动"></a>混杂设备驱动</h3><p>&emsp;&emsp;在<code>Linux</code>系统中，存在一类字符设备，它们共享一个主设备号(<code>10</code>)，但次设备号不同，我们称这类设备为混杂设备(<code>miscdevice</code>)。所有的混杂设备形成一个链表，对设备访问时内核根据次设备号查找到相应的<code>miscdevice</code>设备。使用混杂设备时，要用<code>.minor = MISC_DYNAMIC_MINOR</code>，让系统自动分配设备号。</p>
<h4 id="设备描述"><a href="#设备描述" class="headerlink" title="设备描述"></a>设备描述</h4><p>&emsp;&emsp;<code>Linux</code>内核使用<code>struct miscdevice</code>来描述一个混杂设备。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> minor; <span class="comment">/* 次设备号 */</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/* 设备名 */</span></span><br><span class="line">   <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span> <span class="comment">/* 文件操作 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>Linux</code>内核使用<code>misc_register</code>函数来注册一个混杂设备驱动。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">misc_register</span> <span class="params">( struct miscdevice *misc )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="Kobject-amp-Kset"><a href="#Kobject-amp-Kset" class="headerlink" title="Kobject &amp; Kset"></a>Kobject &amp; Kset</h3><h4 id="Sysfs文件系统"><a href="#Sysfs文件系统" class="headerlink" title="Sysfs文件系统"></a>Sysfs文件系统</h4><p>&emsp;&emsp;<code>sysfs</code> is a <code>ram-based</code> filesystem initially based on ramfs. It provides a means to export kernel data structures, their attributes, and the linkages between them to userspace.<br>&emsp;&emsp;<code>Linux 2.6</code>内核引入了<code>sysfs</code>文件系统。<code>sysfs</code>被看成是与<code>proc</code>同类别的文件系统。<code>sysfs</code>把连接在系统上的设备和总线组织成分级的文件，使其从用户空间可以访问到。<code>Sysfs</code>被加载在<code>/sys</code>目录下，它的子目录包括：</p>
<ul>
<li><code>Block</code>：在系统中发现的每个块设备在该目录下对应一个子目录。每个子目录中又包含一些属性文件，它们描述了这个块设备的各方面属性，如设备大小(<code>loop</code>块设备是使用文件来模拟的)。</li>
<li><code>Bus</code>：在内核中注册的每条总线在该目录下对应一个子目录，如<code>ide</code>、<code>pci</code>、<code>scsi</code>、<code>usb</code>和<code>pcmcia</code>，其中每个总线目录内又包含两个子目录：<code>devices</code>和<code>drivers</code>。<code>devices</code>目录包含了在整个系统中发现的属于该总线类型的设备，<code>drivers</code>目录包含了注册到该总线的所有驱动。</li>
<li><code>Class</code>：将设备按照功能进行的分类，如<code>/sys/class/net</code>目录下包含了所有网络接口。</li>
<li><code>Devices</code>：包含系统所有的设备。</li>
<li><code>Kernel</code>：内核中的配置参数。</li>
<li><code>Module</code>：系统中所有模块的信息。</li>
<li><code>Firmware</code>：系统中的固件。</li>
<li><code>Fs</code>：描述系统中的文件系统。</li>
<li><code>Power</code>：系统中电源选项。</li>
</ul>
<h4 id="Kobject"><a href="#Kobject" class="headerlink" title="Kobject"></a>Kobject</h4><p>&emsp;&emsp;<code>Kobject</code>实现了基本的面向对象管理机制，是构成<code>Linux 2.6</code>设备模型的核心结构。它与<code>sysfs</code>文件系统紧密相连，在内核中注册的每个<code>kobject</code>对象对应<code>sysfs</code>文件系统中的一个目录。<code>kobject</code>在<code>/sys</code>目录下创建目录，<code>kobject</code>充当父类角色。<br>&emsp;&emsp;类似于<code>C++</code>中的基类，<code>Kobject</code>常被嵌入于其他类型(即容器)中，如<code>bus</code>、<code>devices</code>和<code>drivers</code>都是典型的容器。这些容器通过<code>kobject</code>连接起来，形成了一个树状结构。<code>kobject_init_and_add(&amp;kobj, &amp;type, NULL, &quot;kobject_test&quot;)</code>，<code>NULL</code>表明在<code>/sys</code>下创建文件夹。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">parent</span>;</span> <span class="comment">/* 指向父对象 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">kset</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> *<span class="title">ktype</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_dirent</span> *<span class="title">sd</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span> <span class="comment">/* 对象引用计数 */</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized: <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs: <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent: <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent: <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Kobject操作"><a href="#Kobject操作" class="headerlink" title="Kobject操作"></a>Kobject操作</h4><ul>
<li><code>void kobject_init ( struct kobject *kobj );</code>：初始化<code>kobject</code>结构。</li>
<li><code>int kobject_add ( struct kobject *kobj );</code>：将<code>kobject</code>对象注册到<code>Linux</code>系统。</li>
<li><code>int kobject_init_and_add ( struct kobject *kobj, struct kobj_type *ktype, struct kobject *parent, const char *fmt, ... );</code>：初始化<code>kobject</code>，并将其注册到<code>Linux</code>系统。</li>
<li><code>void kobject_del ( struct kobject *kobj );</code>：从<code>Linux</code>系统中删除<code>kobject</code>对象。</li>
<li><code>struct kobject *kobject_get ( struct kobject *kobj );</code>：将<code>kobject</code>对象的引用计数加<code>1</code>，同时返回该对象指针。</li>
<li><code>void kobject_put ( struct kobject *kobj );</code>：将<code>kobject</code>对象的引用计数减<code>1</code>，如果引用计数降为<code>0</code>，则调用<code>release</code>方法释放该<code>kobject</code>对象。</li>
</ul>
<h4 id="Struct-kobj-type"><a href="#Struct-kobj-type" class="headerlink" title="Struct kobj_type"></a>Struct kobj_type</h4><p>&emsp;&emsp;<code>Kobject</code>的<code>ktype</code>成员是一个指向<code>kobj_type</code>结构的指针，该结构中记录了<code>kobject</code>对象的一些属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">   <span class="keyword">void</span> ( *release ) ( struct kobject *kobj );</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>release</code>用于释放<code>kobject</code>占用的资源，当<code>kobject</code>的引用计数为<code>0</code>时被调用。</p>
<h4 id="Struct-attribute"><a href="#Struct-attribute" class="headerlink" title="Struct attribute"></a>Struct attribute</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">   <span class="keyword">char</span> *name; <span class="comment">/* 属性文件名 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">   <span class="keyword">mode_t</span> mode; <span class="comment">/* 属性的保护位 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct attribute</code>(属性)对应于<code>kobject</code>的目录下的一个文件，<code>Name</code>成员就是文件名。</p>
<h4 id="Struct-sysfs-ops"><a href="#Struct-sysfs-ops" class="headerlink" title="Struct sysfs_ops"></a>Struct sysfs_ops</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> &#123;</span></span><br><span class="line">   <span class="keyword">ssize_t</span> ( *show ) ( struct kobject *, struct attribute *, <span class="keyword">char</span> * );</span><br><span class="line">   <span class="keyword">ssize_t</span> ( *store ) ( struct kobject *, struct attribute *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Show</code>：当用户读属性文件时，该函数被调用，该函数将属性值存入<code>buffer</code>中返回给用户态。</li>
<li><code>Store</code>：当用户写属性文件时，该函数被调用，用于存储用户传入的属性值。</li>
</ul>
<h4 id="Kset"><a href="#Kset" class="headerlink" title="Kset"></a>Kset</h4><p>&emsp;&emsp;<code>kset</code>是具有相同类型的<code>kobject</code>的集合，在<code>sysfs</code>中体现成一个目录。<code>kobject</code>是<code>kset</code>的一个子目录，<code>kset_c.kobj.k_set = &amp;kset_p</code>，<code>kset_c</code>目录的属性由kobj来指定，kset_c的父目录为kset_p。在内核中用kset数据结构表示，定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">/* 连接该kset中所有kobject的链表头 */</span></span><br><span class="line">   <span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span> <span class="comment">/* 内嵌的kobject */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span> <span class="comment">/* 处理热插拔事件的操作集合 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/21/Linux驱动程序/Linux设备驱动基础/5.png"></p>
<h4 id="Kset操作"><a href="#Kset操作" class="headerlink" title="Kset操作"></a>Kset操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kset_register</span> <span class="params">( struct kset *kset )</span></span>; <span class="comment">/* 在内核中注册一个kset */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kset_unregister</span> <span class="params">( struct kset *kset )</span></span>; <span class="comment">/* 从内核中注销一个kset */</span></span><br></pre></td></tr></table></figure>
<h4 id="热插拔事件"><a href="#热插拔事件" class="headerlink" title="热插拔事件"></a>热插拔事件</h4><p>&emsp;&emsp;在<code>Linux</code>系统中，当系统配置发生变化时，如添加<code>kset</code>到系统、移动<code>kobject</code>，一个通知会从内核空间发送到用户空间，这就是热插拔事件。热插拔事件会导致用户空间中相应的处理程序(如<code>udev</code>、<code>mdev</code>)被调用，这些处理程序会通过加载驱动程序，创建设备节点等来响应热插拔事件。</p>
<h4 id="操作集合"><a href="#操作集合" class="headerlink" title="操作集合"></a>操作集合</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> ( *filter ) ( struct kset *kset, struct kobject *kobj );</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> * ( *name ) ( struct kset *kset, struct kobject *kobj );</span><br><span class="line">   <span class="keyword">int</span> ( *uevent ) ( struct kset *kset, struct kobject *kobj, struct kobj_uevent_env *env );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三个函数什么时候调用？当该<code>kset</code>所管理的<code>kobject</code>和<code>kset</code>状态发生变化时(如被加入、移动)，这三个函数将被调用(例如<code>kobject_uevent</code>调用)。</p>
<ul>
<li><code>filter</code>：决定是否将事件传递到用户空间。如果<code>filter</code>返回<code>0</code>，将不传递事件(例如<code>uevent_filter</code>)。</li>
<li><code>name</code>：用于将字符串传递给用户空间的热插拔处理程序。</li>
<li><code>uevent</code>：将用户空间需要的参数添加到环境变量中(例如<code>dev_uevent</code>)。</li>
</ul>
<h3 id="设备驱动模型"><a href="#设备驱动模型" class="headerlink" title="设备驱动模型"></a>设备驱动模型</h3><h4 id="设备模型"><a href="#设备模型" class="headerlink" title="设备模型"></a>设备模型</h4><p>&emsp;&emsp;随着技术的不断进步，系统的拓扑结构也越来越复杂，对智能电源管理、热插拔的支持要求也越来越高，<code>2.4</code>内核已经难以满足这些需求。为适应这种形势的需要，<code>Linux 2.6</code>内核提供了全新的内核设备模型。<br>&emsp;&emsp;设备模型元素有总线、驱动和设备。</p>
<h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>&emsp;&emsp;总线是处理器和设备之间的通道，在设备模型中，所有的设备都通过总线相连，甚至是内部的虚拟<code>platform</code>总线。在<code>Linux</code>设备模型中，总线由<code>bus_type</code>结构表示，定义在<code>linux/device.h</code>。</p>
<h4 id="总线描述"><a href="#总线描述" class="headerlink" title="总线描述"></a>总线描述</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/* 总线名称 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">bus_attribute</span> *<span class="title">bus_attrs</span>;</span> <span class="comment">/* 总线属性 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> *<span class="title">dev_attrs</span>;</span> <span class="comment">/* 设备属性 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">driver_attribute</span> *<span class="title">drv_attrs</span>;</span> <span class="comment">/* 驱动属性 */</span></span><br><span class="line">   <span class="keyword">int</span> ( *match ) ( struct device *dev, struct device_driver *drv );</span><br><span class="line">   <span class="keyword">int</span> ( *uevent ) ( struct device *dev, struct kobj_uevent_env *env );</span><br><span class="line">   <span class="keyword">int</span> ( *probe ) ( struct device *dev );</span><br><span class="line">   <span class="keyword">int</span> ( *remove ) ( struct device *dev );</span><br><span class="line">   <span class="keyword">void</span> ( *shutdown ) ( struct device *dev );</span><br><span class="line">   <span class="keyword">int</span> ( *suspend ) ( struct device *dev, <span class="keyword">pm_message_t</span> state );</span><br><span class="line">   <span class="keyword">int</span> ( *suspend_late ) ( struct device *dev, <span class="keyword">pm_message_t</span> state );</span><br><span class="line">   <span class="keyword">int</span> ( *resume_early ) ( struct device *dev );</span><br><span class="line">   <span class="keyword">int</span> ( *resume ) ( struct device *dev );</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">bus_type_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总线注册-删除"><a href="#总线注册-删除" class="headerlink" title="总线注册/删除"></a>总线注册/删除</h4><p>&emsp;&emsp;总线的注册使用<code>bus_register(struct bus_type * bus);</code>。若成功，新的总线将被添加进系统，并可在<code>sysfs</code>的<code>/sys/bus</code>下看到。总线的删除使用<code>void bus_unregister(struct bus_type *bus);</code>。</p>
<h4 id="总线方法"><a href="#总线方法" class="headerlink" title="总线方法"></a>总线方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ( *match ) ( struct device *dev, struct device_driver *drv );</span><br></pre></td></tr></table></figure>
<p>当一个新设备或者驱动被添加到这个总线时，该方法被调用。用于判断指定的驱动程序是否能处理指定的设备。若可以，则返回非零值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ( *uevent ) (</span><br><span class="line">   struct device *dev, <span class="keyword">char</span> **envp, <span class="keyword">int</span> num_envp,</span><br><span class="line">   <span class="keyword">char</span> *buffer, <span class="keyword">int</span> buffer_size );</span><br></pre></td></tr></table></figure>
<p>在为用户空间产生热插拔事件之前，这个方法允许总线添加环境变量。</p>
<h4 id="总线属性"><a href="#总线属性" class="headerlink" title="总线属性"></a>总线属性</h4><p>&emsp;&emsp;总线属性由结构<code>bus_attribute</code>描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_attribute</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">   <span class="keyword">ssize_t</span> ( *show ) ( struct bus_type *, <span class="keyword">char</span> *buf );</span><br><span class="line">   <span class="keyword">ssize_t</span> ( *store ) ( struct bus_type *, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_create_file</span> <span class="params">( struct bus_type *bus, struct bus_attribute *attr )</span></span>; <span class="comment">/* 创建属性 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bus_remove_file</span> <span class="params">( struct bus_type *bus, struct bus_attribute *attr )</span></span>; <span class="comment">/* 删除属性 */</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>Linux</code>系统中的每个设备由一个<code>struct device</code>描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">   <span class="keyword">char</span> bus_id[BUS_ID_SIZE]; <span class="comment">/* 在总线上唯一标识该设备的字符串 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span> <span class="comment">/* 设备所在总线 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span> <span class="comment">/* 管理该设备的驱动 */</span></span><br><span class="line">   <span class="keyword">void</span> *driver_data; <span class="comment">/* 该设备驱动使用的私有数据成员 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_class</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">   <span class="keyword">void</span> ( *release ) ( struct device *dev );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设备注册使用如下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_register</span> <span class="params">( struct device *dev )</span></span>; <span class="comment">/* 注册设备 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_unregister</span> <span class="params">( struct device *dev )</span></span>; <span class="comment">/* 注销设备 */</span></span><br></pre></td></tr></table></figure>
<p>一条总线也是个设备，也必须按设备注册。</p>
<h4 id="设备属性"><a href="#设备属性" class="headerlink" title="设备属性"></a>设备属性</h4><p>&emsp;&emsp;设备属性由<code>struct device_attribute</code>描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">   <span class="keyword">ssize_t</span> ( *show ) ( struct device *dev, struct device_attribute *attr, <span class="keyword">char</span> *buf );</span><br><span class="line">   <span class="keyword">ssize_t</span> ( *store ) ( struct device *dev, struct device_attribute *attr, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_create_file</span> <span class="params">( struct device *device, struct device_attribute *entry )</span></span>; <span class="comment">/* 创建属性 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_remove_file</span> <span class="params">( struct device *dev, struct device_attribute *attr )</span></span>; <span class="comment">/* 删除属性 */</span></span><br></pre></td></tr></table></figure>
<h4 id="驱动描述"><a href="#驱动描述" class="headerlink" title="驱动描述"></a>驱动描述</h4><p>&emsp;&emsp;驱动程序由<code>struct device_driver</code>描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> &#123;</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/* 驱动程序的名字(体现在sysfs中) */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span> <span class="comment">/* 驱动程序所在的总线 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *mod_name;</span><br><span class="line">   <span class="keyword">int</span> ( *probe ) ( struct device *dev );</span><br><span class="line">   <span class="keyword">int</span> ( *remove ) ( struct device *dev );</span><br><span class="line">   <span class="keyword">void</span> ( *shutdown ) ( struct device *dev );</span><br><span class="line">   <span class="keyword">int</span> ( *suspend ) ( struct device *dev, <span class="keyword">pm_message_t</span> state );</span><br><span class="line">   <span class="keyword">int</span> ( *resume ) ( struct device *dev );</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="驱动注册-注销"><a href="#驱动注册-注销" class="headerlink" title="驱动注册/注销"></a>驱动注册/注销</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_register</span> <span class="params">( struct device_driver *drv )</span></span>; <span class="comment">/* 注册驱动 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">driver_unregister</span> <span class="params">( struct device_driver *drv )</span></span>; <span class="comment">/* 注销驱动 */</span></span><br></pre></td></tr></table></figure>
<h4 id="驱动属性"><a href="#驱动属性" class="headerlink" title="驱动属性"></a>驱动属性</h4><p>&emsp;&emsp;驱动的属性使用<code>struct driver_attribute</code>来描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">driver_attribute</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">   <span class="keyword">ssize_t</span> ( *show ) ( struct device_driver *drv, <span class="keyword">char</span> *buf );</span><br><span class="line">   <span class="keyword">ssize_t</span> ( *store ) ( struct device_driver *drv, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_create_file</span> <span class="params">( struct device_driver *drv, struct driver_attribute *attr )</span></span>; <span class="comment">/* 创建属性 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">driver_remove_file</span> <span class="params">( struct device_driver *drv, struct driver_attribute *attr )</span></span>; <span class="comment">/* 删除属性 */</span></span><br></pre></td></tr></table></figure>
<h3 id="Platform驱动程序"><a href="#Platform驱动程序" class="headerlink" title="Platform驱动程序"></a>Platform驱动程序</h3><h4 id="Platform总线"><a href="#Platform总线" class="headerlink" title="Platform总线"></a>Platform总线</h4><p>&emsp;&emsp;<code>Platform</code>总线是<code>linux 2.6</code>内核加入的一种虚拟总线。<code>platform</code>机制的本身使用并不复杂，由两部分组成：<code>platform_device</code>和<code>platform_driver</code>。<code>Platform</code>驱动与传统的设备驱动模型相比，优势在于<code>platform</code>机制将设备本身的资源注册进内核，由内核统一管理，在驱动程序使用这些资源时使用统一的接口，这样提高了程序的可移植性。<br>&emsp;&emsp;通过<code>Platform</code>机制开发底层设备驱动的流程图：定义<code>platform_device -&gt; 注册platform_device -&gt; 定义platform_driver -&gt; 注册platform_driver</code>。</p>
<h4 id="平台设备描述"><a href="#平台设备描述" class="headerlink" title="平台设备描述"></a>平台设备描述</h4><p>&emsp;&emsp;平台设备使用<code>Struct Platform_device</code>来描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/* 设备名 */</span></span><br><span class="line">   <span class="keyword">int</span> id; <span class="comment">/* 设备编号，配合设备名使用 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line">   u32 num_resources;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">resource</span>;</span> <span class="comment">/* 设备资源 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>Struct Platform_device</code>的分配使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct platform_device *<span class="title">platform_device_alloc</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> id )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code>：设备名。</li>
<li><code>id</code>：设备<code>id</code>，一般为<code>-1</code>。</li>
</ul>
<h4 id="平台设备注册"><a href="#平台设备注册" class="headerlink" title="平台设备注册"></a>平台设备注册</h4><p>&emsp;&emsp;注册平台设备，使用函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">platform_device_add</span> <span class="params">( struct platform_device *pdev )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="设备资源"><a href="#设备资源" class="headerlink" title="设备资源"></a>设备资源</h4><p>&emsp;&emsp;平台设备资源使用<code>struct resource</code>来描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">   <span class="keyword">resource_size_t</span> start; <span class="comment">/* 资源的起始物理地址 */</span></span><br><span class="line">   <span class="keyword">resource_size_t</span> end; <span class="comment">/* 资源的结束物理地址 */</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/* 资源的名称 */</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> flags; <span class="comment">/* 资源的类型，比如MEM、IO、IRQ类型 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span> <span class="comment">/* 资源链表指针 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="设备资源示例"><a href="#设备资源示例" class="headerlink" title="设备资源示例"></a>设备资源示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">s3c_wdt_resource1</span> = &#123;</span></span><br><span class="line">   .start = <span class="number">0x44100000</span>, <span class="comment">/* 基地址(设备地址为0x44100000至0x44200000) */</span></span><br><span class="line">   .end = <span class="number">0x44200000</span>,</span><br><span class="line">   .flags = IORESOURCE_MEM,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> struct resource s3c_wdt_resource2 = &#123;</span><br><span class="line">   .start = <span class="number">20</span>, <span class="comment">/*中断号(20号中断) */</span></span><br><span class="line">   .end = <span class="number">20</span>,</span><br><span class="line">   .flags = IORESOURCE_IRQ,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct resource *<span class="title">platform_get_resource</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   struct platform_device *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> num )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>dev</code>：资源所属的设备。</li>
<li><code>type</code>：获取的资源类型；</li>
<li><code>num</code>：获取的资源数。</li>
</ul>
<p>&emsp;&emsp;例如<code>platform_get_resource(pdev, IORESOURCE_IRQ, 0);</code>是获取中断号，<code>0</code>指的是第一个资源。</p>
<h4 id="平台驱动描述"><a href="#平台驱动描述" class="headerlink" title="平台驱动描述"></a>平台驱动描述</h4><p>&emsp;&emsp;平台驱动使用<code>struct platform_driver</code>描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> ( *probe ) ( struct platform_device * );</span><br><span class="line">   <span class="keyword">int</span> ( *remove ) ( struct platform_device * );</span><br><span class="line">   <span class="keyword">void</span> ( *shutdown ) ( struct platform_device * );</span><br><span class="line">   <span class="keyword">int</span> ( *suspend ) ( struct platform_device *, <span class="keyword">pm_message_t</span> state );</span><br><span class="line">   <span class="keyword">int</span> ( *suspend_late ) ( struct platform_device *, <span class="keyword">pm_message_t</span> state );</span><br><span class="line">   <span class="keyword">int</span> ( *resume_early ) ( struct platform_device * );</span><br><span class="line">   <span class="keyword">int</span> ( *resume ) ( struct platform_device * );</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="平台驱动注册"><a href="#平台驱动注册" class="headerlink" title="平台驱动注册"></a>平台驱动注册</h4><p>&emsp;&emsp;平台驱动注册使用函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">platform_driver_register</span> <span class="params">( struct platform_driver * )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><h4 id="中断概念"><a href="#中断概念" class="headerlink" title="中断概念"></a>中断概念</h4><p>&emsp;&emsp;为什么需要中断？主要是因为：</p>
<ul>
<li>外设的处理速度一般慢于<code>CPU</code>。</li>
<li><code>CPU</code>不能一直等待外部事件。</li>
</ul>
<p>所以设备必须有一种方法来通知<code>CPU</code>它的工作进度，这种方法就是中断。</p>
<h4 id="中断实现"><a href="#中断实现" class="headerlink" title="中断实现"></a>中断实现</h4><p>&emsp;&emsp;在<code>Linux</code>驱动程序中，为设备实现一个中断包含两个步骤：向内核注册中断和实现中断处理函数。</p>
<h4 id="中断注册"><a href="#中断注册" class="headerlink" title="中断注册"></a>中断注册</h4><p>&emsp;&emsp;<code>request_irq</code>用于实现中断的注册功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_irq</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> ( *handler ) ( <span class="keyword">int</span>, <span class="keyword">void</span> *, struct pt_regs * ),</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">void</span> *dev_id )</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回<code>0</code>表示成功，或者返回一个错误码。</p>
<ul>
<li><code>irq</code>：中断号。</li>
<li><code>handler</code>：中断处理函数。</li>
<li><code>flags</code>：与中断管理有关的各种选项。</li>
<li><code>devname</code>：设备名(用于在<code>/proc/interrupts</code>中显示中断拥有者)。</li>
<li><code>dev_id</code>：共享中断时使用(用于标示一个唯一的设备)。</li>
</ul>
<p>&emsp;&emsp;在<code>flags</code>参数中，可以选择一些与中断管理有关的选项：</p>
<ul>
<li><code>IRQF_DISABLED(SA_INTERRUPT)</code>：如果设置该位，表示是一个<code>快速</code>中断处理程序；如果没有设置这位，那么是一个<code>慢速</code>中断处理程序。</li>
<li><code>IRQF_SHARED(SA_SHIRQ)</code>：该位表明中断可以在设备间共享。</li>
<li>为<code>0</code>表示普通外部中断。</li>
</ul>
<h4 id="快速-慢速中断"><a href="#快速-慢速中断" class="headerlink" title="快速/慢速中断"></a>快速/慢速中断</h4><p>&emsp;&emsp;这两种类型的中断处理程序的主要区别在于：快速中断保证中断处理的原子性(不被打断)，而慢速中断则不保证。换句话说，也就是<code>开启中断</code>标志位(处理器<code>IF</code>)在运行快速中断处理程序时是关闭的，因此在服务该中断时，不会被其他类型的中断打断；而调用慢速中断处理时，其它类型的中断仍可以得到服务。</p>
<h4 id="共享中断"><a href="#共享中断" class="headerlink" title="共享中断"></a>共享中断</h4><p>&emsp;&emsp;共享中断就是将不同的设备挂到同一个中断信号线上。<code>Linux</code>对共享的支持主要是为<code>PCI</code>设备服务，也可以用于<code>ISA</code>卡。共享中断也是通过<code>request_irq</code>函数来注册的，但有三个特别之处：</p>
<ul>
<li>申请共享中断时，必须在<code>flags</code>参数中指定<code>IRQF_SHARED</code>位。</li>
<li><code>dev_id</code>参数必须是唯一的。任何驱动中定义的全局指针都可以，<code>dev_id</code>一定不能设为<code>NULL</code>。</li>
<li>共享中断的处理程序中，不能使用<code>disable_irq(unsigned int irq)</code>和<code>enable_irq()</code>。为什么？如果使用了这个函数，共享中断信号线的其它设备将同样无法使用中断，也就无法正常工作了。</li>
</ul>
<h4 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h4><p>&emsp;&emsp;什么是中断处理程序，有何特别之处？中断处理程序就是普通的<code>C</code>语言代码。特别之处在于中断处理程序是在中断上下文中运行的，它的行为受到某些限制：</p>
<ul>
<li>不能向用户空间发送或接受数据，因为它不属于任何进程上下文。用户程序的<code>read</code>和<code>write</code>属于进程上下文。用户空间与进程对应，进程变，用户程序也变。</li>
<li>不能使用可能引起阻塞的函数。</li>
<li>不能使用可能引起调度的函数。</li>
</ul>
<h4 id="中断处理函数流程"><a href="#中断处理函数流程" class="headerlink" title="中断处理函数流程"></a>中断处理函数流程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">short_sh_interrupt</span> <span class="params">( <span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id, struct pt_regs *regs )</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 判断是否是本设备产生了中断 */</span></span><br><span class="line">   value = inb ( short_base );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ( ! ( value &amp; <span class="number">0x80</span> ) ) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 清除中断位(如果设备支持自动清除，则不需要这步) */</span></span><br><span class="line">   outb ( value &amp; <span class="number">0x7F</span>, short_base );</span><br><span class="line">   <span class="comment">/* 中断处理,通常是数据接收 */</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">/* 唤醒等待数据的进程 */</span></span><br><span class="line">   wake_up_interruptible ( &amp;short_queue );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果某个共享中断线上的某个设备发生了中断，则这个共享中断线上的所有设备的中断函数都发送响应。</p>
<h4 id="释放中断"><a href="#释放中断" class="headerlink" title="释放中断"></a>释放中断</h4><p>&emsp;&emsp;当设备不再需要使用中断时(通常在驱动卸载时)，应当把它们返还给系统：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_irq</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id )</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="Linux网络体系架构"><a href="#Linux网络体系架构" class="headerlink" title="Linux网络体系架构"></a>Linux网络体系架构</h3><h4 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h4><p>&emsp;&emsp;<code>Linux</code>的优点之一在于它丰富而稳定的网络协议栈。其范围从协议无关层(例如通用<code>socket</code>层接口或设备层)到各种具体的网络协议实现。<br>&emsp;&emsp;对于网络的理论介绍一般都采用<code>OSI</code>(<code>Open Systems Interconnection</code>)模型，但是<code>Linux</code>中网络栈的介绍一般分为四层的Internet模型。</p>
<h4 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h4><p>&emsp;&emsp;网络接口层把数据链路层和物理层合并在了一起，提供访问物理设备的驱动程序，对应的网络协议主要是以太网协议。</p>
<h4 id="网际层"><a href="#网际层" class="headerlink" title="网际层"></a>网际层</h4><p>&emsp;&emsp;网络层协议管理离散的计算机间的数据传输，如<code>IP</code>协议为用户和远程计算机提供了信息包的传输方法，确保信息包能正确地到达目的机器。重要的网络层协议包括<code>ARP</code>(地址解析协议)、<code>ICMP</code>(<code>Internet</code>控制消息协议)和<code>IP</code>协议(网际协议)等。</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>&emsp;&emsp;传输层的功能包括：格式化信息流、提供可靠传输。传输层包括<code>TCP</code>(<code>Transmission Control Protocol</code>，传输控制协议)和<code>UDP</code>(<code>User Datagram Protocol</code>，用户数据报协议)，它们是传输层中最主要的协议。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>&emsp;&emsp;应用层位于协议栈的顶端，它的主要任务是服务于应用，如利用<code>FTP</code>(文件传输协议)传输一个文件。常见的应用层协议有：<code>HTTP</code>、<code>FTP</code>和<code>Telnet</code>等。应用层是<code>Linux</code>网络设定很关键的一层，<code>Linux</code>服务器的配置文档主要针对应用层中的协议。</p>
<h4 id="Linux网络子系统"><a href="#Linux网络子系统" class="headerlink" title="Linux网络子系统"></a>Linux网络子系统</h4><p>&emsp;&emsp;<code>Linux</code>网络子系统的顶部是系统调用接口层。它为用户空间的应用程序提供了一种访问内核网络子系统的方法。位于其下面的是一个协议无关层，它提供了一种通用方法来使用传输层协议。然后是具体协议的实现，在<code>Linux</code>中包括内嵌的<code>TCP</code>、<code>UDP</code>协议，当然还有<code>IP</code>。然后是设备无关层，它提供了协议与设备驱动通信的通用接口，最下面是设备驱动程序。</p>
<p><img src="/2019/03/21/Linux驱动程序/Linux设备驱动基础/6.png" height="280" width="324"></p>
<h4 id="系统调用接口"><a href="#系统调用接口" class="headerlink" title="系统调用接口"></a>系统调用接口</h4><p>&emsp;&emsp;为应用程序提供访问内核网络子系统的方法：<code>Socket</code>系统调用。</p>
<h4 id="协议无关接口"><a href="#协议无关接口" class="headerlink" title="协议无关接口"></a>协议无关接口</h4><p>&emsp;&emsp;<code>Linux</code>中的<code>socket</code>使用<code>struct sock</code>来描述，这个结构包含了特定<code>socket</code>所需要的所有状态信息，还包括<code>socket</code>所使用的特定协议和在<code>socket</code>上可以执行的一些操作。</p>
<h4 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h4><p>&emsp;&emsp;网络协议层用于实现各种具体的网络协议，如<code>TCP</code>、<code>UDP</code>等。</p>
<h4 id="设备无关接口"><a href="#设备无关接口" class="headerlink" title="设备无关接口"></a>设备无关接口</h4><p>&emsp;&emsp;设备无关接口将协议与各种网络设备驱动连接在一起。这一层提供一组通用函数供底层网络设备驱动程序使用，让它们可以对高层协议栈进行操作。首先，设备驱动程序可能会通过调用<code>register_netdevice</code>或<code>unregister_netdevice</code>在内核中进行注册或注销。调用者首先填写<code>net_device</code>结构，然后传递这个结构进行注册。内核调用它的<code>init</code>函数(如果定义了这种函数)，然后执行一组健全性检查，并将新设备添加到设备列表中(内核中的活动设备链表)。<br>&emsp;&emsp;要从协议层向设备发送数据，需要使用<code>dev_queue_xmit</code>函数，这个函数对数据进行排队，并交由底层设备驱动程序进行最终传输报文的接收通常是使用<code>netif_rx</code>执行的。当底层设备驱动程序接收到一个报文(包含在所分配的<code>sk_buff</code>中)时，就会通过调用<code>netif_rx</code>将数据上传至设备无关层。然后，这个函数通过<code>netif_rx_schedule</code>将<code>sk_buff</code>在上层协议队列中进行排队，供以后进行处理。</p>
<h4 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h4><p>&emsp;&emsp;网络体系结构的最底部是负责管理物理网络设备的设备驱动程序层。</p>
<h3 id="网卡驱动设计"><a href="#网卡驱动设计" class="headerlink" title="网卡驱动设计"></a>网卡驱动设计</h3><p>&emsp;&emsp;每个网络接口都由一个<code>net_device</code>(在<code>linux/netdevice.h</code>中定义)结构来描述，该结构可使用如下内核函数动态分配：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct net_device *<span class="title">alloc_netdev</span> <span class="params">( <span class="keyword">int</span> sizeof_priv, <span class="keyword">const</span> <span class="keyword">char</span> *mask, <span class="keyword">void</span> ( *setup ) ( struct net_device * ) )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sizeof_priv</code>：私有数据区大小。</li>
<li><code>mask</code>：设备名。</li>
<li><code>setup</code>：初始化函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct net_device *<span class="title">alloc_etherdev</span> <span class="params">( <span class="keyword">int</span> sizeof_priv )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数分配一个网络设备，它提供了自己的初始化函数(<code>ether_setup</code>)来设置几个<code>net_device</code>的部分字段，使用的针对以太网设备的值。</p>
<h4 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h4><p>&emsp;&emsp;设备驱动没有主次编号。驱动为每个探测到的接口在一个全局的网络设备列表里插入一个数据结构。网络子系统为各种接口提供了一些帮助函数，包裹着<code>alloc_netdev</code>。最常用的是<code>alloc_etherdev</code>，定义在<code>linux/etherdevdevice.h</code>。一旦<code>net_device</code>结构完成了初始化，完成注册的过程就交给<code>register_netdev</code>。在调用<code>register_netdev</code>时，驱动会马上被用来调用来操作设备。<code>unregister_netdev</code>调用从系统中去除接口。</p>
<h4 id="net-device"><a href="#net-device" class="headerlink" title="net_device"></a>net_device</h4><p>&emsp;&emsp;结构<code>net_device</code>的主要成员包括：</p>
<ul>
<li><code>char name[IFNAMSIZ]</code>：设备名如<code>eth%d</code>(<code>eth0</code>、<code>eth1</code>等)。如果名字由设备驱动设置，通常包含一个<code>%d</code>字符串，<code>register_netdev</code>用一个数替换他来形成一个唯一的名字，分配的编号从零开始。</li>
<li><code>unsigned long state</code>：设备状态。这个成员包括几个标志，驱动正常情况下不直接操作这些标志，而是利用了一套函数操作。</li>
<li><code>unsigned char dma</code>：设备分配的<code>DMA</code>通道。</li>
<li><code>unsigned long base_addr</code>：<code>I/O</code>基地址。</li>
<li><code>unsigned int irq</code>：中断号。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ( *init ) ( struct net_device *dev ); <span class="comment">/* 初始化函数 */</span></span><br></pre></td></tr></table></figure>
<p>该函数在<code>register_netdev</code>时被调用来完成对<code>net_device</code>结构的初始化。<br>&emsp;&emsp;和字符驱动一样, 网络设备也要声明能操作它的函数。有些操作可以保留为<code>NULL</code>，有的可以通过<code>ether_setup</code>来使用默认设置。网络接口的设备方法可分为两组：基本的和可选的，基本方法包括那些使用接口所必需的；可选的方法实现更多高级的功能。</p>
<h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><ul>
<li><code>int ( *open ) ( struct net_device *dev );</code>：打开接口，<code>ifconfig</code>激活时，接口将被打开。<code>open</code>方法应当注册它需要的系统资源(<code>I/O</code>口、<code>IRQ</code>、<code>DMA</code>等)，打开硬件，进行任何别的你的设备要求的设置。</li>
<li><code>int ( *stop ) ( struct net_device *dev );</code>：停止接口。</li>
<li><code>int ( *hard_start_xmit ) ( struct sk_buff *skb, struct net_device *dev );</code>：数据发送函数。</li>
</ul>
<p>完整的报头包含在一个<code>socket</code>缓冲区(<code>sk_buff</code>)结构中。</p>
<h4 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ( *do_ioctl ) ( struct net_device *dev, struct ifreq *ifr, <span class="keyword">int</span> cmd ); <span class="comment">/* 处理特定于接口的ioctl命令 */</span></span><br><span class="line"><span class="comment">/* 改变Mac地址的函数，需要硬件支持该功能。如果接口支持改变它的硬件地址的能力，可以实现这个函数 */</span></span><br><span class="line"><span class="keyword">int</span> ( *set_mac_address ) ( struct net_device *dev, <span class="keyword">void</span> *addr );</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;网络接口驱动的注册方式与字符驱动不同之处在于它没有主次设备号，并使用如下函数注册：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_netdev</span> <span class="params">( struct net_device *dev )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注销：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister_netdev</span><span class="params">(struct net_device *dev)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="sk-buff"><a href="#sk-buff" class="headerlink" title="sk_buff"></a>sk_buff</h4><p>&emsp;&emsp;<code>Linux</code>内核中的每个网络数据包都由一个套接字缓冲区结构<code>struct sk_buff</code>描述，即一个<code>sk_buff</code>结构就是一个包，指向<code>sk_buff</code>的指针通常被称做<code>skb</code>。该结构包含如下重要成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>  <span class="comment">/* 处理该包的设备 */</span></span><br><span class="line">__u32 saddr;         <span class="comment">/* IP源地址      */</span></span><br><span class="line">__u32 daddr;         <span class="comment">/* IP目的地址    */</span></span><br><span class="line">__u32 raddr;         <span class="comment">/* IP路由器地址  */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *head; <span class="comment">/* 分配空间的开始 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data; <span class="comment">/* 有效数据的开始 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *tail; <span class="comment">/* 有效数据的结束 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *end;  <span class="comment">/* 分配空间的结束 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> len;   <span class="comment">/* 有效数据的长度 */</span></span><br></pre></td></tr></table></figure>
<h4 id="Skb操作函数"><a href="#Skb操作函数" class="headerlink" title="Skb操作函数"></a>Skb操作函数</h4><p>&emsp;&emsp;操作<code>sk_buff</code>的内核函数如下：</p>
<ul>
<li><code>struct sk_buff *alloc_skb ( unsigned int len, int priority );</code>：分配一个<code>sk_buff</code>结构，供协议栈代码使用。</li>
<li><code>struct sk_buff *dev_alloc_skb ( unsigned int len );</code>：分配一个<code>sk_buff</code>结构，供驱动代码使用。</li>
<li><code>unsigned char *skb_push ( struct sk_buff *skb, int len );</code>：向后移动<code>skb</code>的<code>tail</code>指针，并返回<code>tail</code>移动之前的值。</li>
<li><code>unsigned char *skb_put ( struct sk_buff *skb, int len );</code>：向前移动<code>skb</code>的<code>head</code>指针，并返回<code>head</code>移动之后的值。</li>
<li><code>kfree_skb ( struct sk_buff *skb );</code>：释放一个<code>sk_buff</code>结构，供协议栈代码使用。</li>
<li><code>dev_kfree_skb ( struct sk_buff *skb );</code>：释放一个<code>sk_buff</code>结构，供驱动代码使用。</li>
</ul>
<h4 id="设备打开"><a href="#设备打开" class="headerlink" title="设备打开"></a>设备打开</h4><p>&emsp;&emsp;<code>Open</code>请求任何它需要的系统资源并且启动接口：</p>
<ul>
<li>注册中断、<code>DMA</code>等。</li>
<li>设置寄存器，启动设备。</li>
<li>启动发送队列。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">net_open</span> <span class="params">( struct net_device *dev )</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 申请中断 */</span></span><br><span class="line">   request_irq ( dev-&gt;irq, &amp;net_interrupt, SA_SHIRQ, <span class="string">"dm9000"</span>, dev );</span><br><span class="line">   <span class="comment">/* 设置寄存器，启动设备 */</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">/* 启动发送队列 */</span></span><br><span class="line">   netif_start_queue ( dev );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据发送和接收"><a href="#数据发送和接收" class="headerlink" title="数据发送和接收"></a>数据发送和接收</h4><p>&emsp;&emsp;当核心需要发送一个数据包时，它调用<code>hard_start_transmit</code>函数，该函数将最终调用到<code>net_device</code>结构中的<code>hard_start_xmit</code>函数指针。网络接口驱动可以实现两种方式的报文接收：中断和查询，<code>Linux</code>中驱动多采用中断方式。</p>
<h4 id="接收流程"><a href="#接收流程" class="headerlink" title="接收流程"></a>接收流程</h4><ol>
<li>分配<code>Skb</code>，即<code>skb = dev_alloc_skb(pkt-&gt;datalen + 2)</code>。</li>
<li>从硬件中读取数据到<code>Skb</code>。</li>
<li>调用<code>netif_rx</code>将数据交给协议栈，即<code>netif_rx(skb)</code>。</li>
</ol>
<h4 id="网络接口中断"><a href="#网络接口中断" class="headerlink" title="网络接口中断"></a>网络接口中断</h4><p>&emsp;&emsp;网络接口通常支持<code>3</code>种类型的中断：新报文到达中断、报文发送完成中断和出错中断。中断处理程序可通过查看网卡中的中断状态寄存器，来分辨出中断类型。</p>
<h3 id="Dm9000网卡驱动分析"><a href="#Dm9000网卡驱动分析" class="headerlink" title="Dm9000网卡驱动分析"></a>Dm9000网卡驱动分析</h3><h4 id="芯片介绍"><a href="#芯片介绍" class="headerlink" title="芯片介绍"></a>芯片介绍</h4><p>&emsp;&emsp;<code>Dm9000</code>在收到由上层发来的以太网帧后，开始侦听网络线路，如果线路忙，就等到线路空闲为止，否则立即发送该数据帧。接收时，它将从以太网收到的数据包在经过解码、去掉帧头和地址检验等步骤后缓存在片内。在<code>CRC</code>校验通过后，它会通知<code>CPU</code>收到了数据帧。</p>
<h4 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h4><p>&emsp;&emsp;以太网帧如下：</p>
<p><img src="/2019/03/21/Linux驱动程序/Linux设备驱动基础/7.png" height="248" width="601"></p>
<h3 id="Linux输入子系统"><a href="#Linux输入子系统" class="headerlink" title="Linux输入子系统"></a>Linux输入子系统</h3><h4 id="输入子系统"><a href="#输入子系统" class="headerlink" title="输入子系统"></a>输入子系统</h4><p>&emsp;&emsp;前面章节讲解按键设备驱动，实际上在<code>Linux</code>系统中，一种更值得推荐的实现这类设备驱动的方法是利用<code>input</code>子系统。<code>Linux</code>系统提供了<code>input</code>子系统，按键、触摸屏、鼠标等都可以利用<code>input</code>接口函数来实现设备驱动。输入子系统由驱动层、输入子系统核心层(<code>Input Core</code>)和事件处理层(<code>Event Handler</code>)三部分处理。一个输入事件，如鼠标移动、键盘按键按下，通过<code>Driver -&gt; Input Core -&gt;Event handler -&gt; userspace</code>达到用户空间的应用程序。</p>
<ul>
<li>驱动层：将底层的硬件输入转化为统一事件形式，向输入核心(<code>Input Core</code>)汇报。</li>
<li>输入核心层：为驱动层提供输入设备注册于操作接口，如<code>input_register_device</code>；通知事件处理层对事件进行处理；在<code>/proc</code>下产生相应的设备信息。</li>
<li>事件处理层：主要作用是和用户交互，我们知道<code>linux</code>在用户空间将所有设备当成文件来处理。在一般的设备驱动程序中都有提供<code>fops</code>接口，以及在<code>/dev</code>下生成相应功的设备文件<code>nod</code>，而在输入子系统中，这些工作都是由事件处理层完成的。</li>
</ul>
<h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p>&emsp;&emsp;体系结构如下：</p>
<p><img src="/2019/03/21/Linux驱动程序/Linux设备驱动基础/8.png" height="295" width="356"></p>
<p>&emsp;&emsp;在<code>Linux</code>内核中，<code>input</code>设备用<code>input_dev</code>结构体描述，使用<code>input</code>子系统实现输入设备驱动的时候，驱动的核心工作是向系统报告按键、触摸屏、键盘、鼠标等输入事件(<code>event</code>，通过<code>input_event</code>结构体描述)，不再需要关心文件操作接口，因为<code>input</code>子系统已经完成了文件操作接口。驱动报告的事件经过<code>Input Core</code>和<code>Event handler</code>最终到达用户空间。</p>
<h4 id="设备注册-注销"><a href="#设备注册-注销" class="headerlink" title="设备注册/注销"></a>设备注册/注销</h4><p>&emsp;&emsp;注册输入设备的函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_device</span> <span class="params">( struct input_dev *dev )</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注销输入设备的函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_unregister_device</span> <span class="params">( struct input_dev *dev )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="驱动实现-事件支持"><a href="#驱动实现-事件支持" class="headerlink" title="驱动实现-事件支持"></a>驱动实现-事件支持</h4><p>&emsp;&emsp;设备驱动通过<code>set_bit</code>告诉<code>input</code>子系统它支持哪些事件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_bit ( EV_KEY, button_dev.evbit );</span><br></pre></td></tr></table></figure>
<p><code>Struct iput_dev</code>中有两个成员，一个是<code>evbit</code>，另一个是<code>keybit</code>，分别用来表示设备所支持的事件类型和按键类型。<br>&emsp;&emsp;事件类型如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EV_RST</code></td>
<td><code>Reset</code></td>
</tr>
<tr>
<td><code>EV_KEY</code></td>
<td>按键</td>
</tr>
<tr>
<td><code>EV_REL</code></td>
<td>相对坐标</td>
</tr>
<tr>
<td><code>EV_ABS</code></td>
<td>绝对坐标</td>
</tr>
<tr>
<td><code>EV_MSC</code></td>
<td>其它</td>
</tr>
<tr>
<td><code>EV_LED</code></td>
<td><code>LED</code></td>
</tr>
<tr>
<td><code>EV_SND</code></td>
<td>声音</td>
</tr>
<tr>
<td><code>EV_REP</code></td>
<td><code>Repeat</code></td>
</tr>
<tr>
<td><code>EV_FF</code></td>
<td>力反馈</td>
</tr>
</tbody>
</table>
</div>
<p>但事件类型为<code>EV_KEY</code>时，还需要指明按键类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BTN_LEFT</code></td>
<td>鼠标左键</td>
</tr>
<tr>
<td><code>BTN_RIGHT</code></td>
<td>鼠标右键</td>
</tr>
<tr>
<td><code>BTN_MIDDLE</code></td>
<td>鼠标中键</td>
</tr>
<tr>
<td><code>BTN_0</code></td>
<td>数字<code>0</code>键</td>
</tr>
<tr>
<td><code>BTN_1</code></td>
<td>数字<code>1</code>键</td>
</tr>
</tbody>
</table>
</div>
<h4 id="驱动实现-报告事件"><a href="#驱动实现-报告事件" class="headerlink" title="驱动实现-报告事件"></a>驱动实现-报告事件</h4><p>&emsp;&emsp;用于报告<code>EV_KEY</code>、<code>EV_REL</code>和<code>EV_ABS</code>事件的函数分别为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_report_key</span> <span class="params">( struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_report_rel</span> <span class="params">( struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_report_abs</span> <span class="params">( struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>code</code>：事件的代码。如果事件的类型是<code>EV_KEY</code>，该代码<code>code</code>为设备键盘代码。代码值<code>0</code>至<code>127</code>为键盘上的按键代码，<code>0x110</code>至<code>0x116</code>为鼠标上按键代码，其中<code>0x110</code>(<code>BTN_LEFT</code>)为鼠标左键，<code>0x111</code>(<code>BTN_RIGHT</code>)为鼠标右键，<code>0x112</code>(<code>BTN_MIDDLE</code>)为鼠标中键。其它代码含义请参看<code>include/linux/input.h</code>文件。</li>
<li><code>value</code>：事件的值。如果事件的类型是<code>EV_KEY</code>，当按键按下时值为<code>1</code>，松开时值为<code>0</code>。</li>
</ul>
<p>&emsp;&emsp;<code>input_sync</code>用于事件同步，它告知事件的接收者：驱动已经发出了一个完整的报告。例如在触摸屏设备驱动中，一次坐标及按下状态的整个报告过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input_report_abs ( input_dev, ABS_X, x ); <span class="comment">/* X坐标 */</span></span><br><span class="line">input_report_abs ( input_dev, ABS_Y, y ); <span class="comment">/* Y坐标 */</span></span><br><span class="line">input_report_abs ( input_dev, ABS_PRESSURE, pres ); <span class="comment">/* 压力 */</span></span><br><span class="line">input_sync ( input_dev ); <span class="comment">/* 同步 */</span></span><br></pre></td></tr></table></figure>
<h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在按键中断中报告事件 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">button_interrupt</span> <span class="params">( <span class="keyword">int</span> irq, <span class="keyword">void</span> *dummy, struct pt_regs *fp )</span> </span>&#123;</span><br><span class="line">   input_report_key ( &amp;button_dev, BTN_0, inb ( BUTTON_PORT0 ) );</span><br><span class="line">   input_report_key ( &amp;button_dev, BTN_0, inb ( BUTTON_PORT1 ) );</span><br><span class="line">   input_sync ( &amp;button_dev );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _ _<span class="function">init <span class="title">button_init</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 申请中断 */</span></span><br><span class="line">   <span class="keyword">if</span> ( request_irq ( BUTTON_IRQ, button_interrupt, <span class="number">0</span>, <span class="string">"button"</span>, <span class="literal">NULL</span> ) ) &#123;</span><br><span class="line">      <span class="keyword">return</span> - EBUSY;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   set_bit ( EV_KEY, button_dev.evbit ) <span class="comment">/* 支持EV_KEY事件 */</span></span><br><span class="line">   set_bit ( BTN_0, button_dev.keybit ); <span class="comment">/* 设备支持两个键 */</span></span><br><span class="line">   set_bit ( BTN_1, button_dev.keybit );</span><br><span class="line">   input_register_device ( &amp;button_dev ); <span class="comment">/* 注册input设备 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span> <span class="comment">/* 按键时间 */</span></span><br><span class="line">   __u16 type; <span class="comment">/* 类型，在下面有定义 */</span></span><br><span class="line">   __u16 code; <span class="comment">/* 要模拟成什么按键 */</span></span><br><span class="line">   __s32 value; <span class="comment">/* 是按下还是释放 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">ev_mouse</span>[2];</span></span><br><span class="line">fd = open ( <span class="string">"/dev/input/event3"</span>, O_RDWR );</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">   count = read ( fd, ev_mouse, <span class="keyword">sizeof</span> ( struct input_event ) );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; ( <span class="keyword">int</span> ) count / <span class="keyword">sizeof</span> ( struct input_event ); i++ ) &#123;</span><br><span class="line">      <span class="keyword">if</span> ( EV_REL == ev_mouse[i].type ) &#123;</span><br><span class="line">         <span class="built_in">printf</span> ( <span class="string">"time: % ld. % d"</span>, ev_mouse[i].time.tv_sec, ev_mouse[i].time.tv_usec );</span><br><span class="line">         <span class="built_in">printf</span> ( <span class="string">"type: % d code: % d value: % d\n"</span>, ev_mouse[i].type, ev_mouse[i].code, ev_mouse[i].value );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ( EV_KEY == ev_mouse[i].type ) &#123;</span><br><span class="line">         <span class="built_in">printf</span> ( <span class="string">"time: % ld. % d"</span>, ev_mouse[i].time.tv_sec, ev_mouse[i].time.tv_usec );</span><br><span class="line">         <span class="built_in">printf</span> ( <span class="string">" type: % d code: % d value: % d\n"</span>, ev_mouse[i].type, ev_mouse[i].code, ev_mouse[i].value );</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/20/嵌入式笔记/ARM基础教程/" rel="next" title="ARM基础教程">
                <i class="fa fa-chevron-left"></i> ARM基础教程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/21/外语/新版标准日本语初级词汇表_下册/" rel="prev" title="新版标准日本语初级词汇表_下册">
                新版标准日本语初级词汇表_下册 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">付康为</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">939</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#驱动程序介绍"><span class="nav-number">1.</span> <span class="nav-text">驱动程序介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符设备驱动程序"><span class="nav-number">2.</span> <span class="nav-text">字符设备驱动程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主次设备号"><span class="nav-number">2.1.</span> <span class="nav-text">主次设备号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设备号作用"><span class="nav-number">2.2.</span> <span class="nav-text">设备号作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分配主设备号"><span class="nav-number">2.3.</span> <span class="nav-text">分配主设备号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态申请"><span class="nav-number">2.4.</span> <span class="nav-text">静态申请</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态分配"><span class="nav-number">2.5.</span> <span class="nav-text">动态分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注销设备号"><span class="nav-number">2.6.</span> <span class="nav-text">注销设备号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建设备文件"><span class="nav-number">2.7.</span> <span class="nav-text">创建设备文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#手工创建"><span class="nav-number">2.8.</span> <span class="nav-text">手工创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重要结构"><span class="nav-number">2.9.</span> <span class="nav-text">重要结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Struct-File"><span class="nav-number">2.10.</span> <span class="nav-text">Struct File</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Struct-Inode"><span class="nav-number">2.11.</span> <span class="nav-text">Struct Inode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Struct-file-operations"><span class="nav-number">2.12.</span> <span class="nav-text">Struct file_operations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设备注册"><span class="nav-number">2.13.</span> <span class="nav-text">设备注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设备操作"><span class="nav-number">2.14.</span> <span class="nav-text">设备操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Open方法"><span class="nav-number">2.15.</span> <span class="nav-text">Open方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Release方法"><span class="nav-number">2.16.</span> <span class="nav-text">Release方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读和写"><span class="nav-number">2.17.</span> <span class="nav-text">读和写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读数据模型"><span class="nav-number">2.18.</span> <span class="nav-text">读数据模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设备注消"><span class="nav-number">2.19.</span> <span class="nav-text">设备注消</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#驱动调试技术"><span class="nav-number">3.</span> <span class="nav-text">驱动调试技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#调试技术分类"><span class="nav-number">3.1.</span> <span class="nav-text">调试技术分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#打印调试"><span class="nav-number">3.2.</span> <span class="nav-text">打印调试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合理使用Printk"><span class="nav-number">3.3.</span> <span class="nav-text">合理使用Printk</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发控制"><span class="nav-number">4.</span> <span class="nav-text">并发控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#并发与竞态"><span class="nav-number">4.1.</span> <span class="nav-text">并发与竞态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断屏蔽"><span class="nav-number">4.2.</span> <span class="nav-text">中断屏蔽</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量"><span class="nav-number">4.3.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自旋锁"><span class="nav-number">4.4.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读入者-写入者信号量"><span class="nav-number">4.5.</span> <span class="nav-text">读入者/写入者信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量-PK-自旋锁"><span class="nav-number">4.6.</span> <span class="nav-text">信号量 PK 自旋锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设备Ioctl控制"><span class="nav-number">5.</span> <span class="nav-text">设备Ioctl控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ioctl功能"><span class="nav-number">5.1.</span> <span class="nav-text">ioctl功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用户使用方法"><span class="nav-number">5.2.</span> <span class="nav-text">用户使用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#驱动ioctl方法"><span class="nav-number">5.3.</span> <span class="nav-text">驱动ioctl方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义命令"><span class="nav-number">5.4.</span> <span class="nav-text">定义命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义命令示例"><span class="nav-number">5.5.</span> <span class="nav-text">定义命令示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ioctl函数实现"><span class="nav-number">5.6.</span> <span class="nav-text">Ioctl函数实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ioctl函数实现-参数检查"><span class="nav-number">5.7.</span> <span class="nav-text">Ioctl函数实现(参数检查)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ioctl函数实现-命令操作"><span class="nav-number">5.8.</span> <span class="nav-text">Ioctl函数实现(命令操作)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内核等待队列"><span class="nav-number">6.</span> <span class="nav-text">内核等待队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#等待队列"><span class="nav-number">6.1.</span> <span class="nav-text">等待队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞型字符设备驱动"><span class="nav-number">7.</span> <span class="nav-text">阻塞型字符设备驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#功能"><span class="nav-number">7.1.</span> <span class="nav-text">功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞方式"><span class="nav-number">7.2.</span> <span class="nav-text">阻塞方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非阻塞方式"><span class="nav-number">7.3.</span> <span class="nav-text">非阻塞方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Poll设备操作"><span class="nav-number">7.4.</span> <span class="nav-text">Poll设备操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Select系统调用-功能"><span class="nav-number">7.5.</span> <span class="nav-text">Select系统调用(功能)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Select系统调用-使用方法"><span class="nav-number">7.6.</span> <span class="nav-text">Select系统调用(使用方法)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Poll方法"><span class="nav-number">7.7.</span> <span class="nav-text">Poll方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动创建设备文件"><span class="nav-number">8.</span> <span class="nav-text">自动创建设备文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自动创建-2-4内核"><span class="nav-number">8.1.</span> <span class="nav-text">自动创建(2.4内核)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动创建-2-6内核"><span class="nav-number">8.2.</span> <span class="nav-text">自动创建(2.6内核)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mmap设备操作"><span class="nav-number">9.</span> <span class="nav-text">mmap设备操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap系统调用-功能"><span class="nav-number">9.1.</span> <span class="nav-text">mmap系统调用(功能)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解除映射"><span class="nav-number">9.2.</span> <span class="nav-text">解除映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟内存区域"><span class="nav-number">9.3.</span> <span class="nav-text">虚拟内存区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vm-area-struct"><span class="nav-number">9.4.</span> <span class="nav-text">vm_area_struct</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap设备操作-使用方法"><span class="nav-number">9.5.</span> <span class="nav-text">mmap设备操作(使用方法)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#硬件访问"><span class="nav-number">10.</span> <span class="nav-text">硬件访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#寄存器与内存"><span class="nav-number">10.1.</span> <span class="nav-text">寄存器与内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存与I-O"><span class="nav-number">10.2.</span> <span class="nav-text">内存与I/O</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO端口与IO内存"><span class="nav-number">10.3.</span> <span class="nav-text">IO端口与IO内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作I-O端口"><span class="nav-number">10.4.</span> <span class="nav-text">操作I/O端口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#申请I-O端口"><span class="nav-number">10.5.</span> <span class="nav-text">申请I/O端口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#访问I-O端口"><span class="nav-number">10.6.</span> <span class="nav-text">访问I/O端口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#释放I-O端口"><span class="nav-number">10.7.</span> <span class="nav-text">释放I/O端口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作I-O内存"><span class="nav-number">10.8.</span> <span class="nav-text">操作I/O内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#申请I-O内存"><span class="nav-number">10.9.</span> <span class="nav-text">申请I/O内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#映射I-O内存"><span class="nav-number">10.10.</span> <span class="nav-text">映射I/O内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#访问I-O内存"><span class="nav-number">10.11.</span> <span class="nav-text">访问I/O内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#释放I-O内存"><span class="nav-number">10.12.</span> <span class="nav-text">释放I/O内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#混杂设备驱动"><span class="nav-number">11.</span> <span class="nav-text">混杂设备驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#设备描述"><span class="nav-number">11.1.</span> <span class="nav-text">设备描述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kobject-amp-Kset"><span class="nav-number">12.</span> <span class="nav-text">Kobject &amp; Kset</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Sysfs文件系统"><span class="nav-number">12.1.</span> <span class="nav-text">Sysfs文件系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kobject"><span class="nav-number">12.2.</span> <span class="nav-text">Kobject</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kobject操作"><span class="nav-number">12.3.</span> <span class="nav-text">Kobject操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Struct-kobj-type"><span class="nav-number">12.4.</span> <span class="nav-text">Struct kobj_type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Struct-attribute"><span class="nav-number">12.5.</span> <span class="nav-text">Struct attribute</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Struct-sysfs-ops"><span class="nav-number">12.6.</span> <span class="nav-text">Struct sysfs_ops</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kset"><span class="nav-number">12.7.</span> <span class="nav-text">Kset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kset操作"><span class="nav-number">12.8.</span> <span class="nav-text">Kset操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#热插拔事件"><span class="nav-number">12.9.</span> <span class="nav-text">热插拔事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作集合"><span class="nav-number">12.10.</span> <span class="nav-text">操作集合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设备驱动模型"><span class="nav-number">13.</span> <span class="nav-text">设备驱动模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#设备模型"><span class="nav-number">13.1.</span> <span class="nav-text">设备模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总线"><span class="nav-number">13.2.</span> <span class="nav-text">总线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总线描述"><span class="nav-number">13.3.</span> <span class="nav-text">总线描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总线注册-删除"><span class="nav-number">13.4.</span> <span class="nav-text">总线注册/删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总线方法"><span class="nav-number">13.5.</span> <span class="nav-text">总线方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总线属性"><span class="nav-number">13.6.</span> <span class="nav-text">总线属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设备属性"><span class="nav-number">13.7.</span> <span class="nav-text">设备属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#驱动描述"><span class="nav-number">13.8.</span> <span class="nav-text">驱动描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#驱动注册-注销"><span class="nav-number">13.9.</span> <span class="nav-text">驱动注册/注销</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#驱动属性"><span class="nav-number">13.10.</span> <span class="nav-text">驱动属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Platform驱动程序"><span class="nav-number">14.</span> <span class="nav-text">Platform驱动程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Platform总线"><span class="nav-number">14.1.</span> <span class="nav-text">Platform总线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#平台设备描述"><span class="nav-number">14.2.</span> <span class="nav-text">平台设备描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#平台设备注册"><span class="nav-number">14.3.</span> <span class="nav-text">平台设备注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设备资源"><span class="nav-number">14.4.</span> <span class="nav-text">设备资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设备资源示例"><span class="nav-number">14.5.</span> <span class="nav-text">设备资源示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取资源"><span class="nav-number">14.6.</span> <span class="nav-text">获取资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#平台驱动描述"><span class="nav-number">14.7.</span> <span class="nav-text">平台驱动描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#平台驱动注册"><span class="nav-number">14.8.</span> <span class="nav-text">平台驱动注册</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断处理"><span class="nav-number">15.</span> <span class="nav-text">中断处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#中断概念"><span class="nav-number">15.1.</span> <span class="nav-text">中断概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断实现"><span class="nav-number">15.2.</span> <span class="nav-text">中断实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断注册"><span class="nav-number">15.3.</span> <span class="nav-text">中断注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速-慢速中断"><span class="nav-number">15.4.</span> <span class="nav-text">快速/慢速中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享中断"><span class="nav-number">15.5.</span> <span class="nav-text">共享中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断处理程序"><span class="nav-number">15.6.</span> <span class="nav-text">中断处理程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断处理函数流程"><span class="nav-number">15.7.</span> <span class="nav-text">中断处理函数流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#释放中断"><span class="nav-number">15.8.</span> <span class="nav-text">释放中断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux网络体系架构"><span class="nav-number">16.</span> <span class="nav-text">Linux网络体系架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#协议栈"><span class="nav-number">16.1.</span> <span class="nav-text">协议栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络接口层"><span class="nav-number">16.2.</span> <span class="nav-text">网络接口层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网际层"><span class="nav-number">16.3.</span> <span class="nav-text">网际层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传输层"><span class="nav-number">16.4.</span> <span class="nav-text">传输层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用层"><span class="nav-number">16.5.</span> <span class="nav-text">应用层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux网络子系统"><span class="nav-number">16.6.</span> <span class="nav-text">Linux网络子系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#系统调用接口"><span class="nav-number">16.7.</span> <span class="nav-text">系统调用接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#协议无关接口"><span class="nav-number">16.8.</span> <span class="nav-text">协议无关接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络协议"><span class="nav-number">16.9.</span> <span class="nav-text">网络协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设备无关接口"><span class="nav-number">16.10.</span> <span class="nav-text">设备无关接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#驱动程序"><span class="nav-number">16.11.</span> <span class="nav-text">驱动程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网卡驱动设计"><span class="nav-number">17.</span> <span class="nav-text">网卡驱动设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#设备驱动"><span class="nav-number">17.1.</span> <span class="nav-text">设备驱动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#net-device"><span class="nav-number">17.2.</span> <span class="nav-text">net_device</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本方法"><span class="nav-number">17.3.</span> <span class="nav-text">基本方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可选操作"><span class="nav-number">17.4.</span> <span class="nav-text">可选操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sk-buff"><span class="nav-number">17.5.</span> <span class="nav-text">sk_buff</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Skb操作函数"><span class="nav-number">17.6.</span> <span class="nav-text">Skb操作函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设备打开"><span class="nav-number">17.7.</span> <span class="nav-text">设备打开</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据发送和接收"><span class="nav-number">17.8.</span> <span class="nav-text">数据发送和接收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收流程"><span class="nav-number">17.9.</span> <span class="nav-text">接收流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络接口中断"><span class="nav-number">17.10.</span> <span class="nav-text">网络接口中断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dm9000网卡驱动分析"><span class="nav-number">18.</span> <span class="nav-text">Dm9000网卡驱动分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#芯片介绍"><span class="nav-number">18.1.</span> <span class="nav-text">芯片介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以太网帧"><span class="nav-number">18.2.</span> <span class="nav-text">以太网帧</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux输入子系统"><span class="nav-number">19.</span> <span class="nav-text">Linux输入子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入子系统"><span class="nav-number">19.1.</span> <span class="nav-text">输入子系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#体系结构"><span class="nav-number">19.2.</span> <span class="nav-text">体系结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设备注册-注销"><span class="nav-number">19.3.</span> <span class="nav-text">设备注册/注销</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#驱动实现-事件支持"><span class="nav-number">19.4.</span> <span class="nav-text">驱动实现-事件支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#驱动实现-报告事件"><span class="nav-number">19.5.</span> <span class="nav-text">驱动实现-报告事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例分析"><span class="nav-number">19.6.</span> <span class="nav-text">实例分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用程序"><span class="nav-number">19.7.</span> <span class="nav-text">应用程序</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">付康为</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
